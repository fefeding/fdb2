import { s as defineComponent, a as ref, j as computed, w as watch, v as createElementBlock, F as Fragment, H as createVNode, N as withCtx, o as openBlock, A as createBaseVNode, L as withModifiers, z as createCommentVNode, O as withDirectives, I as createTextVNode, P as vModelText, x as renderList, B as toDisplayString, Q as vModelSelect, R as vModelCheckbox, G as onMounted, y as normalizeClass, S as vShow, T as useRouter, K as normalizeStyle, n as nextTick, U as withKeys, V as useRoute, c as createBlock } from "./vue.js";
import { r as request, M as Modal, _ as _export_sfc, g as getModalInstance, s as showAlert, a as showConfirm, d as defineStore, t as toast, c as commonjsGlobal, T as Toast } from "./index.js";
import "./bootstrap.js";
class ConnectionService {
  /**
   * 获取所有数据库连接配置
   */
  async getAllConnections() {
    return request("/api/database/getConnections", {});
  }
  /**
   * 根据ID获取数据库连接配置
   */
  async getConnectionById(id) {
    return request("/api/database/getConnection", { id });
  }
  /**
   * 添加数据库连接配置
   */
  async addConnection(connection) {
    return request("/api/database/addConnection", connection);
  }
  /**
   * 更新数据库连接配置
   */
  async updateConnection(id, updates) {
    return request("/api/database/updateConnection", { id, ...updates });
  }
  /**
   * 删除数据库连接配置
   */
  async deleteConnection(id) {
    return request("/api/database/deleteConnection", { id });
  }
  /**
   * 测试数据库连接
   */
  async testConnection(connection) {
    return request("/api/database/testConnection", connection);
  }
  /**
   * 获取支持的数据库类型
   */
  async getDatabaseTypes() {
    return request("/api/database/getSupportedDatabaseTypes");
  }
  /**
   * 创建数据库
   */
  async createDatabase(connectionId, databaseName, options) {
    return request("/api/database/createDatabase", {
      id: connectionId,
      databaseName,
      options
    });
  }
  /**
   * 删除数据库
   */
  async dropDatabase(connectionId, databaseName) {
    return request("/api/database/dropDatabase", {
      id: connectionId,
      databaseName
    });
  }
}
class DatabaseService {
  /**
   * 获取数据库列表
   */
  async getDatabases(connectionId) {
    return request("/api/database/getDatabases", { id: connectionId });
  }
  /**
   * 获取数据库详细信息
   */
  async getDatabaseInfo(connectionId, databaseName) {
    return request("/api/database/getDatabaseInfo", { id: connectionId, database: databaseName });
  }
  /**
   * 获取数据库表列表
   */
  async getTables(connectionId, databaseName) {
    return request("/api/database/getTables", { id: connectionId, database: databaseName });
  }
  /**
   * 获取表详细信息
   */
  async getTableInfo(connectionId, databaseName, tableName) {
    return request("/api/database/getTableInfo", { id: connectionId, database: databaseName, table: tableName });
  }
  /**
   * 获取表数据
   */
  async getTableData(connectionId, databaseName, tableName, page = 1, pageSize = 100, where, orderBy) {
    const params = {
      id: connectionId,
      database: databaseName,
      table: tableName,
      page,
      pageSize,
      where,
      orderBy
    };
    return request("/api/database/getTableData", params);
  }
  /**
   * 执行SQL查询
   */
  async executeQuery(connectionId, sql2, databaseName) {
    return request("/api/database/executeQuery", { id: connectionId, sql: sql2, database: databaseName });
  }
  /**
   * 关闭数据库连接
   */
  async closeConnection(connectionId) {
    return request("/api/database/closeConnection", { id: connectionId });
  }
  /**
   * 导出表数据
   */
  async exportTableData(connectionId, databaseName, tableName, format = "json", where) {
    return request("/api/database/exportTableData", {
      id: connectionId,
      database: databaseName,
      table: tableName,
      format,
      where
    });
  }
  /**
   * 导出表数据到SQL文件
   */
  async exportTableDataToSQL(connectionId, databaseName, tableName, options) {
    return request("/api/database/exportTableDataToSQL", {
      id: connectionId,
      database: databaseName,
      table: tableName,
      options
    });
  }
  /**
   * 导出表数据到CSV文件
   */
  async exportTableDataToCSV(connectionId, databaseName, tableName, options) {
    return request("/api/database/exportTableDataToCSV", {
      id: connectionId,
      database: databaseName,
      table: tableName,
      options
    });
  }
  /**
   * 导出表数据到JSON文件
   */
  async exportTableDataToJSON(connectionId, databaseName, tableName, options) {
    return request("/api/database/exportTableDataToJSON", {
      id: connectionId,
      database: databaseName,
      table: tableName,
      options
    });
  }
  /**
   * 导出表数据到Excel文件
   */
  async exportTableDataToExcel(connectionId, databaseName, tableName, options) {
    return request("/api/database/exportTableDataToExcel", {
      id: connectionId,
      database: databaseName,
      table: tableName,
      options
    });
  }
  /**
   * 保存表结构（新建表）
   */
  async saveTableStructure(connectionId, database, table, columns) {
    return request("/api/database/saveTableStructure", {
      id: connectionId,
      database,
      table,
      columns
    });
  }
  /**
   * 修改表结构
   */
  async alterTable(connectionId, database, tableName, columns, oldColumns) {
    return request("/api/database/alterTable", {
      id: connectionId,
      database,
      tableName,
      columns,
      oldColumns
    });
  }
  /**
   * 插入数据
   */
  async insertData(connectionId, database, tableName, data) {
    return request("/api/database/insertData", {
      id: connectionId,
      database,
      table: tableName,
      data
    });
  }
  /**
   * 更新数据
   */
  async updateData(connectionId, database, tableName, data, where) {
    return request("/api/database/updateData", {
      id: connectionId,
      database,
      table: tableName,
      data,
      where
    });
  }
  /**
   * 删除数据
   */
  async deleteData(connectionId, database, tableName, where) {
    return request("/api/database/deleteData", {
      id: connectionId,
      database,
      table: tableName,
      where
    });
  }
  /**
   * 截断表
   */
  async truncateTable(connectionId, database, tableName) {
    return request(`/api/database/truncateTable/${connectionId}/${database}/${tableName}`);
  }
  /**
   * 删除表
   */
  async dropTable(connectionId, database, tableName) {
    return request(`/api/database/dropTable/${connectionId}/${database}/${tableName}`);
  }
  /**
   * 数据库备份
   */
  async backupDatabase(connectionId, database, options) {
    return request("/api/database/backup", { id: connectionId, databaseName: database, options });
  }
  /**
   * 恢复数据库
   */
  async restoreDatabase(connectionId, database, filePath, options) {
    return request("/api/database/restore", { id: connectionId, databaseName: database, filePath, options });
  }
  /**
   * 获取数据库统计信息
   */
  async getDatabaseStats(connectionId, database) {
    return request("/api/database/getStats", { id: connectionId, databaseName: database });
  }
  /**
   * 优化数据库
   */
  async optimizeDatabase(connectionId, database) {
    return request("/api/database/optimize", { id: connectionId, databaseName: database });
  }
  /**
   * 分析表
   */
  async analyzeTables(connectionId, database) {
    return request("/api/database/analyze", { id: connectionId, databaseName: database });
  }
  /**
   * 修复表
   */
  async repairTables(connectionId, database) {
    return request("/api/database/repair", { id: connectionId, databaseName: database });
  }
  /**
   * 检查数据库健康状态
   */
  async checkDatabaseHealth(connectionId, database) {
    return request(`/api/database/health/${connectionId}/${database}`);
  }
  /**
   * 获取视图列表
   */
  async getViews(connectionId, databaseName) {
    return request("/api/database/getViews", { id: connectionId, database: databaseName });
  }
  /**
   * 获取视图定义
   */
  async getViewDefinition(connectionId, databaseName, viewName) {
    return request("/api/database/getViewDefinition", { id: connectionId, database: databaseName, viewName });
  }
  /**
   * 创建视图
   */
  async createView(connectionId, databaseName, viewName, definition) {
    return request("/api/database/createView", {
      id: connectionId,
      database: databaseName,
      viewName,
      definition
    });
  }
  /**
   * 删除视图
   */
  async dropView(connectionId, databaseName, viewName) {
    return request("/api/database/dropView", {
      id: connectionId,
      database: databaseName,
      viewName
    });
  }
  /**
   * 获取存储过程列表
   */
  async getProcedures(connectionId, databaseName) {
    return request("/api/database/getProcedures", { id: connectionId, database: databaseName });
  }
  /**
   * 获取存储过程定义
   */
  async getProcedureDefinition(connectionId, databaseName, procedureName) {
    return request("/api/database/getProcedureDefinition", {
      id: connectionId,
      database: databaseName,
      procedureName
    });
  }
  /**
   * 创建存储过程
   */
  async createProcedure(connectionId, databaseName, procedureName, definition) {
    const sql2 = `CREATE PROCEDURE \`${procedureName}\` ${definition}`;
    return request("/api/database/executeQuery", {
      id: connectionId,
      sql: sql2,
      database: databaseName
    });
  }
  /**
   * 删除存储过程
   */
  async dropProcedure(connectionId, databaseName, procedureName) {
    const sql2 = `DROP PROCEDURE \`${procedureName}\``;
    return request("/api/database/executeQuery", {
      id: connectionId,
      sql: sql2,
      database: databaseName
    });
  }
}
const _hoisted_1$8 = { class: "form-section" };
const _hoisted_2$8 = { class: "section-content" };
const _hoisted_3$8 = { class: "form-grid" };
const _hoisted_4$8 = { class: "form-group-modern" };
const _hoisted_5$8 = { class: "form-group-modern" };
const _hoisted_6$8 = ["value"];
const _hoisted_7$8 = {
  key: 0,
  class: "form-section"
};
const _hoisted_8$8 = { class: "section-content" };
const _hoisted_9$8 = { class: "form-grid" };
const _hoisted_10$8 = { class: "form-group-modern" };
const _hoisted_11$8 = { class: "form-group-modern" };
const _hoisted_12$8 = { class: "form-group-modern" };
const _hoisted_13$8 = { class: "form-group-modern" };
const _hoisted_14$8 = {
  key: 1,
  class: "form-section"
};
const _hoisted_15$8 = { class: "section-content" };
const _hoisted_16$7 = { class: "form-grid" };
const _hoisted_17$7 = { class: "form-group-modern" };
const _hoisted_18$7 = { class: "form-section" };
const _hoisted_19$6 = { class: "section-content" };
const _hoisted_20$6 = { class: "form-grid" };
const _hoisted_21$6 = { class: "form-group-modern" };
const _hoisted_22$6 = { class: "form-group-modern" };
const _hoisted_23$6 = { class: "form-section" };
const _hoisted_24$6 = { class: "section-content" };
const _hoisted_25$6 = { class: "form-group-modern" };
const _hoisted_26$6 = { class: "form-check-modern" };
const _hoisted_27$6 = { class: "error-content" };
const _hoisted_28$6 = { class: "error-message" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    modelValue: { type: Boolean, default: false },
    connection: { default: null }
  },
  emits: ["update:modelValue", "saved"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const connectionModal = ref();
    const toastRef = ref();
    const errorModal = ref();
    const errorMessage = ref("");
    const editingConnection = ref(null);
    const connectionForm = ref({
      id: "",
      name: "",
      type: "",
      host: "localhost",
      port: 3306,
      database: "",
      username: "",
      password: "",
      options: {},
      enabled: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    const databaseTypes = ref([]);
    computed(() => connections.value.filter((conn) => conn.enabled));
    function validateConnection(connection) {
      if (!connection.name?.trim()) {
        return { isValid: false, message: "连接名称不能为空" };
      }
      if (!connection.type?.trim()) {
        return { isValid: false, message: "数据库类型不能为空" };
      }
      if (connection.type !== "sqlite") {
        if (!connection.host?.trim()) {
          return { isValid: false, message: "主机地址不能为空" };
        }
        if (!connection.port || connection.port <= 0 || connection.port > 65535) {
          return { isValid: false, message: "端口号必须在1-65535之间" };
        }
      }
      if (["mysql", "postgres", "mssql"].includes(connection.type) && !connection.database?.trim()) {
        return { isValid: false, message: `${connection.type.toUpperCase()} 数据库名不能为空` };
      }
      if (connection.type === "sqlite" && !connection.database?.trim()) {
        return { isValid: false, message: "SQLite数据库文件路径不能为空" };
      }
      return { isValid: true, message: "配置验证通过" };
    }
    function show() {
      connectionModal.value?.show();
    }
    function hide() {
      connectionModal.value?.hide();
    }
    function showAddModal() {
      editingConnection.value = null;
      connectionForm.value = {
        id: "",
        name: "",
        type: "",
        host: "localhost",
        port: 3306,
        database: "",
        username: "",
        password: "",
        options: {},
        enabled: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      show();
    }
    function showEditModal(connection) {
      editingConnection.value = connection;
      connectionForm.value = { ...connection };
      show();
    }
    async function saveConnection(closeModal = true) {
      try {
        debugger;
        const validation = validateConnection(connectionForm.value);
        if (!validation.isValid) {
          errorMessage.value = validation.message;
          errorModal.value?.show();
          return;
        }
        const connectionService2 = new ConnectionService();
        if (editingConnection.value) {
          await connectionService2.updateConnection(editingConnection.value.id, connectionForm.value);
        } else {
          await connectionService2.addConnection(connectionForm.value);
        }
        if (closeModal) {
          hide();
        }
        emit("saved", connectionForm.value);
        showToast("", editingConnection.value ? "连接配置更新成功" : "连接配置添加成功");
      } catch (error) {
        console.error("保存连接配置失败:", error);
        let errorMsg = "保存配置失败";
        if (error.message) {
          if (error.message.includes("连接") && error.message.includes("失败")) {
            errorMsg = "配置保存失败，请检查服务器状态";
          } else {
            errorMsg = `保存配置失败: ${error.message}`;
          }
        }
        errorMessage.value = errorMsg;
        errorModal.value?.show();
      }
    }
    async function saveAndTestConnection() {
      try {
        await saveConnection(false);
        await testConnection(connectionForm.value);
        hide();
        emit("saved", connectionForm.value);
        showToast("", editingConnection.value ? "连接配置更新并测试成功" : "连接配置添加并测试成功");
      } catch (error) {
        console.error("保存并测试连接失败:", error);
        if (error.message && error.message.includes("连接测试失败")) {
          showToast("警告", "配置已保存，但连接测试失败", "warning");
          hide();
          emit("saved", connectionForm.value);
        }
      }
    }
    async function testConnection(connection) {
      try {
        const connectionService2 = new ConnectionService();
        const response = await connectionService2.testConnection(connection);
        if (response) {
          showToast("", `"${connection.name}" 连接测试成功`, "success");
        } else {
          showToast("", `"${connection.name}" 连接测试失败`, "error");
        }
      } catch (error) {
        console.error("测试连接失败:", error);
        showToast("", `"${connection.name}" 连接测试失败: ${error.message || "未知错误"}`, "error");
      }
    }
    function handleModalClose() {
      hide();
    }
    function onTypeChange() {
      const selectedType = databaseTypes.value.find((t2) => t2.value === connectionForm.value.type);
      if (selectedType?.defaultPort) {
        connectionForm.value.port = selectedType.defaultPort;
      }
    }
    function showToast(title, message, type) {
      toastRef.value?.show(title, message, type);
    }
    async function loadDatabaseTypes() {
      try {
        const connectionService2 = new ConnectionService();
        const response = await connectionService2.getDatabaseTypes();
        databaseTypes.value = response?.data || [];
      } catch (error) {
        console.error("加载数据库类型失败:", error);
      }
    }
    watch(() => props.modelValue, (newValue) => {
      if (newValue) {
        show();
      } else {
        hide();
      }
    });
    watch(() => props.connection, (newConnection) => {
      if (newConnection) {
        showEditModal(newConnection);
      }
    }, { immediate: true });
    __expose({
      showAddModal,
      showEditModal,
      show,
      hide
    });
    loadDatabaseTypes();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(Modal, {
          ref_key: "connectionModal",
          ref: connectionModal,
          title: editingConnection.value ? "编辑数据库连接" : "新增数据库连接",
          closeButton: { text: "取消", show: true },
          confirmButton: { text: "", show: false },
          isFullScreen: true,
          style: { maxWidth: "800px", width: "100%" },
          onOnClose: handleModalClose
        }, {
          footer: withCtx(() => [
            _cache[31] || (_cache[31] = createBaseVNode("button", {
              type: "button",
              class: "btn btn-secondary",
              "data-bs-dismiss": "modal"
            }, [
              createBaseVNode("i", { class: "bi bi-x-circle me-1" }),
              createTextVNode("取消 ")
            ], -1)),
            createBaseVNode("button", {
              type: "button",
              class: "btn btn-outline-primary",
              onClick: _cache[10] || (_cache[10] = ($event) => testConnection(connectionForm.value))
            }, [..._cache[28] || (_cache[28] = [
              createBaseVNode("i", { class: "bi bi-wifi me-1" }, null, -1),
              createTextVNode("测试连接 ", -1)
            ])]),
            createBaseVNode("button", {
              type: "button",
              class: "btn btn-primary",
              onClick: saveConnection
            }, [
              _cache[29] || (_cache[29] = createBaseVNode("i", { class: "bi bi-save me-1" }, null, -1)),
              createTextVNode(toDisplayString(editingConnection.value ? "更新配置" : "保存配置"), 1)
            ]),
            createBaseVNode("button", {
              type: "button",
              class: "btn btn-success",
              onClick: saveAndTestConnection
            }, [..._cache[30] || (_cache[30] = [
              createBaseVNode("i", { class: "bi bi-check-circle me-1" }, null, -1),
              createTextVNode("保存并测试 ", -1)
            ])])
          ]),
          default: withCtx(() => [
            createBaseVNode("form", {
              onSubmit: withModifiers(saveConnection, ["prevent"]),
              class: "connection-form-modern"
            }, [
              createBaseVNode("div", _hoisted_1$8, [
                _cache[14] || (_cache[14] = createBaseVNode("div", { class: "section-header" }, [
                  createBaseVNode("div", { class: "section-icon" }, [
                    createBaseVNode("i", { class: "bi bi-info-circle" })
                  ]),
                  createBaseVNode("h3", { class: "section-title" }, "基本信息")
                ], -1)),
                createBaseVNode("div", _hoisted_2$8, [
                  createBaseVNode("div", _hoisted_3$8, [
                    createBaseVNode("div", _hoisted_4$8, [
                      _cache[11] || (_cache[11] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-tag me-2" }),
                        createTextVNode("连接名称 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => connectionForm.value.name = $event),
                        placeholder: "为连接起一个易记的名称",
                        required: ""
                      }, null, 512), [
                        [vModelText, connectionForm.value.name]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_5$8, [
                      _cache[13] || (_cache[13] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-diagram-3 me-2" }),
                        createTextVNode("数据库类型 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("select", {
                        class: "form-select-modern",
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => connectionForm.value.type = $event),
                        onChange: onTypeChange,
                        required: ""
                      }, [
                        _cache[12] || (_cache[12] = createBaseVNode("option", { value: "" }, "请选择数据库类型", -1)),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(databaseTypes.value, (dbType) => {
                          return openBlock(), createElementBlock("option", {
                            key: dbType.value,
                            value: dbType.value
                          }, toDisplayString(dbType.label), 9, _hoisted_6$8);
                        }), 128))
                      ], 544), [
                        [vModelSelect, connectionForm.value.type]
                      ])
                    ])
                  ])
                ])
              ]),
              connectionForm.value.type !== "sqlite" ? (openBlock(), createElementBlock("div", _hoisted_7$8, [
                _cache[19] || (_cache[19] = createBaseVNode("div", { class: "section-header" }, [
                  createBaseVNode("div", { class: "section-icon" }, [
                    createBaseVNode("i", { class: "bi bi-hdd-network" })
                  ]),
                  createBaseVNode("h3", { class: "section-title" }, "连接配置")
                ], -1)),
                createBaseVNode("div", _hoisted_8$8, [
                  createBaseVNode("div", _hoisted_9$8, [
                    createBaseVNode("div", _hoisted_10$8, [
                      _cache[15] || (_cache[15] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-server me-2" }),
                        createTextVNode("主机地址 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => connectionForm.value.host = $event),
                        placeholder: "数据库服务器地址",
                        required: ""
                      }, null, 512), [
                        [vModelText, connectionForm.value.host]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_11$8, [
                      _cache[16] || (_cache[16] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-door-closed me-2" }),
                        createTextVNode("端口 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => connectionForm.value.port = $event),
                        placeholder: "数据库端口号",
                        min: "1",
                        max: "65535",
                        required: ""
                      }, null, 512), [
                        [
                          vModelText,
                          connectionForm.value.port,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_12$8, [
                      _cache[17] || (_cache[17] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-database me-2" }),
                        createTextVNode("数据库名 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => connectionForm.value.database = $event),
                        placeholder: "要连接的数据库名",
                        required: ""
                      }, null, 512), [
                        [vModelText, connectionForm.value.database]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_13$8, [
                      _cache[18] || (_cache[18] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-clock me-2" }),
                        createTextVNode("连接超时 ")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => connectionForm.value.options.timeout = $event),
                        placeholder: "连接超时时间（秒）",
                        min: "1"
                      }, null, 512), [
                        [
                          vModelText,
                          connectionForm.value.options.timeout,
                          void 0,
                          { number: true }
                        ]
                      ])
                    ])
                  ])
                ])
              ])) : createCommentVNode("", true),
              connectionForm.value.type === "sqlite" ? (openBlock(), createElementBlock("div", _hoisted_14$8, [
                _cache[21] || (_cache[21] = createBaseVNode("div", { class: "section-header" }, [
                  createBaseVNode("div", { class: "section-icon" }, [
                    createBaseVNode("i", { class: "bi bi-file-earmark-text" })
                  ]),
                  createBaseVNode("h3", { class: "section-title" }, "SQLite配置")
                ], -1)),
                createBaseVNode("div", _hoisted_15$8, [
                  createBaseVNode("div", _hoisted_16$7, [
                    createBaseVNode("div", _hoisted_17$7, [
                      _cache[20] || (_cache[20] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-file-earmark me-2" }),
                        createTextVNode("数据库文件 "),
                        createBaseVNode("span", { class: "required" }, "*")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => connectionForm.value.database = $event),
                        placeholder: "SQLite数据库文件路径",
                        required: ""
                      }, null, 512), [
                        [vModelText, connectionForm.value.database]
                      ])
                    ])
                  ])
                ])
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_18$7, [
                _cache[24] || (_cache[24] = createBaseVNode("div", { class: "section-header" }, [
                  createBaseVNode("div", { class: "section-icon" }, [
                    createBaseVNode("i", { class: "bi bi-shield-lock" })
                  ]),
                  createBaseVNode("h3", { class: "section-title" }, "认证信息")
                ], -1)),
                createBaseVNode("div", _hoisted_19$6, [
                  createBaseVNode("div", _hoisted_20$6, [
                    createBaseVNode("div", _hoisted_21$6, [
                      _cache[22] || (_cache[22] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-person me-2" }),
                        createTextVNode("用户名 ")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => connectionForm.value.username = $event),
                        placeholder: "数据库用户名"
                      }, null, 512), [
                        [vModelText, connectionForm.value.username]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_22$6, [
                      _cache[23] || (_cache[23] = createBaseVNode("label", { class: "form-label-modern" }, [
                        createBaseVNode("i", { class: "bi bi-key me-2" }),
                        createTextVNode("密码 ")
                      ], -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "password",
                        class: "form-control-modern",
                        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => connectionForm.value.password = $event),
                        placeholder: "数据库密码"
                      }, null, 512), [
                        [vModelText, connectionForm.value.password]
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_23$6, [
                _cache[27] || (_cache[27] = createBaseVNode("div", { class: "section-header" }, [
                  createBaseVNode("div", { class: "section-icon" }, [
                    createBaseVNode("i", { class: "bi bi-gear" })
                  ]),
                  createBaseVNode("h3", { class: "section-title" }, "其他选项")
                ], -1)),
                createBaseVNode("div", _hoisted_24$6, [
                  createBaseVNode("div", _hoisted_25$6, [
                    _cache[26] || (_cache[26] = createBaseVNode("label", { class: "form-label-modern" }, [
                      createBaseVNode("i", { class: "bi bi-toggle-on me-2" }),
                      createTextVNode("连接状态 ")
                    ], -1)),
                    createBaseVNode("div", _hoisted_26$6, [
                      withDirectives(createBaseVNode("input", {
                        class: "form-check-input-modern",
                        type: "checkbox",
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => connectionForm.value.enabled = $event),
                        id: "enabled"
                      }, null, 512), [
                        [vModelCheckbox, connectionForm.value.enabled]
                      ]),
                      _cache[25] || (_cache[25] = createBaseVNode("label", {
                        class: "form-check-label-modern",
                        for: "enabled"
                      }, [
                        createBaseVNode("span", { class: "check-text" }, "启用此连接"),
                        createBaseVNode("span", { class: "check-description" }, "创建后将自动启用连接")
                      ], -1))
                    ])
                  ])
                ])
              ])
            ], 32)
          ]),
          _: 1
        }, 8, ["title"]),
        createVNode(Modal, {
          ref_key: "errorModal",
          ref: errorModal,
          title: "错误提示",
          closeButton: { text: "确定", show: true },
          confirmButton: { text: "", show: false },
          isFullScreen: false,
          style: { maxWidth: "400px!important", width: "100%" }
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_27$6, [
              _cache[32] || (_cache[32] = createBaseVNode("div", { class: "error-icon" }, [
                createBaseVNode("i", { class: "bi bi-exclamation-triangle" })
              ], -1)),
              createBaseVNode("div", _hoisted_28$6, toDisplayString(errorMessage.value), 1)
            ])
          ]),
          _: 1
        }, 512)
      ], 64);
    };
  }
});
const ConnectionEditor = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-093594aa"]]);
class ModalHelper {
  /**
   * 获取全局modal实例
   */
  getModal() {
    const instance = getModalInstance();
    if (!instance) {
      console.warn("ModalHelper: Vue实例不存在，使用默认实现");
      return null;
    }
    return instance;
  }
  /**
   * 成功提示
   */
  success(content2) {
    const modal2 = this.getModal();
    if (modal2?.success) {
      return modal2.success(content2);
    }
    return showAlert(content2, "success") || Promise.resolve(true);
  }
  /**
   * 错误提示
   */
  error(content2, detail) {
    const modal2 = this.getModal();
    let errorMessage;
    if (content2 instanceof Error) {
      errorMessage = content2.message;
      console.error("Error details:", {
        name: content2.name || detail.name,
        message: content2.message || detail.message,
        stack: content2.stack || detail.stack
      });
    } else {
      errorMessage = String(content2);
    }
    if (modal2?.error) {
      return modal2.error(errorMessage, detail);
    }
    return showAlert(errorMessage, "error", detail) || Promise.resolve(true);
  }
  /**
   * 警告提示
   */
  warning(content2) {
    const modal2 = this.getModal();
    if (modal2?.warning) {
      return modal2.warning(content2);
    }
    return showAlert(content2, "warning") || Promise.resolve(true);
  }
  /**
   * 信息提示
   */
  info(content2) {
    const modal2 = this.getModal();
    if (modal2?.info) {
      return modal2.info(content2);
    }
    return showAlert(content2, "info") || Promise.resolve(true);
  }
  /**
   * 简单提示（替代alert）
   */
  alert(content2) {
    const modal2 = this.getModal();
    if (modal2?.alert) {
      return modal2.alert(content2);
    }
    return showAlert(content2, "info") || Promise.resolve(true);
  }
  /**
   * 确认对话框（替代confirm）
   */
  confirm(content2, options) {
    const modal2 = this.getModal();
    if (modal2?.confirm) {
      return modal2.confirm({
        ...options,
        content: content2
      });
    }
    return showConfirm(content2, options) || Promise.resolve(false);
  }
}
const modal = new ModalHelper();
modal.info.bind(modal);
modal.error.bind(modal);
modal.success.bind(modal);
modal.warning.bind(modal);
modal.alert.bind(modal);
modal.confirm.bind(modal);
function getDefaultState() {
  return getInitialState();
}
function getInitialState() {
  return {
    currentConnection: null,
    databases: [],
    tables: [],
    loading: {
      databases: false,
      tables: false,
      executing: false
    },
    error: null
  };
}
const databaseService = new DatabaseService();
const connectionService = new ConnectionService();
const useConnectionStore = defineStore("connection", {
  state: () => getDefaultState(),
  getters: {
    // 是否有当前连接
    hasConnection: (state) => !!state.currentConnection,
    // 获取当前连接ID
    currentConnectionId: (state) => state.currentConnection?.id || "",
    // 获取数据库数量
    databaseCount: (state) => state.databases.length,
    // 获取表数量
    tableCount: (state) => state.tables.length,
    // 是否正在加载数据库
    isLoadingDatabases: (state) => state.loading.databases,
    // 是否正在加载表
    isLoadingTables: (state) => state.loading.tables,
    // 是否正在执行操作
    isExecuting: (state) => state.loading.executing
  },
  actions: {
    // 设置当前连接
    setCurrentConnection(connection) {
      if (this.currentConnection?.id === connection?.id) return;
      this.currentConnection = connection;
      if (connection) {
        this.loadDatabases();
      } else {
        this.databases = [];
        this.tables = [];
      }
    },
    // 加载数据库列表
    async loadDatabases() {
      if (!this.currentConnection) return;
      if (this.loading.databases) return;
      try {
        this.loading.databases = true;
        this.error = null;
        const connectionId = this.currentConnection.id;
        if (!connectionId) {
          this.error = "连接ID不存在";
          modal.error(this.error);
          return;
        }
        const result = await databaseService.getDatabases(connectionId);
        if (result && typeof result === "object" && "ret" in result && result.ret === 0) {
          const dbList = result.data || [];
          this.databases = dbList.map((db) => ({
            name: db,
            size: 0,
            tableCount: 0,
            tables: []
          }));
        } else if (Array.isArray(result)) {
          this.databases = result.map((db) => ({
            name: db,
            size: 0,
            tableCount: 0,
            tables: []
          }));
        } else {
          this.error = result && typeof result === "object" && "msg" in result && typeof result.msg === "string" ? result.msg : "获取数据库列表失败";
          modal.error(this.error);
        }
      } catch (error) {
        this.error = error.message || "获取数据库列表失败";
        console.error("获取数据库列表失败:", error);
        modal.error(this.error);
      } finally {
        this.loading.databases = false;
      }
    },
    // 加载数据库详细信息
    async loadDatabaseInfo(databaseName) {
      if (!this.currentConnection) return;
      try {
        this.loading.executing = true;
        this.error = null;
        const result = await databaseService.getDatabaseInfo(this.currentConnection.id, databaseName);
        if (result.ret === 0) {
          const databaseInfo = result.data;
          const index = this.databases.findIndex((db) => db.name === databaseName);
          if (index !== -1) {
            this.databases[index] = databaseInfo;
          }
          this.tables = databaseInfo.tables || [];
        } else {
          this.error = result.msg || "获取数据库详细信息失败";
          modal.error(this.error);
        }
      } catch (error) {
        this.error = error.message || "获取数据库详细信息失败";
        console.error("获取数据库详细信息失败:", error);
        modal.error(this.error);
      } finally {
        this.loading.executing = false;
      }
    },
    // 加载表列表
    async loadTables(databaseName) {
      if (!this.currentConnection) return;
      try {
        this.loading.tables = true;
        this.error = null;
        const result = await databaseService.getTables(this.currentConnection.id, databaseName);
        if (result.ret === 0) {
          this.tables = result.data || [];
          const index = this.databases.findIndex((db) => db.name === databaseName);
          if (index !== -1) {
            this.databases[index].tableCount = this.tables.length;
          }
        } else {
          this.error = result.msg || "获取表列表失败";
          modal.error(this.error);
        }
      } catch (error) {
        this.error = error.message || "获取表列表失败";
        console.error("获取表列表失败:", error);
        modal.error(this.error);
      } finally {
        this.loading.tables = false;
      }
    },
    // 创建数据库
    async createDatabase(databaseName, options) {
      if (!this.currentConnection) return;
      try {
        this.loading.executing = true;
        this.error = null;
        const filteredOptions = Object.fromEntries(
          Object.entries(options || {}).filter(([_, value]) => value !== "")
        );
        await connectionService.createDatabase(this.currentConnection.id, databaseName, filteredOptions);
        modal.success("数据库创建成功");
        this.loadDatabases();
      } catch (error) {
        this.error = error.message || "创建数据库失败";
        console.error("创建数据库失败:", error);
        modal.error(this.error);
      } finally {
        this.loading.executing = false;
      }
    },
    // 测试连接
    async testConnection(connection) {
      try {
        this.loading.executing = true;
        this.error = null;
        const result = await connectionService.testConnection(connection);
        if (result.ret === 0) {
          toast.success("连接测试成功");
          return true;
        } else {
          this.error = result.msg || "连接测试失败";
          toast.error(this.error || "连接测试失败");
          return false;
        }
      } catch (error) {
        this.error = error.message || "连接测试失败";
        console.error("连接测试失败:", error);
        toast.error(this.error || "连接测试失败");
        return false;
      } finally {
        this.loading.executing = false;
      }
    },
    // 清除错误信息
    clearError() {
      this.error = null;
    },
    // 重置状态
    resetState() {
      Object.assign(this.$state, getInitialState());
    }
  }
});
let rangeFrom = [], rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 0, n = 0; i < numbers.length; i++)
    (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
const ZWJ = 8205;
function findClusterBreak$1(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow$1(str.charCodeAt(pos)) && surrogateHigh$1(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt$1(str, pos);
  pos += codePointSize$1(prev);
  while (pos < str.length) {
    let next = codePointAt$1(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize$1(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt$1(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt$1(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh$1(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow$1(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow$1(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh$1(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize$1(code) {
  return code < 65536 ? 1 : 2;
}
class Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      pos += a.value.length;
      if (a.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
}
class TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof TextLeaf))
      return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
}
class TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children)
          add(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
class RawTextCursor {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak$1(str, pos, forward, includeExtending);
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ (function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
})(MapMode || (MapMode = {}));
class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json2);
  }
  /**
  @internal
  */
  static create(sections) {
    return new ChangeDesc(sections);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i = 0, pos = 0; ; ) {
      let next = i == ranges.length ? 1e9 : ranges[i++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json2) {
    if (!Array.isArray(json2))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json2.length; i++) {
      let part = json2[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (last >= 0 && len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert2)
            addInsert(insert2, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert2 && inserted < a.i)
        addInsert(insert2, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && this.goalColumn == other.goalColumn && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new SelectionRange(from, to, flags);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
}
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config = {}) {
    return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray$1 : (a, b) => a === b), !!config.static, config.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
}
function sameArray$1(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config) {
    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
    if (config.provide)
      field.provides = config.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i) => i.field == this)) && reInit != oldInit.find((i) => i.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray$1(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
class Annotation {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection2, effects, annotations, scrollIntoView2);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e = this.annotation(Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray$1(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray$1(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray$1(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray$1(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ (function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
})(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config, doc2, selection2, values, computeSlot, tr) {
    this.config = config;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values;
    this.status = config.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray$1(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray$1(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json2, config = {}, fields) {
    if (!json2 || typeof json2.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json2, prop)) {
          let field = fields[prop], value = json2[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config = {}) {
    let configuration = Configuration.resolve(config.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase, ...insert2) {
    for (let map of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase)) {
        phrase = map[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    let chars = this.languageDataAt("wordChars", at);
    return makeCategorizer(chars.length ? chars[0] : "");
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a, b) {
    let kA = Object.keys(a), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config of configs)
    for (let key of Object.keys(config)) {
      let value = config[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}
class RangeValue {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range$1.create(from, to, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
function cmpVal(a, b) {
  return a == b || a.constructor == b.constructor && a.eq(b);
}
let Range$1 = class Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new Range(from, to, value);
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter)
      return this;
    if (sort)
      add = add.slice().sort(cmpRange);
    if (this.isEmpty)
      return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur.value || i < add.length) {
      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
        let range = add[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
          if (!builder.addInner(cur.from, cur.to, cur.value))
            spill.push(Range$1.create(cur.from, cur.to, cur.value));
        }
        cur.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !cmpVal(sideA.point, sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer2 = sets[i]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer)
        result = new RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur = ranges[i];
      if (cmpRange(prev, cur) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint <= 0)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
        shared.add(set.chunk[i]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur of this.heap)
      cur.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur of this.heap)
      cur.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index) {
  for (let cur = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur.compare(child) < 0)
      break;
    heap[childIndex] = cur;
    heap[index] = child;
    index = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
}
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  let bounds = !!comparator.boundChange;
  for (let boundChange = false; ; ) {
    let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    let point = a.point || b.point;
    if (point) {
      if (!(a.point && b.point && cmpVal(a.point, b.point) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
      boundChange = false;
    } else {
      if (boundChange)
        comparator.boundChange(pos);
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
      if (bounds && clipEnd < endB && (dEnd || a.openEnd(end) != b.openEnd(end)))
        boundChange = true;
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !cmpVal(a[i], b[i]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n = 0;
  for (let i = 0; i < to && i < string2.length; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return string2.length;
}
const C = "ͼ";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : /* @__PURE__ */ Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set = root[SET], nonce = options && options.nonce;
    if (!set) set = new StyleSet(root, nonce);
    else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
}
let adoptedSet = /* @__PURE__ */ new Map();
class StyleSet {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  safari,
  safari_version: safari ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
const noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a, b, ignore) {
  if (a == b)
    return true;
  if (!a)
    a = noAttrs;
  if (!b)
    b = noAttrs;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length - 0 != keysB.length - 0)
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
      return false;
  }
  return true;
}
function setAttrs(dom, attrs) {
  for (let i = dom.attributes.length - 1; i >= 0; i--) {
    let name2 = dom.attributes[i].name;
    if (attrs[name2] == null)
      dom.removeAttribute(name2);
  }
  for (let name2 in attrs) {
    let value = attrs[name2];
    if (name2 == "style")
      dom.style.cssText = value;
    else if (dom.getAttribute(name2) != value)
      dom.setAttribute(name2, value);
  }
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
}
var BlockType = /* @__PURE__ */ (function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
})(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.attrs = spec.class && spec.attributes ? combineAttrs(spec.attributes, { class: spec.class }) : spec.class ? { class: spec.class } : spec.attributes || noAttrs;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
class BlockWrapper extends RangeValue {
  constructor(tagName, attributes) {
    super();
    this.tagName = tagName;
    this.attributes = attributes;
  }
  eq(other) {
    return other == this || other instanceof BlockWrapper && this.tagName == other.tagName && attrsEq(this.attributes, other.attributes);
  }
  /**
  Create a block wrapper object with the given tag name and
  attributes.
  */
  static create(spec) {
    return new BlockWrapper(spec.tagName, spec.attributes || noAttrs);
  }
  /**
  Create a range set from the given block wrapper ranges.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
}
BlockWrapper.prototype.startSide = BlockWrapper.prototype.endSide = -1;
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur = dom, stop = false; cur && !stop; ) {
    if (cur.nodeType == 1) {
      let bounding, top2 = cur == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
          stop = true;
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.assignedSlot || cur.parentNode;
          continue;
        }
        let rect2 = cur.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur.scrollTop;
            cur.scrollTop += moveY / scaleY;
            movedY = (cur.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur.scrollLeft;
            cur.scrollLeft += moveX / scaleX;
            movedX = (cur.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x, y;
  for (let cur = dom.parentNode; cur; ) {
    if (cur == doc2.body || x && y) {
      break;
    } else if (cur.nodeType == 1) {
      if (!y && cur.scrollHeight > cur.clientHeight)
        y = cur;
      if (!x && cur.scrollWidth > cur.clientWidth)
        x = cur;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
  return { x, y };
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
if (browser.safari && browser.safari_version >= 26)
  preventScrollSupported = false;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code, mods) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode, offset = selection2.focusOffset;
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node));
  for (; ; ) {
    if (offset) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset > 0) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return { node, offset };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
class DOMPos {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
var Direction = /* @__PURE__ */ (function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
function isolatesEq(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let iA = a[i], iB = b[i];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
const types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from, ch, br, type; i < to; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from; i < to; ) {
      let type = types[i];
      if (type == 256) {
        let end = i + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i = end;
      } else {
        prev = type;
        i++;
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
  for (let i = from; i < to; i++) {
    let type = charType(text.charCodeAt(i));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler = /* @__PURE__ */ Facet.define();
const focusChangeEffect = /* @__PURE__ */ Facet.define();
const clipboardInputFilter = /* @__PURE__ */ Facet.define();
const clipboardOutputFilter = /* @__PURE__ */ Facet.define();
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
const scrollHandler = /* @__PURE__ */ Facet.define();
class ScrollTarget {
  constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
const setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception)) ;
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define({
  combine(plugins) {
    return plugins.filter((p, i) => {
      for (let j = 0; j < i; j++)
        if (plugins[j].plugin == p.plugin)
          return false;
      return true;
    });
  }
});
class ViewPlugin {
  constructor(id, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.baseExtensions = buildExtensions(this);
    this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(arg) {
    return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
      let ext = [];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return ViewPlugin.define((view, arg) => new cls(view, arg), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.plugin.create(view, this.spec.arg);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const blockWrappers = /* @__PURE__ */ Facet.define();
const outerDecorations = /* @__PURE__ */ Facet.define();
const atomicRanges = /* @__PURE__ */ Facet.define();
const bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i) => i instanceof Function ? i(view) : i);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to = toDoc - line.from;
      let level = result;
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add = { from, to, direction, inner: [] };
          level.push(add);
          level = add.inner;
        }
      }
    }
  });
  return result;
}
const scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m = source(view);
    if (m) {
      if (m.left != null)
        left = Math.max(left, m.left);
      if (m.right != null)
        right = Math.max(right, m.right);
      if (m.top != null)
        top2 = Math.max(top2, m.top);
      if (m.bottom != null)
        bottom = Math.max(bottom, m.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  // Extend a set to cover all the content in `ranges`, which is a
  // flat array with each pair of numbers representing fromB/toB
  // positions. These pairs are generated in unchanged ranges, so the
  // offset between doc A and doc B is the same for their start and
  // end points.
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, off = 0; ; ) {
      let nextD = dI < diff.length ? diff[dI].fromB : 1e9;
      let nextR = rI < ranges.length ? ranges[rI] : 1e9;
      let fromB = Math.min(nextD, nextR);
      if (fromB == 1e9)
        break;
      let fromA = fromB + off, toB = fromB, toA = fromA;
      for (; ; ) {
        if (rI < ranges.length && ranges[rI] <= toB) {
          let end = ranges[rI + 1];
          rI += 2;
          toB = Math.max(toB, end);
          for (let i = dI; i < diff.length && diff[i].fromB <= toB; i++)
            off = diff[i].toA - diff[i].toB;
          toA = Math.max(toA, end + off);
        } else if (dI < diff.length && diff[dI].fromB <= toB) {
          let next = diff[dI++];
          toB = Math.max(toB, next.toB);
          toA = Math.max(toA, next.toA);
          off = next.toA - next.toB;
        } else {
          break;
        }
      }
      result.push(new ChangedRange(fromA, toA, fromB, toB));
    }
    return result;
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
const noChildren = [];
class Tile {
  constructor(dom, length, flags = 0) {
    this.dom = dom;
    this.length = length;
    this.flags = flags;
    this.parent = null;
    dom.cmTile = this;
  }
  get breakAfter() {
    return this.flags & 1;
  }
  get children() {
    return noChildren;
  }
  isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  isComposite() {
    return false;
  }
  isLine() {
    return false;
  }
  isText() {
    return false;
  }
  isBlock() {
    return false;
  }
  get domAttrs() {
    return null;
  }
  sync(track) {
    this.flags |= 2;
    if (this.flags & 4) {
      this.flags &= -5;
      let attrs = this.domAttrs;
      if (attrs)
        setAttrs(this.dom, attrs);
    }
  }
  toString() {
    return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
  }
  destroy() {
    this.parent = null;
  }
  setDOM(dom) {
    this.dom = dom;
    dom.cmTile = this;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(tile, start = this.posAtStart) {
    let pos = start;
    for (let child of this.children) {
      if (child == tile)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(tile) {
    return this.posBefore(tile) + tile.length;
  }
  covers(side) {
    return true;
  }
  coordsIn(pos, side) {
    return null;
  }
  domPosFor(off, side) {
    let index = domIndex(this.dom);
    let after = this.length ? off > 0 : side > 0;
    return new DOMPos(this.parent.dom, index + (after ? 1 : 0), off == 0 || off == this.length);
  }
  markDirty(attrs) {
    this.flags &= -3;
    if (attrs)
      this.flags |= 4;
    if (this.parent && this.parent.flags & 2)
      this.parent.markDirty(false);
  }
  get overrideDOMText() {
    return null;
  }
  get root() {
    for (let t2 = this; t2; t2 = t2.parent)
      if (t2 instanceof DocTile)
        return t2;
    return null;
  }
  static get(dom) {
    return dom.cmTile;
  }
}
class CompositeTile extends Tile {
  constructor(dom) {
    super(dom, 0);
    this._children = [];
  }
  isComposite() {
    return true;
  }
  get children() {
    return this._children;
  }
  get lastChild() {
    return this.children.length ? this.children[this.children.length - 1] : null;
  }
  append(child) {
    this.children.push(child);
    child.parent = this;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    let parent = this.dom, prev = null, next;
    let tracking = (track === null || track === void 0 ? void 0 : track.node) == parent ? track : null;
    let length = 0;
    for (let child of this.children) {
      child.sync(track);
      length += child.length + child.breakAfter;
      next = prev ? prev.nextSibling : parent.firstChild;
      if (tracking && next != child.dom)
        tracking.written = true;
      if (child.dom.parentNode == parent) {
        while (next && next != child.dom)
          next = rm$1(next);
      } else {
        parent.insertBefore(child.dom, next);
      }
      prev = child.dom;
    }
    next = prev ? prev.nextSibling : parent.firstChild;
    if (tracking && next)
      tracking.written = true;
    while (next)
      next = rm$1(next);
    this.length = length;
  }
}
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class DocTile extends CompositeTile {
  constructor(view, dom) {
    super(dom);
    this.view = view;
  }
  owns(tile) {
    for (; tile; tile = tile.parent)
      if (tile == this)
        return true;
    return false;
  }
  isBlock() {
    return true;
  }
  nearest(dom) {
    for (; ; ) {
      if (!dom)
        return null;
      let tile = Tile.get(dom);
      if (tile && this.owns(tile))
        return tile;
      dom = dom.parentNode;
    }
  }
  blockTiles(f) {
    for (let stack = [], cur = this, i = 0, pos = 0; ; ) {
      if (i == cur.children.length) {
        if (!stack.length)
          return;
        cur = cur.parent;
        if (cur.breakAfter)
          pos++;
        i = stack.pop();
      } else {
        let next = cur.children[i++];
        if (next instanceof BlockWrapperTile) {
          stack.push(i);
          cur = next;
          i = 0;
        } else {
          let end = pos + next.length;
          let result = f(next, pos);
          if (result !== void 0)
            return result;
          pos = end + next.breakAfter;
        }
      }
    }
  }
  // Find the block at the given position. If side < -1, make sure to
  // stay before block widgets at that position, if side > 1, after
  // such widgets (used for selection drawing, which needs to be able
  // to get coordinates for positions that aren't valid cursor positions).
  resolveBlock(pos, side) {
    let before, beforeOff = -1, after, afterOff = -1;
    this.blockTiles((tile, off) => {
      let end = off + tile.length;
      if (pos >= off && pos <= end) {
        if (tile.isWidget() && side >= -1 && side <= 1) {
          if (tile.flags & 32)
            return true;
          if (tile.flags & 16)
            before = void 0;
        }
        if ((off < pos || pos == end && (side < -1 ? tile.length : tile.covers(1))) && (!before || !tile.isWidget() && before.isWidget())) {
          before = tile;
          beforeOff = pos - off;
        }
        if ((end > pos || pos == off && (side > 1 ? tile.length : tile.covers(-1))) && (!after || !tile.isWidget() && after.isWidget())) {
          after = tile;
          afterOff = pos - off;
        }
      }
    });
    if (!before && !after)
      throw new Error("No tile at position " + pos);
    return before && side < 0 || !after ? { tile: before, offset: beforeOff } : { tile: after, offset: afterOff };
  }
}
class BlockWrapperTile extends CompositeTile {
  constructor(dom, wrapper) {
    super(dom);
    this.wrapper = wrapper;
  }
  isBlock() {
    return true;
  }
  covers(side) {
    if (!this.children.length)
      return false;
    return side < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1);
  }
  get domAttrs() {
    return this.wrapper.attributes;
  }
  static of(wrapper, dom) {
    let tile = new BlockWrapperTile(dom || document.createElement(wrapper.tagName), wrapper);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
}
class LineTile extends CompositeTile {
  constructor(dom, attrs) {
    super(dom);
    this.attrs = attrs;
  }
  isLine() {
    return true;
  }
  static start(attrs, dom, keepAttrs) {
    let line = new LineTile(dom || document.createElement("div"), attrs);
    if (!dom || !keepAttrs)
      line.flags |= 4;
    return line;
  }
  get domAttrs() {
    return this.attrs;
  }
  // Find the tile associated with a given position in this line.
  resolveInline(pos, side, forCoords) {
    let before = null, beforeOff = -1, after = null, afterOff = -1;
    function scan(tile, pos2) {
      for (let i = 0, off = 0; i < tile.children.length && off <= pos2; i++) {
        let child = tile.children[i], end = off + child.length;
        if (end >= pos2) {
          if (child.isComposite()) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && (side > 0 || forCoords && onSameLine(after, child))) && (end > pos2 || child.flags & 32)) {
            after = child;
            afterOff = pos2 - off;
          } else if (off < pos2 || child.flags & 16 && !child.isHidden) {
            before = child;
            beforeOff = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(this, pos);
    let target = (side < 0 ? before : after) || before || after;
    return target ? { tile: target, offset: target == before ? beforeOff : afterOff } : null;
  }
  coordsIn(pos, side) {
    let found = this.resolveInline(pos, side, true);
    if (!found)
      return fallbackRect(this);
    return found.tile.coordsIn(Math.max(0, found.offset), side);
  }
  domIn(pos, side) {
    let found = this.resolveInline(pos, side);
    if (found) {
      let { tile, offset } = found;
      if (this.dom.contains(tile.dom)) {
        if (tile.isText())
          return new DOMPos(tile.dom, Math.min(tile.dom.nodeValue.length, offset));
        return tile.domPosFor(offset, tile.flags & 16 ? 1 : tile.flags & 32 ? -1 : side);
      }
      let parent = found.tile.parent, saw = false;
      for (let ch of parent.children) {
        if (saw)
          return new DOMPos(ch.dom, 0);
        if (ch == found.tile) {
          saw = true;
        }
      }
    }
    return new DOMPos(this.dom, 0);
  }
}
function fallbackRect(tile) {
  let last = tile.dom.lastChild;
  if (!last)
    return tile.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function onSameLine(a, b) {
  let posA = a.coordsIn(0, 1), posB = b.coordsIn(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
class MarkTile extends CompositeTile {
  constructor(dom, mark) {
    super(dom);
    this.mark = mark;
  }
  get domAttrs() {
    return this.mark.attrs;
  }
  static of(mark, dom) {
    let tile = new MarkTile(dom || document.createElement(mark.tagName), mark);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
}
class TextTile extends Tile {
  constructor(dom, text) {
    super(dom, text.length);
    this.text = text;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  isText() {
    return true;
  }
  toString() {
    return JSON.stringify(this.text);
  }
  coordsIn(pos, side) {
    let length = this.dom.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(this.dom, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  static of(text, dom) {
    let tile = new TextTile(dom || document.createTextNode(text), text);
    if (!dom)
      tile.flags |= 2;
    return tile;
  }
}
class WidgetTile extends Tile {
  constructor(dom, length, widget, flags) {
    super(dom, length, flags);
    this.widget = widget;
  }
  isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  covers(side) {
    if (this.flags & 48)
      return false;
    return (this.flags & (side < 0 ? 64 : 128)) > 0;
  }
  coordsIn(pos, side) {
    return this.coordsInWidget(pos, side, false);
  }
  coordsInWidget(pos, side, block) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (block) {
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    } else {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.flags & 16 ? true : this.flags & 32 ? false : pos > 0;
      for (let i = fromBack ? rects.length - 1 : 0; ; i += fromBack ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
  }
  get overrideDOMText() {
    if (!this.length)
      return Text.empty;
    let { root } = this;
    if (!root)
      return Text.empty;
    let start = this.posAtStart;
    return root.view.state.doc.slice(start, start + this.length);
  }
  destroy() {
    super.destroy();
    this.widget.destroy(this.dom);
  }
  static of(widget, view, length, flags, dom) {
    if (!dom) {
      dom = widget.toDOM(view);
      if (!widget.editable)
        dom.contentEditable = "false";
    }
    return new WidgetTile(dom, length, widget, flags);
  }
}
class WidgetBufferTile extends Tile {
  constructor(flags) {
    let img = document.createElement("img");
    img.className = "cm-widgetBuffer";
    img.setAttribute("aria-hidden", "true");
    super(img, 0, flags);
  }
  get isHidden() {
    return true;
  }
  get overrideDOMText() {
    return Text.empty;
  }
  coordsIn(pos) {
    return this.dom.getBoundingClientRect();
  }
}
class TilePointer {
  constructor(top2) {
    this.index = 0;
    this.beforeBreak = false;
    this.parents = [];
    this.tile = top2;
  }
  // Advance by the given distance. If side is -1, stop leaving or
  // entering tiles, or skipping zero-length tiles, once the distance
  // has been traversed. When side is 1, leave, enter, or skip
  // everything at the end position.
  advance(dist2, side, walker) {
    let { tile, index, beforeBreak, parents } = this;
    while (dist2 || side > 0) {
      if (!tile.isComposite()) {
        if (index == tile.length) {
          beforeBreak = !!tile.breakAfter;
          ({ tile, index } = parents.pop());
          index++;
        } else if (!dist2) {
          break;
        } else {
          let take = Math.min(dist2, tile.length - index);
          if (walker)
            walker.skip(tile, index, index + take);
          dist2 -= take;
          index += take;
        }
      } else if (beforeBreak) {
        if (!dist2)
          break;
        if (walker)
          walker.break();
        dist2--;
        beforeBreak = false;
      } else if (index == tile.children.length) {
        if (!dist2 && !parents.length)
          break;
        if (walker)
          walker.leave(tile);
        beforeBreak = !!tile.breakAfter;
        ({ tile, index } = parents.pop());
        index++;
      } else {
        let next = tile.children[index], brk = next.breakAfter;
        if ((side > 0 ? next.length <= dist2 : next.length < dist2) && (!walker || walker.skip(next, 0, next.length) !== false || !next.isComposite)) {
          beforeBreak = !!brk;
          index++;
          dist2 -= next.length;
        } else {
          parents.push({ tile, index });
          tile = next;
          index = 0;
          if (walker && next.isComposite())
            walker.enter(next);
        }
      }
    }
    this.tile = tile;
    this.index = index;
    this.beforeBreak = beforeBreak;
    return this;
  }
  get root() {
    return this.parents.length ? this.parents[0].tile : this.tile;
  }
}
class OpenWrapper {
  constructor(from, to, wrapper, rank) {
    this.from = from;
    this.to = to;
    this.wrapper = wrapper;
    this.rank = rank;
  }
}
class TileBuilder {
  constructor(cache, root, blockWrappers2) {
    this.cache = cache;
    this.root = root;
    this.blockWrappers = blockWrappers2;
    this.curLine = null;
    this.lastBlock = null;
    this.afterWidget = null;
    this.pos = 0;
    this.wrappers = [];
    this.wrapperPos = 0;
  }
  addText(text, marks, openStart, tile) {
    var _a2;
    this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    let prev = parent.lastChild;
    if (prev && prev.isText() && !(prev.flags & 8)) {
      this.cache.reused.set(
        prev,
        2
        /* Reused.DOM */
      );
      let tile2 = parent.children[parent.children.length - 1] = new TextTile(prev.dom, prev.text + text);
      tile2.parent = parent;
    } else {
      parent.append(tile || TextTile.of(text, (_a2 = this.cache.find(TextTile)) === null || _a2 === void 0 ? void 0 : _a2.dom));
    }
    this.pos += text.length;
    this.afterWidget = null;
  }
  addComposition(composition, context) {
    let line = this.curLine;
    if (line.dom != context.line.dom) {
      line.setDOM(this.cache.reused.has(context.line) ? freeNode(context.line.dom) : context.line.dom);
      this.cache.reused.set(
        context.line,
        2
        /* Reused.DOM */
      );
    }
    let head = line;
    for (let i = context.marks.length - 1; i >= 0; i--) {
      let mark = context.marks[i];
      let last = head.lastChild;
      if (last instanceof MarkTile && last.mark.eq(mark.mark)) {
        if (last.dom != mark.dom)
          last.setDOM(freeNode(mark.dom));
        head = last;
      } else {
        if (this.cache.reused.get(mark)) {
          let tile = Tile.get(mark.dom);
          if (tile)
            tile.setDOM(freeNode(mark.dom));
        }
        let nw = MarkTile.of(mark.mark, mark.dom);
        head.append(nw);
        head = nw;
      }
      this.cache.reused.set(
        mark,
        2
        /* Reused.DOM */
      );
    }
    let oldTile = Tile.get(composition.text);
    if (oldTile)
      this.cache.reused.set(
        oldTile,
        2
        /* Reused.DOM */
      );
    let text = new TextTile(composition.text, composition.text.nodeValue);
    text.flags |= 8;
    head.append(text);
  }
  addInlineWidget(widget, marks, openStart) {
    let noSpace = this.afterWidget && widget.flags & 48 && (this.afterWidget.flags & 48) == (widget.flags & 48);
    if (!noSpace)
      this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    if (!noSpace && !(widget.flags & 16))
      parent.append(this.getBuffer(1));
    parent.append(widget);
    this.pos += widget.length;
    this.afterWidget = widget;
  }
  addMark(tile, marks, openStart) {
    this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    parent.append(tile);
    this.pos += tile.length;
    this.afterWidget = null;
  }
  addBlockWidget(widget) {
    this.getBlockPos().append(widget);
    this.pos += widget.length;
    this.lastBlock = widget;
    this.endLine();
  }
  continueWidget(length) {
    let widget = this.afterWidget || this.lastBlock;
    widget.length += length;
    this.pos += length;
  }
  addLineStart(attrs, dom) {
    var _a2;
    if (!attrs)
      attrs = lineBaseAttrs;
    let tile = LineTile.start(attrs, dom || ((_a2 = this.cache.find(LineTile)) === null || _a2 === void 0 ? void 0 : _a2.dom), !!dom);
    this.getBlockPos().append(this.lastBlock = this.curLine = tile);
  }
  addLine(tile) {
    this.getBlockPos().append(tile);
    this.pos += tile.length;
    this.lastBlock = tile;
    this.endLine();
  }
  addBreak() {
    this.lastBlock.flags |= 1;
    this.endLine();
    this.pos++;
  }
  addLineStartIfNotCovered(attrs) {
    if (!this.blockPosCovered())
      this.addLineStart(attrs);
  }
  ensureLine(attrs) {
    if (!this.curLine)
      this.addLineStart(attrs);
  }
  ensureMarks(marks, openStart) {
    var _a2;
    let parent = this.curLine;
    for (let i = marks.length - 1; i >= 0; i--) {
      let mark = marks[i], last;
      if (openStart > 0 && (last = parent.lastChild) && last instanceof MarkTile && last.mark.eq(mark)) {
        parent = last;
        openStart--;
      } else {
        let tile = MarkTile.of(mark, (_a2 = this.cache.find(MarkTile, (m) => m.mark.eq(mark))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
        openStart = 0;
      }
    }
    return parent;
  }
  endLine() {
    if (this.curLine) {
      this.flushBuffer();
      let last = this.curLine.lastChild;
      if (!last || !hasContent(this.curLine, false) || last.dom.nodeName != "BR" && last.isWidget() && !(browser.ios && hasContent(this.curLine, true)))
        this.curLine.append(this.cache.findWidget(
          BreakWidget,
          0,
          32
          /* TileFlag.After */
        ) || new WidgetTile(
          BreakWidget.toDOM(),
          0,
          BreakWidget,
          32
          /* TileFlag.After */
        ));
      this.curLine = this.afterWidget = null;
    }
  }
  updateBlockWrappers() {
    if (this.wrapperPos > this.pos + 1e4) {
      this.blockWrappers.goto(this.pos);
      this.wrappers.length = 0;
    }
    for (let i = this.wrappers.length - 1; i >= 0; i--)
      if (this.wrappers[i].to < this.pos)
        this.wrappers.splice(i, 1);
    for (let cur = this.blockWrappers; cur.value && cur.from <= this.pos; cur.next())
      if (cur.to >= this.pos) {
        let wrap = new OpenWrapper(cur.from, cur.to, cur.value, cur.rank), i = this.wrappers.length;
        while (i > 0 && (this.wrappers[i - 1].rank - wrap.rank || this.wrappers[i - 1].to - wrap.to) < 0)
          i--;
        this.wrappers.splice(i, 0, wrap);
      }
    this.wrapperPos = this.pos;
  }
  getBlockPos() {
    var _a2;
    this.updateBlockWrappers();
    let parent = this.root;
    for (let wrap of this.wrappers) {
      let last = parent.lastChild;
      if (wrap.from < this.pos && last instanceof BlockWrapperTile && last.wrapper.eq(wrap.wrapper)) {
        parent = last;
      } else {
        let tile = BlockWrapperTile.of(wrap.wrapper, (_a2 = this.cache.find(BlockWrapperTile, (t2) => t2.wrapper.eq(wrap.wrapper))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
      }
    }
    return parent;
  }
  blockPosCovered() {
    let last = this.lastBlock;
    return last != null && !last.breakAfter && (!last.isWidget() || (last.flags & (32 | 128)) > 0);
  }
  getBuffer(side) {
    let flags = 2 | (side < 0 ? 16 : 32);
    let found = this.cache.find(
      WidgetBufferTile,
      void 0,
      1
      /* Reused.Full */
    );
    if (found)
      found.flags = flags;
    return found || new WidgetBufferTile(flags);
  }
  flushBuffer() {
    if (this.afterWidget && !(this.afterWidget.flags & 32)) {
      this.afterWidget.parent.append(this.getBuffer(-1));
      this.afterWidget = null;
    }
  }
}
class TextStream {
  constructor(doc2) {
    this.skipCount = 0;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
  }
  skip(len) {
    if (this.textOff + len <= this.text.length) {
      this.textOff += len;
    } else {
      this.skipCount += len - (this.text.length - this.textOff);
      this.text = "";
      this.textOff = 0;
    }
  }
  next(maxLen) {
    if (this.textOff == this.text.length) {
      let { value, lineBreak, done } = this.cursor.next(this.skipCount);
      this.skipCount = 0;
      if (done)
        throw new Error("Ran out of text content when drawing inline views");
      this.text = value;
      let len = this.textOff = Math.min(maxLen, value.length);
      return lineBreak ? null : value.slice(0, len);
    }
    let end = Math.min(this.text.length, this.textOff + maxLen);
    let chars = this.text.slice(this.textOff, end);
    this.textOff = end;
    return chars;
  }
}
const buckets = [WidgetTile, LineTile, TextTile, MarkTile, WidgetBufferTile, BlockWrapperTile, DocTile];
for (let i = 0; i < buckets.length; i++)
  buckets[i].bucket = i;
class TileCache {
  constructor(view) {
    this.view = view;
    this.buckets = buckets.map(() => []);
    this.index = buckets.map(() => 0);
    this.reused = /* @__PURE__ */ new Map();
  }
  // Put a tile in the cache.
  add(tile) {
    let i = tile.constructor.bucket, bucket = this.buckets[i];
    if (bucket.length < 6)
      bucket.push(tile);
    else
      bucket[
        this.index[i] = (this.index[i] + 1) % 6
        /* C.Bucket */
      ] = tile;
  }
  find(cls, test, type = 2) {
    let i = cls.bucket;
    let bucket = this.buckets[i], off = this.index[i];
    for (let j = bucket.length - 1; j >= 0; j--) {
      let index = (j + off) % bucket.length, tile = bucket[index];
      if ((!test || test(tile)) && !this.reused.has(tile)) {
        bucket.splice(index, 1);
        if (index < off)
          this.index[i]--;
        this.reused.set(tile, type);
        return tile;
      }
    }
    return null;
  }
  findWidget(widget, length, flags) {
    let widgets = this.buckets[0];
    if (widgets.length)
      for (let i = 0, pass = 0; ; i++) {
        if (i == widgets.length) {
          if (pass)
            return null;
          pass = 1;
          i = 0;
        }
        let tile = widgets[i];
        if (!this.reused.has(tile) && (pass == 0 ? tile.widget.compare(widget) : tile.widget.constructor == widget.constructor && widget.updateDOM(tile.dom, this.view))) {
          widgets.splice(i, 1);
          if (i < this.index[0])
            this.index[0]--;
          if (tile.widget == widget && tile.length == length && (tile.flags & (496 | 1)) == flags) {
            this.reused.set(
              tile,
              1
              /* Reused.Full */
            );
            return tile;
          } else {
            this.reused.set(
              tile,
              2
              /* Reused.DOM */
            );
            return new WidgetTile(tile.dom, length, widget, tile.flags & -498 | flags);
          }
        }
      }
  }
  reuse(tile) {
    this.reused.set(
      tile,
      1
      /* Reused.Full */
    );
    return tile;
  }
  maybeReuse(tile, type = 2) {
    if (this.reused.has(tile))
      return void 0;
    this.reused.set(tile, type);
    return tile.dom;
  }
  clear() {
    for (let i = 0; i < this.buckets.length; i++)
      this.buckets[i].length = this.index[i] = 0;
  }
}
class TileUpdate {
  constructor(view, old, blockWrappers2, decorations2, disallowBlockEffectsFor) {
    this.view = view;
    this.decorations = decorations2;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.openWidget = false;
    this.openMarks = 0;
    this.cache = new TileCache(view);
    this.text = new TextStream(view.state.doc);
    this.builder = new TileBuilder(this.cache, new DocTile(view, view.contentDOM), RangeSet.iter(blockWrappers2));
    this.cache.reused.set(
      old,
      2
      /* Reused.DOM */
    );
    this.old = new TilePointer(old);
    this.reuseWalker = {
      skip: (tile, from, to) => {
        this.cache.add(tile);
        if (tile.isComposite())
          return false;
      },
      enter: (tile) => this.cache.add(tile),
      leave: () => {
      },
      break: () => {
      }
    };
  }
  run(changes, composition) {
    let compositionContext = composition && this.getCompositionContext(composition.text);
    for (let posA = 0, posB = 0, i = 0; ; ) {
      let next = i < changes.length ? changes[i++] : null;
      let skipA = next ? next.fromA : this.old.root.length;
      if (skipA > posA) {
        let len = skipA - posA;
        this.preserve(len, !i, !next);
        posA = skipA;
        posB += len;
      }
      if (!next)
        break;
      if (composition && next.fromA <= composition.range.fromA && next.toA >= composition.range.toA) {
        this.forward(next.fromA, composition.range.fromA, composition.range.fromA < composition.range.toA ? 1 : -1);
        this.emit(posB, composition.range.fromB);
        this.cache.clear();
        this.builder.addComposition(composition, compositionContext);
        this.text.skip(composition.range.toB - composition.range.fromB);
        this.forward(composition.range.fromA, next.toA);
        this.emit(composition.range.toB, next.toB);
      } else {
        this.forward(next.fromA, next.toA);
        this.emit(posB, next.toB);
      }
      posB = next.toB;
      posA = next.toA;
    }
    if (this.builder.curLine)
      this.builder.endLine();
    return this.builder.root;
  }
  preserve(length, incStart, incEnd) {
    let activeMarks = getMarks(this.old), openMarks = this.openMarks;
    this.old.advance(length, incEnd ? 1 : -1, {
      skip: (tile, from, to) => {
        if (tile.isWidget()) {
          if (this.openWidget) {
            this.builder.continueWidget(to - from);
          } else {
            let widget = to > 0 || from < tile.length ? WidgetTile.of(tile.widget, this.view, to - from, tile.flags & 496, this.cache.maybeReuse(tile)) : this.cache.reuse(tile);
            if (widget.flags & 256) {
              widget.flags &= -2;
              this.builder.addBlockWidget(widget);
            } else {
              this.builder.ensureLine(null);
              this.builder.addInlineWidget(widget, activeMarks, openMarks);
              openMarks = activeMarks.length;
            }
          }
        } else if (tile.isText()) {
          this.builder.ensureLine(null);
          if (!from && to == tile.length) {
            this.builder.addText(tile.text, activeMarks, openMarks, this.cache.reuse(tile));
          } else {
            this.cache.add(tile);
            this.builder.addText(tile.text.slice(from, to), activeMarks, openMarks);
          }
          openMarks = activeMarks.length;
        } else if (tile.isLine()) {
          tile.flags &= -2;
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          this.builder.addLine(tile);
        } else if (tile instanceof WidgetBufferTile) {
          this.cache.add(tile);
        } else if (tile instanceof MarkTile) {
          this.builder.ensureLine(null);
          this.builder.addMark(tile, activeMarks, openMarks);
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          openMarks = activeMarks.length;
        } else {
          return false;
        }
        this.openWidget = false;
      },
      enter: (tile) => {
        if (tile.isLine()) {
          this.builder.addLineStart(tile.attrs, this.cache.maybeReuse(tile));
        } else {
          this.cache.add(tile);
          if (tile instanceof MarkTile)
            activeMarks.unshift(tile.mark);
        }
        this.openWidget = false;
      },
      leave: (tile) => {
        if (tile.isLine()) {
          if (activeMarks.length)
            activeMarks.length = openMarks = 0;
        } else if (tile instanceof MarkTile) {
          activeMarks.shift();
          openMarks = Math.min(openMarks, activeMarks.length);
        }
      },
      break: () => {
        this.builder.addBreak();
        this.openWidget = false;
      }
    });
    this.text.skip(length);
  }
  emit(from, to) {
    let pendingLineAttrs = null;
    let b = this.builder, markCount = 0;
    let openEnd = RangeSet.spans(this.decorations, from, to, {
      point: (from2, to2, deco, active, openStart, index) => {
        if (deco instanceof PointDecoration) {
          if (this.disallowBlockEffectsFor[index]) {
            if (deco.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (to2 > this.view.state.doc.lineAt(from2).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          markCount = active.length;
          if (openStart > active.length) {
            b.continueWidget(to2 - from2);
          } else {
            let widget = deco.widget || (deco.block ? NullWidget.block : NullWidget.inline);
            let flags = widgetFlags(deco);
            let tile = this.cache.findWidget(widget, to2 - from2, flags) || WidgetTile.of(widget, this.view, to2 - from2, flags);
            if (deco.block) {
              if (deco.startSide > 0)
                b.addLineStartIfNotCovered(pendingLineAttrs);
              b.addBlockWidget(tile);
            } else {
              b.ensureLine(pendingLineAttrs);
              b.addInlineWidget(tile, active, openStart);
            }
          }
          pendingLineAttrs = null;
        } else {
          pendingLineAttrs = addLineDeco(pendingLineAttrs, deco);
        }
        if (to2 > from2)
          this.text.skip(to2 - from2);
      },
      span: (from2, to2, active, openStart) => {
        for (let pos = from2; pos < to2; ) {
          let chars = this.text.next(Math.min(512, to2 - pos));
          if (chars == null) {
            b.addLineStartIfNotCovered(pendingLineAttrs);
            b.addBreak();
            pos++;
          } else {
            b.ensureLine(pendingLineAttrs);
            b.addText(chars, active, openStart);
            pos += chars.length;
          }
          pendingLineAttrs = null;
        }
      }
    });
    b.addLineStartIfNotCovered(pendingLineAttrs);
    this.openWidget = openEnd > markCount;
    this.openMarks = openEnd;
  }
  forward(from, to, side = 1) {
    if (to - from <= 10) {
      this.old.advance(to - from, side, this.reuseWalker);
    } else {
      this.old.advance(5, -1, this.reuseWalker);
      this.old.advance(to - from - 10, -1);
      this.old.advance(5, side, this.reuseWalker);
    }
  }
  getCompositionContext(text) {
    let marks = [], line = null;
    for (let parent = text.parentNode; ; parent = parent.parentNode) {
      let tile = Tile.get(parent);
      if (parent == this.view.contentDOM)
        break;
      if (tile instanceof MarkTile)
        marks.push(tile);
      else if (tile === null || tile === void 0 ? void 0 : tile.isLine())
        line = tile;
      else if (parent.nodeName == "DIV" && !line && parent != this.view.contentDOM)
        line = new LineTile(parent, lineBaseAttrs);
      else
        marks.push(MarkTile.of(new MarkDecoration({ tagName: parent.nodeName.toLowerCase(), attributes: getAttrs(parent) }), parent));
    }
    return { line, marks };
  }
}
function hasContent(tile, requireText) {
  let scan = (tile2) => {
    for (let ch of tile2.children)
      if ((requireText ? ch.isText() : ch.length) || scan(ch))
        return true;
    return false;
  };
  return scan(tile);
}
function widgetFlags(deco) {
  let flags = deco.isReplace ? (deco.startSide < 0 ? 64 : 0) | (deco.endSide > 0 ? 128 : 0) : deco.startSide > 0 ? 32 : 16;
  if (deco.block)
    flags |= 256;
  return flags;
}
const lineBaseAttrs = { class: "cm-line" };
function addLineDeco(value, deco) {
  let attrs = deco.spec.attributes, cls = deco.spec.class;
  if (!attrs && !cls)
    return value;
  if (!value)
    value = { class: "cm-line" };
  if (attrs)
    combineAttrs(attrs, value);
  if (cls)
    value.class += " " + cls;
  return value;
}
function getMarks(ptr) {
  let found = [];
  for (let i = ptr.parents.length; i > 1; i--) {
    let tile = i == ptr.parents.length ? ptr.tile : ptr.parents[i].tile;
    if (tile instanceof MarkTile)
      found.push(tile.mark);
  }
  return found;
}
function freeNode(node) {
  let tile = Tile.get(node);
  if (tile)
    tile.setDOM(node.cloneNode());
  return node;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
NullWidget.block = /* @__PURE__ */ new NullWidget("div");
const BreakWidget = /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    return document.createElement("br");
  }
  get isHidden() {
    return true;
  }
  get editable() {
    return true;
  }
}();
class DocView {
  constructor(view) {
    this.view = view;
    this.decorations = [];
    this.blockWrappers = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.updateDeco();
    this.tile = new DocTile(view, view.contentDOM);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      let { from, to } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, prevWrappers = this.blockWrappers;
    this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, this.decorations, update.changes);
    if (decoDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let blockDiff = findChangedWrappers(prevWrappers, this.blockWrappers, update.changes);
    if (blockDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, blockDiff);
    if (composition && !changedRanges.some((r) => r.fromA <= composition.range.fromA && r.toA >= composition.range.toA))
      changedRanges = composition.range.addToSet(changedRanges.slice());
    if (this.tile.flags & 2 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, composition) {
    this.view.viewState.mustMeasureContent = true;
    let { observer } = this.view;
    observer.ignore(() => {
      if (composition || changes.length) {
        let oldTile = this.tile;
        let builder = new TileUpdate(this.view, oldTile, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
        this.tile = builder.run(changes, composition);
        destroyDropped(oldTile, builder.cache.reused);
      }
      this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.tile.sync(track);
      if (track && (track.written || observer.selectionRange.focusNode != track.node || !this.tile.dom.contains(track.node)))
        this.forceSelection = true;
      this.tile.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.tile.children)
        if (child.isWidget() && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let { dom } = this.tile;
    let activeElt = this.view.root.activeElement, focused = activeElt == dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || dom.tabIndex > -1) && hasSelection(dom, this.view.observer.selectionRange) && !(activeElt && dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main, anchor, head;
    if (main.empty) {
      head = anchor = this.inlineDOMNearPos(main.anchor, main.assoc || 1);
    } else {
      head = this.inlineDOMNearPos(main.head, main.head == main.from ? 1 : -1);
      anchor = this.inlineDOMNearPos(main.anchor, main.anchor == main.from ? 1 : -1);
    }
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, dom)) {
          dom.blur();
          dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == dom) {
          dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = this.lineAt(cursor2.head, cursor2.assoc);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc, cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  posFromDOM(node, offset) {
    let tile = this.tile.nearest(node);
    if (!tile)
      return this.tile.dom.compareDocumentPosition(node) & 2 ? 0 : this.view.state.doc.length;
    let start = tile.posAtStart;
    if (tile.isComposite()) {
      let after;
      if (node == tile.dom) {
        after = tile.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == tile.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == tile.dom.firstChild)
        return start;
      while (after && !Tile.get(after))
        after = after.nextSibling;
      if (!after)
        return start + tile.length;
      for (let i = 0, pos = start; ; i++) {
        let child = tile.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    } else if (tile.isText()) {
      return node == tile.dom ? start + offset : start + (offset ? tile.length : 0);
    } else {
      return start;
    }
  }
  domAtPos(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget())
      return tile.domPosFor(pos, side);
    return tile.domIn(offset, side);
  }
  inlineDOMNearPos(pos, side) {
    let before, beforeOff = -1, beforeBad = false;
    let after, afterOff = -1, afterBad = false;
    this.tile.blockTiles((tile, off) => {
      if (tile.isWidget()) {
        if (tile.flags & 32 && off >= pos)
          return true;
        if (tile.flags & 16)
          beforeBad = true;
      } else {
        let end = off + tile.length;
        if (off <= pos) {
          before = tile;
          beforeOff = pos - off;
          beforeBad = end < pos;
        }
        if (end >= pos && !after) {
          after = tile;
          afterOff = pos - off;
          afterBad = off > pos;
        }
        if (off > pos && after)
          return true;
      }
    });
    if (!before && !after)
      return this.domAtPos(pos, side);
    if (beforeBad && after)
      before = null;
    else if (afterBad && before)
      after = null;
    return before && side < 0 || !after ? before.domIn(beforeOff, side) : after.domIn(afterOff, side);
  }
  coordsAt(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget()) {
      if (tile.widget instanceof BlockGapWidget)
        return null;
      return tile.coordsInWidget(offset, side, true);
    }
    return tile.coordsIn(offset, side);
  }
  lineAt(pos, side) {
    let { tile } = this.tile.resolveBlock(pos, side);
    return tile.isLine() ? tile : null;
  }
  coordsForChar(pos) {
    let { tile, offset } = this.tile.resolveBlock(pos, 1);
    if (!tile.isLine())
      return null;
    function scan(tile2, offset2) {
      if (tile2.isComposite()) {
        for (let ch of tile2.children) {
          if (ch.length >= offset2) {
            let found = scan(ch, offset2);
            if (found)
              return found;
          }
          offset2 -= ch.length;
          if (offset2 < 0)
            break;
        }
      } else if (tile2.isText() && offset2 < tile2.length) {
        let end = findClusterBreak(tile2.text, offset2);
        if (end == offset2)
          return null;
        let rects = textRange(tile2.dom, offset2, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
          let rect = rects[i];
          if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
            return rect;
        }
      }
      return null;
    }
    return scan(tile, offset);
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    let spaceAbove = 0;
    let scan = (tile, pos, measureBounds) => {
      for (let i = 0; i < tile.children.length; i++) {
        if (pos > to)
          break;
        let child = tile.children[i], end = pos + child.length;
        let childRect = child.dom.getBoundingClientRect(), { height } = childRect;
        if (measureBounds && !i)
          spaceAbove += childRect.top - measureBounds.top;
        if (child instanceof BlockWrapperTile) {
          if (end > from)
            scan(child, pos, childRect);
        } else if (pos >= from) {
          if (spaceAbove > 0)
            result.push(-spaceAbove);
          result.push(height + spaceAbove);
          spaceAbove = 0;
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        if (measureBounds && i == tile.children.length - 1)
          spaceAbove += measureBounds.bottom - childRect.bottom;
        pos = end + child.breakAfter;
      }
    };
    scan(this.tile, 0, null);
    return result;
  }
  textDirectionAt(pos) {
    let { tile } = this.tile.resolveBlock(pos, 1);
    return getComputedStyle(tile.dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    let lineMeasure = this.tile.blockTiles((tile) => {
      if (tile.isLine() && tile.children.length && tile.length <= 20) {
        let totalWidth = 0, textHeight2;
        for (let child of tile.children) {
          if (!child.isText() || /[^ -~]/.test(child.text))
            return void 0;
          let rects = clientRectsFor(child.dom);
          if (rects.length != 1)
            return void 0;
          totalWidth += rects[0].width;
          textHeight2 = rects[0].height;
        }
        if (totalWidth)
          return {
            lineHeight: tile.dom.getBoundingClientRect().height,
            charWidth: totalWidth / tile.length,
            textHeight: textHeight2
          };
      }
    });
    if (lineMeasure)
      return lineMeasure;
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.tile.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect && rect.width ? rect.width / 27 : 7;
      textHeight = rect && rect.height ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.view.state.doc.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i = 1;
    let allDeco = this.view.state.facet(decorations).map((d) => {
      let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i2) => {
      let dynamic = typeof d == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d(this.view) : d;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i < this.decorations.length)
      this.dynamicDecorationMap[i++] = false;
    this.blockWrappers = this.view.state.facet(blockWrappers).map((v) => typeof v == "function" ? v(this.view) : v);
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref2 = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref2.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e) {
        logException(this.view.state, e, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
  lineHasWidget(pos) {
    let scan = (child) => child.isWidget() || child.children.some(scan);
    return scan(this.tile.resolveBlock(pos, 1).tile);
  }
  destroy() {
    destroyDropped(this.tile);
  }
}
function destroyDropped(tile, reused) {
  let r = reused === null || reused === void 0 ? void 0 : reused.get(tile);
  if (r != 1) {
    if (r == null)
      tile.destroy();
    for (let ch of tile.children)
      destroyDropped(ch, reused);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let tileAfter = Tile.get(textAfter.node);
    if (!tileAfter || tileAfter.isText() && tileAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let tileBefore = Tile.get(textBefore.node);
      if (!(!tileBefore || tileBefore.isText() && tileBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  return { range: new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to), text: textNode };
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
class WrapperComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint() {
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
}
function findChangedWrappers(a, b, diff) {
  let comp = new WrapperComparator();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside) {
  for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
    if (cur.nodeType == 1 && cur.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l of line.type) {
      if (l.from > pos)
        break;
      if (l.to < pos)
        continue;
      if (l.from < pos && l.to > pos)
        return l;
      if (!best || l.type == BlockType.Text && (best.type != l.type || (side < 0 ? l.from < pos : l.to > pos)))
        best = l;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur;
    }
    cur = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  let pos = posAtCoords(view, { x: resolvedGoal, y: startY + dist2 * dir }, false, dir);
  return EditorSelection.cursor(pos.pos, pos.assoc, void 0, goal);
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtomsForSelection(atoms, sel) {
  let ranges = null;
  for (let i = 0; i < sel.ranges.length; i++) {
    let range = sel.ranges[i], updated = null;
    if (range.empty) {
      let pos = skipAtomicRanges(atoms, range.from, 0);
      if (pos != range.from)
        updated = EditorSelection.cursor(pos, -1);
    } else {
      let from = skipAtomicRanges(atoms, range.from, -1);
      let to = skipAtomicRanges(atoms, range.to, 1);
      if (from != range.from || to != range.to)
        updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
    }
    if (updated) {
      if (!ranges)
        ranges = sel.ranges.slice();
      ranges[i] = updated;
    }
  }
  return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
class PosAssoc {
  constructor(pos, assoc) {
    this.pos = pos;
    this.assoc = assoc;
  }
}
function posAtCoords(view, coords, precise, scanY) {
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let { x, y } = coords, yOffset = y - docTop, block;
  for (; ; ) {
    if (yOffset < 0)
      return new PosAssoc(0, 1);
    if (yOffset > view.viewState.docHeight)
      return new PosAssoc(view.state.doc.length, -1);
    block = view.elementAtHeight(yOffset);
    if (scanY == null)
      break;
    if (block.type == BlockType.Text) {
      let rect = view.docView.coordsAt(scanY < 0 ? block.from : block.to, scanY);
      if (rect && (scanY < 0 ? rect.top <= yOffset + docTop : rect.bottom >= yOffset + docTop))
        break;
    }
    let halfLine = view.viewState.heightOracle.textHeight / 2;
    yOffset = scanY > 0 ? block.bottom + halfLine : block.top - halfLine;
  }
  if (view.viewport.from >= block.to || view.viewport.to <= block.from) {
    if (precise)
      return null;
    if (block.type == BlockType.Text) {
      let pos = posAtCoordsImprecise(view, content2, block, x, y);
      return new PosAssoc(pos, pos == block.from ? 1 : -1);
    }
  }
  if (block.type != BlockType.Text)
    return yOffset < (block.top + block.bottom) / 2 ? new PosAssoc(block.from, 1) : new PosAssoc(block.to, -1);
  let line = view.docView.lineAt(block.from, 2);
  if (!line || line.length != block.length)
    line = view.docView.lineAt(block.from, -2);
  return posAtCoordsInline(view, line, block.from, x, y);
}
function posAtCoordsInline(view, tile, offset, x, y) {
  let closest = -1, closestRect = null;
  let dxClosest = 1e9, dyClosest = 1e9;
  let rowTop = y, rowBot = y;
  let checkRects = (rects, index) => {
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top == rect.bottom)
        continue;
      let dx = rect.left > x ? rect.left - x : rect.right < x ? x - rect.right : 0;
      let dy = rect.top > y ? rect.top - y : rect.bottom < y ? y - rect.bottom : 0;
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowTop = Math.min(rect.top, rowTop);
        rowBot = Math.max(rect.bottom, rowBot);
        dy = 0;
      }
      if (closest < 0 || (dy - dyClosest || dx - dxClosest) < 0) {
        if (closest >= 0 && dyClosest && dxClosest < dx && closestRect.top <= rowBot - 2 && closestRect.bottom >= rowTop + 2) {
          dyClosest = 0;
        } else {
          closest = index;
          dxClosest = dx;
          dyClosest = dy;
          closestRect = rect;
        }
      }
    }
  };
  if (tile.isText()) {
    for (let i = 0; i < tile.length; ) {
      let next = findClusterBreak(tile.text, i);
      checkRects(textRange(tile.dom, i, next).getClientRects(), i);
      if (!dxClosest && !dyClosest)
        break;
      i = next;
    }
    let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(offset + findClusterBreak(tile.text, closest), -1) : new PosAssoc(offset + closest, 1);
  } else {
    if (!tile.length)
      return new PosAssoc(offset, 1);
    for (let i = 0; i < tile.children.length; i++) {
      let child = tile.children[i];
      if (child.flags & 48)
        continue;
      let rects = (child.dom.nodeType == 1 ? child.dom : textRange(child.dom, 0, child.length)).getClientRects();
      checkRects(rects, i);
      if (!dxClosest && !dyClosest)
        break;
    }
    let inner = tile.children[closest], innerOff = tile.posBefore(inner, offset);
    if (inner.isComposite() || inner.isText())
      return posAtCoordsInline(view, inner, innerOff, Math.max(closestRect.left, Math.min(closestRect.right, x)), y);
    let after = x > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(innerOff + inner.length, -1) : new PosAssoc(innerOff, 1);
  }
}
function dirAt(view, pos) {
  let line = view.state.doc.lineAt(pos), spans = view.bidiSpans(line);
  return spans[BidiSpan.find(view.bidiSpans(line), pos - line.from, -1, 1)].dir;
}
const LineBreakPlaceholder = "￿";
class DOMReader {
  constructor(points, view) {
    this.points = points;
    this.view = view;
    this.text = "";
    this.lineSeparator = view.state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur = start; ; ) {
      this.findPointBefore(parent, cur);
      let oldLen = this.text.length;
      this.readNode(cur);
      let tile = Tile.get(cur), next = cur.nextSibling;
      if (next == end) {
        if ((tile === null || tile === void 0 ? void 0 : tile.breakAfter) && !next && parent != this.view.contentDOM)
          this.lineBreak();
        break;
      }
      let nextTile = Tile.get(next);
      if ((tile && nextTile ? tile.breakAfter : (tile ? tile.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || (tile === null || tile === void 0 ? void 0 : tile.isWidget())) && this.text.length > oldLen) && !isEmptyToEnd(next, end))
        this.lineBreak();
      cur = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    let tile = Tile.get(node);
    let fromView = tile && tile.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
}
function isAtEnd(parent, node, offset) {
  for (; ; ) {
    if (!node || offset < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
function isEmptyToEnd(node, end) {
  let widgets;
  for (; ; node = node.nextSibling) {
    if (node == end || !node)
      break;
    let view = Tile.get(node);
    if (!(view === null || view === void 0 ? void 0 : view.isWidget()))
      return false;
    if (view)
      (widgets || (widgets = [])).push(view);
  }
  if (widgets)
    for (let w of widgets) {
      let override = w.overrideDOMText;
      if (override === null || override === void 0 ? void 0 : override.length)
        return false;
    }
  return true;
}
class DOMPoint {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = domBoundsAround(view.docView.tile, start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      if (view.inputState.composing > -1 && view.state.selection.ranges.length > 1)
        this.newSel = view.state.selection.replaceRange(EditorSelection.range(anchor, head));
      else
        this.newSel = EditorSelection.single(anchor, head);
    }
  }
}
function domBoundsAround(tile, from, to, offset) {
  if (tile.isComposite()) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < tile.children.length; i++) {
      let child = tile.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return domBoundsAround(child, from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == tile.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + tile.length : toEnd,
      startDOM: (fromI ? tile.children[fromI - 1].dom.nextSibling : null) || tile.dom.firstChild,
      endDOM: toI < tile.children.length && toI >= 0 ? tile.children[toI].dom : null
    };
  } else if (tile.isText()) {
    return { from: offset, to: offset + tile.length, startDOM: tile.dom, endDOM: tile.dom.nextSibling };
  } else {
    return null;
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || sameSelPos(newSel, sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.toText(view.inputState.insertingText)
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !sameSelPos(newSel, sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
      if (userEvent == "select.pointer")
        newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f) => f(view)), newSel);
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;
  if (change.from == change.to && change.from < sel.from || change.from > sel.to) {
    let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;
    let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f) => f(view)), pos, side);
    if (change.from == moved)
      inAtomic = moved;
  }
  if (inAtomic > -1) {
    tr = {
      changes: change,
      selection: EditorSelection.cursor(change.from + change.insert.length, -1)
    };
  } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && (view.inputState.composing >= 0 || view.inputState.compositionPendingChange) && change.to <= sel.to + 10 && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset, from = to - replaced.length;
        if (view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        to >= compositionRange.from && from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
function sameSelPos(selection2, range) {
  return range.head == selection2.main.head && range.anchor == selection2.main.anchor;
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.insertingText = "";
    this.insertingTextAt = 0;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event.type, event));
    else
      this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type) || event.synthetic)
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin of plugins) {
    let spec = plugin.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
    if (handlers2)
      for (let type in handlers2) {
        let f = handlers2[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin.value, f));
      }
    if (observers2)
      for (let type in observers2) {
        let f = observers2[type];
        if (f)
          record(type).observers.push(bindHandler(plugin.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x, y } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y)
      this.view.win.scrollBy(x, y);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  select(event) {
    let { view } = this, selection2 = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, tile; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (tile = Tile.get(node)) && tile.isWidget() && !tile.isHidden && tile.widget.ignoreEvent(event))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const observers = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter of state.facet(facet))
    text = filter(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  } else {
    view.inputState.setSelectionOrigin("select.pointer");
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = view.docView.lineAt(pos, bias), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = view.posAndSideAtCoords({ x: event.clientX, y: event.clientY }, false), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur = view.posAndSideAtCoords({ x: event2.clientX, y: event2.clientY }, false), removed;
      let range = rangeForClick(view, cur.pos, cur.assoc, type);
      if (start.pos != cur.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.assoc, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let { from, to } = sel.ranges[i];
    if (from <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let tile = view.docView.tile.nearest(event.target);
    if (tile && tile.isWidget()) {
      let from = tile.posAtStart, to = from + tile.length;
      if (from >= range.to || to <= range.from)
        range = EditorSelection.range(from, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let domSel = getSelection(view.root);
  if (domSel && !hasSelection(view.contentDOM, domSel))
    return false;
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
const isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2, _b;
  if (event.inputType == "insertText" || event.inputType == "insertCompositionText") {
    view.inputState.insertingText = event.data;
    view.inputState.insertingTextAt = Date.now();
  }
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r = ranges[0];
      let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
const appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.abs(lineHeight - this.lineHeight) > 0.3 || this.lineWrapping != lineWrapping || Math.abs(charWidth - this.charWidth) > 0.1;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
}
var QueryType = /* @__PURE__ */ (function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & -3;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }
}
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
const SpaceDeco = /* @__PURE__ */ Decoration.replace({});
class HeightMapBlock extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
    this.spaceAbove = 0;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
  }
  blockAt(height, _oracle, top2, offset) {
    return this.spaceAbove && height < top2 + this.spaceAbove ? new BlockInfo(offset, 0, top2, this.spaceAbove, SpaceDeco) : this.mainBlock(top2, offset);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    let main = this.mainBlock(top2, offset);
    return this.spaceAbove ? this.blockAt(0, oracle, top2, offset).join(main) : main;
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    if (from <= offset + this.length && to >= offset)
      f(this.lineAt(0, QueryType.ByPos, oracle, top2, offset));
  }
  setMeasuredHeight(measured) {
    let next = measured.heights[measured.index++];
    if (next < 0) {
      this.spaceAbove = -next;
      next = measured.heights[measured.index++];
    } else {
      this.spaceAbove = 0;
    }
    this.setHeight(next);
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setMeasuredHeight(measured);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height, above) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
    this.spaceAbove = above;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new HeightMapText(node.length, this.height, this.spaceAbove);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more) {
      this.setMeasuredHeight(measured);
    } else if (force || this.outdated) {
      this.spaceAbove = 0;
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    }
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++], above = 0;
        if (height < 0) {
          above = -height;
          height = measured.heights[measured.index++];
        }
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height, above);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1, 0));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1, 0));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1, 0);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1, 0));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
class DecorationComparator2 {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt) {
  let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
class LineGap {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = staticDeco(state);
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i = 0; i < 2; i++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = staticDeco(this.state);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = prevHeight;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && (update.selectionSet || update.focusChanged) && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace) || this.mustMeasureContent;
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i = 0; i < ranges.length && !(changed & 8); i++) {
        let old = this.visibleRanges[i], nw = ranges[i];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
            changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
function staticDeco(state) {
  let deco = state.facet(decorations).filter((d) => typeof d != "function");
  let outer = state.facet(outerDecorations).filter((d) => typeof d != "function");
  if (outer.length)
    deco.push(RangeSet.join(outer));
  return deco;
}
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && browser.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.tile.nearest(sel.anchorNode);
    if (context && context.isWidget() && context.widget.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection2 = getSelection(view.root);
    if (!selection2)
      return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !sameSelPos(this.view.state.selection, domChange.newSel.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let tile = this.view.docView.tile.nearest(rec.target);
    if (!tile || tile.isWidget())
      return null;
    tile.markDirty(rec.type == "attributes");
    if (rec.type == "childList") {
      let childBefore = findChild(tile, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(tile, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? tile.posAfter(childBefore) : tile.posAtStart,
        to: childAfter ? tile.posBefore(childAfter) : tile.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: tile.posAtStart, to: tile.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
}
function findChild(tile, dom, dir) {
  while (dom) {
    let curTile = Tile.get(dom);
    if (curTile && curTile.parent == tile)
      return curTile;
    let parent = dom.parentNode;
    dom = parent != tile.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor, 1);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e) => {
      let main = view.state.selection.main, { anchor, head } = main;
      let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };
      let deletes = to - from > e.text.length;
      if (from == this.from && anchor < this.from)
        from = anchor;
      else if (to == this.to && anchor > this.to)
        to = anchor;
      let diff = findDiff(view.state.sliceDoc(from, to), e.text, (deletes ? main.from : main.to) - from, deletes ? "end" : null);
      if (!diff) {
        let newSel = EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
        if (!sameSelPos(newSel, main))
          view.dispatch({ selection: newSel, userEvent: "select" });
        return;
      }
      let change = {
        from: diff.from + from,
        to: diff.toA + from,
        insert: Text.of(e.text.slice(diff.from, diff.toB).split("\n"))
      };
      if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off")
        change = { from, to, insert: Text.of([e.text.replace(".", " ")]) };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
      if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(context.text.slice(Math.max(0, e.updateRangeStart - 1), Math.min(context.text.length, e.updateRangeStart + 1))))
        this.handlers.compositionend(e);
    };
    this.handlers.characterboundsupdate = (e) => {
      let rects = [], prev = null;
      for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
        let rect = view.coordsForChar(i);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e) => {
      let deco = [];
      for (let format of e.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {
          let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + " " : lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${/thin/i.test(thickness) ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event in this.handlers)
      context.addEventListener(event, this.handlers[event]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event]);
  }
}
class EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config = {}) {
    var _a2;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config.parent)
      config.parent.appendChild(this.dom);
    let { dispatch } = config;
    this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config.root || getRoot(config.parent) || document;
    this.viewState = new ViewState(config.state || EditorState.create(config));
    if (config.scrollTo && config.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => {
        this.viewState.mustMeasureContent = true;
        this.requestMeasure();
      });
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView))
            scrollTarget = e.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin of this.plugins) {
      let val = plugin.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e) {
          logException(this.state, e, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i = 0; ; i++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request2) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request2) {
      if (this.measureRequests.indexOf(request2) > -1)
        return;
      if (request2.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request2.key) {
            this.measureRequests[i] = request2;
            return;
          }
        }
      this.measureRequests.push(request2);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.plugin != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.plugin == plugin) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos, side = 1) {
    return this.docView.domAtPos(pos, side);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    let found = posAtCoords(this, coords, precise);
    return found && found.pos;
  }
  posAndSideAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref2 = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref2.from), "start", "start", ref2.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let tile = content2 && Tile.get(content2) || Tile.get(dom);
    return ((_a2 = tile === null || tile === void 0 ? void 0 : tile.root) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.blockWrappers = blockWrappers;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c) => c.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
const handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
const Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
let storedPrefix = null;
const PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift)
        add(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd of binding.run)
        if (!ran.has(cmd)) {
          ran.add(cmd);
          if (cmd(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
    !(browser.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
class RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
}
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y });
  let right = view.posAtCoords({ x: editorRect.right - 1, y });
  if (left == null || right == null)
    return inside;
  return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i = 0; i < horizontal.length; i += 2)
      pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r of view.visibleRanges)
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
      if (browser.safari && browser.safari_version >= 26)
        this.dom.style.display = this.dom.firstChild ? "" : "none";
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
}
const layerOrder = /* @__PURE__ */ Facet.define();
function layer(config) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config)),
    layerOrder.of(config)
  ];
}
const selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config = {}) {
  return [
    selectionConfig.of(config),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      if (r.empty || conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
const hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
}));
function highlightActiveLine() {
  return activeLineHighlighter;
}
const lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r of view.state.selection.ranges) {
      let line = view.lineBlockAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
class Placeholder extends WidgetType {
  constructor(content2) {
    super();
    this.content = content2;
  }
  toDOM(view) {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
    wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length)
      return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
}
function placeholder(content2) {
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, { decorations: (v) => v.decorations });
  return typeof content2 == "string" ? [
    plugin,
    EditorView.contentAttributes.of({ "aria-placeholder": content2 })
  ] : plugin;
}
class GutterMarker extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = /* @__PURE__ */ Facet.define();
const gutterWidgetClass = /* @__PURE__ */ Facet.define();
const activeGutters = /* @__PURE__ */ Facet.define();
const unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config) {
  let result = [
    gutterView
  ];
  return result;
}
const gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.domAfter = null;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters cm-gutters-before";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    this.fixed = !view.state.facet(unfixGutters);
    for (let gutter of this.gutters) {
      if (gutter.config.side == "after")
        this.getDOMAfter().appendChild(gutter.dom);
      else
        this.dom.appendChild(gutter.dom);
    }
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  getDOMAfter() {
    if (!this.domAfter) {
      this.domAfter = document.createElement("div");
      this.domAfter.className = "cm-gutters cm-gutters-after";
      this.domAfter.setAttribute("aria-hidden", "true");
      this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.domAfter.style.position = this.fixed ? "sticky" : "";
      this.view.scrollDOM.appendChild(this.domAfter);
    }
    return this.domAfter;
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      let min = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = min;
      if (this.domAfter)
        this.domAfter.style.minHeight = min;
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
      if (this.domAfter)
        this.domAfter.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach) {
      this.dom.remove();
      if (this.domAfter)
        this.domAfter.remove();
    }
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter) => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b of line.type) {
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (let cx of contexts)
              cx.line(this.view, b, classSet);
            first = false;
          } else if (b.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach) {
      this.view.scrollDOM.insertBefore(this.dom, after);
      if (this.domAfter)
        this.view.scrollDOM.appendChild(this.domAfter);
    }
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur) {
      for (let gutter of this.gutters)
        if (gutter.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2) {
        if (g.config.side == "after")
          this.getDOMAfter().appendChild(g.dom);
        else
          this.dom.appendChild(g.dom);
      }
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
    if (this.domAfter)
      this.domAfter.remove();
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
    return view.textDirection == Direction.LTR ? { left: before, right: after } : { right: before, left: after };
  })
});
function asArray(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
class UpdateContext {
  constructor(gutter, viewport, height) {
    this.gutter = gutter;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter.elements.push(newElt);
      gutter.dom.appendChild(newElt.dom);
    } else {
      gutter.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter = this.gutter;
    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block.widget, block);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block, markers);
  }
  finish() {
    let gutter = this.gutter;
    while (gutter.elements.length > this.i) {
      let last = gutter.elements.pop();
      gutter.dom.removeChild(last.dom);
      last.destroy();
    }
  }
}
class SingleGutterView {
  constructor(view, config) {
    this.view = view;
    this.config = config;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray(config.markers(view));
    if (config.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
}
class GutterElement {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c)
          cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++)
          if (this.markers[i].compare(marker)) {
            skipTo = i;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
const lineNumberMarkers = /* @__PURE__ */ Facet.define();
const lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
const lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add(view, line, event2) : add;
        }
        return result;
      }
    });
  }
});
class NumberMarker extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
const lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m of view.state.facet(lineNumberWidgetMarker)) {
      let result = m(view, widget, block);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
  side: "before"
}));
function lineNumbers(config = {}) {
  return [
    lineNumberConfig.of(config),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
const activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
const activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range2 {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
class NodeProp {
  /**
  Create a new node prop type.
  */
  constructor(config = {}) {
    this.id = nextPropID++;
    this.perNode = !!config.perNode;
    this.deserialize = config.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
    this.combine = config.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
  constructor(tree, overlay, parser2, bracketed = false) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
    this.bracketed = bracketed;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
}
const noProps = /* @__PURE__ */ Object.create(null);
class NodeType {
  /**
  @internal
  */
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
}
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          let value = add[1], prop = add[0];
          if (prop.combine && prop.id in newProps)
            value = prop.combine(newProps[prop.id], value);
          newProps[prop.id] = value;
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
}
const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  IterMode2[IterMode2["EnterBracketed"] = 16] = "EnterBracketed";
})(IterMode || (IterMode = {}));
class Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id in this.props)
        result.push([+id, this.props[id]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index) {
    let id = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new TreeBuffer(copy, len, this.set);
  }
}
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
class BaseNode {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    var _a2;
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!(mode & IterMode.EnterBracketed && next instanceof Tree && ((_a2 = MountedTree.get(next)) === null || _a2 === void 0 ? void 0 : _a2.overlay) === null && (start >= pos || start + next.length <= pos)) && !checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side, mode);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this._tree.prop(prop);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from, enterBracketed = mode & IterMode.EnterBracketed && mounted.bracketed;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 || enterBracketed ? from <= rPos : from < rPos) && (side < 0 || enterBracketed ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur.type.is(before);
      if (!cur.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
class BufferContext {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this.type.prop(prop);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
class StackIterator {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
}
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
class TreeCursor {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    this.mode = mode & ~IterMode.EnterBracketed;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
        for (let c = cache; c; c = c._parent)
          if (c.index == index) {
            if (index == this.index)
              return c;
            result = c;
            depth = d + 1;
            break scan;
          }
        index = this.stack[--d];
      }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types2[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
}
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    if (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id;
        return;
      } else if (size == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index = data2.length;
      while (cursor2.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3 || fork.size == -4)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id;
    } else if (size == -3) {
      contextHash = id;
    } else if (size == -4) {
      lookAhead = id;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
class TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
}
new NodeProp({ perNode: true });
let nextTagID = 0;
class Tag {
  /**
  @internal
  */
  constructor(name2, set, base2, modified) {
    this.name = name2;
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base2.name, set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config of configs)
          set.push(Modifier.get(parent, config));
    return tag;
  }
}
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = new NodeProp({
  combine(a, b) {
    let cur, root, take;
    while (a || b) {
      if (!a || b && a.depth >= b.depth) {
        take = b;
        b = b.next;
      } else {
        take = a;
        a = a.next;
      }
      if (cur && cur.mode == take.mode && !take.context && !cur.context)
        continue;
      let copy = new Rule(take.tags, take.mode, take.context);
      if (cur)
        cur.next = copy;
      else
        root = copy;
      cur = copy;
    }
    return root;
  }
});
class Rule {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i = 0, pos = start; ; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
}
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
const t = Tag.define;
const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
const tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);
var _a;
const languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
const sublanguageProp = /* @__PURE__ */ new NodeProp();
class Language {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser2, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from, to: r.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers | IterMode.EnterBracketed))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
class LRLanguage extends Language {
  constructor(data, parser2, name2) {
    super(data, parser2, [], name2);
    this.parser = parser2;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
class DocInput {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser2, state, viewport) {
    return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
let requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
const language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
class LanguageSupport {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
}
const indentService = /* @__PURE__ */ Facet.define();
const indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
class IndentContext {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add = [];
    for (let cur = inner; cur && !(cur.from < stack.node.from || cur.to > stack.node.to || cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)
      add.push(cur);
    for (let i = add.length - 1; i >= 0; i--)
      stack = { node: add[i], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur = stack; cur; cur = cur.next) {
    let strategy = indentStrategy(cur.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
}
function isParent(parent, of) {
  for (let cur = of; cur; cur = cur.parent)
    if (parent == cur)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd)
        return null;
      let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space };
    }
    pos = next.to;
  }
}
function delimitedStrategy(context, align, units, closing, closedAt) {
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
  let aligned = bracketedAligned(context);
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
const foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
class HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
}
const highlighterFacet = /* @__PURE__ */ Facet.define();
const fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder.finish();
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
const defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
const bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config = {}) {
  let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur = node; cur; cur = cur.parent) {
    let matches = matchingNodes(cur.type, dir, brackets);
    if (matches && cur.from < cur.to) {
      let handle = findHandle(cur);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
const noTokens = /* @__PURE__ */ Object.create(null);
const typeArray = [NodeType.none];
const warned = [];
const byTag = /* @__PURE__ */ Object.create(null);
const defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
({
  rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR })
});
const toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
const toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
const toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
const toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos, 1);
  return data.length ? data[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    if (toLine.from > fromLine.from && toLine.from == r.to)
      toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens2 = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens2.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens2[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens2[i].open + " " }, { from: range.to, insert: " " + tokens2[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token = tokens2[i], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty = indent == line.length;
        let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment: comment2, token, indent, empty, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty, single } of lines)
      if (single || !empty)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
const cursorLineUp = (view) => cursorByLine(view, false);
const cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
const cursorPageUp = (view) => cursorByPage(view, false);
const cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
const cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
const cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
const cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
const cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
const cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
const selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
const selectLineUp = (view) => selectByLine(view, false);
const selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
const selectPageUp = (view) => selectByPage(view, false);
const selectPageDown = (view) => selectByPage(view, true);
const selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
const selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
const selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
const selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
const selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
const cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
const cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
const selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
const selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
const selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
const selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
const selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur = stack; cur; cur = cur.next) {
      let { node } = cur;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function addCursorVertically(view, forward) {
  let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
  for (let range of state.selection.ranges) {
    let line = state.doc.lineAt(range.head);
    if (forward ? line.to < view.state.doc.length : line.from > 0)
      for (let cur = range; ; ) {
        let next = view.moveVertically(cur, forward);
        if (next.head < line.from || next.head > line.to) {
          if (!ranges.some((r) => r.head == next.head))
            ranges.push(next);
          break;
        } else if (next.head == cur.head) {
          break;
        } else {
          cur = next;
        }
      }
  }
  if (ranges.length == sel.ranges.length)
    return false;
  view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
  return true;
}
const addCursorAbove = (view) => addCursorVertically(view, false);
const addCursorBelow = (view) => addCursorVertically(view, true);
const simplifySelection = ({ state, dispatch }) => {
  let cur = state.selection, selection2 = null;
  if (cur.ranges.length > 1)
    selection2 = EditorSelection.create([cur.main]);
  else if (!cur.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
const deleteCharBackward = (view) => deleteByChar(view, false, true);
const deleteCharForward = (view) => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
const deleteGroupBackward = (target) => deleteByGroup(target, false);
const deleteGroupForward = (target) => deleteByGroup(target, true);
const deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
const deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
const splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  let changeSet = state.changes(changes);
  dispatch(state.update({
    changes: changeSet,
    selection: state.selection.map(changeSet, forward ? 1 : -1),
    scrollIntoView: true,
    userEvent: "input.copyline"
  }));
  return true;
}
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
const deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
const indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
const indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
const indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
const toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
const emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
const standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward, preventDefault: true },
  { key: "Delete", run: deleteCharForward, preventDefault: true },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward, preventDefault: true },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward, preventDefault: true },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward, preventDefault: true },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward, preventDefault: true }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
const defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Mod-Alt-ArrowUp", run: addCursorAbove },
  { key: "Mod-Alt-ArrowDown", run: addCursorBelow },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
var define_process_env_default = {};
class Stack {
  /**
  @internal
  */
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a2;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top2 = this.buffer.length;
      if (top2 == 0 && cur.parent) {
        top2 = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top2 - 2] >= start) {
          cur.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && (this.buffer[index - 4] != 0 || this.buffer[index - 1] < 0)) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      this.pos = end;
      if (!parser2.stateFlag(
        nextState,
        1
        /* StateFlag.Skipped */
      ) && (end > start || type <= parser2.maxNode))
        this.reducePos = end;
      this.pushState(nextState, Math.min(start, this.reducePos));
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead <= this.lookAhead)
      return false;
    this.emitLookAhead();
    this.lookAhead = lookAhead;
    return true;
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
}
class SimulatedStack {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
}
class StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
function decodeArray(input, Type2 = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type2(value);
  }
  return array;
}
class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
}
const nullToken = new CachedToken();
class InputStream {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
}
class TokenGroup {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
}
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect: dialect2 } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state]) == 0)
      break;
    let accEnd = data[state + 1];
    for (let i = state + 3; i < accEnd; i += 2)
      if ((data[i + 1] & groupMask) > 0) {
        let term = data[i];
        if (dialect2.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from = data[index], to = data[index + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data[index + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
const verbose = typeof process != "undefined" && define_process_env_default && /\bparse\b/.test(define_process_env_default.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
class FragmentCursor {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index = this.index[last];
      if (index == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index];
      let start = this.start[last] + top2.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
}
class TokenCache {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
}
class Parse {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i];
        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12) {
        newStacks.sort((a, b) => b.score - a.score);
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
      }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens2, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens2[i << 1], tokenEnd = tokens2[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; j < 10 && force.forceReduce(); j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < force.score) {
        finished = force;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
class Dialect {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
}
class LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a) => a == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config.props)
      copy.nodeSet = this.nodeSet.extend(...config.props);
    if (config.top) {
      let info = this.topRules[config.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config.top}`);
      copy.top = info;
    }
    if (config.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config.contextTracker)
      copy.context = config.contextTracker;
    if (config.dialect)
      copy.dialect = this.parseDialect(config.dialect);
    if (config.strict != null)
      copy.strict = config.strict;
    if (config.wrap)
      copy.wrappers = copy.wrappers.concat(config.wrap);
    if (config.bufferLength != null)
      copy.bufferLength = config.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect2) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect2)
      for (let part of dialect2.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect2, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new LRParser(spec);
  }
}
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1)
        return null;
      if (pos.type.isTop)
        break;
    }
    return source(context);
  };
}
const closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const whitespace = 36, LineComment = 1, BlockComment = 2, String$1 = 3, Number$1 = 4, Bool = 5, Null = 6, ParenL = 7, ParenR = 8, BraceL = 9, BraceR = 10, BracketL = 11, BracketR = 12, Semi = 13, Dot = 14, Operator = 15, Punctuation = 16, SpecialVar = 17, Identifier = 18, QuotedIdentifier = 19, Keyword = 20, Type = 21, Bits = 22, Bytes = 23, Builtin = 24;
function isAlpha(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70;
}
function readLiteral(input, endQuote, backslashEscapes) {
  for (let escaped = false; ; ) {
    if (input.next < 0)
      return;
    if (input.next == endQuote && !escaped) {
      input.advance();
      return;
    }
    escaped = backslashEscapes && !escaped && input.next == 92;
    input.advance();
  }
}
function readDoubleDollarLiteral(input, tag) {
  scan: for (; ; ) {
    if (input.next < 0)
      return;
    if (input.next == 36) {
      input.advance();
      for (let i = 0; i < tag.length; i++) {
        if (input.next != tag.charCodeAt(i))
          continue scan;
        input.advance();
      }
      if (input.next == 36) {
        input.advance();
        return;
      }
    } else {
      input.advance();
    }
  }
}
function readPLSQLQuotedLiteral(input, openDelim) {
  let matchingDelim = "[{<(".indexOf(String.fromCharCode(openDelim));
  let closeDelim = matchingDelim < 0 ? openDelim : "]}>)".charCodeAt(matchingDelim);
  for (; ; ) {
    if (input.next < 0)
      return;
    if (input.next == closeDelim && input.peek(1) == 39) {
      input.advance(2);
      return;
    }
    input.advance();
  }
}
function readWord(input, result) {
  for (; ; ) {
    if (input.next != 95 && !isAlpha(input.next))
      break;
    if (result != null)
      result += String.fromCharCode(input.next);
    input.advance();
  }
  return result;
}
function readWordOrQuoted(input) {
  if (input.next == 39 || input.next == 34 || input.next == 96) {
    let quote = input.next;
    input.advance();
    readLiteral(input, quote, false);
  } else {
    readWord(input);
  }
}
function readBits(input, endQuote) {
  while (input.next == 48 || input.next == 49)
    input.advance();
  if (endQuote && input.next == endQuote)
    input.advance();
}
function readNumber(input, sawDot) {
  for (; ; ) {
    if (input.next == 46) {
      if (sawDot)
        break;
      sawDot = true;
    } else if (input.next < 48 || input.next > 57) {
      break;
    }
    input.advance();
  }
  if (input.next == 69 || input.next == 101) {
    input.advance();
    if (input.next == 43 || input.next == 45)
      input.advance();
    while (input.next >= 48 && input.next <= 57)
      input.advance();
  }
}
function eol(input) {
  while (!(input.next < 0 || input.next == 10))
    input.advance();
}
function inString(ch, str) {
  for (let i = 0; i < str.length; i++)
    if (str.charCodeAt(i) == ch)
      return true;
  return false;
}
const Space = " 	\r\n";
function keywords(keywords2, types2, builtin) {
  let result = /* @__PURE__ */ Object.create(null);
  result["true"] = result["false"] = Bool;
  result["null"] = result["unknown"] = Null;
  for (let kw of keywords2.split(" "))
    if (kw)
      result[kw] = Keyword;
  for (let tp of types2.split(" "))
    if (tp)
      result[tp] = Type;
  for (let kw of (builtin || "").split(" "))
    if (kw)
      result[kw] = Builtin;
  return result;
}
const SQLTypes = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
const SQLKeywords = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
const defaults = {
  backslashEscapes: false,
  hashComments: false,
  spaceAfterDashes: false,
  slashComments: false,
  doubleQuotedStrings: false,
  doubleDollarQuotedStrings: false,
  unquotedBitLiterals: false,
  treatBitsAsBytes: false,
  charSetCasts: false,
  plsqlQuotingMechanism: false,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: false,
  words: /* @__PURE__ */ keywords(SQLKeywords, SQLTypes)
};
function dialect(spec, kws, types2, builtin) {
  let dialect2 = {};
  for (let prop in defaults)
    dialect2[prop] = (spec.hasOwnProperty(prop) ? spec : defaults)[prop];
  if (kws)
    dialect2.words = keywords(kws, types2 || "", builtin);
  return dialect2;
}
function tokensFor(d) {
  return new ExternalTokenizer((input) => {
    var _a2;
    let { next } = input;
    input.advance();
    if (inString(next, Space)) {
      while (inString(input.next, Space))
        input.advance();
      input.acceptToken(whitespace);
    } else if (next == 36 && d.doubleDollarQuotedStrings) {
      let tag = readWord(input, "");
      if (input.next == 36) {
        input.advance();
        readDoubleDollarLiteral(input, tag);
        input.acceptToken(String$1);
      }
    } else if (next == 39 || next == 34 && d.doubleQuotedStrings) {
      readLiteral(input, next, d.backslashEscapes);
      input.acceptToken(String$1);
    } else if (next == 35 && d.hashComments || next == 47 && input.next == 47 && d.slashComments) {
      eol(input);
      input.acceptToken(LineComment);
    } else if (next == 45 && input.next == 45 && (!d.spaceAfterDashes || input.peek(1) == 32)) {
      eol(input);
      input.acceptToken(LineComment);
    } else if (next == 47 && input.next == 42) {
      input.advance();
      for (let depth = 1; ; ) {
        let cur = input.next;
        if (input.next < 0)
          break;
        input.advance();
        if (cur == 42 && input.next == 47) {
          depth--;
          input.advance();
          if (!depth)
            break;
        } else if (cur == 47 && input.next == 42) {
          depth++;
          input.advance();
        }
      }
      input.acceptToken(BlockComment);
    } else if ((next == 101 || next == 69) && input.next == 39) {
      input.advance();
      readLiteral(input, 39, true);
      input.acceptToken(String$1);
    } else if ((next == 110 || next == 78) && input.next == 39 && d.charSetCasts) {
      input.advance();
      readLiteral(input, 39, d.backslashEscapes);
      input.acceptToken(String$1);
    } else if (next == 95 && d.charSetCasts) {
      for (let i = 0; ; i++) {
        if (input.next == 39 && i > 1) {
          input.advance();
          readLiteral(input, 39, d.backslashEscapes);
          input.acceptToken(String$1);
          break;
        }
        if (!isAlpha(input.next))
          break;
        input.advance();
      }
    } else if (d.plsqlQuotingMechanism && (next == 113 || next == 81) && input.next == 39 && input.peek(1) > 0 && !inString(input.peek(1), Space)) {
      let openDelim = input.peek(1);
      input.advance(2);
      readPLSQLQuotedLiteral(input, openDelim);
      input.acceptToken(String$1);
    } else if (inString(next, d.identifierQuotes)) {
      const endQuote = next == 91 ? 93 : next;
      readLiteral(input, endQuote, false);
      input.acceptToken(QuotedIdentifier);
    } else if (next == 40) {
      input.acceptToken(ParenL);
    } else if (next == 41) {
      input.acceptToken(ParenR);
    } else if (next == 123) {
      input.acceptToken(BraceL);
    } else if (next == 125) {
      input.acceptToken(BraceR);
    } else if (next == 91) {
      input.acceptToken(BracketL);
    } else if (next == 93) {
      input.acceptToken(BracketR);
    } else if (next == 59) {
      input.acceptToken(Semi);
    } else if (d.unquotedBitLiterals && next == 48 && input.next == 98) {
      input.advance();
      readBits(input);
      input.acceptToken(Bits);
    } else if ((next == 98 || next == 66) && (input.next == 39 || input.next == 34)) {
      const quoteStyle = input.next;
      input.advance();
      if (d.treatBitsAsBytes) {
        readLiteral(input, quoteStyle, d.backslashEscapes);
        input.acceptToken(Bytes);
      } else {
        readBits(input, quoteStyle);
        input.acceptToken(Bits);
      }
    } else if (next == 48 && (input.next == 120 || input.next == 88) || (next == 120 || next == 88) && input.next == 39) {
      let quoted = input.next == 39;
      input.advance();
      while (isHexDigit(input.next))
        input.advance();
      if (quoted && input.next == 39)
        input.advance();
      input.acceptToken(Number$1);
    } else if (next == 46 && input.next >= 48 && input.next <= 57) {
      readNumber(input, true);
      input.acceptToken(Number$1);
    } else if (next == 46) {
      input.acceptToken(Dot);
    } else if (next >= 48 && next <= 57) {
      readNumber(input, false);
      input.acceptToken(Number$1);
    } else if (inString(next, d.operatorChars)) {
      while (inString(input.next, d.operatorChars))
        input.advance();
      input.acceptToken(Operator);
    } else if (inString(next, d.specialVar)) {
      if (input.next == next)
        input.advance();
      readWordOrQuoted(input);
      input.acceptToken(SpecialVar);
    } else if (next == 58 || next == 44) {
      input.acceptToken(Punctuation);
    } else if (isAlpha(next)) {
      let word = readWord(input, String.fromCharCode(next));
      input.acceptToken(input.next == 46 || input.peek(-word.length - 1) == 46 ? Identifier : (_a2 = d.words[word.toLowerCase()]) !== null && _a2 !== void 0 ? _a2 : Identifier);
    }
  });
}
const tokens = /* @__PURE__ */ tokensFor(defaults);
const parser$1 = /* @__PURE__ */ LRParser.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, tokens],
  topRules: { "Script": [0, 25] },
  tokenPrec: 0
});
function tokenBefore(tree) {
  let cursor2 = tree.cursor().moveTo(tree.from, -1);
  while (/Comment/.test(cursor2.name))
    cursor2.moveTo(cursor2.from, -1);
  return cursor2.node;
}
function idName(doc2, node) {
  let text = doc2.sliceString(node.from, node.to);
  let quoted = /^([`'"\[])(.*)([`'"\]])$/.exec(text);
  return quoted ? quoted[2] : text;
}
function plainID(node) {
  return node && (node.name == "Identifier" || node.name == "QuotedIdentifier");
}
function pathFor(doc2, id) {
  if (id.name == "CompositeIdentifier") {
    let path = [];
    for (let ch = id.firstChild; ch; ch = ch.nextSibling)
      if (plainID(ch))
        path.push(idName(doc2, ch));
    return path;
  }
  return [idName(doc2, id)];
}
function parentsFor(doc2, node) {
  for (let path = []; ; ) {
    if (!node || node.name != ".")
      return path;
    let name2 = tokenBefore(node);
    if (!plainID(name2))
      return path;
    path.unshift(idName(doc2, name2));
    node = tokenBefore(name2);
  }
}
function sourceContext(state, startPos) {
  let pos = syntaxTree(state).resolveInner(startPos, -1);
  let aliases = getAliases(state.doc, pos);
  if (pos.name == "Identifier" || pos.name == "QuotedIdentifier" || pos.name == "Keyword") {
    return {
      from: pos.from,
      quoted: pos.name == "QuotedIdentifier" ? state.doc.sliceString(pos.from, pos.from + 1) : null,
      parents: parentsFor(state.doc, tokenBefore(pos)),
      aliases
    };
  }
  if (pos.name == ".") {
    return { from: startPos, quoted: null, parents: parentsFor(state.doc, pos), aliases };
  } else {
    return { from: startPos, quoted: null, parents: [], empty: true, aliases };
  }
}
const EndFrom = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function getAliases(doc2, at) {
  let statement;
  for (let parent = at; !statement; parent = parent.parent) {
    if (!parent)
      return null;
    if (parent.name == "Statement")
      statement = parent;
  }
  let aliases = null;
  for (let scan = statement.firstChild, sawFrom = false, prevID = null; scan; scan = scan.nextSibling) {
    let kw = scan.name == "Keyword" ? doc2.sliceString(scan.from, scan.to).toLowerCase() : null;
    let alias = null;
    if (!sawFrom) {
      sawFrom = kw == "from";
    } else if (kw == "as" && prevID && plainID(scan.nextSibling)) {
      alias = idName(doc2, scan.nextSibling);
    } else if (kw && EndFrom.has(kw)) {
      break;
    } else if (prevID && plainID(scan)) {
      alias = idName(doc2, scan);
    }
    if (alias) {
      if (!aliases)
        aliases = /* @__PURE__ */ Object.create(null);
      aliases[alias] = pathFor(doc2, prevID);
    }
    prevID = /Identifier$/.test(scan.name) ? scan : null;
  }
  return aliases;
}
function maybeQuoteCompletions(openingQuote, closingQuote, completions) {
  return completions.map((c) => ({ ...c, label: c.label[0] == openingQuote ? c.label : openingQuote + c.label + closingQuote, apply: void 0 }));
}
const Span = /^\w*$/, QuotedSpan = /^[`'"\[]?\w*[`'"\]]?$/;
function isSelfTag(namespace) {
  return namespace.self && typeof namespace.self.label == "string";
}
class CompletionLevel {
  constructor(idQuote, idCaseInsensitive) {
    this.idQuote = idQuote;
    this.idCaseInsensitive = idCaseInsensitive;
    this.list = [];
    this.children = void 0;
  }
  child(name2) {
    let children = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    let found = children[name2];
    if (found)
      return found;
    if (name2 && !this.list.some((c) => c.label == name2))
      this.list.push(nameCompletion(name2, "type", this.idQuote, this.idCaseInsensitive));
    return children[name2] = new CompletionLevel(this.idQuote, this.idCaseInsensitive);
  }
  maybeChild(name2) {
    return this.children ? this.children[name2] : null;
  }
  addCompletion(option) {
    let found = this.list.findIndex((o) => o.label == option.label);
    if (found > -1)
      this.list[found] = option;
    else
      this.list.push(option);
  }
  addCompletions(completions) {
    for (let option of completions)
      this.addCompletion(typeof option == "string" ? nameCompletion(option, "property", this.idQuote, this.idCaseInsensitive) : option);
  }
  addNamespace(namespace) {
    if (Array.isArray(namespace)) {
      this.addCompletions(namespace);
    } else if (isSelfTag(namespace)) {
      this.addNamespace(namespace.children);
    } else {
      this.addNamespaceObject(namespace);
    }
  }
  addNamespaceObject(namespace) {
    for (let name2 of Object.keys(namespace)) {
      let children = namespace[name2], self2 = null;
      let parts = name2.replace(/\\?\./g, (p) => p == "." ? "\0" : p).split("\0");
      let scope = this;
      if (isSelfTag(children)) {
        self2 = children.self;
        children = children.children;
      }
      for (let i = 0; i < parts.length; i++) {
        if (self2 && i == parts.length - 1)
          scope.addCompletion(self2);
        scope = scope.child(parts[i].replace(/\\\./g, "."));
      }
      scope.addNamespace(children);
    }
  }
}
function nameCompletion(label, type, idQuote, idCaseInsensitive) {
  if (new RegExp("^[a-z_][a-z_\\d]*$", idCaseInsensitive ? "i" : "").test(label))
    return { label, type };
  return { label, type, apply: idQuote + label + getClosingQuote(idQuote) };
}
function getClosingQuote(openingQuote) {
  return openingQuote === "[" ? "]" : openingQuote;
}
function completeFromSchema(schema, tables, schemas, defaultTableName, defaultSchemaName, dialect2) {
  var _a2;
  let idQuote = ((_a2 = dialect2 === null || dialect2 === void 0 ? void 0 : dialect2.spec.identifierQuotes) === null || _a2 === void 0 ? void 0 : _a2[0]) || '"';
  let top2 = new CompletionLevel(idQuote, !!(dialect2 === null || dialect2 === void 0 ? void 0 : dialect2.spec.caseInsensitiveIdentifiers));
  let defaultSchema = defaultSchemaName ? top2.child(defaultSchemaName) : null;
  top2.addNamespace(schema);
  if (tables)
    (defaultSchema || top2).addCompletions(tables);
  if (schemas)
    top2.addCompletions(schemas);
  if (defaultSchema)
    top2.addCompletions(defaultSchema.list);
  if (defaultTableName)
    top2.addCompletions((defaultSchema || top2).child(defaultTableName).list);
  return (context) => {
    let { parents, from, quoted, empty, aliases } = sourceContext(context.state, context.pos);
    if (empty && !context.explicit)
      return null;
    if (aliases && parents.length == 1)
      parents = aliases[parents[0]] || parents;
    let level = top2;
    for (let name2 of parents) {
      while (!level.children || !level.children[name2]) {
        if (level == top2 && defaultSchema)
          level = defaultSchema;
        else if (level == defaultSchema && defaultTableName)
          level = level.child(defaultTableName);
        else
          return null;
      }
      let next = level.maybeChild(name2);
      if (!next)
        return null;
      level = next;
    }
    let options = level.list;
    if (level == top2 && aliases)
      options = options.concat(Object.keys(aliases).map((name2) => ({ label: name2, type: "constant" })));
    if (quoted) {
      let openingQuote = quoted[0];
      let closingQuote = getClosingQuote(openingQuote);
      let quoteAfter = context.state.sliceDoc(context.pos, context.pos + 1) == closingQuote;
      return {
        from,
        to: quoteAfter ? context.pos + 1 : void 0,
        options: maybeQuoteCompletions(openingQuote, closingQuote, options),
        validFor: QuotedSpan
      };
    } else {
      return {
        from,
        options,
        validFor: Span
      };
    }
  };
}
function completionType(tokenType) {
  return tokenType == Type ? "type" : tokenType == Keyword ? "keyword" : "variable";
}
function completeKeywords(keywords2, upperCase, build) {
  let completions = Object.keys(keywords2).map((keyword2) => build(upperCase ? keyword2.toUpperCase() : keyword2, completionType(keywords2[keyword2])));
  return ifNotIn(["QuotedIdentifier", "String", "LineComment", "BlockComment", "."], completeFromList(completions));
}
let parser$2 = /* @__PURE__ */ parser$1.configure({
  props: [
    /* @__PURE__ */ indentNodeProp.add({
      Statement: /* @__PURE__ */ continuedIndent()
    }),
    /* @__PURE__ */ foldNodeProp.add({
      Statement(tree, state) {
        return { from: Math.min(tree.from + 100, state.doc.lineAt(tree.from).to), to: tree.to };
      },
      BlockComment(tree) {
        return { from: tree.from + 2, to: tree.to - 2 };
      }
    }),
    /* @__PURE__ */ styleTags({
      Keyword: tags.keyword,
      Type: tags.typeName,
      Builtin: /* @__PURE__ */ tags.standard(tags.name),
      Bits: tags.number,
      Bytes: tags.string,
      Bool: tags.bool,
      Null: tags.null,
      Number: tags.number,
      String: tags.string,
      Identifier: tags.name,
      QuotedIdentifier: /* @__PURE__ */ tags.special(tags.string),
      SpecialVar: /* @__PURE__ */ tags.special(tags.name),
      LineComment: tags.lineComment,
      BlockComment: tags.blockComment,
      Operator: tags.operator,
      "Semi Punctuation": tags.punctuation,
      "( )": tags.paren,
      "{ }": tags.brace,
      "[ ]": tags.squareBracket
    })
  ]
});
class SQLDialect {
  constructor(dialect2, language2, spec) {
    this.dialect = dialect2;
    this.language = language2;
    this.spec = spec;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Reconfigure the parser used by this dialect. Returns a new
  dialect object.
  */
  configureLanguage(options, name2) {
    return new SQLDialect(this.dialect, this.language.configure(options, name2), this.spec);
  }
  /**
  Define a new dialect.
  */
  static define(spec) {
    let d = dialect(spec, spec.keywords, spec.types, spec.builtin);
    let language2 = LRLanguage.define({
      name: "sql",
      parser: parser$2.configure({
        tokenizers: [{ from: tokens, to: tokensFor(d) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new SQLDialect(d, language2, spec);
  }
}
function defaultKeyword(label, type) {
  return { label, type, boost: -1 };
}
function keywordCompletionSource(dialect2, upperCase = false, build) {
  return completeKeywords(dialect2.dialect.words, upperCase, build || defaultKeyword);
}
function schemaCompletionSource(config) {
  return config.schema ? completeFromSchema(config.schema, config.tables, config.schemas, config.defaultTable, config.defaultSchema, config.dialect || StandardSQL) : () => null;
}
function schemaCompletion(config) {
  return config.schema ? (config.dialect || StandardSQL).language.data.of({
    autocomplete: schemaCompletionSource(config)
  }) : [];
}
function sql(config = {}) {
  let lang = config.dialect || StandardSQL;
  return new LanguageSupport(lang.language, [
    schemaCompletion(config),
    lang.language.data.of({
      autocomplete: keywordCompletionSource(lang, config.upperCaseKeywords, config.keywordCompletion)
    })
  ]);
}
const StandardSQL = /* @__PURE__ */ SQLDialect.define({});
const jsonHighlighting = styleTags({
  String: tags.string,
  Number: tags.number,
  "True False": tags.bool,
  PropertyName: tags.propertyName,
  Null: tags.null,
  ", :": tags.separator,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});
const parser = LRParser.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 14, "["],
    ["closedBy", 8, "}", 15, "]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { "JsonText": [0, 1] },
  tokenPrec: 0
});
const jsonLanguage = /* @__PURE__ */ LRLanguage.define({
  name: "json",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Object: /* @__PURE__ */ continuedIndent({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ continuedIndent({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Object Array": foldInside
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new LanguageSupport(jsonLanguage);
}
const chalky = "#e5c07b", coral = "#e06c75", cyan = "#56b6c2", invalid = "#ffffff", ivory = "#abb2bf", stone = "#7d8799", malibu = "#61afef", sage = "#98c379", whiskey = "#d19a66", violet = "#c678dd", darkBackground = "#21252b", highlightBackground = "#2c313a", background = "#282c34", tooltipBackground = "#353a42", selection = "#3E4451", cursor = "#528bff";
const oneDarkTheme = /* @__PURE__ */ EditorView.theme({
  "&": {
    color: ivory,
    backgroundColor: background
  },
  ".cm-content": {
    caretColor: cursor
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
  ".cm-panels": { backgroundColor: darkBackground, color: ivory },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: background,
    color: stone,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: highlightBackground
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: tooltipBackground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tooltipBackground,
    borderBottomColor: tooltipBackground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: highlightBackground,
      color: ivory
    }
  }
}, { dark: true });
const oneDarkHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.keyword,
    color: violet
  },
  {
    tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
    color: coral
  },
  {
    tag: [/* @__PURE__ */ tags.function(tags.variableName), tags.labelName],
    color: malibu
  },
  {
    tag: [tags.color, /* @__PURE__ */ tags.constant(tags.name), /* @__PURE__ */ tags.standard(tags.name)],
    color: whiskey
  },
  {
    tag: [/* @__PURE__ */ tags.definition(tags.name), tags.separator],
    color: ivory
  },
  {
    tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
    color: chalky
  },
  {
    tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /* @__PURE__ */ tags.special(tags.string)],
    color: cyan
  },
  {
    tag: [tags.meta, tags.comment],
    color: stone
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.link,
    color: stone,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    fontWeight: "bold",
    color: coral
  },
  {
    tag: [tags.atom, tags.bool, /* @__PURE__ */ tags.special(tags.variableName)],
    color: whiskey
  },
  {
    tag: [tags.processingInstruction, tags.string, tags.inserted],
    color: sage
  },
  {
    tag: tags.invalid,
    color: invalid
  }
]);
const oneDark = [oneDarkTheme, /* @__PURE__ */ syntaxHighlighting(oneDarkHighlightStyle)];
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var exceljs_min = { exports: {} };
var hasRequiredExceljs_min;
function requireExceljs_min() {
  if (hasRequiredExceljs_min) return exceljs_min.exports;
  hasRequiredExceljs_min = 1;
  (function(module, exports$1) {
    !(function(e) {
      module.exports = e();
    })((function() {
      return (function e(t2, r, n) {
        function i(o2, a) {
          if (!r[o2]) {
            if (!t2[o2]) {
              var l = "function" == typeof commonjsRequire && commonjsRequire;
              if (!a && l) return l(o2, true);
              if (s) return s(o2, true);
              var c = new Error("Cannot find module '" + o2 + "'");
              throw c.code = "MODULE_NOT_FOUND", c;
            }
            var u = r[o2] = { exports: {} };
            t2[o2][0].call(u.exports, (function(e2) {
              return i(t2[o2][1][e2] || e2);
            }), u, u.exports, e, t2, r, n);
          }
          return r[o2].exports;
        }
        for (var s = "function" == typeof commonjsRequire && commonjsRequire, o = 0; o < n.length; o++) i(n[o]);
        return i;
      })({ 1: [function(e, t2, r) {
        const n = e("fs"), i = e("fast-csv"), s = e("dayjs/plugin/customParseFormat"), o = e("dayjs/plugin/utc"), a = e("dayjs").extend(s).extend(o), l = e("../utils/stream-buf"), { fs: { exists: c } } = e("../utils/utils"), u = { true: true, false: false, "#N/A": { error: "#N/A" }, "#REF!": { error: "#REF!" }, "#NAME?": { error: "#NAME?" }, "#DIV/0!": { error: "#DIV/0!" }, "#NULL!": { error: "#NULL!" }, "#VALUE!": { error: "#VALUE!" }, "#NUM!": { error: "#NUM!" } };
        t2.exports = class {
          constructor(e2) {
            this.workbook = e2, this.worksheet = null;
          }
          async readFile(e2, t3) {
            if (t3 = t3 || {}, !await c(e2)) throw new Error("File not found: " + e2);
            const r2 = n.createReadStream(e2), i2 = await this.read(r2, t3);
            return r2.close(), i2;
          }
          read(e2, t3) {
            return t3 = t3 || {}, new Promise((r2, n2) => {
              const s2 = this.workbook.addWorksheet(t3.sheetName), o2 = t3.dateFormats || ["YYYY-MM-DD[T]HH:mm:ssZ", "YYYY-MM-DD[T]HH:mm:ss", "MM-DD-YYYY", "YYYY-MM-DD"], l2 = t3.map || function(e3) {
                if ("" === e3) return null;
                const t4 = Number(e3);
                if (!Number.isNaN(t4) && t4 !== 1 / 0) return t4;
                const r3 = o2.reduce((t5, r4) => {
                  if (t5) return t5;
                  const n4 = a(e3, r4, true);
                  return n4.isValid() ? n4 : null;
                }, null);
                if (r3) return new Date(r3.valueOf());
                const n3 = u[e3];
                return void 0 !== n3 ? n3 : e3;
              }, c2 = i.parse(t3.parserOptions).on("data", (e3) => {
                s2.addRow(e3.map(l2));
              }).on("end", () => {
                c2.emit("worksheet", s2);
              });
              c2.on("worksheet", r2).on("error", n2), e2.pipe(c2);
            });
          }
          createInputStream() {
            throw new Error("`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
          }
          write(e2, t3) {
            return new Promise((r2, n2) => {
              t3 = t3 || {};
              const s2 = this.workbook.getWorksheet(t3.sheetName || t3.sheetId), o2 = i.format(t3.formatterOptions);
              e2.on("finish", () => {
                r2();
              }), o2.on("error", n2), o2.pipe(e2);
              const { dateFormat: l2, dateUTC: c2 } = t3, u2 = t3.map || ((e3) => {
                if (e3) {
                  if (e3.text || e3.hyperlink) return e3.hyperlink || e3.text || "";
                  if (e3.formula || e3.result) return e3.result || "";
                  if (e3 instanceof Date) return l2 ? c2 ? a.utc(e3).format(l2) : a(e3).format(l2) : c2 ? a.utc(e3).format() : a(e3).format();
                  if (e3.error) return e3.error;
                  if ("object" == typeof e3) return JSON.stringify(e3);
                }
                return e3;
              }), h = void 0 === t3.includeEmptyRows || t3.includeEmptyRows;
              let f = 1;
              s2 && s2.eachRow((e3, t4) => {
                if (h) for (; f++ < t4 - 1; ) o2.write([]);
                const { values: r3 } = e3;
                r3.shift(), o2.write(r3.map(u2)), f = t4;
              }), o2.end();
            });
          }
          writeFile(e2, t3) {
            const r2 = { encoding: (t3 = t3 || {}).encoding || "utf8" }, i2 = n.createWriteStream(e2, r2);
            return this.write(i2, t3);
          }
          async writeBuffer(e2) {
            const t3 = new l();
            return await this.write(t3, e2), t3.read();
          }
        };
      }, { "../utils/stream-buf": 24, "../utils/utils": 27, dayjs: 391, "dayjs/plugin/customParseFormat": 392, "dayjs/plugin/utc": 393, "fast-csv": 424, fs: 216 }], 2: [function(e, t2, r) {
        const n = e("../utils/col-cache");
        class i {
          constructor(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (this.worksheet = e2, t3) if ("string" == typeof t3) {
              const e3 = n.decodeAddress(t3);
              this.nativeCol = e3.col + r2, this.nativeColOff = 0, this.nativeRow = e3.row + r2, this.nativeRowOff = 0;
            } else void 0 !== t3.nativeCol ? (this.nativeCol = t3.nativeCol || 0, this.nativeColOff = t3.nativeColOff || 0, this.nativeRow = t3.nativeRow || 0, this.nativeRowOff = t3.nativeRowOff || 0) : void 0 !== t3.col ? (this.col = t3.col + r2, this.row = t3.row + r2) : (this.nativeCol = 0, this.nativeColOff = 0, this.nativeRow = 0, this.nativeRowOff = 0);
            else this.nativeCol = 0, this.nativeColOff = 0, this.nativeRow = 0, this.nativeRowOff = 0;
          }
          static asInstance(e2) {
            return e2 instanceof i || null == e2 ? e2 : new i(e2);
          }
          get col() {
            return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
          }
          set col(e2) {
            this.nativeCol = Math.floor(e2), this.nativeColOff = Math.floor((e2 - this.nativeCol) * this.colWidth);
          }
          get row() {
            return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
          }
          set row(e2) {
            this.nativeRow = Math.floor(e2), this.nativeRowOff = Math.floor((e2 - this.nativeRow) * this.rowHeight);
          }
          get colWidth() {
            return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(1e4 * this.worksheet.getColumn(this.nativeCol + 1).width) : 64e4;
          }
          get rowHeight() {
            return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(1e4 * this.worksheet.getRow(this.nativeRow + 1).height) : 18e4;
          }
          get model() {
            return { nativeCol: this.nativeCol, nativeColOff: this.nativeColOff, nativeRow: this.nativeRow, nativeRowOff: this.nativeRowOff };
          }
          set model(e2) {
            this.nativeCol = e2.nativeCol, this.nativeColOff = e2.nativeColOff, this.nativeRow = e2.nativeRow, this.nativeRowOff = e2.nativeRowOff;
          }
        }
        t2.exports = i;
      }, { "../utils/col-cache": 19 }], 3: [function(e, t2, r) {
        const n = e("../utils/col-cache"), i = e("../utils/under-dash"), s = e("./enums"), { slideFormula: o } = e("../utils/shared-formula"), a = e("./note");
        class l {
          constructor(e2, t3, r2) {
            if (!e2 || !t3) throw new Error("A Cell needs a Row");
            this._row = e2, this._column = t3, n.validateAddress(r2), this._address = r2, this._value = c.create(l.Types.Null, this), this.style = this._mergeStyle(e2.style, t3.style, {}), this._mergeCount = 0;
          }
          get worksheet() {
            return this._row.worksheet;
          }
          get workbook() {
            return this._row.worksheet.workbook;
          }
          destroy() {
            delete this.style, delete this._value, delete this._row, delete this._column, delete this._address;
          }
          get numFmt() {
            return this.style.numFmt;
          }
          set numFmt(e2) {
            this.style.numFmt = e2;
          }
          get font() {
            return this.style.font;
          }
          set font(e2) {
            this.style.font = e2;
          }
          get alignment() {
            return this.style.alignment;
          }
          set alignment(e2) {
            this.style.alignment = e2;
          }
          get border() {
            return this.style.border;
          }
          set border(e2) {
            this.style.border = e2;
          }
          get fill() {
            return this.style.fill;
          }
          set fill(e2) {
            this.style.fill = e2;
          }
          get protection() {
            return this.style.protection;
          }
          set protection(e2) {
            this.style.protection = e2;
          }
          _mergeStyle(e2, t3, r2) {
            const n2 = e2 && e2.numFmt || t3 && t3.numFmt;
            n2 && (r2.numFmt = n2);
            const i2 = e2 && e2.font || t3 && t3.font;
            i2 && (r2.font = i2);
            const s2 = e2 && e2.alignment || t3 && t3.alignment;
            s2 && (r2.alignment = s2);
            const o2 = e2 && e2.border || t3 && t3.border;
            o2 && (r2.border = o2);
            const a2 = e2 && e2.fill || t3 && t3.fill;
            a2 && (r2.fill = a2);
            const l2 = e2 && e2.protection || t3 && t3.protection;
            return l2 && (r2.protection = l2), r2;
          }
          get address() {
            return this._address;
          }
          get row() {
            return this._row.number;
          }
          get col() {
            return this._column.number;
          }
          get $col$row() {
            return `$${this._column.letter}$${this.row}`;
          }
          get type() {
            return this._value.type;
          }
          get effectiveType() {
            return this._value.effectiveType;
          }
          toCsvString() {
            return this._value.toCsvString();
          }
          addMergeRef() {
            this._mergeCount++;
          }
          releaseMergeRef() {
            this._mergeCount--;
          }
          get isMerged() {
            return this._mergeCount > 0 || this.type === l.Types.Merge;
          }
          merge(e2, t3) {
            this._value.release(), this._value = c.create(l.Types.Merge, this, e2), t3 || (this.style = e2.style);
          }
          unmerge() {
            this.type === l.Types.Merge && (this._value.release(), this._value = c.create(l.Types.Null, this), this.style = this._mergeStyle(this._row.style, this._column.style, {}));
          }
          isMergedTo(e2) {
            return this._value.type === l.Types.Merge && this._value.isMergedTo(e2);
          }
          get master() {
            return this.type === l.Types.Merge ? this._value.master : this;
          }
          get isHyperlink() {
            return this._value.type === l.Types.Hyperlink;
          }
          get hyperlink() {
            return this._value.hyperlink;
          }
          get value() {
            return this._value.value;
          }
          set value(e2) {
            this.type !== l.Types.Merge ? (this._value.release(), this._value = c.create(c.getType(e2), this, e2)) : this._value.master.value = e2;
          }
          get note() {
            return this._comment && this._comment.note;
          }
          set note(e2) {
            this._comment = new a(e2);
          }
          get text() {
            return this._value.toString();
          }
          get html() {
            return i.escapeHtml(this.text);
          }
          toString() {
            return this.text;
          }
          _upgradeToHyperlink(e2) {
            this.type === l.Types.String && (this._value = c.create(l.Types.Hyperlink, this, { text: this._value.value, hyperlink: e2 }));
          }
          get formula() {
            return this._value.formula;
          }
          get result() {
            return this._value.result;
          }
          get formulaType() {
            return this._value.formulaType;
          }
          get fullAddress() {
            const { worksheet: e2 } = this._row;
            return { sheetName: e2.name, address: this.address, row: this.row, col: this.col };
          }
          get name() {
            return this.names[0];
          }
          set name(e2) {
            this.names = [e2];
          }
          get names() {
            return this.workbook.definedNames.getNamesEx(this.fullAddress);
          }
          set names(e2) {
            const { definedNames: t3 } = this.workbook;
            t3.removeAllNames(this.fullAddress), e2.forEach((e3) => {
              t3.addEx(this.fullAddress, e3);
            });
          }
          addName(e2) {
            this.workbook.definedNames.addEx(this.fullAddress, e2);
          }
          removeName(e2) {
            this.workbook.definedNames.removeEx(this.fullAddress, e2);
          }
          removeAllNames() {
            this.workbook.definedNames.removeAllNames(this.fullAddress);
          }
          get _dataValidations() {
            return this.worksheet.dataValidations;
          }
          get dataValidation() {
            return this._dataValidations.find(this.address);
          }
          set dataValidation(e2) {
            this._dataValidations.add(this.address, e2);
          }
          get model() {
            const { model: e2 } = this._value;
            return e2.style = this.style, this._comment && (e2.comment = this._comment.model), e2;
          }
          set model(e2) {
            if (this._value.release(), this._value = c.create(e2.type, this), this._value.model = e2, e2.comment) switch (e2.comment.type) {
              case "note":
                this._comment = a.fromModel(e2.comment);
            }
            e2.style ? this.style = e2.style : this.style = {};
          }
        }
        l.Types = s.ValueType;
        const c = { getType: (e2) => null == e2 ? l.Types.Null : e2 instanceof String || "string" == typeof e2 ? l.Types.String : "number" == typeof e2 ? l.Types.Number : "boolean" == typeof e2 ? l.Types.Boolean : e2 instanceof Date ? l.Types.Date : e2.text && e2.hyperlink ? l.Types.Hyperlink : e2.formula || e2.sharedFormula ? l.Types.Formula : e2.richText ? l.Types.RichText : e2.sharedString ? l.Types.SharedString : e2.error ? l.Types.Error : l.Types.JSON, types: [{ t: l.Types.Null, f: class {
          constructor(e2) {
            this.model = { address: e2.address, type: l.Types.Null };
          }
          get value() {
            return null;
          }
          set value(e2) {
          }
          get type() {
            return l.Types.Null;
          }
          get effectiveType() {
            return l.Types.Null;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return "";
          }
          release() {
          }
          toString() {
            return "";
          }
        } }, { t: l.Types.Number, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Number, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.Number;
          }
          get effectiveType() {
            return l.Types.Number;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.value.toString();
          }
          release() {
          }
          toString() {
            return this.model.value.toString();
          }
        } }, { t: l.Types.String, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.String, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.String;
          }
          get effectiveType() {
            return l.Types.String;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return `"${this.model.value.replace(/"/g, '""')}"`;
          }
          release() {
          }
          toString() {
            return this.model.value;
          }
        } }, { t: l.Types.Date, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Date, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.Date;
          }
          get effectiveType() {
            return l.Types.Date;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.value.toISOString();
          }
          release() {
          }
          toString() {
            return this.model.value.toString();
          }
        } }, { t: l.Types.Hyperlink, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Hyperlink, text: t3 ? t3.text : void 0, hyperlink: t3 ? t3.hyperlink : void 0 }, t3 && t3.tooltip && (this.model.tooltip = t3.tooltip);
          }
          get value() {
            const e2 = { text: this.model.text, hyperlink: this.model.hyperlink };
            return this.model.tooltip && (e2.tooltip = this.model.tooltip), e2;
          }
          set value(e2) {
            this.model = { text: e2.text, hyperlink: e2.hyperlink }, e2.tooltip && (this.model.tooltip = e2.tooltip);
          }
          get text() {
            return this.model.text;
          }
          set text(e2) {
            this.model.text = e2;
          }
          get hyperlink() {
            return this.model.hyperlink;
          }
          set hyperlink(e2) {
            this.model.hyperlink = e2;
          }
          get type() {
            return l.Types.Hyperlink;
          }
          get effectiveType() {
            return l.Types.Hyperlink;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.hyperlink;
          }
          release() {
          }
          toString() {
            return this.model.text;
          }
        } }, { t: l.Types.Formula, f: class {
          constructor(e2, t3) {
            this.cell = e2, this.model = { address: e2.address, type: l.Types.Formula, shareType: t3 ? t3.shareType : void 0, ref: t3 ? t3.ref : void 0, formula: t3 ? t3.formula : void 0, sharedFormula: t3 ? t3.sharedFormula : void 0, result: t3 ? t3.result : void 0 };
          }
          _copyModel(e2) {
            const t3 = {}, r2 = (r3) => {
              const n2 = e2[r3];
              n2 && (t3[r3] = n2);
            };
            return r2("formula"), r2("result"), r2("ref"), r2("shareType"), r2("sharedFormula"), t3;
          }
          get value() {
            return this._copyModel(this.model);
          }
          set value(e2) {
            this.model = this._copyModel(e2);
          }
          validate(e2) {
            switch (c.getType(e2)) {
              case l.Types.Null:
              case l.Types.String:
              case l.Types.Number:
              case l.Types.Date:
                break;
              case l.Types.Hyperlink:
              case l.Types.Formula:
              default:
                throw new Error("Cannot process that type of result value");
            }
          }
          get dependencies() {
            return { ranges: this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g), cells: this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g) };
          }
          get formula() {
            return this.model.formula || this._getTranslatedFormula();
          }
          set formula(e2) {
            this.model.formula = e2;
          }
          get formulaType() {
            return this.model.formula ? s.FormulaType.Master : this.model.sharedFormula ? s.FormulaType.Shared : s.FormulaType.None;
          }
          get result() {
            return this.model.result;
          }
          set result(e2) {
            this.model.result = e2;
          }
          get type() {
            return l.Types.Formula;
          }
          get effectiveType() {
            const e2 = this.model.result;
            return null == e2 ? s.ValueType.Null : e2 instanceof String || "string" == typeof e2 ? s.ValueType.String : "number" == typeof e2 ? s.ValueType.Number : e2 instanceof Date ? s.ValueType.Date : e2.text && e2.hyperlink ? s.ValueType.Hyperlink : e2.formula ? s.ValueType.Formula : s.ValueType.Null;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          _getTranslatedFormula() {
            if (!this._translatedFormula && this.model.sharedFormula) {
              const { worksheet: e2 } = this.cell, t3 = e2.findCell(this.model.sharedFormula);
              this._translatedFormula = t3 && o(t3.formula, t3.address, this.model.address);
            }
            return this._translatedFormula;
          }
          toCsvString() {
            return "" + (this.model.result || "");
          }
          release() {
          }
          toString() {
            return this.model.result ? this.model.result.toString() : "";
          }
        } }, { t: l.Types.Merge, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Merge, master: t3 ? t3.address : void 0 }, this._master = t3, t3 && t3.addMergeRef();
          }
          get value() {
            return this._master.value;
          }
          set value(e2) {
            e2 instanceof l ? (this._master && this._master.releaseMergeRef(), e2.addMergeRef(), this._master = e2) : this._master.value = e2;
          }
          isMergedTo(e2) {
            return e2 === this._master;
          }
          get master() {
            return this._master;
          }
          get type() {
            return l.Types.Merge;
          }
          get effectiveType() {
            return this._master.effectiveType;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return "";
          }
          release() {
            this._master.releaseMergeRef();
          }
          toString() {
            return this.value.toString();
          }
        } }, { t: l.Types.JSON, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.String, value: JSON.stringify(t3), rawValue: t3 };
          }
          get value() {
            return this.model.rawValue;
          }
          set value(e2) {
            this.model.rawValue = e2, this.model.value = JSON.stringify(e2);
          }
          get type() {
            return l.Types.String;
          }
          get effectiveType() {
            return l.Types.String;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.value;
          }
          release() {
          }
          toString() {
            return this.model.value;
          }
        } }, { t: l.Types.SharedString, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.SharedString, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.SharedString;
          }
          get effectiveType() {
            return l.Types.SharedString;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.value.toString();
          }
          release() {
          }
          toString() {
            return this.model.value.toString();
          }
        } }, { t: l.Types.RichText, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.String, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          toString() {
            return this.model.value.richText.map((e2) => e2.text).join("");
          }
          get type() {
            return l.Types.RichText;
          }
          get effectiveType() {
            return l.Types.RichText;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return `"${this.text.replace(/"/g, '""')}"`;
          }
          release() {
          }
        } }, { t: l.Types.Boolean, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Boolean, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.Boolean;
          }
          get effectiveType() {
            return l.Types.Boolean;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.model.value ? 1 : 0;
          }
          release() {
          }
          toString() {
            return this.model.value.toString();
          }
        } }, { t: l.Types.Error, f: class {
          constructor(e2, t3) {
            this.model = { address: e2.address, type: l.Types.Error, value: t3 };
          }
          get value() {
            return this.model.value;
          }
          set value(e2) {
            this.model.value = e2;
          }
          get type() {
            return l.Types.Error;
          }
          get effectiveType() {
            return l.Types.Error;
          }
          get address() {
            return this.model.address;
          }
          set address(e2) {
            this.model.address = e2;
          }
          toCsvString() {
            return this.toString();
          }
          release() {
          }
          toString() {
            return this.model.value.error.toString();
          }
        } }].reduce((e2, t3) => (e2[t3.t] = t3.f, e2), []), create(e2, t3, r2) {
          const n2 = this.types[e2];
          if (!n2) throw new Error("Could not create Value of type " + e2);
          return new n2(t3, r2);
        } };
        t2.exports = l;
      }, { "../utils/col-cache": 19, "../utils/shared-formula": 23, "../utils/under-dash": 26, "./enums": 7, "./note": 9 }], 4: [function(e, t2, r) {
        const n = e("../utils/under-dash"), i = e("./enums"), s = e("../utils/col-cache");
        class o {
          constructor(e2, t3, r2) {
            this._worksheet = e2, this._number = t3, false !== r2 && (this.defn = r2);
          }
          get number() {
            return this._number;
          }
          get worksheet() {
            return this._worksheet;
          }
          get letter() {
            return s.n2l(this._number);
          }
          get isCustomWidth() {
            return void 0 !== this.width && 9 !== this.width;
          }
          get defn() {
            return { header: this._header, key: this.key, width: this.width, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel };
          }
          set defn(e2) {
            e2 ? (this.key = e2.key, this.width = void 0 !== e2.width ? e2.width : 9, this.outlineLevel = e2.outlineLevel, e2.style ? this.style = e2.style : this.style = {}, this.header = e2.header, this._hidden = !!e2.hidden) : (delete this._header, delete this._key, delete this.width, this.style = {}, this.outlineLevel = 0);
          }
          get headers() {
            return this._header && this._header instanceof Array ? this._header : [this._header];
          }
          get header() {
            return this._header;
          }
          set header(e2) {
            void 0 !== e2 ? (this._header = e2, this.headers.forEach((e3, t3) => {
              this._worksheet.getCell(t3 + 1, this.number).value = e3;
            })) : this._header = void 0;
          }
          get key() {
            return this._key;
          }
          set key(e2) {
            (this._key && this._worksheet.getColumnKey(this._key)) === this && this._worksheet.deleteColumnKey(this._key), this._key = e2, e2 && this._worksheet.setColumnKey(this._key, this);
          }
          get hidden() {
            return !!this._hidden;
          }
          set hidden(e2) {
            this._hidden = e2;
          }
          get outlineLevel() {
            return this._outlineLevel || 0;
          }
          set outlineLevel(e2) {
            this._outlineLevel = e2;
          }
          get collapsed() {
            return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
          }
          toString() {
            return JSON.stringify({ key: this.key, width: this.width, headers: this.headers.length ? this.headers : void 0 });
          }
          equivalentTo(e2) {
            return this.width === e2.width && this.hidden === e2.hidden && this.outlineLevel === e2.outlineLevel && n.isEqual(this.style, e2.style);
          }
          get isDefault() {
            if (this.isCustomWidth) return false;
            if (this.hidden) return false;
            if (this.outlineLevel) return false;
            const e2 = this.style;
            return !e2 || !(e2.font || e2.numFmt || e2.alignment || e2.border || e2.fill || e2.protection);
          }
          get headerCount() {
            return this.headers.length;
          }
          eachCell(e2, t3) {
            const r2 = this.number;
            t3 || (t3 = e2, e2 = null), this._worksheet.eachRow(e2, (e3, n2) => {
              t3(e3.getCell(r2), n2);
            });
          }
          get values() {
            const e2 = [];
            return this.eachCell((t3, r2) => {
              t3 && t3.type !== i.ValueType.Null && (e2[r2] = t3.value);
            }), e2;
          }
          set values(e2) {
            if (!e2) return;
            const t3 = this.number;
            let r2 = 0;
            e2.hasOwnProperty("0") && (r2 = 1), e2.forEach((e3, n2) => {
              this._worksheet.getCell(n2 + r2, t3).value = e3;
            });
          }
          _applyStyle(e2, t3) {
            return this.style[e2] = t3, this.eachCell((r2) => {
              r2[e2] = t3;
            }), t3;
          }
          get numFmt() {
            return this.style.numFmt;
          }
          set numFmt(e2) {
            this._applyStyle("numFmt", e2);
          }
          get font() {
            return this.style.font;
          }
          set font(e2) {
            this._applyStyle("font", e2);
          }
          get alignment() {
            return this.style.alignment;
          }
          set alignment(e2) {
            this._applyStyle("alignment", e2);
          }
          get protection() {
            return this.style.protection;
          }
          set protection(e2) {
            this._applyStyle("protection", e2);
          }
          get border() {
            return this.style.border;
          }
          set border(e2) {
            this._applyStyle("border", e2);
          }
          get fill() {
            return this.style.fill;
          }
          set fill(e2) {
            this._applyStyle("fill", e2);
          }
          static toModel(e2) {
            const t3 = [];
            let r2 = null;
            return e2 && e2.forEach((e3, n2) => {
              e3.isDefault ? r2 && (r2 = null) : r2 && e3.equivalentTo(r2) ? r2.max = n2 + 1 : (r2 = { min: n2 + 1, max: n2 + 1, width: void 0 !== e3.width ? e3.width : 9, style: e3.style, isCustomWidth: e3.isCustomWidth, hidden: e3.hidden, outlineLevel: e3.outlineLevel, collapsed: e3.collapsed }, t3.push(r2));
            }), t3.length ? t3 : void 0;
          }
          static fromModel(e2, t3) {
            const r2 = [];
            let n2 = 1, i2 = 0;
            for (t3 = (t3 = t3 || []).sort((function(e3, t4) {
              return e3.min - t4.min;
            })); i2 < t3.length; ) {
              const s2 = t3[i2++];
              for (; n2 < s2.min; ) r2.push(new o(e2, n2++));
              for (; n2 <= s2.max; ) r2.push(new o(e2, n2++, s2));
            }
            return r2.length ? r2 : null;
          }
        }
        t2.exports = o;
      }, { "../utils/col-cache": 19, "../utils/under-dash": 26, "./enums": 7 }], 5: [function(e, t2, r) {
        t2.exports = class {
          constructor(e2) {
            this.model = e2 || {};
          }
          add(e2, t3) {
            return this.model[e2] = t3;
          }
          find(e2) {
            return this.model[e2];
          }
          remove(e2) {
            this.model[e2] = void 0;
          }
        };
      }, {}], 6: [function(e, t2, r) {
        const n = e("../utils/under-dash"), i = e("../utils/col-cache"), s = e("../utils/cell-matrix"), o = e("./range"), a = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
        t2.exports = class {
          constructor() {
            this.matrixMap = {};
          }
          getMatrix(e2) {
            return this.matrixMap[e2] || (this.matrixMap[e2] = new s());
          }
          add(e2, t3) {
            const r2 = i.decodeEx(e2);
            this.addEx(r2, t3);
          }
          addEx(e2, t3) {
            const r2 = this.getMatrix(t3);
            if (e2.top) for (let t4 = e2.left; t4 <= e2.right; t4++) for (let n2 = e2.top; n2 <= e2.bottom; n2++) {
              const s2 = { sheetName: e2.sheetName, address: i.n2l(t4) + n2, row: n2, col: t4 };
              r2.addCellEx(s2);
            }
            else r2.addCellEx(e2);
          }
          remove(e2, t3) {
            const r2 = i.decodeEx(e2);
            this.removeEx(r2, t3);
          }
          removeEx(e2, t3) {
            this.getMatrix(t3).removeCellEx(e2);
          }
          removeAllNames(e2) {
            n.each(this.matrixMap, (t3) => {
              t3.removeCellEx(e2);
            });
          }
          forEach(e2) {
            n.each(this.matrixMap, (t3, r2) => {
              t3.forEach((t4) => {
                e2(r2, t4);
              });
            });
          }
          getNames(e2) {
            return this.getNamesEx(i.decodeEx(e2));
          }
          getNamesEx(e2) {
            return n.map(this.matrixMap, (t3, r2) => t3.findCellEx(e2) && r2).filter(Boolean);
          }
          _explore(e2, t3) {
            t3.mark = false;
            const { sheetName: r2 } = t3, n2 = new o(t3.row, t3.col, t3.row, t3.col, r2);
            let i2, s2;
            function a2(i3, s3) {
              const o2 = e2.findCellAt(r2, i3, t3.col);
              return !(!o2 || !o2.mark) && (n2[s3] = i3, o2.mark = false, true);
            }
            for (s2 = t3.row - 1; a2(s2, "top"); s2--) ;
            for (s2 = t3.row + 1; a2(s2, "bottom"); s2++) ;
            function l(t4, i3) {
              const o2 = [];
              for (s2 = n2.top; s2 <= n2.bottom; s2++) {
                const n3 = e2.findCellAt(r2, s2, t4);
                if (!n3 || !n3.mark) return false;
                o2.push(n3);
              }
              n2[i3] = t4;
              for (let e3 = 0; e3 < o2.length; e3++) o2[e3].mark = false;
              return true;
            }
            for (i2 = t3.col - 1; l(i2, "left"); i2--) ;
            for (i2 = t3.col + 1; l(i2, "right"); i2++) ;
            return n2;
          }
          getRanges(e2, t3) {
            if (!(t3 = t3 || this.matrixMap[e2])) return { name: e2, ranges: [] };
            t3.forEach((e3) => {
              e3.mark = true;
            });
            return { name: e2, ranges: t3.map((e3) => e3.mark && this._explore(t3, e3)).filter(Boolean).map((e3) => e3.$shortRange) };
          }
          normaliseMatrix(e2, t3) {
            e2.forEachInSheet(t3, (e3, t4, r2) => {
              e3 && (e3.row === t4 && e3.col === r2 || (e3.row = t4, e3.col = r2, e3.address = i.n2l(r2) + t4));
            });
          }
          spliceRows(e2, t3, r2, i2) {
            n.each(this.matrixMap, (n2) => {
              n2.spliceRows(e2, t3, r2, i2), this.normaliseMatrix(n2, e2);
            });
          }
          spliceColumns(e2, t3, r2, i2) {
            n.each(this.matrixMap, (n2) => {
              n2.spliceColumns(e2, t3, r2, i2), this.normaliseMatrix(n2, e2);
            });
          }
          get model() {
            return n.map(this.matrixMap, (e2, t3) => this.getRanges(t3, e2)).filter((e2) => e2.ranges.length);
          }
          set model(e2) {
            const t3 = this.matrixMap = {};
            e2.forEach((e3) => {
              const r2 = t3[e3.name] = new s();
              e3.ranges.forEach((e4) => {
                a.test(e4.split("!").pop() || "") && r2.addCell(e4);
              });
            });
          }
        };
      }, { "../utils/cell-matrix": 18, "../utils/col-cache": 19, "../utils/under-dash": 26, "./range": 10 }], 7: [function(e, t2, r) {
        t2.exports = { ValueType: { Null: 0, Merge: 1, Number: 2, String: 3, Date: 4, Hyperlink: 5, Formula: 6, SharedString: 7, RichText: 8, Boolean: 9, Error: 10 }, FormulaType: { None: 0, Master: 1, Shared: 2 }, RelationshipType: { None: 0, OfficeDocument: 1, Worksheet: 2, CalcChain: 3, SharedStrings: 4, Styles: 5, Theme: 6, Hyperlink: 7 }, DocumentType: { Xlsx: 1 }, ReadingOrder: { LeftToRight: 1, RightToLeft: 2 }, ErrorValue: { NotApplicable: "#N/A", Ref: "#REF!", Name: "#NAME?", DivZero: "#DIV/0!", Null: "#NULL!", Value: "#VALUE!", Num: "#NUM!" } };
      }, {}], 8: [function(e, t2, r) {
        const n = e("../utils/col-cache"), i = e("./anchor");
        t2.exports = class {
          constructor(e2, t3) {
            this.worksheet = e2, this.model = t3;
          }
          get model() {
            switch (this.type) {
              case "background":
                return { type: this.type, imageId: this.imageId };
              case "image":
                return { type: this.type, imageId: this.imageId, hyperlinks: this.range.hyperlinks, range: { tl: this.range.tl.model, br: this.range.br && this.range.br.model, ext: this.range.ext, editAs: this.range.editAs } };
              default:
                throw new Error("Invalid Image Type");
            }
          }
          set model(e2) {
            let { type: t3, imageId: r2, range: s, hyperlinks: o } = e2;
            if (this.type = t3, this.imageId = r2, "image" === t3) if ("string" == typeof s) {
              const e3 = n.decode(s);
              this.range = { tl: new i(this.worksheet, { col: e3.left, row: e3.top }, -1), br: new i(this.worksheet, { col: e3.right, row: e3.bottom }, 0), editAs: "oneCell" };
            } else this.range = { tl: new i(this.worksheet, s.tl, 0), br: s.br && new i(this.worksheet, s.br, 0), ext: s.ext, editAs: s.editAs, hyperlinks: o || s.hyperlinks };
          }
        };
      }, { "../utils/col-cache": 19, "./anchor": 2 }], 9: [function(e, t2, r) {
        const n = e("../utils/under-dash");
        class i {
          constructor(e2) {
            this.note = e2;
          }
          get model() {
            let e2 = null;
            switch (typeof this.note) {
              case "string":
                e2 = { type: "note", note: { texts: [{ text: this.note }] } };
                break;
              default:
                e2 = { type: "note", note: this.note };
            }
            return n.deepMerge({}, i.DEFAULT_CONFIGS, e2);
          }
          set model(e2) {
            const { note: t3 } = e2, { texts: r2 } = t3;
            1 === r2.length && 1 === Object.keys(r2[0]).length ? this.note = r2[0].text : this.note = t3;
          }
          static fromModel(e2) {
            const t3 = new i();
            return t3.model = e2, t3;
          }
        }
        i.DEFAULT_CONFIGS = { note: { margins: { insetmode: "auto", inset: [0.13, 0.13, 0.25, 0.25] }, protection: { locked: "True", lockText: "True" }, editAs: "absolute" } }, t2.exports = i;
      }, { "../utils/under-dash": 26 }], 10: [function(e, t2, r) {
        const n = e("../utils/col-cache");
        class i {
          constructor() {
            this.decode(arguments);
          }
          setTLBR(e2, t3, r2, i2, s) {
            if (arguments.length < 4) {
              const i3 = n.decodeAddress(e2), o = n.decodeAddress(t3);
              this.model = { top: Math.min(i3.row, o.row), left: Math.min(i3.col, o.col), bottom: Math.max(i3.row, o.row), right: Math.max(i3.col, o.col), sheetName: r2 }, this.setTLBR(i3.row, i3.col, o.row, o.col, s);
            } else this.model = { top: Math.min(e2, r2), left: Math.min(t3, i2), bottom: Math.max(e2, r2), right: Math.max(t3, i2), sheetName: s };
          }
          decode(e2) {
            switch (e2.length) {
              case 5:
                this.setTLBR(e2[0], e2[1], e2[2], e2[3], e2[4]);
                break;
              case 4:
                this.setTLBR(e2[0], e2[1], e2[2], e2[3]);
                break;
              case 3:
                this.setTLBR(e2[0], e2[1], e2[2]);
                break;
              case 2:
                this.setTLBR(e2[0], e2[1]);
                break;
              case 1: {
                const t3 = e2[0];
                if (t3 instanceof i) this.model = { top: t3.model.top, left: t3.model.left, bottom: t3.model.bottom, right: t3.model.right, sheetName: t3.sheetName };
                else if (t3 instanceof Array) this.decode(t3);
                else if (t3.top && t3.left && t3.bottom && t3.right) this.model = { top: t3.top, left: t3.left, bottom: t3.bottom, right: t3.right, sheetName: t3.sheetName };
                else {
                  const e3 = n.decodeEx(t3);
                  e3.top ? this.model = { top: e3.top, left: e3.left, bottom: e3.bottom, right: e3.right, sheetName: e3.sheetName } : this.model = { top: e3.row, left: e3.col, bottom: e3.row, right: e3.col, sheetName: e3.sheetName };
                }
                break;
              }
              case 0:
                this.model = { top: 0, left: 0, bottom: 0, right: 0 };
                break;
              default:
                throw new Error("Invalid number of arguments to _getDimensions() - " + e2.length);
            }
          }
          get top() {
            return this.model.top || 1;
          }
          set top(e2) {
            this.model.top = e2;
          }
          get left() {
            return this.model.left || 1;
          }
          set left(e2) {
            this.model.left = e2;
          }
          get bottom() {
            return this.model.bottom || 1;
          }
          set bottom(e2) {
            this.model.bottom = e2;
          }
          get right() {
            return this.model.right || 1;
          }
          set right(e2) {
            this.model.right = e2;
          }
          get sheetName() {
            return this.model.sheetName;
          }
          set sheetName(e2) {
            this.model.sheetName = e2;
          }
          get _serialisedSheetName() {
            const { sheetName: e2 } = this.model;
            return e2 ? /^[a-zA-Z0-9]*$/.test(e2) ? e2 + "!" : `'${e2}'!` : "";
          }
          expand(e2, t3, r2, n2) {
            (!this.model.top || e2 < this.top) && (this.top = e2), (!this.model.left || t3 < this.left) && (this.left = t3), (!this.model.bottom || r2 > this.bottom) && (this.bottom = r2), (!this.model.right || n2 > this.right) && (this.right = n2);
          }
          expandRow(e2) {
            if (e2) {
              const { dimensions: t3, number: r2 } = e2;
              t3 && this.expand(r2, t3.min, r2, t3.max);
            }
          }
          expandToAddress(e2) {
            const t3 = n.decodeEx(e2);
            this.expand(t3.row, t3.col, t3.row, t3.col);
          }
          get tl() {
            return n.n2l(this.left) + this.top;
          }
          get $t$l() {
            return `$${n.n2l(this.left)}$${this.top}`;
          }
          get br() {
            return n.n2l(this.right) + this.bottom;
          }
          get $b$r() {
            return `$${n.n2l(this.right)}$${this.bottom}`;
          }
          get range() {
            return `${this._serialisedSheetName + this.tl}:${this.br}`;
          }
          get $range() {
            return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
          }
          get shortRange() {
            return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
          }
          get $shortRange() {
            return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
          }
          get count() {
            return (1 + this.bottom - this.top) * (1 + this.right - this.left);
          }
          toString() {
            return this.range;
          }
          intersects(e2) {
            return (!e2.sheetName || !this.sheetName || e2.sheetName === this.sheetName) && (!(e2.bottom < this.top) && (!(e2.top > this.bottom) && (!(e2.right < this.left) && !(e2.left > this.right))));
          }
          contains(e2) {
            const t3 = n.decodeEx(e2);
            return this.containsEx(t3);
          }
          containsEx(e2) {
            return (!e2.sheetName || !this.sheetName || e2.sheetName === this.sheetName) && (e2.row >= this.top && e2.row <= this.bottom && e2.col >= this.left && e2.col <= this.right);
          }
          forEachAddress(e2) {
            for (let t3 = this.left; t3 <= this.right; t3++) for (let r2 = this.top; r2 <= this.bottom; r2++) e2(n.encodeAddress(r2, t3), r2, t3);
          }
        }
        t2.exports = i;
      }, { "../utils/col-cache": 19 }], 11: [function(e, t2, r) {
        const n = e("../utils/under-dash"), i = e("./enums"), s = e("../utils/col-cache"), o = e("./cell");
        t2.exports = class {
          constructor(e2, t3) {
            this._worksheet = e2, this._number = t3, this._cells = [], this.style = {}, this.outlineLevel = 0;
          }
          get number() {
            return this._number;
          }
          get worksheet() {
            return this._worksheet;
          }
          commit() {
            this._worksheet._commitRow(this);
          }
          destroy() {
            delete this._worksheet, delete this._cells, delete this.style;
          }
          findCell(e2) {
            return this._cells[e2 - 1];
          }
          getCellEx(e2) {
            let t3 = this._cells[e2.col - 1];
            if (!t3) {
              const r2 = this._worksheet.getColumn(e2.col);
              t3 = new o(this, r2, e2.address), this._cells[e2.col - 1] = t3;
            }
            return t3;
          }
          getCell(e2) {
            if ("string" == typeof e2) {
              const t3 = this._worksheet.getColumnKey(e2);
              e2 = t3 ? t3.number : s.l2n(e2);
            }
            return this._cells[e2 - 1] || this.getCellEx({ address: s.encodeAddress(this._number, e2), row: this._number, col: e2 });
          }
          splice(e2, t3) {
            const r2 = e2 + t3;
            for (var n2 = arguments.length, i2 = new Array(n2 > 2 ? n2 - 2 : 0), s2 = 2; s2 < n2; s2++) i2[s2 - 2] = arguments[s2];
            const o2 = i2.length - t3, a = this._cells.length;
            let l, c, u;
            if (o2 < 0) for (l = e2 + i2.length; l <= a; l++) u = this._cells[l - 1], c = this._cells[l - o2 - 1], c ? (u = this.getCell(l), u.value = c.value, u.style = c.style, u._comment = c._comment) : u && (u.value = null, u.style = {}, u._comment = void 0);
            else if (o2 > 0) for (l = a; l >= r2; l--) c = this._cells[l - 1], c ? (u = this.getCell(l + o2), u.value = c.value, u.style = c.style, u._comment = c._comment) : this._cells[l + o2 - 1] = void 0;
            for (l = 0; l < i2.length; l++) u = this.getCell(e2 + l), u.value = i2[l], u.style = {}, u._comment = void 0;
          }
          eachCell(e2, t3) {
            if (t3 || (t3 = e2, e2 = null), e2 && e2.includeEmpty) {
              const e3 = this._cells.length;
              for (let r2 = 1; r2 <= e3; r2++) t3(this.getCell(r2), r2);
            } else this._cells.forEach((e3, r2) => {
              e3 && e3.type !== i.ValueType.Null && t3(e3, r2 + 1);
            });
          }
          addPageBreak(e2, t3) {
            const r2 = this._worksheet, n2 = Math.max(0, e2 - 1) || 0, i2 = Math.max(0, t3 - 1) || 16838, s2 = { id: this._number, max: i2, man: 1 };
            n2 && (s2.min = n2), r2.rowBreaks.push(s2);
          }
          get values() {
            const e2 = [];
            return this._cells.forEach((t3) => {
              t3 && t3.type !== i.ValueType.Null && (e2[t3.col] = t3.value);
            }), e2;
          }
          set values(e2) {
            if (this._cells = [], e2) if (e2 instanceof Array) {
              let t3 = 0;
              e2.hasOwnProperty("0") && (t3 = 1), e2.forEach((e3, r2) => {
                void 0 !== e3 && (this.getCellEx({ address: s.encodeAddress(this._number, r2 + t3), row: this._number, col: r2 + t3 }).value = e3);
              });
            } else this._worksheet.eachColumnKey((t3, r2) => {
              void 0 !== e2[r2] && (this.getCellEx({ address: s.encodeAddress(this._number, t3.number), row: this._number, col: t3.number }).value = e2[r2]);
            });
          }
          get hasValues() {
            return n.some(this._cells, (e2) => e2 && e2.type !== i.ValueType.Null);
          }
          get cellCount() {
            return this._cells.length;
          }
          get actualCellCount() {
            let e2 = 0;
            return this.eachCell(() => {
              e2++;
            }), e2;
          }
          get dimensions() {
            let e2 = 0, t3 = 0;
            return this._cells.forEach((r2) => {
              r2 && r2.type !== i.ValueType.Null && ((!e2 || e2 > r2.col) && (e2 = r2.col), t3 < r2.col && (t3 = r2.col));
            }), e2 > 0 ? { min: e2, max: t3 } : null;
          }
          _applyStyle(e2, t3) {
            return this.style[e2] = t3, this._cells.forEach((r2) => {
              r2 && (r2[e2] = t3);
            }), t3;
          }
          get numFmt() {
            return this.style.numFmt;
          }
          set numFmt(e2) {
            this._applyStyle("numFmt", e2);
          }
          get font() {
            return this.style.font;
          }
          set font(e2) {
            this._applyStyle("font", e2);
          }
          get alignment() {
            return this.style.alignment;
          }
          set alignment(e2) {
            this._applyStyle("alignment", e2);
          }
          get protection() {
            return this.style.protection;
          }
          set protection(e2) {
            this._applyStyle("protection", e2);
          }
          get border() {
            return this.style.border;
          }
          set border(e2) {
            this._applyStyle("border", e2);
          }
          get fill() {
            return this.style.fill;
          }
          set fill(e2) {
            this._applyStyle("fill", e2);
          }
          get hidden() {
            return !!this._hidden;
          }
          set hidden(e2) {
            this._hidden = e2;
          }
          get outlineLevel() {
            return this._outlineLevel || 0;
          }
          set outlineLevel(e2) {
            this._outlineLevel = e2;
          }
          get collapsed() {
            return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
          }
          get model() {
            const e2 = [];
            let t3 = 0, r2 = 0;
            return this._cells.forEach((n2) => {
              if (n2) {
                const i2 = n2.model;
                i2 && ((!t3 || t3 > n2.col) && (t3 = n2.col), r2 < n2.col && (r2 = n2.col), e2.push(i2));
              }
            }), this.height || e2.length ? { cells: e2, number: this.number, min: t3, max: r2, height: this.height, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel, collapsed: this.collapsed } : null;
          }
          set model(e2) {
            if (e2.number !== this._number) throw new Error("Invalid row number in model");
            let t3;
            this._cells = [], e2.cells.forEach((e3) => {
              switch (e3.type) {
                case o.Types.Merge:
                  break;
                default: {
                  let r2;
                  if (e3.address) r2 = s.decodeAddress(e3.address);
                  else if (t3) {
                    const { row: e4 } = t3, n2 = t3.col + 1;
                    r2 = { row: e4, col: n2, address: s.encodeAddress(e4, n2), $col$row: `$${s.n2l(n2)}$${e4}` };
                  }
                  t3 = r2;
                  this.getCellEx(r2).model = e3;
                  break;
                }
              }
            }), e2.height ? this.height = e2.height : delete this.height, this.hidden = e2.hidden, this.outlineLevel = e2.outlineLevel || 0, this.style = e2.style && JSON.parse(JSON.stringify(e2.style)) || {};
          }
        };
      }, { "../utils/col-cache": 19, "../utils/under-dash": 26, "./cell": 3, "./enums": 7 }], 12: [function(e, t2, r) {
        const n = e("../utils/col-cache");
        class i {
          constructor(e2, t3, r2) {
            this.table = e2, this.column = t3, this.index = r2;
          }
          _set(e2, t3) {
            this.table.cacheState(), this.column[e2] = t3;
          }
          get name() {
            return this.column.name;
          }
          set name(e2) {
            this._set("name", e2);
          }
          get filterButton() {
            return this.column.filterButton;
          }
          set filterButton(e2) {
            this.column.filterButton = e2;
          }
          get style() {
            return this.column.style;
          }
          set style(e2) {
            this.column.style = e2;
          }
          get totalsRowLabel() {
            return this.column.totalsRowLabel;
          }
          set totalsRowLabel(e2) {
            this._set("totalsRowLabel", e2);
          }
          get totalsRowFunction() {
            return this.column.totalsRowFunction;
          }
          set totalsRowFunction(e2) {
            this._set("totalsRowFunction", e2);
          }
          get totalsRowResult() {
            return this.column.totalsRowResult;
          }
          set totalsRowResult(e2) {
            this._set("totalsRowResult", e2);
          }
          get totalsRowFormula() {
            return this.column.totalsRowFormula;
          }
          set totalsRowFormula(e2) {
            this._set("totalsRowFormula", e2);
          }
        }
        t2.exports = class {
          constructor(e2, t3) {
            this.worksheet = e2, t3 && (this.table = t3, this.validate(), this.store());
          }
          getFormula(e2) {
            switch (e2.totalsRowFunction) {
              case "none":
                return null;
              case "average":
                return `SUBTOTAL(101,${this.table.name}[${e2.name}])`;
              case "countNums":
                return `SUBTOTAL(102,${this.table.name}[${e2.name}])`;
              case "count":
                return `SUBTOTAL(103,${this.table.name}[${e2.name}])`;
              case "max":
                return `SUBTOTAL(104,${this.table.name}[${e2.name}])`;
              case "min":
                return `SUBTOTAL(105,${this.table.name}[${e2.name}])`;
              case "stdDev":
                return `SUBTOTAL(106,${this.table.name}[${e2.name}])`;
              case "var":
                return `SUBTOTAL(107,${this.table.name}[${e2.name}])`;
              case "sum":
                return `SUBTOTAL(109,${this.table.name}[${e2.name}])`;
              case "custom":
                return e2.totalsRowFormula;
              default:
                throw new Error("Invalid Totals Row Function: " + e2.totalsRowFunction);
            }
          }
          get width() {
            return this.table.columns.length;
          }
          get height() {
            return this.table.rows.length;
          }
          get filterHeight() {
            return this.height + (this.table.headerRow ? 1 : 0);
          }
          get tableHeight() {
            return this.filterHeight + (this.table.totalsRow ? 1 : 0);
          }
          validate() {
            const { table: e2 } = this, t3 = (e3, t4, r3) => {
              void 0 === e3[t4] && (e3[t4] = r3);
            };
            t3(e2, "headerRow", true), t3(e2, "totalsRow", false), t3(e2, "style", {}), t3(e2.style, "theme", "TableStyleMedium2"), t3(e2.style, "showFirstColumn", false), t3(e2.style, "showLastColumn", false), t3(e2.style, "showRowStripes", false), t3(e2.style, "showColumnStripes", false);
            const r2 = (e3, t4) => {
              if (!e3) throw new Error(t4);
            };
            r2(e2.ref, "Table must have ref"), r2(e2.columns, "Table must have column definitions"), r2(e2.rows, "Table must have row definitions"), e2.tl = n.decodeAddress(e2.ref);
            const { row: i2, col: s } = e2.tl;
            r2(i2 > 0, "Table must be on valid row"), r2(s > 0, "Table must be on valid col");
            const { width: o, filterHeight: a, tableHeight: l } = this;
            e2.autoFilterRef = n.encode(i2, s, i2 + a - 1, s + o - 1), e2.tableRef = n.encode(i2, s, i2 + l - 1, s + o - 1), e2.columns.forEach((e3, n2) => {
              r2(e3.name, `Column ${n2} must have a name`), 0 === n2 ? t3(e3, "totalsRowLabel", "Total") : (t3(e3, "totalsRowFunction", "none"), e3.totalsRowFormula = this.getFormula(e3));
            });
          }
          store() {
            const e2 = (e3, t4) => {
              t4 && Object.keys(t4).forEach((r3) => {
                e3[r3] = t4[r3];
              });
            }, { worksheet: t3, table: r2 } = this, { row: n2, col: i2 } = r2.tl;
            let s = 0;
            if (r2.headerRow) {
              const o = t3.getRow(n2 + s++);
              r2.columns.forEach((t4, r3) => {
                const { style: n3, name: s2 } = t4, a = o.getCell(i2 + r3);
                a.value = s2, e2(a, n3);
              });
            }
            if (r2.rows.forEach((o) => {
              const a = t3.getRow(n2 + s++);
              o.forEach((t4, n3) => {
                const s2 = a.getCell(i2 + n3);
                s2.value = t4, e2(s2, r2.columns[n3].style);
              });
            }), r2.totalsRow) {
              const o = t3.getRow(n2 + s++);
              r2.columns.forEach((t4, r3) => {
                const n3 = o.getCell(i2 + r3);
                if (0 === r3) n3.value = t4.totalsRowLabel;
                else {
                  const e3 = this.getFormula(t4);
                  n3.value = e3 ? { formula: t4.totalsRowFormula, result: t4.totalsRowResult } : null;
                }
                e2(n3, t4.style);
              });
            }
          }
          load(e2) {
            const { table: t3 } = this, { row: r2, col: n2 } = t3.tl;
            let i2 = 0;
            if (t3.headerRow) {
              const s = e2.getRow(r2 + i2++);
              t3.columns.forEach((e3, t4) => {
                s.getCell(n2 + t4).value = e3.name;
              });
            }
            if (t3.rows.forEach((t4) => {
              const s = e2.getRow(r2 + i2++);
              t4.forEach((e3, t5) => {
                s.getCell(n2 + t5).value = e3;
              });
            }), t3.totalsRow) {
              const s = e2.getRow(r2 + i2++);
              t3.columns.forEach((e3, t4) => {
                const r3 = s.getCell(n2 + t4);
                if (0 === t4) r3.value = e3.totalsRowLabel;
                else {
                  this.getFormula(e3) && (r3.value = { formula: e3.totalsRowFormula, result: e3.totalsRowResult });
                }
              });
            }
          }
          get model() {
            return this.table;
          }
          set model(e2) {
            this.table = e2;
          }
          cacheState() {
            this._cache || (this._cache = { ref: this.ref, width: this.width, tableHeight: this.tableHeight });
          }
          commit() {
            if (!this._cache) return;
            this.validate();
            const e2 = n.decodeAddress(this._cache.ref);
            if (this.ref !== this._cache.ref) for (let t3 = 0; t3 < this._cache.tableHeight; t3++) {
              const r2 = this.worksheet.getRow(e2.row + t3);
              for (let t4 = 0; t4 < this._cache.width; t4++) {
                r2.getCell(e2.col + t4).value = null;
              }
            }
            else {
              for (let t3 = this.tableHeight; t3 < this._cache.tableHeight; t3++) {
                const r2 = this.worksheet.getRow(e2.row + t3);
                for (let t4 = 0; t4 < this._cache.width; t4++) {
                  r2.getCell(e2.col + t4).value = null;
                }
              }
              for (let t3 = 0; t3 < this.tableHeight; t3++) {
                const r2 = this.worksheet.getRow(e2.row + t3);
                for (let t4 = this.width; t4 < this._cache.width; t4++) {
                  r2.getCell(e2.col + t4).value = null;
                }
              }
            }
            this.store();
          }
          addRow(e2, t3) {
            this.cacheState(), void 0 === t3 ? this.table.rows.push(e2) : this.table.rows.splice(t3, 0, e2);
          }
          removeRows(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            this.cacheState(), this.table.rows.splice(e2, t3);
          }
          getColumn(e2) {
            const t3 = this.table.columns[e2];
            return new i(this, t3, e2);
          }
          addColumn(e2, t3, r2) {
            this.cacheState(), void 0 === r2 ? (this.table.columns.push(e2), this.table.rows.forEach((e3, r3) => {
              e3.push(t3[r3]);
            })) : (this.table.columns.splice(r2, 0, e2), this.table.rows.forEach((e3, n2) => {
              e3.splice(r2, 0, t3[n2]);
            }));
          }
          removeColumns(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            this.cacheState(), this.table.columns.splice(e2, t3), this.table.rows.forEach((r2) => {
              r2.splice(e2, t3);
            });
          }
          _assign(e2, t3, r2) {
            this.cacheState(), e2[t3] = r2;
          }
          get ref() {
            return this.table.ref;
          }
          set ref(e2) {
            this._assign(this.table, "ref", e2);
          }
          get name() {
            return this.table.name;
          }
          set name(e2) {
            this.table.name = e2;
          }
          get displayName() {
            return this.table.displyName || this.table.name;
          }
          set displayNamename(e2) {
            this.table.displayName = e2;
          }
          get headerRow() {
            return this.table.headerRow;
          }
          set headerRow(e2) {
            this._assign(this.table, "headerRow", e2);
          }
          get totalsRow() {
            return this.table.totalsRow;
          }
          set totalsRow(e2) {
            this._assign(this.table, "totalsRow", e2);
          }
          get theme() {
            return this.table.style.name;
          }
          set theme(e2) {
            this.table.style.name = e2;
          }
          get showFirstColumn() {
            return this.table.style.showFirstColumn;
          }
          set showFirstColumn(e2) {
            this.table.style.showFirstColumn = e2;
          }
          get showLastColumn() {
            return this.table.style.showLastColumn;
          }
          set showLastColumn(e2) {
            this.table.style.showLastColumn = e2;
          }
          get showRowStripes() {
            return this.table.style.showRowStripes;
          }
          set showRowStripes(e2) {
            this.table.style.showRowStripes = e2;
          }
          get showColumnStripes() {
            return this.table.style.showColumnStripes;
          }
          set showColumnStripes(e2) {
            this.table.style.showColumnStripes = e2;
          }
        };
      }, { "../utils/col-cache": 19 }], 13: [function(e, t2, r) {
        const n = e("./worksheet"), i = e("./defined-names"), s = e("../xlsx/xlsx"), o = e("../csv/csv");
        t2.exports = class {
          constructor() {
            this.category = "", this.company = "", this.created = /* @__PURE__ */ new Date(), this.description = "", this.keywords = "", this.manager = "", this.modified = this.created, this.properties = {}, this.calcProperties = {}, this._worksheets = [], this.subject = "", this.title = "", this.views = [], this.media = [], this._definedNames = new i();
          }
          get xlsx() {
            return this._xlsx || (this._xlsx = new s(this)), this._xlsx;
          }
          get csv() {
            return this._csv || (this._csv = new o(this)), this._csv;
          }
          get nextId() {
            for (let e2 = 1; e2 < this._worksheets.length; e2++) if (!this._worksheets[e2]) return e2;
            return this._worksheets.length || 1;
          }
          addWorksheet(e2, t3) {
            const r2 = this.nextId;
            t3 && ("string" == typeof t3 ? (console.trace('tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'), t3 = { properties: { tabColor: { argb: t3 } } }) : (t3.argb || t3.theme || t3.indexed) && (console.trace("tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }"), t3 = { properties: { tabColor: t3 } }));
            const i2 = this._worksheets.reduce((e3, t4) => (t4 && t4.orderNo) > e3 ? t4.orderNo : e3, 0), s2 = Object.assign({}, t3, { id: r2, name: e2, orderNo: i2 + 1, workbook: this }), o2 = new n(s2);
            return this._worksheets[r2] = o2, o2;
          }
          removeWorksheetEx(e2) {
            delete this._worksheets[e2.id];
          }
          removeWorksheet(e2) {
            const t3 = this.getWorksheet(e2);
            t3 && t3.destroy();
          }
          getWorksheet(e2) {
            return void 0 === e2 ? this._worksheets.find(Boolean) : "number" == typeof e2 ? this._worksheets[e2] : "string" == typeof e2 ? this._worksheets.find((t3) => t3 && t3.name === e2) : void 0;
          }
          get worksheets() {
            return this._worksheets.slice(1).sort((e2, t3) => e2.orderNo - t3.orderNo).filter(Boolean);
          }
          eachSheet(e2) {
            this.worksheets.forEach((t3) => {
              e2(t3, t3.id);
            });
          }
          get definedNames() {
            return this._definedNames;
          }
          clearThemes() {
            this._themes = void 0;
          }
          addImage(e2) {
            const t3 = this.media.length;
            return this.media.push(Object.assign({}, e2, { type: "image" })), t3;
          }
          getImage(e2) {
            return this.media[e2];
          }
          get model() {
            return { creator: this.creator || "Unknown", lastModifiedBy: this.lastModifiedBy || "Unknown", lastPrinted: this.lastPrinted, created: this.created, modified: this.modified, properties: this.properties, worksheets: this.worksheets.map((e2) => e2.model), sheets: this.worksheets.map((e2) => e2.model).filter(Boolean), definedNames: this._definedNames.model, views: this.views, company: this.company, manager: this.manager, title: this.title, subject: this.subject, keywords: this.keywords, category: this.category, description: this.description, language: this.language, revision: this.revision, contentStatus: this.contentStatus, themes: this._themes, media: this.media, calcProperties: this.calcProperties };
          }
          set model(e2) {
            this.creator = e2.creator, this.lastModifiedBy = e2.lastModifiedBy, this.lastPrinted = e2.lastPrinted, this.created = e2.created, this.modified = e2.modified, this.company = e2.company, this.manager = e2.manager, this.title = e2.title, this.subject = e2.subject, this.keywords = e2.keywords, this.category = e2.category, this.description = e2.description, this.language = e2.language, this.revision = e2.revision, this.contentStatus = e2.contentStatus, this.properties = e2.properties, this.calcProperties = e2.calcProperties, this._worksheets = [], e2.worksheets.forEach((t3) => {
              const { id: r2, name: i2, state: s2 } = t3, o2 = e2.sheets && e2.sheets.findIndex((e3) => e3.id === r2);
              (this._worksheets[r2] = new n({ id: r2, name: i2, orderNo: o2, state: s2, workbook: this })).model = t3;
            }), this._definedNames.model = e2.definedNames, this.views = e2.views, this._themes = e2.themes, this.media = e2.media || [];
          }
        };
      }, { "../csv/csv": 1, "../xlsx/xlsx": 144, "./defined-names": 6, "./worksheet": 14 }], 14: [function(e, t2, r) {
        const n = e("../utils/under-dash"), i = e("../utils/col-cache"), s = e("./range"), o = e("./row"), a = e("./column"), l = e("./enums"), c = e("./image"), u = e("./table"), h = e("./data-validations"), f = e("../utils/encryptor"), { copyStyle: d } = e("../utils/copy-style");
        t2.exports = class {
          constructor(e2) {
            e2 = e2 || {}, this._workbook = e2.workbook, this.id = e2.id, this.orderNo = e2.orderNo, this.name = e2.name, this.state = e2.state || "visible", this._rows = [], this._columns = null, this._keys = {}, this._merges = {}, this.rowBreaks = [], this.properties = Object.assign({}, { defaultRowHeight: 15, dyDescent: 55, outlineLevelCol: 0, outlineLevelRow: 0 }, e2.properties), this.pageSetup = Object.assign({}, { margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }, orientation: "portrait", horizontalDpi: 4294967295, verticalDpi: 4294967295, fitToPage: !(!e2.pageSetup || !e2.pageSetup.fitToWidth && !e2.pageSetup.fitToHeight || e2.pageSetup.scale), pageOrder: "downThenOver", blackAndWhite: false, draft: false, cellComments: "None", errors: "displayed", scale: 100, fitToWidth: 1, fitToHeight: 1, paperSize: void 0, showRowColHeaders: false, showGridLines: false, firstPageNumber: void 0, horizontalCentered: false, verticalCentered: false, rowBreaks: null, colBreaks: null }, e2.pageSetup), this.headerFooter = Object.assign({}, { differentFirst: false, differentOddEven: false, oddHeader: null, oddFooter: null, evenHeader: null, evenFooter: null, firstHeader: null, firstFooter: null }, e2.headerFooter), this.dataValidations = new h(), this.views = e2.views || [], this.autoFilter = e2.autoFilter || null, this._media = [], this.sheetProtection = null, this.tables = {}, this.conditionalFormattings = [];
          }
          get name() {
            return this._name;
          }
          set name(e2) {
            if (void 0 === e2 && (e2 = "sheet" + this.id), this._name !== e2) {
              if ("string" != typeof e2) throw new Error("The name has to be a string.");
              if ("" === e2) throw new Error("The name can't be empty.");
              if ("History" === e2) throw new Error('The name "History" is protected. Please use a different name.');
              if (/[*?:/\\[\]]/.test(e2)) throw new Error(`Worksheet name ${e2} cannot include any of the following characters: * ? : \\ / [ ]`);
              if (/(^')|('$)/.test(e2)) throw new Error("The first or last character of worksheet name cannot be a single quotation mark: " + e2);
              if (e2 && e2.length > 31 && (console.warn(`Worksheet name ${e2} exceeds 31 chars. This will be truncated`), e2 = e2.substring(0, 31)), this._workbook._worksheets.find((t3) => t3 && t3.name.toLowerCase() === e2.toLowerCase())) throw new Error("Worksheet name already exists: " + e2);
              this._name = e2;
            }
          }
          get workbook() {
            return this._workbook;
          }
          destroy() {
            this._workbook.removeWorksheetEx(this);
          }
          get dimensions() {
            const e2 = new s();
            return this._rows.forEach((t3) => {
              if (t3) {
                const r2 = t3.dimensions;
                r2 && e2.expand(t3.number, r2.min, t3.number, r2.max);
              }
            }), e2;
          }
          get columns() {
            return this._columns;
          }
          set columns(e2) {
            this._headerRowCount = e2.reduce((e3, t4) => {
              const r3 = (t4.header ? 1 : t4.headers && t4.headers.length) || 0;
              return Math.max(e3, r3);
            }, 0);
            let t3 = 1;
            const r2 = this._columns = [];
            e2.forEach((e3) => {
              const n2 = new a(this, t3++, false);
              r2.push(n2), n2.defn = e3;
            });
          }
          getColumnKey(e2) {
            return this._keys[e2];
          }
          setColumnKey(e2, t3) {
            this._keys[e2] = t3;
          }
          deleteColumnKey(e2) {
            delete this._keys[e2];
          }
          eachColumnKey(e2) {
            n.each(this._keys, e2);
          }
          getColumn(e2) {
            if ("string" == typeof e2) {
              const t3 = this._keys[e2];
              if (t3) return t3;
              e2 = i.l2n(e2);
            }
            if (this._columns || (this._columns = []), e2 > this._columns.length) {
              let t3 = this._columns.length + 1;
              for (; t3 <= e2; ) this._columns.push(new a(this, t3++));
            }
            return this._columns[e2 - 1];
          }
          spliceColumns(e2, t3) {
            const r2 = this._rows.length;
            for (var n2 = arguments.length, i2 = new Array(n2 > 2 ? n2 - 2 : 0), s2 = 2; s2 < n2; s2++) i2[s2 - 2] = arguments[s2];
            if (i2.length > 0) for (let n3 = 0; n3 < r2; n3++) {
              const r3 = [e2, t3];
              i2.forEach((e3) => {
                r3.push(e3[n3] || null);
              });
              const s3 = this.getRow(n3 + 1);
              s3.splice.apply(s3, r3);
            }
            else this._rows.forEach((r3) => {
              r3 && r3.splice(e2, t3);
            });
            const o2 = i2.length - t3, a2 = e2 + t3, l2 = this._columns.length;
            if (o2 < 0) for (let t4 = e2 + i2.length; t4 <= l2; t4++) this.getColumn(t4).defn = this.getColumn(t4 - o2).defn;
            else if (o2 > 0) for (let e3 = l2; e3 >= a2; e3--) this.getColumn(e3 + o2).defn = this.getColumn(e3).defn;
            for (let t4 = e2; t4 < e2 + i2.length; t4++) this.getColumn(t4).defn = null;
            this.workbook.definedNames.spliceColumns(this.name, e2, t3, i2.length);
          }
          get lastColumn() {
            return this.getColumn(this.columnCount);
          }
          get columnCount() {
            let e2 = 0;
            return this.eachRow((t3) => {
              e2 = Math.max(e2, t3.cellCount);
            }), e2;
          }
          get actualColumnCount() {
            const e2 = [];
            let t3 = 0;
            return this.eachRow((r2) => {
              r2.eachCell((r3) => {
                let { col: n2 } = r3;
                e2[n2] || (e2[n2] = true, t3++);
              });
            }), t3;
          }
          _commitRow() {
          }
          get _lastRowNumber() {
            const e2 = this._rows;
            let t3 = e2.length;
            for (; t3 > 0 && void 0 === e2[t3 - 1]; ) t3--;
            return t3;
          }
          get _nextRow() {
            return this._lastRowNumber + 1;
          }
          get lastRow() {
            if (this._rows.length) return this._rows[this._rows.length - 1];
          }
          findRow(e2) {
            return this._rows[e2 - 1];
          }
          findRows(e2, t3) {
            return this._rows.slice(e2 - 1, e2 - 1 + t3);
          }
          get rowCount() {
            return this._lastRowNumber;
          }
          get actualRowCount() {
            let e2 = 0;
            return this.eachRow(() => {
              e2++;
            }), e2;
          }
          getRow(e2) {
            let t3 = this._rows[e2 - 1];
            return t3 || (t3 = this._rows[e2 - 1] = new o(this, e2)), t3;
          }
          getRows(e2, t3) {
            if (t3 < 1) return;
            const r2 = [];
            for (let n2 = e2; n2 < e2 + t3; n2++) r2.push(this.getRow(n2));
            return r2;
          }
          addRow(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "n";
            const r2 = this._nextRow, n2 = this.getRow(r2);
            return n2.values = e2, this._setStyleOption(r2, "i" === t3[0] ? t3 : "n"), n2;
          }
          addRows(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "n";
            const r2 = [];
            return e2.forEach((e3) => {
              r2.push(this.addRow(e3, t3));
            }), r2;
          }
          insertRow(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "n";
            return this.spliceRows(e2, 0, t3), this._setStyleOption(e2, r2), this.getRow(e2);
          }
          insertRows(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "n";
            if (this.spliceRows(e2, 0, ...t3), "n" !== r2) for (let n2 = 0; n2 < t3.length; n2++) "o" === r2[0] && void 0 !== this.findRow(t3.length + e2 + n2) ? this._copyStyle(t3.length + e2 + n2, e2 + n2, "+" === r2[1]) : "i" === r2[0] && void 0 !== this.findRow(e2 - 1) && this._copyStyle(e2 - 1, e2 + n2, "+" === r2[1]);
            return this.getRows(e2, t3.length);
          }
          _setStyleOption(e2) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "n";
            "o" === t3[0] && void 0 !== this.findRow(e2 + 1) ? this._copyStyle(e2 + 1, e2, "+" === t3[1]) : "i" === t3[0] && void 0 !== this.findRow(e2 - 1) && this._copyStyle(e2 - 1, e2, "+" === t3[1]);
          }
          _copyStyle(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const n2 = this.getRow(e2), i2 = this.getRow(t3);
            i2.style = d(n2.style), n2.eachCell({ includeEmpty: r2 }, (e3, t4) => {
              i2.getCell(t4).style = d(e3.style);
            }), i2.height = n2.height;
          }
          duplicateRow(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const n2 = this._rows[e2 - 1], i2 = new Array(t3).fill(n2.values);
            this.spliceRows(e2 + 1, r2 ? 0 : t3, ...i2);
            for (let r3 = 0; r3 < t3; r3++) {
              const t4 = this._rows[e2 + r3];
              t4.style = n2.style, t4.height = n2.height, n2.eachCell({ includeEmpty: true }, (e3, r4) => {
                t4.getCell(r4).style = e3.style;
              });
            }
          }
          spliceRows(e2, t3) {
            const r2 = e2 + t3;
            for (var n2 = arguments.length, i2 = new Array(n2 > 2 ? n2 - 2 : 0), s2 = 2; s2 < n2; s2++) i2[s2 - 2] = arguments[s2];
            const o2 = i2.length, a2 = o2 - t3, l2 = this._rows.length;
            let c2, u2;
            if (a2 < 0) for (e2 === l2 && (this._rows[l2 - 1] = void 0), c2 = r2; c2 <= l2; c2++) if (u2 = this._rows[c2 - 1], u2) {
              const e3 = this.getRow(c2 + a2);
              e3.values = u2.values, e3.style = u2.style, e3.height = u2.height, u2.eachCell({ includeEmpty: true }, (t4, r3) => {
                e3.getCell(r3).style = t4.style;
              }), this._rows[c2 - 1] = void 0;
            } else this._rows[c2 + a2 - 1] = void 0;
            else if (a2 > 0) for (c2 = l2; c2 >= r2; c2--) if (u2 = this._rows[c2 - 1], u2) {
              const e3 = this.getRow(c2 + a2);
              e3.values = u2.values, e3.style = u2.style, e3.height = u2.height, u2.eachCell({ includeEmpty: true }, (t4, r3) => {
                if (e3.getCell(r3).style = t4.style, "MergeValue" === t4._value.constructor.name) {
                  const e4 = this.getRow(t4._row._number + o2).getCell(r3), n3 = t4._value._master, i3 = this.getRow(n3._row._number + o2).getCell(n3._column._number);
                  e4.merge(i3);
                }
              });
            } else this._rows[c2 + a2 - 1] = void 0;
            for (c2 = 0; c2 < o2; c2++) {
              const t4 = this.getRow(e2 + c2);
              t4.style = {}, t4.values = i2[c2];
            }
            this.workbook.definedNames.spliceRows(this.name, e2, t3, o2);
          }
          eachRow(e2, t3) {
            if (t3 || (t3 = e2, e2 = void 0), e2 && e2.includeEmpty) {
              const e3 = this._rows.length;
              for (let r2 = 1; r2 <= e3; r2++) t3(this.getRow(r2), r2);
            } else this._rows.forEach((e3) => {
              e3 && e3.hasValues && t3(e3, e3.number);
            });
          }
          getSheetValues() {
            const e2 = [];
            return this._rows.forEach((t3) => {
              t3 && (e2[t3.number] = t3.values);
            }), e2;
          }
          findCell(e2, t3) {
            const r2 = i.getAddress(e2, t3), n2 = this._rows[r2.row - 1];
            return n2 ? n2.findCell(r2.col) : void 0;
          }
          getCell(e2, t3) {
            const r2 = i.getAddress(e2, t3);
            return this.getRow(r2.row).getCellEx(r2);
          }
          mergeCells() {
            for (var e2 = arguments.length, t3 = new Array(e2), r2 = 0; r2 < e2; r2++) t3[r2] = arguments[r2];
            const n2 = new s(t3);
            this._mergeCellsInternal(n2);
          }
          mergeCellsWithoutStyle() {
            for (var e2 = arguments.length, t3 = new Array(e2), r2 = 0; r2 < e2; r2++) t3[r2] = arguments[r2];
            const n2 = new s(t3);
            this._mergeCellsInternal(n2, true);
          }
          _mergeCellsInternal(e2, t3) {
            n.each(this._merges, (t4) => {
              if (t4.intersects(e2)) throw new Error("Cannot merge already merged cells");
            });
            const r2 = this.getCell(e2.top, e2.left);
            for (let n2 = e2.top; n2 <= e2.bottom; n2++) for (let i2 = e2.left; i2 <= e2.right; i2++) (n2 > e2.top || i2 > e2.left) && this.getCell(n2, i2).merge(r2, t3);
            this._merges[r2.address] = e2;
          }
          _unMergeMaster(e2) {
            const t3 = this._merges[e2.address];
            if (t3) {
              for (let e3 = t3.top; e3 <= t3.bottom; e3++) for (let r2 = t3.left; r2 <= t3.right; r2++) this.getCell(e3, r2).unmerge();
              delete this._merges[e2.address];
            }
          }
          get hasMerges() {
            return n.some(this._merges, Boolean);
          }
          unMergeCells() {
            for (var e2 = arguments.length, t3 = new Array(e2), r2 = 0; r2 < e2; r2++) t3[r2] = arguments[r2];
            const n2 = new s(t3);
            for (let e3 = n2.top; e3 <= n2.bottom; e3++) for (let t4 = n2.left; t4 <= n2.right; t4++) {
              const r3 = this.findCell(e3, t4);
              r3 && (r3.type === l.ValueType.Merge ? this._unMergeMaster(r3.master) : this._merges[r3.address] && this._unMergeMaster(r3));
            }
          }
          fillFormula(e2, t3, r2) {
            let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "shared";
            const s2 = i.decode(e2), { top: o2, left: a2, bottom: l2, right: c2 } = s2, u2 = c2 - a2 + 1, h2 = i.encodeAddress(o2, a2), f2 = "shared" === n2;
            let d2;
            d2 = "function" == typeof r2 ? r2 : Array.isArray(r2) ? Array.isArray(r2[0]) ? (e3, t4) => r2[e3 - o2][t4 - a2] : (e3, t4) => r2[(e3 - o2) * u2 + (t4 - a2)] : () => {
            };
            let p = true;
            for (let r3 = o2; r3 <= l2; r3++) for (let i2 = a2; i2 <= c2; i2++) p ? (this.getCell(r3, i2).value = { shareType: n2, formula: t3, ref: e2, result: d2(r3, i2) }, p = false) : this.getCell(r3, i2).value = f2 ? { sharedFormula: h2, result: d2(r3, i2) } : d2(r3, i2);
          }
          addImage(e2, t3) {
            const r2 = { type: "image", imageId: e2, range: t3 };
            this._media.push(new c(this, r2));
          }
          getImages() {
            return this._media.filter((e2) => "image" === e2.type);
          }
          addBackgroundImage(e2) {
            const t3 = { type: "background", imageId: e2 };
            this._media.push(new c(this, t3));
          }
          getBackgroundImageId() {
            const e2 = this._media.find((e3) => "background" === e3.type);
            return e2 && e2.imageId;
          }
          protect(e2, t3) {
            return new Promise((r2) => {
              this.sheetProtection = { sheet: true }, t3 && "spinCount" in t3 && (t3.spinCount = Number.isFinite(t3.spinCount) ? Math.round(Math.max(0, t3.spinCount)) : 1e5), e2 && (this.sheetProtection.algorithmName = "SHA-512", this.sheetProtection.saltValue = f.randomBytes(16).toString("base64"), this.sheetProtection.spinCount = t3 && "spinCount" in t3 ? t3.spinCount : 1e5, this.sheetProtection.hashValue = f.convertPasswordToHash(e2, "SHA512", this.sheetProtection.saltValue, this.sheetProtection.spinCount)), t3 && (this.sheetProtection = Object.assign(this.sheetProtection, t3), !e2 && "spinCount" in t3 && delete this.sheetProtection.spinCount), r2();
            });
          }
          unprotect() {
            this.sheetProtection = null;
          }
          addTable(e2) {
            const t3 = new u(this, e2);
            return this.tables[e2.name] = t3, t3;
          }
          getTable(e2) {
            return this.tables[e2];
          }
          removeTable(e2) {
            delete this.tables[e2];
          }
          getTables() {
            return Object.values(this.tables);
          }
          addConditionalFormatting(e2) {
            this.conditionalFormattings.push(e2);
          }
          removeConditionalFormatting(e2) {
            "number" == typeof e2 ? this.conditionalFormattings.splice(e2, 1) : this.conditionalFormattings = e2 instanceof Function ? this.conditionalFormattings.filter(e2) : [];
          }
          get tabColor() {
            return console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor"), this.properties.tabColor;
          }
          set tabColor(e2) {
            console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor"), this.properties.tabColor = e2;
          }
          get model() {
            const e2 = { id: this.id, name: this.name, dataValidations: this.dataValidations.model, properties: this.properties, state: this.state, pageSetup: this.pageSetup, headerFooter: this.headerFooter, rowBreaks: this.rowBreaks, views: this.views, autoFilter: this.autoFilter, media: this._media.map((e3) => e3.model), sheetProtection: this.sheetProtection, tables: Object.values(this.tables).map((e3) => e3.model), conditionalFormattings: this.conditionalFormattings };
            e2.cols = a.toModel(this.columns);
            const t3 = e2.rows = [], r2 = e2.dimensions = new s();
            return this._rows.forEach((e3) => {
              const n2 = e3 && e3.model;
              n2 && (r2.expand(n2.number, n2.min, n2.number, n2.max), t3.push(n2));
            }), e2.merges = [], n.each(this._merges, (t4) => {
              e2.merges.push(t4.range);
            }), e2;
          }
          _parseRows(e2) {
            this._rows = [], e2.rows.forEach((e3) => {
              const t3 = new o(this, e3.number);
              this._rows[t3.number - 1] = t3, t3.model = e3;
            });
          }
          _parseMergeCells(e2) {
            n.each(e2.mergeCells, (e3) => {
              this.mergeCellsWithoutStyle(e3);
            });
          }
          set model(e2) {
            this.name = e2.name, this._columns = a.fromModel(this, e2.cols), this._parseRows(e2), this._parseMergeCells(e2), this.dataValidations = new h(e2.dataValidations), this.properties = e2.properties, this.pageSetup = e2.pageSetup, this.headerFooter = e2.headerFooter, this.views = e2.views, this.autoFilter = e2.autoFilter, this._media = e2.media.map((e3) => new c(this, e3)), this.sheetProtection = e2.sheetProtection, this.tables = e2.tables.reduce((e3, t3) => {
              const r2 = new u();
              return r2.model = t3, e3[t3.name] = r2, e3;
            }, {}), this.conditionalFormattings = e2.conditionalFormattings;
          }
        };
      }, { "../utils/col-cache": 19, "../utils/copy-style": 20, "../utils/encryptor": 21, "../utils/under-dash": 26, "./column": 4, "./data-validations": 5, "./enums": 7, "./image": 8, "./range": 10, "./row": 11, "./table": 12 }], 15: [function(e, t2, r) {
        e("core-js/modules/es.promise"), e("core-js/modules/es.promise.finally"), e("core-js/modules/es.object.assign"), e("core-js/modules/es.object.keys"), e("core-js/modules/es.object.values"), e("core-js/modules/es.symbol"), e("core-js/modules/es.symbol.async-iterator"), e("core-js/modules/es.array.iterator"), e("core-js/modules/es.array.includes"), e("core-js/modules/es.array.find-index"), e("core-js/modules/es.array.find"), e("core-js/modules/es.string.from-code-point"), e("core-js/modules/es.string.includes"), e("core-js/modules/es.number.is-nan"), e("regenerator-runtime/runtime");
        const n = { Workbook: e("./doc/workbook") }, i = e("./doc/enums");
        Object.keys(i).forEach((e2) => {
          n[e2] = i[e2];
        }), t2.exports = n;
      }, { "./doc/enums": 7, "./doc/workbook": 13, "core-js/modules/es.array.find": 359, "core-js/modules/es.array.find-index": 358, "core-js/modules/es.array.includes": 360, "core-js/modules/es.array.iterator": 361, "core-js/modules/es.number.is-nan": 363, "core-js/modules/es.object.assign": 364, "core-js/modules/es.object.keys": 366, "core-js/modules/es.object.values": 367, "core-js/modules/es.promise": 372, "core-js/modules/es.promise.finally": 371, "core-js/modules/es.string.from-code-point": 376, "core-js/modules/es.string.includes": 377, "core-js/modules/es.symbol": 381, "core-js/modules/es.symbol.async-iterator": 378, "regenerator-runtime/runtime": 492 }], 16: [function(e, t2, r) {
        const n = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
        r.bufferToString = function(e2) {
          return "string" == typeof e2 ? e2 : n ? n.decode(e2) : e2.toString();
        };
      }, {}], 17: [function(e, t2, r) {
        const n = "undefined" == typeof TextEncoder ? null : new TextEncoder("utf-8"), { Buffer: i } = e("buffer");
        r.stringToBuffer = function(e2) {
          return "string" != typeof e2 ? e2 : n ? i.from(n.encode(e2).buffer) : i.from(e2);
        };
      }, { buffer: 220 }], 18: [function(e, t2, r) {
        const n = e("./under-dash"), i = e("./col-cache");
        t2.exports = class {
          constructor(e2) {
            this.template = e2, this.sheets = {};
          }
          addCell(e2) {
            this.addCellEx(i.decodeEx(e2));
          }
          getCell(e2) {
            return this.findCellEx(i.decodeEx(e2), true);
          }
          findCell(e2) {
            return this.findCellEx(i.decodeEx(e2), false);
          }
          findCellAt(e2, t3, r2) {
            const n2 = this.sheets[e2], i2 = n2 && n2[t3];
            return i2 && i2[r2];
          }
          addCellEx(e2) {
            if (e2.top) for (let t3 = e2.top; t3 <= e2.bottom; t3++) for (let r2 = e2.left; r2 <= e2.right; r2++) this.getCellAt(e2.sheetName, t3, r2);
            else this.findCellEx(e2, true);
          }
          getCellEx(e2) {
            return this.findCellEx(e2, true);
          }
          findCellEx(e2, t3) {
            const r2 = this.findSheet(e2, t3), n2 = this.findSheetRow(r2, e2, t3);
            return this.findRowCell(n2, e2, t3);
          }
          getCellAt(e2, t3, r2) {
            const n2 = this.sheets[e2] || (this.sheets[e2] = []), s = n2[t3] || (n2[t3] = []);
            return s[r2] || (s[r2] = { sheetName: e2, address: i.n2l(r2) + t3, row: t3, col: r2 });
          }
          removeCellEx(e2) {
            const t3 = this.findSheet(e2);
            if (!t3) return;
            const r2 = this.findSheetRow(t3, e2);
            r2 && delete r2[e2.col];
          }
          forEachInSheet(e2, t3) {
            const r2 = this.sheets[e2];
            r2 && r2.forEach((e3, r3) => {
              e3 && e3.forEach((e4, n2) => {
                e4 && t3(e4, r3, n2);
              });
            });
          }
          forEach(e2) {
            n.each(this.sheets, (t3, r2) => {
              this.forEachInSheet(r2, e2);
            });
          }
          map(e2) {
            const t3 = [];
            return this.forEach((r2) => {
              t3.push(e2(r2));
            }), t3;
          }
          findSheet(e2, t3) {
            const r2 = e2.sheetName;
            return this.sheets[r2] ? this.sheets[r2] : t3 ? this.sheets[r2] = [] : void 0;
          }
          findSheetRow(e2, t3, r2) {
            const { row: n2 } = t3;
            return e2 && e2[n2] ? e2[n2] : r2 ? e2[n2] = [] : void 0;
          }
          findRowCell(e2, t3, r2) {
            const { col: n2 } = t3;
            return e2 && e2[n2] ? e2[n2] : r2 ? e2[n2] = this.template ? Object.assign(t3, JSON.parse(JSON.stringify(this.template))) : t3 : void 0;
          }
          spliceRows(e2, t3, r2, n2) {
            const i2 = this.sheets[e2];
            if (i2) {
              const e3 = [];
              for (let t4 = 0; t4 < n2; t4++) e3.push([]);
              i2.splice(t3, r2, ...e3);
            }
          }
          spliceColumns(e2, t3, r2, i2) {
            const s = this.sheets[e2];
            if (s) {
              const e3 = [];
              for (let t4 = 0; t4 < i2; t4++) e3.push(null);
              n.each(s, (n2) => {
                n2.splice(t3, r2, ...e3);
              });
            }
          }
        };
      }, { "./col-cache": 19, "./under-dash": 26 }], 19: [function(e, t2, r) {
        const n = /^[A-Z]+\d+$/, i = { _dictionary: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"], _l2nFill: 0, _l2n: {}, _n2l: [], _level: (e2) => e2 <= 26 ? 1 : e2 <= 676 ? 2 : 3, _fill(e2) {
          let t3, r2, n2, i2, s, o = 1;
          if (e2 >= 4) throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
          if (this._l2nFill < 1 && e2 >= 1) {
            for (; o <= 26; ) t3 = this._dictionary[o - 1], this._n2l[o] = t3, this._l2n[t3] = o, o++;
            this._l2nFill = 1;
          }
          if (this._l2nFill < 2 && e2 >= 2) {
            for (o = 27; o <= 702; ) r2 = o - 27, n2 = r2 % 26, i2 = Math.floor(r2 / 26), t3 = this._dictionary[i2] + this._dictionary[n2], this._n2l[o] = t3, this._l2n[t3] = o, o++;
            this._l2nFill = 2;
          }
          if (this._l2nFill < 3 && e2 >= 3) {
            for (o = 703; o <= 16384; ) r2 = o - 703, n2 = r2 % 26, i2 = Math.floor(r2 / 26) % 26, s = Math.floor(r2 / 676), t3 = this._dictionary[s] + this._dictionary[i2] + this._dictionary[n2], this._n2l[o] = t3, this._l2n[t3] = o, o++;
            this._l2nFill = 3;
          }
        }, l2n(e2) {
          if (this._l2n[e2] || this._fill(e2.length), !this._l2n[e2]) throw new Error("Out of bounds. Invalid column letter: " + e2);
          return this._l2n[e2];
        }, n2l(e2) {
          if (e2 < 1 || e2 > 16384) throw new Error(e2 + " is out of bounds. Excel supports columns from 1 to 16384");
          return this._n2l[e2] || this._fill(this._level(e2)), this._n2l[e2];
        }, _hash: {}, validateAddress(e2) {
          if (!n.test(e2)) throw new Error("Invalid Address: " + e2);
          return true;
        }, decodeAddress(e2) {
          const t3 = e2.length < 5 && this._hash[e2];
          if (t3) return t3;
          let r2 = false, n2 = "", i2 = 0, s = false, o = "", a = 0;
          for (let t4, l2 = 0; l2 < e2.length; l2++) if (t4 = e2.charCodeAt(l2), !s && t4 >= 65 && t4 <= 90) r2 = true, n2 += e2[l2], i2 = 26 * i2 + t4 - 64;
          else if (t4 >= 48 && t4 <= 57) s = true, o += e2[l2], a = 10 * a + t4 - 48;
          else if (s && r2 && 36 !== t4) break;
          if (r2) {
            if (i2 > 16384) throw new Error("Out of bounds. Invalid column letter: " + n2);
          } else i2 = void 0;
          s || (a = void 0);
          const l = { address: e2 = n2 + o, col: i2, row: a, $col$row: `$${n2}$${o}` };
          return i2 <= 100 && a <= 100 && (this._hash[e2] = l, this._hash[l.$col$row] = l), l;
        }, getAddress(e2, t3) {
          if (t3) {
            const r2 = this.n2l(t3) + e2;
            return this.decodeAddress(r2);
          }
          return this.decodeAddress(e2);
        }, decode(e2) {
          const t3 = e2.split(":");
          if (2 === t3.length) {
            const e3 = this.decodeAddress(t3[0]), r2 = this.decodeAddress(t3[1]), n2 = { top: Math.min(e3.row, r2.row), left: Math.min(e3.col, r2.col), bottom: Math.max(e3.row, r2.row), right: Math.max(e3.col, r2.col) };
            return n2.tl = this.n2l(n2.left) + n2.top, n2.br = this.n2l(n2.right) + n2.bottom, n2.dimensions = `${n2.tl}:${n2.br}`, n2;
          }
          return this.decodeAddress(e2);
        }, decodeEx(e2) {
          const t3 = e2.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/), r2 = t3[1] || t3[2], n2 = t3[3], i2 = n2.split(":");
          if (i2.length > 1) {
            let e3 = this.decodeAddress(i2[0]), t4 = this.decodeAddress(i2[1]);
            const n3 = Math.min(e3.row, t4.row), s2 = Math.min(e3.col, t4.col), o = Math.max(e3.row, t4.row), a = Math.max(e3.col, t4.col);
            return e3 = this.n2l(s2) + n3, t4 = this.n2l(a) + o, { top: n3, left: s2, bottom: o, right: a, sheetName: r2, tl: { address: e3, col: s2, row: n3, $col$row: `$${this.n2l(s2)}$${n3}`, sheetName: r2 }, br: { address: t4, col: a, row: o, $col$row: `$${this.n2l(a)}$${o}`, sheetName: r2 }, dimensions: `${e3}:${t4}` };
          }
          if (n2.startsWith("#")) return r2 ? { sheetName: r2, error: n2 } : { error: n2 };
          const s = this.decodeAddress(n2);
          return r2 ? { sheetName: r2, ...s } : s;
        }, encodeAddress: (e2, t3) => i.n2l(t3) + e2, encode() {
          switch (arguments.length) {
            case 2:
              return i.encodeAddress(arguments[0], arguments[1]);
            case 4:
              return `${i.encodeAddress(arguments[0], arguments[1])}:${i.encodeAddress(arguments[2], arguments[3])}`;
            default:
              throw new Error("Can only encode with 2 or 4 arguments");
          }
        }, inRange(e2, t3) {
          const [r2, n2, , i2, s] = e2, [o, a] = t3;
          return o >= r2 && o <= i2 && a >= n2 && a <= s;
        } };
        t2.exports = i;
      }, {}], 20: [function(e, t2, r) {
        const n = (e2, t3) => ({ ...e2, ...t3.reduce((t4, r2) => (e2[r2] && (t4[r2] = { ...e2[r2] }), t4), {}) }), i = function(e2, t3, r2) {
          let i2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
          e2[r2] && (t3[r2] = n(e2[r2], i2));
        };
        r.copyStyle = (e2) => {
          if (!e2) return e2;
          if (t3 = e2, 0 === Object.keys(t3).length) return {};
          var t3;
          const r2 = { ...e2 };
          return i(e2, r2, "font", ["color"]), i(e2, r2, "alignment"), i(e2, r2, "protection"), e2.border && (i(e2, r2, "border"), i(e2.border, r2.border, "top", ["color"]), i(e2.border, r2.border, "left", ["color"]), i(e2.border, r2.border, "bottom", ["color"]), i(e2.border, r2.border, "right", ["color"]), i(e2.border, r2.border, "diagonal", ["color"])), e2.fill && (i(e2, r2, "fill", ["fgColor", "bgColor", "center"]), e2.fill.stops && (r2.fill.stops = e2.fill.stops.map((e3) => n(e3, ["color"])))), r2;
        };
      }, {}], 21: [function(e, t2, r) {
        (function(r2) {
          (function() {
            const n = e("crypto"), i = { hash(e2) {
              const t3 = n.createHash(e2);
              for (var i2 = arguments.length, s = new Array(i2 > 1 ? i2 - 1 : 0), o = 1; o < i2; o++) s[o - 1] = arguments[o];
              return t3.update(r2.concat(s)), t3.digest();
            }, convertPasswordToHash(e2, t3, i2, s) {
              t3 = t3.toLowerCase();
              if (n.getHashes().indexOf(t3) < 0) throw new Error(`Hash algorithm '${t3}' not supported!`);
              const o = r2.from(e2, "utf16le");
              let a = this.hash(t3, r2.from(i2, "base64"), o);
              for (let e3 = 0; e3 < s; e3++) {
                const n2 = r2.alloc(4);
                n2.writeUInt32LE(e3, 0), a = this.hash(t3, a, n2);
              }
              return a.toString("base64");
            }, randomBytes: (e2) => n.randomBytes(e2) };
            t2.exports = i;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 220, crypto: 390 }], 22: [function(e, t2, r) {
        const { SaxesParser: n } = e("saxes"), { PassThrough: i } = e("readable-stream"), { bufferToString: s } = e("./browser-buffer-decode");
        t2.exports = async function* (e2) {
          e2.pipe && !e2[Symbol.asyncIterator] && (e2 = e2.pipe(new i()));
          const t3 = new n();
          let r2;
          t3.on("error", (e3) => {
            r2 = e3;
          });
          let o = [];
          t3.on("opentag", (e3) => o.push({ eventType: "opentag", value: e3 })), t3.on("text", (e3) => o.push({ eventType: "text", value: e3 })), t3.on("closetag", (e3) => o.push({ eventType: "closetag", value: e3 }));
          for await (const n2 of e2) {
            if (t3.write(s(n2)), r2) throw r2;
            yield o, o = [];
          }
        };
      }, { "./browser-buffer-decode": 16, "readable-stream": 491, saxes: 496 }], 23: [function(e, t2, r) {
        const n = e("./col-cache"), i = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi, s = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
        t2.exports = { slideFormula: function(e2, t3, r2) {
          const o = n.decode(t3), a = n.decode(r2);
          return e2.replace(i, (e3, t4, r3, i2, l) => {
            if (l) return e3;
            const c = s.exec(i2);
            if (c) {
              const r4 = c[1], i3 = c[2].toUpperCase(), s2 = c[3], l2 = c[4];
              if (i3.length > 3 || 3 === i3.length && i3 > "XFD") return e3;
              let u = n.l2n(i3), h = parseInt(l2, 10);
              r4 || (u += a.col - o.col), s2 || (h += a.row - o.row);
              return (t4 || "") + (r4 || "") + n.n2l(u) + (s2 || "") + h;
            }
            return e3;
          });
        } };
      }, { "./col-cache": 19 }], 24: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            const i = e("readable-stream"), s = e("./utils"), o = e("./string-buf");
            class a {
              constructor(e2, t3) {
                this._data = e2, this._encoding = t3;
              }
              get length() {
                return this.toBuffer().length;
              }
              copy(e2, t3, r3, n2) {
                return this.toBuffer().copy(e2, t3, r3, n2);
              }
              toBuffer() {
                return this._buffer || (this._buffer = n.from(this._data, this._encoding)), this._buffer;
              }
            }
            class l {
              constructor(e2) {
                this._data = e2;
              }
              get length() {
                return this._data.length;
              }
              copy(e2, t3, r3, n2) {
                return this._data._buf.copy(e2, t3, r3, n2);
              }
              toBuffer() {
                return this._data.toBuffer();
              }
            }
            class c {
              constructor(e2) {
                this._data = e2;
              }
              get length() {
                return this._data.length;
              }
              copy(e2, t3, r3, n2) {
                this._data.copy(e2, t3, r3, n2);
              }
              toBuffer() {
                return this._data;
              }
            }
            class u {
              constructor(e2) {
                this.size = e2, this.buffer = n.alloc(e2), this.iRead = 0, this.iWrite = 0;
              }
              toBuffer() {
                if (0 === this.iRead && this.iWrite === this.size) return this.buffer;
                const e2 = n.alloc(this.iWrite - this.iRead);
                return this.buffer.copy(e2, 0, this.iRead, this.iWrite), e2;
              }
              get length() {
                return this.iWrite - this.iRead;
              }
              get eod() {
                return this.iRead === this.iWrite;
              }
              get full() {
                return this.iWrite === this.size;
              }
              read(e2) {
                let t3;
                return 0 === e2 ? null : void 0 === e2 || e2 >= this.length ? (t3 = this.toBuffer(), this.iRead = this.iWrite, t3) : (t3 = n.alloc(e2), this.buffer.copy(t3, 0, this.iRead, e2), this.iRead += e2, t3);
              }
              write(e2, t3, r3) {
                const n2 = Math.min(r3, this.size - this.iWrite);
                return e2.copy(this.buffer, this.iWrite, t3, t3 + n2), this.iWrite += n2, n2;
              }
            }
            const h = function(e2) {
              e2 = e2 || {}, this.bufSize = e2.bufSize || 1048576, this.buffers = [], this.batch = e2.batch || false, this.corked = false, this.inPos = 0, this.outPos = 0, this.pipes = [], this.paused = false, this.encoding = null;
            };
            s.inherits(h, i.Duplex, { toBuffer() {
              switch (this.buffers.length) {
                case 0:
                  return null;
                case 1:
                  return this.buffers[0].toBuffer();
                default:
                  return n.concat(this.buffers.map((e2) => e2.toBuffer()));
              }
            }, _getWritableBuffer() {
              if (this.buffers.length) {
                const e3 = this.buffers[this.buffers.length - 1];
                if (!e3.full) return e3;
              }
              const e2 = new u(this.bufSize);
              return this.buffers.push(e2), e2;
            }, async _pipe(e2) {
              await Promise.all(this.pipes.map((function(t3) {
                return new Promise((r3) => {
                  t3.write(e2.toBuffer(), () => {
                    r3();
                  });
                });
              })));
            }, _writeToBuffers(e2) {
              let t3 = 0;
              const r3 = e2.length;
              for (; t3 < r3; ) {
                t3 += this._getWritableBuffer().write(e2, t3, r3 - t3);
              }
            }, async write(e2, t3, i2) {
              let u2;
              if (t3 instanceof Function && (i2 = t3, t3 = "utf8"), i2 = i2 || s.nop, e2 instanceof o) u2 = new l(e2);
              else if (e2 instanceof n) u2 = new c(e2);
              else {
                if (!("string" == typeof e2 || e2 instanceof String || e2 instanceof ArrayBuffer)) throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
                u2 = new a(e2, t3);
              }
              if (this.pipes.length) if (this.batch) for (this._writeToBuffers(u2); !this.corked && this.buffers.length > 1; ) this._pipe(this.buffers.shift());
              else this.corked ? (this._writeToBuffers(u2), r2.nextTick(i2)) : (await this._pipe(u2), i2());
              else this.paused || this.emit("data", u2.toBuffer()), this._writeToBuffers(u2), this.emit("readable");
              return true;
            }, cork() {
              this.corked = true;
            }, _flush() {
              if (this.pipes.length) for (; this.buffers.length; ) this._pipe(this.buffers.shift());
            }, uncork() {
              this.corked = false, this._flush();
            }, end(e2, t3, r3) {
              const n2 = (e3) => {
                e3 ? r3(e3) : (this._flush(), this.pipes.forEach((e4) => {
                  e4.end();
                }), this.emit("finish"));
              };
              e2 ? this.write(e2, t3, n2) : n2();
            }, read(e2) {
              let t3;
              if (e2) {
                for (t3 = []; e2 && this.buffers.length && !this.buffers[0].eod; ) {
                  const r3 = this.buffers[0], n2 = r3.read(e2);
                  e2 -= n2.length, t3.push(n2), r3.eod && r3.full && this.buffers.shift();
                }
                return n.concat(t3);
              }
              return t3 = this.buffers.map((e3) => e3.toBuffer()).filter(Boolean), this.buffers = [], n.concat(t3);
            }, setEncoding(e2) {
              this.encoding = e2;
            }, pause() {
              this.paused = true;
            }, resume() {
              this.paused = false;
            }, isPaused() {
              return !!this.paused;
            }, pipe(e2) {
              this.pipes.push(e2), !this.paused && this.buffers.length && this.end();
            }, unpipe(e2) {
              this.pipes = this.pipes.filter((t3) => t3 !== e2);
            }, unshift() {
              throw new Error("Not Implemented");
            }, wrap() {
              throw new Error("Not Implemented");
            } }), t2.exports = h;
          }).call(this);
        }).call(this, e("_process"), e("buffer").Buffer);
      }, { "./string-buf": 25, "./utils": 27, _process: 467, buffer: 220, "readable-stream": 491 }], 25: [function(e, t2, r) {
        (function(e2) {
          (function() {
            t2.exports = class {
              constructor(t3) {
                this._buf = e2.alloc(t3 && t3.size || 16384), this._encoding = t3 && t3.encoding || "utf8", this._inPos = 0, this._buffer = void 0;
              }
              get length() {
                return this._inPos;
              }
              get capacity() {
                return this._buf.length;
              }
              get buffer() {
                return this._buf;
              }
              toBuffer() {
                return this._buffer || (this._buffer = e2.alloc(this.length), this._buf.copy(this._buffer, 0, 0, this.length)), this._buffer;
              }
              reset(e3) {
                e3 = e3 || 0, this._buffer = void 0, this._inPos = e3;
              }
              _grow(t3) {
                let r2 = 2 * this._buf.length;
                for (; r2 < t3; ) r2 *= 2;
                const n = e2.alloc(r2);
                this._buf.copy(n, 0), this._buf = n;
              }
              addText(e3) {
                this._buffer = void 0;
                let t3 = this._inPos + this._buf.write(e3, this._inPos, this._encoding);
                for (; t3 >= this._buf.length - 4; ) this._grow(this._inPos + e3.length), t3 = this._inPos + this._buf.write(e3, this._inPos, this._encoding);
                this._inPos = t3;
              }
              addStringBuf(e3) {
                e3.length && (this._buffer = void 0, this.length + e3.length > this.capacity && this._grow(this.length + e3.length), e3._buf.copy(this._buf, this._inPos, 0, e3.length), this._inPos += e3.length);
              }
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 220 }], 26: [function(e, t2, r) {
        const { toString: n } = Object.prototype, i = /["&<>]/, s = { each: function(e2, t3) {
          e2 && (Array.isArray(e2) ? e2.forEach(t3) : Object.keys(e2).forEach((r2) => {
            t3(e2[r2], r2);
          }));
        }, some: function(e2, t3) {
          return !!e2 && (Array.isArray(e2) ? e2.some(t3) : Object.keys(e2).some((r2) => t3(e2[r2], r2)));
        }, every: function(e2, t3) {
          return !e2 || (Array.isArray(e2) ? e2.every(t3) : Object.keys(e2).every((r2) => t3(e2[r2], r2)));
        }, map: function(e2, t3) {
          return e2 ? Array.isArray(e2) ? e2.map(t3) : Object.keys(e2).map((r2) => t3(e2[r2], r2)) : [];
        }, keyBy: (e2, t3) => e2.reduce((e3, r2) => (e3[r2[t3]] = r2, e3), {}), isEqual: function(e2, t3) {
          const r2 = typeof e2, n2 = typeof t3, i2 = Array.isArray(e2), o = Array.isArray(t3);
          let a;
          if (r2 !== n2) return false;
          switch (typeof e2) {
            case "object":
              if (i2 || o) return !(!i2 || !o) && (e2.length === t3.length && e2.every((e3, r3) => {
                const n3 = t3[r3];
                return s.isEqual(e3, n3);
              }));
              if (null === e2 || null === t3) return e2 === t3;
              if (a = Object.keys(e2), Object.keys(t3).length !== a.length) return false;
              for (const e3 of a) if (!t3.hasOwnProperty(e3)) return false;
              return s.every(e2, (e3, r3) => {
                const n3 = t3[r3];
                return s.isEqual(e3, n3);
              });
            default:
              return e2 === t3;
          }
        }, escapeHtml(e2) {
          const t3 = i.exec(e2);
          if (!t3) return e2;
          let r2 = "", n2 = "", s2 = 0, o = t3.index;
          for (; o < e2.length; o++) {
            switch (e2.charAt(o)) {
              case '"':
                n2 = "&quot;";
                break;
              case "&":
                n2 = "&amp;";
                break;
              case "'":
                n2 = "&apos;";
                break;
              case "<":
                n2 = "&lt;";
                break;
              case ">":
                n2 = "&gt;";
                break;
              default:
                continue;
            }
            s2 !== o && (r2 += e2.substring(s2, o)), s2 = o + 1, r2 += n2;
          }
          return s2 !== o ? r2 + e2.substring(s2, o) : r2;
        }, strcmp: (e2, t3) => e2 < t3 ? -1 : e2 > t3 ? 1 : 0, isUndefined: (e2) => "[object Undefined]" === n.call(e2), isObject: (e2) => "[object Object]" === n.call(e2), deepMerge() {
          const e2 = arguments[0] || {}, { length: t3 } = arguments;
          let r2, n2, i2;
          function o(t4, o2) {
            r2 = e2[o2], i2 = Array.isArray(t4), s.isObject(t4) || i2 ? (i2 ? (i2 = false, n2 = r2 && Array.isArray(r2) ? r2 : []) : n2 = r2 && s.isObject(r2) ? r2 : {}, e2[o2] = s.deepMerge(n2, t4)) : s.isUndefined(t4) || (e2[o2] = t4);
          }
          for (let e3 = 0; e3 < t3; e3++) s.each(arguments[e3], o);
          return e2;
        } };
        t2.exports = s;
      }, {}], 27: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            const i = e("fs"), s = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/, o = { nop() {
            }, promiseImmediate: (e2) => new Promise((t3) => {
              r2.setImmediate ? n(() => {
                t3(e2);
              }) : setTimeout(() => {
                t3(e2);
              }, 1);
            }), inherits: function(e2, t3, r3, n2) {
              e2.super_ = t3, n2 || (n2 = r3, r3 = null), r3 && Object.keys(r3).forEach((t4) => {
                Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(r3, t4));
              });
              const i2 = { constructor: { value: e2, enumerable: false, writable: false, configurable: true } };
              n2 && Object.keys(n2).forEach((e3) => {
                i2[e3] = Object.getOwnPropertyDescriptor(n2, e3);
              }), e2.prototype = Object.create(t3.prototype, i2);
            }, dateToExcel: (e2, t3) => 25569 + e2.getTime() / 864e5 - (t3 ? 1462 : 0), excelToDate(e2, t3) {
              const r3 = Math.round(24 * (e2 - 25569 + (t3 ? 1462 : 0)) * 3600 * 1e3);
              return new Date(r3);
            }, parsePath(e2) {
              const t3 = e2.lastIndexOf("/");
              return { path: e2.substring(0, t3), name: e2.substring(t3 + 1) };
            }, getRelsPath(e2) {
              const t3 = o.parsePath(e2);
              return `${t3.path}/_rels/${t3.name}.rels`;
            }, xmlEncode(e2) {
              const t3 = s.exec(e2);
              if (!t3) return e2;
              let r3 = "", n2 = "", i2 = 0, o2 = t3.index;
              for (; o2 < e2.length; o2++) {
                const t4 = e2.charCodeAt(o2);
                switch (t4) {
                  case 34:
                    n2 = "&quot;";
                    break;
                  case 38:
                    n2 = "&amp;";
                    break;
                  case 39:
                    n2 = "&apos;";
                    break;
                  case 60:
                    n2 = "&lt;";
                    break;
                  case 62:
                    n2 = "&gt;";
                    break;
                  case 127:
                    n2 = "";
                    break;
                  default:
                    if (t4 <= 31 && (t4 <= 8 || t4 >= 11 && 13 !== t4)) {
                      n2 = "";
                      break;
                    }
                    continue;
                }
                i2 !== o2 && (r3 += e2.substring(i2, o2)), i2 = o2 + 1, n2 && (r3 += n2);
              }
              return i2 !== o2 ? r3 + e2.substring(i2, o2) : r3;
            }, xmlDecode: (e2) => e2.replace(/&([a-z]*);/g, (e3) => {
              switch (e3) {
                case "&lt;":
                  return "<";
                case "&gt;":
                  return ">";
                case "&amp;":
                  return "&";
                case "&apos;":
                  return "'";
                case "&quot;":
                  return '"';
                default:
                  return e3;
              }
            }), validInt(e2) {
              const t3 = parseInt(e2, 10);
              return Number.isNaN(t3) ? 0 : t3;
            }, isDateFmt(e2) {
              if (!e2) return false;
              return null !== (e2 = (e2 = e2.replace(/\[[^\]]*]/g, "")).replace(/"[^"]*"/g, "")).match(/[ymdhMsb]+/);
            }, fs: { exists: (e2) => new Promise((t3) => {
              i.access(e2, i.constants.F_OK, (e3) => {
                t3(!e3);
              });
            }) }, toIsoDateString: (e2) => e2.toIsoString().subsstr(0, 10), parseBoolean: (e2) => true === e2 || "true" === e2 || 1 === e2 || "1" === e2 };
            t2.exports = o;
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("timers").setImmediate);
      }, { fs: 216, timers: 523 }], 28: [function(e, t2, r) {
        const n = e("./under-dash"), i = e("./utils");
        function s(e2, t3, r2) {
          e2.push(` ${t3}="${i.xmlEncode(r2.toString())}"`);
        }
        function o(e2, t3) {
          if (t3) {
            const r2 = [];
            n.each(t3, (e3, t4) => {
              void 0 !== e3 && s(r2, t4, e3);
            }), e2.push(r2.join(""));
          }
        }
        class a {
          constructor() {
            this._xml = [], this._stack = [], this._rollbacks = [];
          }
          get tos() {
            return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
          }
          get cursor() {
            return this._xml.length;
          }
          openXml(e2) {
            const t3 = this._xml;
            t3.push("<?xml"), o(t3, e2), t3.push("?>\n");
          }
          openNode(e2, t3) {
            const r2 = this.tos, n2 = this._xml;
            r2 && this.open && n2.push(">"), this._stack.push(e2), n2.push("<"), n2.push(e2), o(n2, t3), this.leaf = true, this.open = true;
          }
          addAttribute(e2, t3) {
            if (!this.open) throw new Error("Cannot write attributes to node if it is not open");
            void 0 !== t3 && s(this._xml, e2, t3);
          }
          addAttributes(e2) {
            if (!this.open) throw new Error("Cannot write attributes to node if it is not open");
            o(this._xml, e2);
          }
          writeText(e2) {
            const t3 = this._xml;
            this.open && (t3.push(">"), this.open = false), this.leaf = false, t3.push(i.xmlEncode(e2.toString()));
          }
          writeXml(e2) {
            this.open && (this._xml.push(">"), this.open = false), this.leaf = false, this._xml.push(e2);
          }
          closeNode() {
            const e2 = this._stack.pop(), t3 = this._xml;
            this.leaf ? t3.push("/>") : (t3.push("</"), t3.push(e2), t3.push(">")), this.open = false, this.leaf = false;
          }
          leafNode(e2, t3, r2) {
            this.openNode(e2, t3), void 0 !== r2 && this.writeText(r2), this.closeNode();
          }
          closeAll() {
            for (; this._stack.length; ) this.closeNode();
          }
          addRollback() {
            return this._rollbacks.push({ xml: this._xml.length, stack: this._stack.length, leaf: this.leaf, open: this.open }), this.cursor;
          }
          commit() {
            this._rollbacks.pop();
          }
          rollback() {
            const e2 = this._rollbacks.pop();
            this._xml.length > e2.xml && this._xml.splice(e2.xml, this._xml.length - e2.xml), this._stack.length > e2.stack && this._stack.splice(e2.stack, this._stack.length - e2.stack), this.leaf = e2.leaf, this.open = e2.open;
          }
          get xml() {
            return this.closeAll(), this._xml.join("");
          }
        }
        a.StdDocAttributes = { version: "1.0", encoding: "UTF-8", standalone: "yes" }, t2.exports = a;
      }, { "./under-dash": 26, "./utils": 27 }], 29: [function(e, t2, r) {
        (function(r2) {
          (function() {
            const n = e("events"), i = e("jszip"), s = e("./stream-buf"), { stringToBuffer: o } = e("./browser-buffer-encode");
            class a extends n.EventEmitter {
              constructor(e2) {
                super(), this.options = Object.assign({ type: "nodebuffer", compression: "DEFLATE" }, e2), this.zip = new i(), this.stream = new s();
              }
              append(e2, t3) {
                t3.hasOwnProperty("base64") && t3.base64 ? this.zip.file(t3.name, e2, { base64: true }) : (r2.browser && "string" == typeof e2 && (e2 = o(e2)), this.zip.file(t3.name, e2));
              }
              async finalize() {
                const e2 = await this.zip.generateAsync(this.options);
                this.stream.end(e2), this.emit("finish");
              }
              read(e2) {
                return this.stream.read(e2);
              }
              setEncoding(e2) {
                return this.stream.setEncoding(e2);
              }
              pause() {
                return this.stream.pause();
              }
              resume() {
                return this.stream.resume();
              }
              isPaused() {
                return this.stream.isPaused();
              }
              pipe(e2, t3) {
                return this.stream.pipe(e2, t3);
              }
              unpipe(e2) {
                return this.stream.unpipe(e2);
              }
              unshift(e2) {
                return this.stream.unshift(e2);
              }
              wrap(e2) {
                return this.stream.wrap(e2);
              }
            }
            t2.exports = { ZipWriter: a };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./browser-buffer-encode": 17, "./stream-buf": 24, _process: 467, events: 422, jszip: 441 }], 30: [function(e, t2, r) {
        t2.exports = { 0: { f: "General" }, 1: { f: "0" }, 2: { f: "0.00" }, 3: { f: "#,##0" }, 4: { f: "#,##0.00" }, 9: { f: "0%" }, 10: { f: "0.00%" }, 11: { f: "0.00E+00" }, 12: { f: "# ?/?" }, 13: { f: "# ??/??" }, 14: { f: "mm-dd-yy" }, 15: { f: "d-mmm-yy" }, 16: { f: "d-mmm" }, 17: { f: "mmm-yy" }, 18: { f: "h:mm AM/PM" }, 19: { f: "h:mm:ss AM/PM" }, 20: { f: "h:mm" }, 21: { f: "h:mm:ss" }, 22: { f: 'm/d/yy "h":mm' }, 27: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"年"m"月"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"年" mm"月" dd"日"' }, 28: { "zh-tw": '[$-404]e"年"m"月"d"日"', "zh-cn": 'm"月"d"日"', "ja-jp": '[$-411]ggge"年"m"月"d"日"', "ko-kr": "mm-dd" }, 29: { "zh-tw": '[$-404]e"年"m"月"d"日"', "zh-cn": 'm"月"d"日"', "ja-jp": '[$-411]ggge"年"m"月"d"日"', "ko-kr": "mm-dd" }, 30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" }, 31: { "zh-tw": 'yyyy"年"m"月"d"日"', "zh-cn": 'yyyy"年"m"月"d"日"', "ja-jp": 'yyyy"年"m"月"d"日"', "ko-kr": 'yyyy"년" mm"월" dd"일"' }, 32: { "zh-tw": 'hh"時"mm"分"', "zh-cn": 'h"时"mm"分"', "ja-jp": 'h"時"mm"分"', "ko-kr": 'h"시" mm"분"' }, 33: { "zh-tw": 'hh"時"mm"分"ss"秒"', "zh-cn": 'h"时"mm"分"ss"秒"', "ja-jp": 'h"時"mm"分"ss"秒"', "ko-kr": 'h"시" mm"분" ss"초"' }, 34: { "zh-tw": '上午/下午 hh"時"mm"分"', "zh-cn": '上午/下午 h"时"mm"分"', "ja-jp": 'yyyy"年"m"月"', "ko-kr": "yyyy-mm-dd" }, 35: { "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"', "zh-cn": '上午/下午 h"时"mm"分"ss"秒"', "ja-jp": 'm"月"d"日"', "ko-kr": "yyyy-mm-dd" }, 36: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"年"m"月"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"年" mm"月" dd"日"' }, 37: { f: "#,##0 ;(#,##0)" }, 38: { f: "#,##0 ;[Red](#,##0)" }, 39: { f: "#,##0.00 ;(#,##0.00)" }, 40: { f: "#,##0.00 ;[Red](#,##0.00)" }, 45: { f: "mm:ss" }, 46: { f: "[h]:mm:ss" }, 47: { f: "mmss.0" }, 48: { f: "##0.0E+0" }, 49: { f: "@" }, 50: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"年"m"月"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"年" mm"月" dd"日"' }, 51: { "zh-tw": '[$-404]e"年"m"月"d"日"', "zh-cn": 'm"月"d"日"', "ja-jp": '[$-411]ggge"年"m"月"d"日"', "ko-kr": "mm-dd" }, 52: { "zh-tw": '上午/下午 hh"時"mm"分"', "zh-cn": 'yyyy"年"m"月"', "ja-jp": 'yyyy"年"m"月"', "ko-kr": "yyyy-mm-dd" }, 53: { "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"', "zh-cn": 'm"月"d"日"', "ja-jp": 'm"月"d"日"', "ko-kr": "yyyy-mm-dd" }, 54: { "zh-tw": '[$-404]e"年"m"月"d"日"', "zh-cn": 'm"月"d"日"', "ja-jp": '[$-411]ggge"年"m"月"d"日"', "ko-kr": "mm-dd" }, 55: { "zh-tw": '上午/下午 hh"時"mm"分"', "zh-cn": '上午/下午 h"时"mm"分"', "ja-jp": 'yyyy"年"m"月"', "ko-kr": "yyyy-mm-dd" }, 56: { "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"', "zh-cn": '上午/下午 h"时"mm"分"ss"秒"', "ja-jp": 'm"月"d"日"', "ko-kr": "yyyy-mm-dd" }, 57: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy"年"m"月"', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"年" mm"月" dd"日"' }, 58: { "zh-tw": '[$-404]e"年"m"月"d"日"', "zh-cn": 'm"月"d"日"', "ja-jp": '[$-411]ggge"年"m"月"d"日"', "ko-kr": "mm-dd" }, 59: { "th-th": "t0" }, 60: { "th-th": "t0.00" }, 61: { "th-th": "t#,##0" }, 62: { "th-th": "t#,##0.00" }, 67: { "th-th": "t0%" }, 68: { "th-th": "t0.00%" }, 69: { "th-th": "t# ?/?" }, 70: { "th-th": "t# ??/??" }, 81: { "th-th": "d/m/bb" } };
      }, {}], 31: [function(e, t2, r) {
        t2.exports = { OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain", SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings", Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing", Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" };
      }, {}], 32: [function(e, t2, r) {
        const n = e("../../utils/parse-sax"), i = e("../../utils/xml-stream");
        class s {
          prepare() {
          }
          render() {
          }
          parseOpen(e2) {
          }
          parseText(e2) {
          }
          parseClose(e2) {
          }
          reconcile(e2, t3) {
          }
          reset() {
            this.model = null, this.map && Object.values(this.map).forEach((e2) => {
              e2 instanceof s ? e2.reset() : e2.xform && e2.xform.reset();
            });
          }
          mergeModel(e2) {
            this.model = Object.assign(this.model || {}, e2);
          }
          async parse(e2) {
            for await (const t3 of e2) for (const { eventType: e3, value: r2 } of t3) if ("opentag" === e3) this.parseOpen(r2);
            else if ("text" === e3) this.parseText(r2);
            else if ("closetag" === e3 && !this.parseClose(r2.name)) return this.model;
            return this.model;
          }
          async parseStream(e2) {
            return this.parse(n(e2));
          }
          get xml() {
            return this.toXml(this.model);
          }
          toXml(e2) {
            const t3 = new i();
            return this.render(t3, e2), t3.xml;
          }
          static toAttribute(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (void 0 === e2) {
              if (r2) return t3;
            } else if (r2 || e2 !== t3) return e2.toString();
          }
          static toStringAttribute(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return s.toAttribute(e2, t3, r2);
          }
          static toStringValue(e2, t3) {
            return void 0 === e2 ? t3 : e2;
          }
          static toBoolAttribute(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (void 0 === e2) {
              if (r2) return t3;
            } else if (r2 || e2 !== t3) return e2 ? "1" : "0";
          }
          static toBoolValue(e2, t3) {
            return void 0 === e2 ? t3 : "1" === e2;
          }
          static toIntAttribute(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return s.toAttribute(e2, t3, r2);
          }
          static toIntValue(e2, t3) {
            return void 0 === e2 ? t3 : parseInt(e2, 10);
          }
          static toFloatAttribute(e2, t3) {
            let r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return s.toAttribute(e2, t3, r2);
          }
          static toFloatValue(e2, t3) {
            return void 0 === e2 ? t3 : parseFloat(e2);
          }
        }
        t2.exports = s;
      }, { "../../utils/parse-sax": 22, "../../utils/xml-stream": 28 }], 33: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../../../utils/col-cache");
        function s(e2) {
          try {
            return i.decodeEx(e2), true;
          } catch (e3) {
            return false;
          }
        }
        function o(e2) {
          const t3 = [];
          let r2 = false, n2 = "";
          return e2.split(",").forEach((e3) => {
            if (!e3) return;
            const i2 = (e3.match(/'/g) || []).length;
            if (!i2) return void (r2 ? n2 += e3 + "," : s(e3) && t3.push(e3));
            const o2 = i2 % 2 == 0;
            !r2 && o2 && s(e3) ? t3.push(e3) : r2 && !o2 ? (r2 = false, s(n2 + e3) && t3.push(n2 + e3), n2 = "") : (r2 = true, n2 += e3 + ",");
          }), t3;
        }
        t2.exports = class extends n {
          render(e2, t3) {
            e2.openNode("definedName", { name: t3.name, localSheetId: t3.localSheetId }), e2.writeText(t3.ranges.join(",")), e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "definedName":
                return this._parsedName = e2.attributes.name, this._parsedLocalSheetId = e2.attributes.localSheetId, this._parsedText = [], true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this._parsedText.push(e2);
          }
          parseClose() {
            return this.model = { name: this._parsedName, ranges: o(this._parsedText.join("")) }, void 0 !== this._parsedLocalSheetId && (this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10)), false;
          }
        };
      }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 34: [function(e, t2, r) {
        const n = e("../../../utils/utils"), i = e("../base-xform");
        t2.exports = class extends i {
          render(e2, t3) {
            e2.leafNode("sheet", { sheetId: t3.id, name: t3.name, state: t3.state, "r:id": t3.rId });
          }
          parseOpen(e2) {
            return "sheet" === e2.name && (this.model = { name: n.xmlDecode(e2.attributes.name), id: parseInt(e2.attributes.sheetId, 10), state: e2.attributes.state, rId: e2.attributes["r:id"] }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/utils": 27, "../base-xform": 32 }], 35: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            e2.leafNode("calcPr", { calcId: 171027, fullCalcOnLoad: t3.fullCalcOnLoad ? 1 : void 0 });
          }
          parseOpen(e2) {
            return "calcPr" === e2.name && (this.model = {}, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 36: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            e2.leafNode("workbookPr", { date1904: t3.date1904 ? 1 : void 0, defaultThemeVersion: 164011, filterPrivacy: 1 });
          }
          parseOpen(e2) {
            return "workbookPr" === e2.name && (this.model = { date1904: "1" === e2.attributes.date1904 }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 37: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            const r2 = { xWindow: t3.x || 0, yWindow: t3.y || 0, windowWidth: t3.width || 12e3, windowHeight: t3.height || 24e3, firstSheet: t3.firstSheet, activeTab: t3.activeTab };
            t3.visibility && "visible" !== t3.visibility && (r2.visibility = t3.visibility), e2.leafNode("workbookView", r2);
          }
          parseOpen(e2) {
            if ("workbookView" === e2.name) {
              const t3 = this.model = {}, r2 = function(e3, r3, n3) {
                const i = void 0 !== r3 ? t3[e3] = r3 : n3;
                void 0 !== i && (t3[e3] = i);
              }, n2 = function(e3, r3, n3) {
                const i = void 0 !== r3 ? t3[e3] = parseInt(r3, 10) : n3;
                void 0 !== i && (t3[e3] = i);
              };
              return n2("x", e2.attributes.xWindow, 0), n2("y", e2.attributes.yWindow, 0), n2("width", e2.attributes.windowWidth, 25e3), n2("height", e2.attributes.windowHeight, 1e4), r2("visibility", e2.attributes.visibility, "visible"), n2("activeTab", e2.attributes.activeTab, void 0), n2("firstSheet", e2.attributes.firstSheet, void 0), true;
            }
            return false;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 38: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../../../utils/col-cache"), s = e("../../../utils/xml-stream"), o = e("../base-xform"), a = e("../static-xform"), l = e("../list-xform"), c = e("./defined-name-xform"), u = e("./sheet-xform"), h = e("./workbook-view-xform"), f = e("./workbook-properties-xform"), d = e("./workbook-calc-properties-xform");
        class p extends o {
          constructor() {
            super(), this.map = { fileVersion: p.STATIC_XFORMS.fileVersion, workbookPr: new f(), bookViews: new l({ tag: "bookViews", count: false, childXform: new h() }), sheets: new l({ tag: "sheets", count: false, childXform: new u() }), definedNames: new l({ tag: "definedNames", count: false, childXform: new c() }), calcPr: new d() };
          }
          prepare(e2) {
            e2.sheets = e2.worksheets;
            const t3 = [];
            let r2 = 0;
            e2.sheets.forEach((e3) => {
              if (e3.pageSetup && e3.pageSetup.printArea && e3.pageSetup.printArea.split("&&").forEach((n2) => {
                const i2 = n2.split(":"), s2 = { name: "_xlnm.Print_Area", ranges: [`'${e3.name}'!$${i2[0]}:$${i2[1]}`], localSheetId: r2 };
                t3.push(s2);
              }), e3.pageSetup && (e3.pageSetup.printTitlesRow || e3.pageSetup.printTitlesColumn)) {
                const n2 = [];
                if (e3.pageSetup.printTitlesColumn) {
                  const t4 = e3.pageSetup.printTitlesColumn.split(":");
                  n2.push(`'${e3.name}'!$${t4[0]}:$${t4[1]}`);
                }
                if (e3.pageSetup.printTitlesRow) {
                  const t4 = e3.pageSetup.printTitlesRow.split(":");
                  n2.push(`'${e3.name}'!$${t4[0]}:$${t4[1]}`);
                }
                const i2 = { name: "_xlnm.Print_Titles", ranges: n2, localSheetId: r2 };
                t3.push(i2);
              }
              r2++;
            }), t3.length && (e2.definedNames = e2.definedNames.concat(t3)), (e2.media || []).forEach((e3, t4) => {
              e3.name = e3.type + (t4 + 1);
            });
          }
          render(e2, t3) {
            e2.openXml(s.StdDocAttributes), e2.openNode("workbook", p.WORKBOOK_ATTRIBUTES), this.map.fileVersion.render(e2), this.map.workbookPr.render(e2, t3.properties), this.map.bookViews.render(e2, t3.views), this.map.sheets.render(e2, t3.sheets), this.map.definedNames.render(e2, t3.definedNames), this.map.calcPr.render(e2, t3.calcProperties), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "workbook":
                return true;
              default:
                return this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2), true;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case "workbook":
                return this.model = { sheets: this.map.sheets.model, properties: this.map.workbookPr.model || {}, views: this.map.bookViews.model, calcProperties: {} }, this.map.definedNames.model && (this.model.definedNames = this.map.definedNames.model), false;
              default:
                return true;
            }
          }
          reconcile(e2) {
            const t3 = (e2.workbookRels || []).reduce((e3, t4) => (e3[t4.Id] = t4, e3), {}), r2 = [];
            let s2, o2 = 0;
            (e2.sheets || []).forEach((n2) => {
              const i2 = t3[n2.rId];
              i2 && (s2 = e2.worksheetHash["xl/" + i2.Target.replace(/^(\s|\/xl\/)+/, "")], s2 && (s2.name = n2.name, s2.id = n2.id, s2.state = n2.state, r2[o2++] = s2));
            });
            const a2 = [];
            n.each(e2.definedNames, (e3) => {
              if ("_xlnm.Print_Area" === e3.name) {
                if (s2 = r2[e3.localSheetId], s2) {
                  s2.pageSetup || (s2.pageSetup = {});
                  const t4 = i.decodeEx(e3.ranges[0]);
                  s2.pageSetup.printArea = s2.pageSetup.printArea ? `${s2.pageSetup.printArea}&&${t4.dimensions}` : t4.dimensions;
                }
              } else if ("_xlnm.Print_Titles" === e3.name) {
                if (s2 = r2[e3.localSheetId], s2) {
                  s2.pageSetup || (s2.pageSetup = {});
                  const t4 = e3.ranges.join(","), r3 = /\$/g, n2 = /\$\d+:\$\d+/, i2 = t4.match(n2);
                  if (i2 && i2.length) {
                    const e4 = i2[0];
                    s2.pageSetup.printTitlesRow = e4.replace(r3, "");
                  }
                  const o3 = /\$[A-Z]+:\$[A-Z]+/, a3 = t4.match(o3);
                  if (a3 && a3.length) {
                    const e4 = a3[0];
                    s2.pageSetup.printTitlesColumn = e4.replace(r3, "");
                  }
                }
              } else a2.push(e3);
            }), e2.definedNames = a2, e2.media.forEach((e3, t4) => {
              e3.index = t4;
            });
          }
        }
        p.WORKBOOK_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x15", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, p.STATIC_XFORMS = { fileVersion: new a({ tag: "fileVersion", $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 } }) }, t2.exports = p;
      }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "../static-xform": 120, "./defined-name-xform": 33, "./sheet-xform": 34, "./workbook-calc-properties-xform": 35, "./workbook-properties-xform": 36, "./workbook-view-xform": 37 }], 39: [function(e, t2, r) {
        const n = e("../strings/rich-text-xform"), i = e("../../../utils/utils"), s = e("../base-xform"), o = t2.exports = function(e2) {
          this.model = e2;
        };
        i.inherits(o, s, { get tag() {
          return "r";
        }, get richTextXform() {
          return this._richTextXform || (this._richTextXform = new n()), this._richTextXform;
        }, render(e2, t3) {
          t3 = t3 || this.model, e2.openNode("comment", { ref: t3.ref, authorId: 0 }), e2.openNode("text"), t3 && t3.note && t3.note.texts && t3.note.texts.forEach((t4) => {
            this.richTextXform.render(e2, t4);
          }), e2.closeNode(), e2.closeNode();
        }, parseOpen(e2) {
          if (this.parser) return this.parser.parseOpen(e2), true;
          switch (e2.name) {
            case "comment":
              return this.model = { type: "note", note: { texts: [] }, ...e2.attributes }, true;
            case "r":
              return this.parser = this.richTextXform, this.parser.parseOpen(e2), true;
            default:
              return false;
          }
        }, parseText(e2) {
          this.parser && this.parser.parseText(e2);
        }, parseClose(e2) {
          switch (e2) {
            case "comment":
              return false;
            case "r":
              return this.model.note.texts.push(this.parser.model), this.parser = void 0, true;
            default:
              return this.parser && this.parser.parseClose(e2), true;
          }
        } });
      }, { "../../../utils/utils": 27, "../base-xform": 32, "../strings/rich-text-xform": 122 }], 40: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../../../utils/utils"), s = e("../base-xform"), o = e("./comment-xform"), a = t2.exports = function() {
          this.map = { comment: new o() };
        };
        i.inherits(a, s, { COMMENTS_ATTRIBUTES: { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main" } }, { render(e2, t3) {
          t3 = t3 || this.model, e2.openXml(n.StdDocAttributes), e2.openNode("comments", a.COMMENTS_ATTRIBUTES), e2.openNode("authors"), e2.leafNode("author", null, "Author"), e2.closeNode(), e2.openNode("commentList"), t3.comments.forEach((t4) => {
            this.map.comment.render(e2, t4);
          }), e2.closeNode(), e2.closeNode();
        }, parseOpen(e2) {
          if (this.parser) return this.parser.parseOpen(e2), true;
          switch (e2.name) {
            case "commentList":
              return this.model = { comments: [] }, true;
            case "comment":
              return this.parser = this.map.comment, this.parser.parseOpen(e2), true;
            default:
              return false;
          }
        }, parseText(e2) {
          this.parser && this.parser.parseText(e2);
        }, parseClose(e2) {
          switch (e2) {
            case "commentList":
              return false;
            case "comment":
              return this.model.comments.push(this.parser.model), this.parser = void 0, true;
            default:
              return this.parser && this.parser.parseClose(e2), true;
          }
        } });
      }, { "../../../utils/utils": 27, "../../../utils/xml-stream": 28, "../base-xform": 32, "./comment-xform": 39 }], 41: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this._model = e2;
          }
          get tag() {
            return this._model && this._model.tag;
          }
          render(e2, t3, r2) {
            (t3 === r2[2] || "x:SizeWithCells" === this.tag && t3 === r2[1]) && e2.leafNode(this.tag);
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = {}, this.model[this.tag] = true, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../base-xform": 32 }], 42: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this._model = e2;
          }
          get tag() {
            return this._model && this._model.tag;
          }
          render(e2, t3) {
            e2.leafNode(this.tag, null, t3);
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.text = "", true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.text = e2;
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../base-xform": 32 }], 43: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "x:Anchor";
          }
          getAnchorRect(e2) {
            const t3 = Math.floor(e2.left), r2 = Math.floor(68 * (e2.left - t3)), n2 = Math.floor(e2.top), i = Math.floor(18 * (e2.top - n2)), s = Math.floor(e2.right), o = Math.floor(68 * (e2.right - s)), a = Math.floor(e2.bottom);
            return [t3, r2, n2, i, s, o, a, Math.floor(18 * (e2.bottom - a))];
          }
          getDefaultRect(e2) {
            const t3 = e2.col, r2 = Math.max(e2.row - 2, 0);
            return [t3, 6, r2, 14, t3 + 2, 2, r2 + 4, 16];
          }
          render(e2, t3) {
            const r2 = t3.anchor ? this.getAnchorRect(t3.anchor) : this.getDefaultRect(t3.refAddress);
            e2.leafNode("x:Anchor", null, r2.join(", "));
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.text = "", true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.text = e2;
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 44: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./vml-anchor-xform"), s = e("./style/vml-protection-xform"), o = e("./style/vml-position-xform"), a = ["twoCells", "oneCells", "absolute"];
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "x:Anchor": new i(), "x:Locked": new s({ tag: "x:Locked" }), "x:LockText": new s({ tag: "x:LockText" }), "x:SizeWithCells": new o({ tag: "x:SizeWithCells" }), "x:MoveWithCells": new o({ tag: "x:MoveWithCells" }) };
          }
          get tag() {
            return "x:ClientData";
          }
          render(e2, t3) {
            const { protection: r2, editAs: n2 } = t3.note;
            e2.openNode(this.tag, { ObjectType: "Note" }), this.map["x:MoveWithCells"].render(e2, n2, a), this.map["x:SizeWithCells"].render(e2, n2, a), this.map["x:Anchor"].render(e2, t3), this.map["x:Locked"].render(e2, r2.locked), e2.leafNode("x:AutoFill", null, "False"), this.map["x:LockText"].render(e2, r2.lockText), e2.leafNode("x:Row", null, t3.refAddress.row - 1), e2.leafNode("x:Column", null, t3.refAddress.col - 1), e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                this.reset(), this.model = { anchor: [], protection: {}, editAs: "" };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.normalizeModel(), false;
              default:
                return true;
            }
          }
          normalizeModel() {
            const e2 = Object.assign({}, this.map["x:MoveWithCells"].model, this.map["x:SizeWithCells"].model), t3 = Object.keys(e2).length;
            this.model.editAs = a[t3], this.model.anchor = this.map["x:Anchor"].text, this.model.protection.locked = this.map["x:Locked"].text, this.model.protection.lockText = this.map["x:LockText"].text;
          }
        };
      }, { "../base-xform": 32, "./style/vml-position-xform": 41, "./style/vml-protection-xform": 42, "./vml-anchor-xform": 43 }], 45: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("./vml-shape-xform");
        class o extends i {
          constructor() {
            super(), this.map = { "v:shape": new s() };
          }
          get tag() {
            return "xml";
          }
          render(e2, t3) {
            e2.openXml(n.StdDocAttributes), e2.openNode(this.tag, o.DRAWING_ATTRIBUTES), e2.openNode("o:shapelayout", { "v:ext": "edit" }), e2.leafNode("o:idmap", { "v:ext": "edit", data: 1 }), e2.closeNode(), e2.openNode("v:shapetype", { id: "_x0000_t202", coordsize: "21600,21600", "o:spt": 202, path: "m,l,21600r21600,l21600,xe" }), e2.leafNode("v:stroke", { joinstyle: "miter" }), e2.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" }), e2.closeNode(), t3.comments.forEach((t4, r2) => {
              this.map["v:shape"].render(e2, t4, r2);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset(), this.model = { comments: [] };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.model.comments.push(this.parser.model), this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            e2.anchors.forEach((e3) => {
              e3.br ? this.map["xdr:twoCellAnchor"].reconcile(e3, t3) : this.map["xdr:oneCellAnchor"].reconcile(e3, t3);
            });
          }
        }
        o.DRAWING_ATTRIBUTES = { "xmlns:v": "urn:schemas-microsoft-com:vml", "xmlns:o": "urn:schemas-microsoft-com:office:office", "xmlns:x": "urn:schemas-microsoft-com:office:excel" }, t2.exports = o;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./vml-shape-xform": 46 }], 46: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./vml-textbox-xform"), s = e("./vml-client-data-xform");
        class o extends n {
          constructor() {
            super(), this.map = { "v:textbox": new i(), "x:ClientData": new s() };
          }
          get tag() {
            return "v:shape";
          }
          render(e2, t3, r2) {
            e2.openNode("v:shape", o.V_SHAPE_ATTRIBUTES(t3, r2)), e2.leafNode("v:fill", { color2: "infoBackground [80]" }), e2.leafNode("v:shadow", { color: "none [81]", obscured: "t" }), e2.leafNode("v:path", { "o:connecttype": "none" }), this.map["v:textbox"].render(e2, t3), this.map["x:ClientData"].render(e2, t3), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset(), this.model = { margins: { insetmode: e2.attributes["o:insetmode"] }, anchor: "", editAs: "", protection: {} };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset, this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection, this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor, this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs, false;
              default:
                return true;
            }
          }
        }
        o.V_SHAPE_ATTRIBUTES = (e2, t3) => ({ id: "_x0000_s" + (1025 + t3), type: "#_x0000_t202", style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden", fillcolor: "infoBackground [80]", strokecolor: "none [81]", "o:insetmode": e2.note.margins && e2.note.margins.insetmode }), t2.exports = o;
      }, { "../base-xform": 32, "./vml-client-data-xform": 44, "./vml-textbox-xform": 47 }], 47: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "v:textbox";
          }
          conversionUnit(e2, t3, r2) {
            return `${parseFloat(e2) * t3.toFixed(2)}${r2}`;
          }
          reverseConversionUnit(e2) {
            return (e2 || "").split(",").map((e3) => Number(parseFloat(this.conversionUnit(parseFloat(e3), 0.1, "")).toFixed(2)));
          }
          render(e2, t3) {
            const r2 = { style: "mso-direction-alt:auto" };
            if (t3 && t3.note) {
              let { inset: e3 } = t3.note && t3.note.margins;
              Array.isArray(e3) && (e3 = e3.map((e4) => this.conversionUnit(e4, 10, "mm")).join(",")), e3 && (r2.inset = e3);
            }
            e2.openNode("v:textbox", r2), e2.leafNode("div", { style: "text-align:left" }), e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { inset: this.reverseConversionUnit(e2.attributes.inset) }, true;
              default:
                return true;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32 }], 48: [function(e, t2, r) {
        const n = e("./base-xform");
        t2.exports = class extends n {
          createNewModel(e2) {
            return {};
          }
          parseOpen(e2) {
            return this.parser = this.parser || this.map[e2.name], this.parser ? (this.parser.parseOpen(e2), true) : e2.name === this.tag && (this.model = this.createNewModel(e2), true);
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          onParserClose(e2, t3) {
            this.model[e2] = t3.model;
          }
          parseClose(e2) {
            return this.parser ? (this.parser.parseClose(e2) || (this.onParserClose(e2, this.parser), this.parser = void 0), true) : e2 !== this.tag;
          }
        };
      }, { "./base-xform": 32 }], 49: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            e2.openNode("HeadingPairs"), e2.openNode("vt:vector", { size: 2, baseType: "variant" }), e2.openNode("vt:variant"), e2.leafNode("vt:lpstr", void 0, "Worksheets"), e2.closeNode(), e2.openNode("vt:variant"), e2.leafNode("vt:i4", void 0, t3.length), e2.closeNode(), e2.closeNode(), e2.closeNode();
          }
          parseOpen(e2) {
            return "HeadingPairs" === e2.name;
          }
          parseText() {
          }
          parseClose(e2) {
            return "HeadingPairs" !== e2;
          }
        };
      }, { "../base-xform": 32 }], 50: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            e2.openNode("TitlesOfParts"), e2.openNode("vt:vector", { size: t3.length, baseType: "lpstr" }), t3.forEach((t4) => {
              e2.leafNode("vt:lpstr", void 0, t4.name);
            }), e2.closeNode(), e2.closeNode();
          }
          parseOpen(e2) {
            return "TitlesOfParts" === e2.name;
          }
          parseText() {
          }
          parseClose(e2) {
            return "TitlesOfParts" !== e2;
          }
        };
      }, { "../base-xform": 32 }], 51: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("../simple/string-xform"), o = e("./app-heading-pairs-xform"), a = e("./app-titles-of-parts-xform");
        class l extends i {
          constructor() {
            super(), this.map = { Company: new s({ tag: "Company" }), Manager: new s({ tag: "Manager" }), HeadingPairs: new o(), TitleOfParts: new a() };
          }
          render(e2, t3) {
            e2.openXml(n.StdDocAttributes), e2.openNode("Properties", l.PROPERTY_ATTRIBUTES), e2.leafNode("Application", void 0, "Microsoft Excel"), e2.leafNode("DocSecurity", void 0, "0"), e2.leafNode("ScaleCrop", void 0, "false"), this.map.HeadingPairs.render(e2, t3.worksheets), this.map.TitleOfParts.render(e2, t3.worksheets), this.map.Company.render(e2, t3.company || ""), this.map.Manager.render(e2, t3.manager), e2.leafNode("LinksUpToDate", void 0, "false"), e2.leafNode("SharedDoc", void 0, "false"), e2.leafNode("HyperlinksChanged", void 0, "false"), e2.leafNode("AppVersion", void 0, "16.0300"), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "Properties":
                return true;
              default:
                return this.parser = this.map[e2.name], !!this.parser && (this.parser.parseOpen(e2), true);
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case "Properties":
                return this.model = { worksheets: this.map.TitleOfParts.model, company: this.map.Company.model, manager: this.map.Manager.model }, false;
              default:
                return true;
            }
          }
        }
        l.DateFormat = function(e2) {
          return e2.toISOString().replace(/[.]\d{3,6}/, "");
        }, l.DateAttrs = { "xsi:type": "dcterms:W3CDTF" }, l.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties", "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes" }, t2.exports = l;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../simple/string-xform": 119, "./app-heading-pairs-xform": 49, "./app-titles-of-parts-xform": 50 }], 52: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform");
        class s extends i {
          render(e2, t3) {
            e2.openXml(n.StdDocAttributes), e2.openNode("Types", s.PROPERTY_ATTRIBUTES);
            const r2 = {};
            (t3.media || []).forEach((t4) => {
              if ("image" === t4.type) {
                const n2 = t4.extension;
                r2[n2] || (r2[n2] = true, e2.leafNode("Default", { Extension: n2, ContentType: "image/" + n2 }));
              }
            }), e2.leafNode("Default", { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" }), e2.leafNode("Default", { Extension: "xml", ContentType: "application/xml" }), e2.leafNode("Override", { PartName: "/xl/workbook.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" }), t3.worksheets.forEach((t4) => {
              const r3 = `/xl/worksheets/sheet${t4.id}.xml`;
              e2.leafNode("Override", { PartName: r3, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" });
            }), e2.leafNode("Override", { PartName: "/xl/theme/theme1.xml", ContentType: "application/vnd.openxmlformats-officedocument.theme+xml" }), e2.leafNode("Override", { PartName: "/xl/styles.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" });
            t3.sharedStrings && t3.sharedStrings.count && e2.leafNode("Override", { PartName: "/xl/sharedStrings.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" }), t3.tables && t3.tables.forEach((t4) => {
              e2.leafNode("Override", { PartName: "/xl/tables/" + t4.target, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml" });
            }), t3.drawings && t3.drawings.forEach((t4) => {
              e2.leafNode("Override", { PartName: `/xl/drawings/${t4.name}.xml`, ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml" });
            }), t3.commentRefs && (e2.leafNode("Default", { Extension: "vml", ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing" }), t3.commentRefs.forEach((t4) => {
              let { commentName: r3 } = t4;
              e2.leafNode("Override", { PartName: `/xl/${r3}.xml`, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml" });
            })), e2.leafNode("Override", { PartName: "/docProps/core.xml", ContentType: "application/vnd.openxmlformats-package.core-properties+xml" }), e2.leafNode("Override", { PartName: "/docProps/app.xml", ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml" }), e2.closeNode();
          }
          parseOpen() {
            return false;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        }
        s.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/content-types" }, t2.exports = s;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32 }], 53: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("../simple/date-xform"), o = e("../simple/string-xform"), a = e("../simple/integer-xform");
        class l extends i {
          constructor() {
            super(), this.map = { "dc:creator": new o({ tag: "dc:creator" }), "dc:title": new o({ tag: "dc:title" }), "dc:subject": new o({ tag: "dc:subject" }), "dc:description": new o({ tag: "dc:description" }), "dc:identifier": new o({ tag: "dc:identifier" }), "dc:language": new o({ tag: "dc:language" }), "cp:keywords": new o({ tag: "cp:keywords" }), "cp:category": new o({ tag: "cp:category" }), "cp:lastModifiedBy": new o({ tag: "cp:lastModifiedBy" }), "cp:lastPrinted": new s({ tag: "cp:lastPrinted", format: l.DateFormat }), "cp:revision": new a({ tag: "cp:revision" }), "cp:version": new o({ tag: "cp:version" }), "cp:contentStatus": new o({ tag: "cp:contentStatus" }), "cp:contentType": new o({ tag: "cp:contentType" }), "dcterms:created": new s({ tag: "dcterms:created", attrs: l.DateAttrs, format: l.DateFormat }), "dcterms:modified": new s({ tag: "dcterms:modified", attrs: l.DateAttrs, format: l.DateFormat }) };
          }
          render(e2, t3) {
            e2.openXml(n.StdDocAttributes), e2.openNode("cp:coreProperties", l.CORE_PROPERTY_ATTRIBUTES), this.map["dc:creator"].render(e2, t3.creator), this.map["dc:title"].render(e2, t3.title), this.map["dc:subject"].render(e2, t3.subject), this.map["dc:description"].render(e2, t3.description), this.map["dc:identifier"].render(e2, t3.identifier), this.map["dc:language"].render(e2, t3.language), this.map["cp:keywords"].render(e2, t3.keywords), this.map["cp:category"].render(e2, t3.category), this.map["cp:lastModifiedBy"].render(e2, t3.lastModifiedBy), this.map["cp:lastPrinted"].render(e2, t3.lastPrinted), this.map["cp:revision"].render(e2, t3.revision), this.map["cp:version"].render(e2, t3.version), this.map["cp:contentStatus"].render(e2, t3.contentStatus), this.map["cp:contentType"].render(e2, t3.contentType), this.map["dcterms:created"].render(e2, t3.created), this.map["dcterms:modified"].render(e2, t3.modified), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "cp:coreProperties":
              case "coreProperties":
                return true;
              default:
                if (this.parser = this.map[e2.name], this.parser) return this.parser.parseOpen(e2), true;
                throw new Error("Unexpected xml node in parseOpen: " + JSON.stringify(e2));
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case "cp:coreProperties":
              case "coreProperties":
                return this.model = { creator: this.map["dc:creator"].model, title: this.map["dc:title"].model, subject: this.map["dc:subject"].model, description: this.map["dc:description"].model, identifier: this.map["dc:identifier"].model, language: this.map["dc:language"].model, keywords: this.map["cp:keywords"].model, category: this.map["cp:category"].model, lastModifiedBy: this.map["cp:lastModifiedBy"].model, lastPrinted: this.map["cp:lastPrinted"].model, revision: this.map["cp:revision"].model, contentStatus: this.map["cp:contentStatus"].model, contentType: this.map["cp:contentType"].model, created: this.map["dcterms:created"].model, modified: this.map["dcterms:modified"].model }, false;
              default:
                throw new Error("Unexpected xml node in parseClose: " + e2);
            }
          }
        }
        l.DateFormat = function(e2) {
          return e2.toISOString().replace(/[.]\d{3}/, "");
        }, l.DateAttrs = { "xsi:type": "dcterms:W3CDTF" }, l.CORE_PROPERTY_ATTRIBUTES = { "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties", "xmlns:dc": "http://purl.org/dc/elements/1.1/", "xmlns:dcterms": "http://purl.org/dc/terms/", "xmlns:dcmitype": "http://purl.org/dc/dcmitype/", "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance" }, t2.exports = l;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../simple/date-xform": 117, "../simple/integer-xform": 118, "../simple/string-xform": 119 }], 54: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          render(e2, t3) {
            e2.leafNode("Relationship", t3);
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "Relationship":
                return this.model = e2.attributes, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 55: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("./relationship-xform");
        class o extends i {
          constructor() {
            super(), this.map = { Relationship: new s() };
          }
          render(e2, t3) {
            t3 = t3 || this._values, e2.openXml(n.StdDocAttributes), e2.openNode("Relationships", o.RELATIONSHIPS_ATTRIBUTES), t3.forEach((t4) => {
              this.map.Relationship.render(e2, t4);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "Relationships":
                return this.model = [], true;
              default:
                if (this.parser = this.map[e2.name], this.parser) return this.parser.parseOpen(e2), true;
                throw new Error("Unexpected xml node in parseOpen: " + JSON.stringify(e2));
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.model.push(this.parser.model), this.parser = void 0), true;
            switch (e2) {
              case "Relationships":
                return false;
              default:
                throw new Error("Unexpected xml node in parseClose: " + e2);
            }
          }
        }
        o.RELATIONSHIPS_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/relationships" }, t2.exports = o;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./relationship-xform": 54 }], 56: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset(), this.model = { range: { editAs: e2.attributes.editAs || "oneCell" } };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          reconcilePicture(e2, t3) {
            if (e2 && e2.rId) {
              const r2 = t3.rels[e2.rId].Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
              if (r2) {
                const e3 = r2[1], n2 = t3.mediaIndex[e3];
                return t3.media[n2];
              }
            }
          }
        };
      }, { "../base-xform": 32 }], 57: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./blip-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "a:blip": new i() };
          }
          get tag() {
            return "xdr:blipFill";
          }
          render(e2, t3) {
            e2.openNode(this.tag), this.map["a:blip"].render(e2, t3), e2.openNode("a:stretch"), e2.leafNode("a:fillRect"), e2.closeNode(), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset();
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText() {
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model = this.map["a:blip"].model, false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "./blip-xform": 58 }], 58: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "a:blip";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:embed": t3.rId, cstate: "print" });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { rId: e2.attributes["r:embed"] }, true;
              default:
                return true;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32 }], 59: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "xdr:cNvPicPr";
          }
          render(e2) {
            e2.openNode(this.tag), e2.leafNode("a:picLocks", { noChangeAspect: "1" }), e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
              default:
                return true;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32 }], 60: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./hlink-click-xform"), s = e("./ext-lst-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "a:hlinkClick": new i(), "a:extLst": new s() };
          }
          get tag() {
            return "xdr:cNvPr";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { id: t3.index, name: "Picture " + t3.index }), this.map["a:hlinkClick"].render(e2, t3), this.map["a:extLst"].render(e2, t3), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset();
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText() {
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model = this.map["a:hlinkClick"].model, false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "./ext-lst-xform": 63, "./hlink-click-xform": 65 }], 61: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../simple/integer-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.map = { "xdr:col": new i({ tag: "xdr:col", zero: true }), "xdr:colOff": new i({ tag: "xdr:colOff", zero: true }), "xdr:row": new i({ tag: "xdr:row", zero: true }), "xdr:rowOff": new i({ tag: "xdr:rowOff", zero: true }) };
          }
          render(e2, t3) {
            e2.openNode(this.tag), this.map["xdr:col"].render(e2, t3.nativeCol), this.map["xdr:colOff"].render(e2, t3.nativeColOff), this.map["xdr:row"].render(e2, t3.nativeRow), this.map["xdr:rowOff"].render(e2, t3.nativeRowOff), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset();
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model = { nativeCol: this.map["xdr:col"].model, nativeColOff: this.map["xdr:colOff"].model, nativeRow: this.map["xdr:row"].model, nativeRowOff: this.map["xdr:rowOff"].model }, false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "../simple/integer-xform": 118 }], 62: [function(e, t2, r) {
        const n = e("../../../utils/col-cache"), i = e("../../../utils/xml-stream"), s = e("../base-xform"), o = e("./two-cell-anchor-xform"), a = e("./one-cell-anchor-xform");
        class l extends s {
          constructor() {
            super(), this.map = { "xdr:twoCellAnchor": new o(), "xdr:oneCellAnchor": new a() };
          }
          prepare(e2) {
            e2.anchors.forEach((e3, t3) => {
              e3.anchorType = (function(e4) {
                return ("string" == typeof e4.range ? n.decode(e4.range) : e4.range).br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
              })(e3);
              this.map[e3.anchorType].prepare(e3, { index: t3 });
            });
          }
          get tag() {
            return "xdr:wsDr";
          }
          render(e2, t3) {
            e2.openXml(i.StdDocAttributes), e2.openNode(this.tag, l.DRAWING_ATTRIBUTES), t3.anchors.forEach((t4) => {
              this.map[t4.anchorType].render(e2, t4);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset(), this.model = { anchors: [] };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.model.anchors.push(this.parser.model), this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            e2.anchors.forEach((e3) => {
              e3.br ? this.map["xdr:twoCellAnchor"].reconcile(e3, t3) : this.map["xdr:oneCellAnchor"].reconcile(e3, t3);
            });
          }
        }
        l.DRAWING_ATTRIBUTES = { "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing", "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main" }, t2.exports = l;
      }, { "../../../utils/col-cache": 19, "../../../utils/xml-stream": 28, "../base-xform": 32, "./one-cell-anchor-xform": 67, "./two-cell-anchor-xform": 70 }], 63: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "a:extLst";
          }
          render(e2) {
            e2.openNode(this.tag), e2.openNode("a:ext", { uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}" }), e2.leafNode("a16:creationId", { "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main", id: "{00000000-0008-0000-0000-000002000000}" }), e2.closeNode(), e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
              default:
                return true;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32 }], 64: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.map = {};
          }
          render(e2, t3) {
            e2.openNode(this.tag);
            const r2 = Math.floor(9525 * t3.width), n2 = Math.floor(9525 * t3.height);
            e2.addAttribute("cx", r2), e2.addAttribute("cy", n2), e2.closeNode();
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.model = { width: parseInt(e2.attributes.cx || "0", 10) / 9525, height: parseInt(e2.attributes.cy || "0", 10) / 9525 }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 65: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "a:hlinkClick";
          }
          render(e2, t3) {
            t3.hyperlinks && t3.hyperlinks.rId && e2.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:id": t3.hyperlinks.rId, tooltip: t3.hyperlinks.tooltip });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { hyperlinks: { rId: e2.attributes["r:id"], tooltip: e2.attributes.tooltip } }, true;
              default:
                return true;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 66: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./c-nv-pr-xform"), s = e("./c-nv-pic-pr-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xdr:cNvPr": new i(), "xdr:cNvPicPr": new s() };
          }
          get tag() {
            return "xdr:nvPicPr";
          }
          render(e2, t3) {
            e2.openNode(this.tag), this.map["xdr:cNvPr"].render(e2, t3), this.map["xdr:cNvPicPr"].render(e2, t3), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset();
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText() {
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model = this.map["xdr:cNvPr"].model, false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "./c-nv-pic-pr-xform": 59, "./c-nv-pr-xform": 60 }], 67: [function(e, t2, r) {
        const n = e("./base-cell-anchor-xform"), i = e("../static-xform"), s = e("./cell-position-xform"), o = e("./ext-xform"), a = e("./pic-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xdr:from": new s({ tag: "xdr:from" }), "xdr:ext": new o({ tag: "xdr:ext" }), "xdr:pic": new a(), "xdr:clientData": new i({ tag: "xdr:clientData" }) };
          }
          get tag() {
            return "xdr:oneCellAnchor";
          }
          prepare(e2, t3) {
            this.map["xdr:pic"].prepare(e2.picture, t3);
          }
          render(e2, t3) {
            e2.openNode(this.tag, { editAs: t3.range.editAs || "oneCell" }), this.map["xdr:from"].render(e2, t3.range.tl), this.map["xdr:ext"].render(e2, t3.range.ext), this.map["xdr:pic"].render(e2, t3.picture), this.map["xdr:clientData"].render(e2, {}), e2.closeNode();
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model.range.tl = this.map["xdr:from"].model, this.model.range.ext = this.map["xdr:ext"].model, this.model.picture = this.map["xdr:pic"].model, false;
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            e2.medium = this.reconcilePicture(e2.picture, t3);
          }
        };
      }, { "../static-xform": 120, "./base-cell-anchor-xform": 56, "./cell-position-xform": 61, "./ext-xform": 64, "./pic-xform": 68 }], 68: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../static-xform"), s = e("./blip-fill-xform"), o = e("./nv-pic-pr-xform"), a = e("./sp-pr");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xdr:nvPicPr": new o(), "xdr:blipFill": new s(), "xdr:spPr": new i(a) };
          }
          get tag() {
            return "xdr:pic";
          }
          prepare(e2, t3) {
            e2.index = t3.index + 1;
          }
          render(e2, t3) {
            e2.openNode(this.tag), this.map["xdr:nvPicPr"].render(e2, t3), this.map["xdr:blipFill"].render(e2, t3), this.map["xdr:spPr"].render(e2, t3), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                this.reset();
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText() {
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.mergeModel(this.parser.model), this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "../static-xform": 120, "./blip-fill-xform": 57, "./nv-pic-pr-xform": 66, "./sp-pr": 69 }], 69: [function(e, t2, r) {
        t2.exports = { tag: "xdr:spPr", c: [{ tag: "a:xfrm", c: [{ tag: "a:off", $: { x: "0", y: "0" } }, { tag: "a:ext", $: { cx: "0", cy: "0" } }] }, { tag: "a:prstGeom", $: { prst: "rect" }, c: [{ tag: "a:avLst" }] }] };
      }, {}], 70: [function(e, t2, r) {
        const n = e("./base-cell-anchor-xform"), i = e("../static-xform"), s = e("./cell-position-xform"), o = e("./pic-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xdr:from": new s({ tag: "xdr:from" }), "xdr:to": new s({ tag: "xdr:to" }), "xdr:pic": new o(), "xdr:clientData": new i({ tag: "xdr:clientData" }) };
          }
          get tag() {
            return "xdr:twoCellAnchor";
          }
          prepare(e2, t3) {
            this.map["xdr:pic"].prepare(e2.picture, t3);
          }
          render(e2, t3) {
            e2.openNode(this.tag, { editAs: t3.range.editAs || "oneCell" }), this.map["xdr:from"].render(e2, t3.range.tl), this.map["xdr:to"].render(e2, t3.range.br), this.map["xdr:pic"].render(e2, t3.picture), this.map["xdr:clientData"].render(e2, {}), e2.closeNode();
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model.range.tl = this.map["xdr:from"].model, this.model.range.br = this.map["xdr:to"].model, this.model.picture = this.map["xdr:pic"].model, false;
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            e2.medium = this.reconcilePicture(e2.picture, t3);
          }
        };
      }, { "../static-xform": 120, "./base-cell-anchor-xform": 56, "./cell-position-xform": 61, "./pic-xform": 68 }], 71: [function(e, t2, r) {
        const n = e("./base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.always = !!e2.always, this.count = e2.count, this.empty = e2.empty, this.$count = e2.$count || "count", this.$ = e2.$, this.childXform = e2.childXform, this.maxItems = e2.maxItems;
          }
          prepare(e2, t3) {
            const { childXform: r2 } = this;
            e2 && e2.forEach((e3, n2) => {
              t3.index = n2, r2.prepare(e3, t3);
            });
          }
          render(e2, t3) {
            if (this.always || t3 && t3.length) {
              e2.openNode(this.tag, this.$), this.count && e2.addAttribute(this.$count, t3 && t3.length || 0);
              const { childXform: r2 } = this;
              (t3 || []).forEach((t4, n2) => {
                r2.render(e2, t4, n2);
              }), e2.closeNode();
            } else this.empty && e2.leafNode(this.tag);
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                return this.model = [], true;
              default:
                return !!this.childXform.parseOpen(e2) && (this.parser = this.childXform, true);
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) {
              if (!this.parser.parseClose(e2) && (this.model.push(this.parser.model), this.parser = void 0, this.maxItems && this.model.length > this.maxItems)) throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
              return true;
            }
            return false;
          }
          reconcile(e2, t3) {
            if (e2) {
              const { childXform: r2 } = this;
              e2.forEach((e3) => {
                r2.reconcile(e3, t3);
              });
            }
          }
        };
      }, { "./base-xform": 32 }], 72: [function(e, t2, r) {
        const n = e("../../../utils/col-cache"), i = e("../base-xform");
        t2.exports = class extends i {
          get tag() {
            return "autoFilter";
          }
          render(e2, t3) {
            if (t3) if ("string" == typeof t3) e2.leafNode("autoFilter", { ref: t3 });
            else {
              const r2 = function(e3) {
                return "string" == typeof e3 ? e3 : n.getAddress(e3.row, e3.column).address;
              }, i2 = r2(t3.from), s = r2(t3.to);
              i2 && s && e2.leafNode("autoFilter", { ref: `${i2}:${s}` });
            }
          }
          parseOpen(e2) {
            "autoFilter" === e2.name && (this.model = e2.attributes.ref);
          }
        };
      }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 73: [function(e, t2, r) {
        const n = e("../../../utils/utils"), i = e("../base-xform"), s = e("../../../doc/range"), o = e("../../../doc/enums"), a = e("../strings/rich-text-xform");
        function l(e2) {
          if (null == e2) return o.ValueType.Null;
          if (e2 instanceof String || "string" == typeof e2) return o.ValueType.String;
          if ("number" == typeof e2) return o.ValueType.Number;
          if ("boolean" == typeof e2) return o.ValueType.Boolean;
          if (e2 instanceof Date) return o.ValueType.Date;
          if (e2.text && e2.hyperlink) return o.ValueType.Hyperlink;
          if (e2.formula) return o.ValueType.Formula;
          if (e2.error) return o.ValueType.Error;
          throw new Error("I could not understand type of value");
        }
        t2.exports = class extends i {
          constructor() {
            super(), this.richTextXForm = new a();
          }
          get tag() {
            return "c";
          }
          prepare(e2, t3) {
            const r2 = t3.styles.addStyleModel(e2.style || {}, (function(e3) {
              switch (e3.type) {
                case o.ValueType.Formula:
                  return l(e3.result);
                default:
                  return e3.type;
              }
            })(e2));
            switch (r2 && (e2.styleId = r2), e2.comment && t3.comments.push({ ...e2.comment, ref: e2.address }), e2.type) {
              case o.ValueType.String:
              case o.ValueType.RichText:
                t3.sharedStrings && (e2.ssId = t3.sharedStrings.add(e2.value));
                break;
              case o.ValueType.Date:
                t3.date1904 && (e2.date1904 = true);
                break;
              case o.ValueType.Hyperlink:
                t3.sharedStrings && void 0 !== e2.text && null !== e2.text && (e2.ssId = t3.sharedStrings.add(e2.text)), t3.hyperlinks.push({ address: e2.address, target: e2.hyperlink, tooltip: e2.tooltip });
                break;
              case o.ValueType.Merge:
                t3.merges.add(e2);
                break;
              case o.ValueType.Formula:
                if (t3.date1904 && (e2.date1904 = true), "shared" === e2.shareType && (e2.si = t3.siFormulae++), e2.formula) t3.formulae[e2.address] = e2;
                else if (e2.sharedFormula) {
                  const r3 = t3.formulae[e2.sharedFormula];
                  if (!r3) throw new Error("Shared Formula master must exist above and or left of clone for cell " + e2.address);
                  void 0 === r3.si ? (r3.shareType = "shared", r3.si = t3.siFormulae++, r3.range = new s(r3.address, e2.address)) : r3.range && r3.range.expandToAddress(e2.address), e2.si = r3.si;
                }
            }
          }
          renderFormula(e2, t3) {
            let r2 = null;
            switch (t3.shareType) {
              case "shared":
                r2 = { t: "shared", ref: t3.ref || t3.range.range, si: t3.si };
                break;
              case "array":
                r2 = { t: "array", ref: t3.ref };
                break;
              default:
                void 0 !== t3.si && (r2 = { t: "shared", si: t3.si });
            }
            switch (l(t3.result)) {
              case o.ValueType.Null:
                e2.leafNode("f", r2, t3.formula);
                break;
              case o.ValueType.String:
                e2.addAttribute("t", "str"), e2.leafNode("f", r2, t3.formula), e2.leafNode("v", null, t3.result);
                break;
              case o.ValueType.Number:
                e2.leafNode("f", r2, t3.formula), e2.leafNode("v", null, t3.result);
                break;
              case o.ValueType.Boolean:
                e2.addAttribute("t", "b"), e2.leafNode("f", r2, t3.formula), e2.leafNode("v", null, t3.result ? 1 : 0);
                break;
              case o.ValueType.Error:
                e2.addAttribute("t", "e"), e2.leafNode("f", r2, t3.formula), e2.leafNode("v", null, t3.result.error);
                break;
              case o.ValueType.Date:
                e2.leafNode("f", r2, t3.formula), e2.leafNode("v", null, n.dateToExcel(t3.result, t3.date1904));
                break;
              default:
                throw new Error("I could not understand type of value");
            }
          }
          render(e2, t3) {
            if (t3.type !== o.ValueType.Null || t3.styleId) {
              switch (e2.openNode("c"), e2.addAttribute("r", t3.address), t3.styleId && e2.addAttribute("s", t3.styleId), t3.type) {
                case o.ValueType.Null:
                  break;
                case o.ValueType.Number:
                  e2.leafNode("v", null, t3.value);
                  break;
                case o.ValueType.Boolean:
                  e2.addAttribute("t", "b"), e2.leafNode("v", null, t3.value ? "1" : "0");
                  break;
                case o.ValueType.Error:
                  e2.addAttribute("t", "e"), e2.leafNode("v", null, t3.value.error);
                  break;
                case o.ValueType.String:
                case o.ValueType.RichText:
                  void 0 !== t3.ssId ? (e2.addAttribute("t", "s"), e2.leafNode("v", null, t3.ssId)) : t3.value && t3.value.richText ? (e2.addAttribute("t", "inlineStr"), e2.openNode("is"), t3.value.richText.forEach((t4) => {
                    this.richTextXForm.render(e2, t4);
                  }), e2.closeNode("is")) : (e2.addAttribute("t", "str"), e2.leafNode("v", null, t3.value));
                  break;
                case o.ValueType.Date:
                  e2.leafNode("v", null, n.dateToExcel(t3.value, t3.date1904));
                  break;
                case o.ValueType.Hyperlink:
                  void 0 !== t3.ssId ? (e2.addAttribute("t", "s"), e2.leafNode("v", null, t3.ssId)) : (e2.addAttribute("t", "str"), e2.leafNode("v", null, t3.text));
                  break;
                case o.ValueType.Formula:
                  this.renderFormula(e2, t3);
                  break;
                case o.ValueType.Merge:
              }
              e2.closeNode();
            }
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "c":
                return this.model = { address: e2.attributes.r }, this.t = e2.attributes.t, e2.attributes.s && (this.model.styleId = parseInt(e2.attributes.s, 10)), true;
              case "f":
                return this.currentNode = "f", this.model.si = e2.attributes.si, this.model.shareType = e2.attributes.t, this.model.ref = e2.attributes.ref, true;
              case "v":
                return this.currentNode = "v", true;
              case "t":
                return this.currentNode = "t", true;
              case "r":
                return this.parser = this.richTextXForm, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            if (this.parser) this.parser.parseText(e2);
            else switch (this.currentNode) {
              case "f":
                this.model.formula = this.model.formula ? this.model.formula + e2 : e2;
                break;
              case "v":
              case "t":
                this.model.value && this.model.value.richText ? this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + e2 : e2 : this.model.value = this.model.value ? this.model.value + e2 : e2;
            }
          }
          parseClose(e2) {
            switch (e2) {
              case "c": {
                const { model: e3 } = this;
                if (e3.formula || e3.shareType) e3.type = o.ValueType.Formula, e3.value && ("str" === this.t ? e3.result = n.xmlDecode(e3.value) : "b" === this.t ? e3.result = 0 !== parseInt(e3.value, 10) : "e" === this.t ? e3.result = { error: e3.value } : e3.result = parseFloat(e3.value), e3.value = void 0);
                else if (void 0 !== e3.value) switch (this.t) {
                  case "s":
                    e3.type = o.ValueType.String, e3.value = parseInt(e3.value, 10);
                    break;
                  case "str":
                    e3.type = o.ValueType.String, e3.value = n.xmlDecode(e3.value);
                    break;
                  case "inlineStr":
                    e3.type = o.ValueType.String;
                    break;
                  case "b":
                    e3.type = o.ValueType.Boolean, e3.value = 0 !== parseInt(e3.value, 10);
                    break;
                  case "e":
                    e3.type = o.ValueType.Error, e3.value = { error: e3.value };
                    break;
                  default:
                    e3.type = o.ValueType.Number, e3.value = parseFloat(e3.value);
                }
                else e3.styleId ? e3.type = o.ValueType.Null : e3.type = o.ValueType.Merge;
                return false;
              }
              case "f":
              case "v":
              case "is":
                return this.currentNode = void 0, true;
              case "t":
                return this.parser ? (this.parser.parseClose(e2), true) : (this.currentNode = void 0, true);
              case "r":
                return this.model.value = this.model.value || {}, this.model.value.richText = this.model.value.richText || [], this.model.value.richText.push(this.parser.model), this.parser = void 0, this.currentNode = void 0, true;
              default:
                return !!this.parser && (this.parser.parseClose(e2), true);
            }
          }
          reconcile(e2, t3) {
            const r2 = e2.styleId && t3.styles && t3.styles.getStyleModel(e2.styleId);
            switch (r2 && (e2.style = r2), void 0 !== e2.styleId && (e2.styleId = void 0), e2.type) {
              case o.ValueType.String:
                "number" == typeof e2.value && t3.sharedStrings && (e2.value = t3.sharedStrings.getString(e2.value)), e2.value.richText && (e2.type = o.ValueType.RichText);
                break;
              case o.ValueType.Number:
                r2 && n.isDateFmt(r2.numFmt) && (e2.type = o.ValueType.Date, e2.value = n.excelToDate(e2.value, t3.date1904));
                break;
              case o.ValueType.Formula:
                void 0 !== e2.result && r2 && n.isDateFmt(r2.numFmt) && (e2.result = n.excelToDate(e2.result, t3.date1904)), "shared" === e2.shareType && (e2.ref ? t3.formulae[e2.si] = e2.address : (e2.sharedFormula = t3.formulae[e2.si], delete e2.shareType), delete e2.si);
            }
            const i2 = t3.hyperlinkMap[e2.address];
            i2 && (e2.type === o.ValueType.Formula ? (e2.text = e2.result, e2.result = void 0) : (e2.text = e2.value, e2.value = void 0), e2.type = o.ValueType.Hyperlink, e2.hyperlink = i2);
            const s2 = t3.commentsMap && t3.commentsMap[e2.address];
            s2 && (e2.comment = s2);
          }
        };
      }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/utils": 27, "../base-xform": 32, "../strings/rich-text-xform": 122 }], 74: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "x14:cfIcon";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, { iconSet: t3.iconSet, iconId: t3.iconId });
          }
          parseOpen(e2) {
            let { attributes: t3 } = e2;
            this.model = { iconSet: t3.iconSet, iconId: n.toIntValue(t3.iconId) };
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        };
      }, { "../../base-xform": 32 }], 75: [function(e, t2, r) {
        const { v4: n } = e("uuid"), i = e("../../base-xform"), s = e("../../composite-xform"), o = e("./databar-ext-xform"), a = e("./icon-set-ext-xform"), l = { "3Triangles": true, "3Stars": true, "5Boxes": true };
        class c extends s {
          constructor() {
            super(), this.map = { "x14:dataBar": this.databarXform = new o(), "x14:iconSet": this.iconSetXform = new a() };
          }
          get tag() {
            return "x14:cfRule";
          }
          static isExt(e2) {
            return "dataBar" === e2.type ? o.isExt(e2) : !("iconSet" !== e2.type || !e2.custom && !l[e2.iconSet]);
          }
          prepare(e2) {
            c.isExt(e2) && (e2.x14Id = `{${n()}}`.toUpperCase());
          }
          render(e2, t3) {
            if (c.isExt(t3)) switch (t3.type) {
              case "dataBar":
                this.renderDataBar(e2, t3);
                break;
              case "iconSet":
                this.renderIconSet(e2, t3);
            }
          }
          renderDataBar(e2, t3) {
            e2.openNode(this.tag, { type: "dataBar", id: t3.x14Id }), this.databarXform.render(e2, t3), e2.closeNode();
          }
          renderIconSet(e2, t3) {
            e2.openNode(this.tag, { type: "iconSet", priority: t3.priority, id: t3.x14Id || `{${n()}}` }), this.iconSetXform.render(e2, t3), e2.closeNode();
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { type: t3.type, x14Id: t3.id, priority: i.toIntValue(t3.priority) };
          }
          onParserClose(e2, t3) {
            Object.assign(this.model, t3.model);
          }
        }
        t2.exports = c;
      }, { "../../base-xform": 32, "../../composite-xform": 48, "./databar-ext-xform": 79, "./icon-set-ext-xform": 81, uuid: 528 }], 76: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("./f-ext-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xm:f": this.fExtXform = new i() };
          }
          get tag() {
            return "x14:cfvo";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { type: t3.type }), void 0 !== t3.value && this.fExtXform.render(e2, t3.value), e2.closeNode();
          }
          createNewModel(e2) {
            return { type: e2.attributes.type };
          }
          onParserClose(e2, t3) {
            switch (e2) {
              case "xm:f":
                this.model.value = t3.model ? parseFloat(t3.model) : 0;
            }
          }
        };
      }, { "../../composite-xform": 48, "./f-ext-xform": 80 }], 77: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("./sqref-ext-xform"), s = e("./cf-rule-ext-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "xm:sqref": this.sqRef = new i(), "x14:cfRule": this.cfRule = new s() };
          }
          get tag() {
            return "x14:conditionalFormatting";
          }
          prepare(e2, t3) {
            e2.rules.forEach((e3) => {
              this.cfRule.prepare(e3, t3);
            });
          }
          render(e2, t3) {
            t3.rules.some(s.isExt) && (e2.openNode(this.tag, { "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main" }), t3.rules.filter(s.isExt).forEach((t4) => this.cfRule.render(e2, t4)), this.sqRef.render(e2, t3.ref), e2.closeNode());
          }
          createNewModel() {
            return { rules: [] };
          }
          onParserClose(e2, t3) {
            switch (e2) {
              case "xm:sqref":
                this.model.ref = t3.model;
                break;
              case "x14:cfRule":
                this.model.rules.push(t3.model);
            }
          }
        };
      }, { "../../composite-xform": 48, "./cf-rule-ext-xform": 75, "./sqref-ext-xform": 82 }], 78: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("./cf-rule-ext-xform"), s = e("./conditional-formatting-ext-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { "x14:conditionalFormatting": this.cfXform = new s() };
          }
          get tag() {
            return "x14:conditionalFormattings";
          }
          hasContent(e2) {
            return void 0 === e2.hasExtContent && (e2.hasExtContent = e2.some((e3) => e3.rules.some(i.isExt))), e2.hasExtContent;
          }
          prepare(e2, t3) {
            e2.forEach((e3) => {
              this.cfXform.prepare(e3, t3);
            });
          }
          render(e2, t3) {
            this.hasContent(t3) && (e2.openNode(this.tag), t3.forEach((t4) => this.cfXform.render(e2, t4)), e2.closeNode());
          }
          createNewModel() {
            return [];
          }
          onParserClose(e2, t3) {
            this.model.push(t3.model);
          }
        };
      }, { "../../composite-xform": 48, "./cf-rule-ext-xform": 75, "./conditional-formatting-ext-xform": 77 }], 79: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("../../composite-xform"), s = e("../../style/color-xform"), o = e("./cfvo-ext-xform");
        t2.exports = class extends i {
          constructor() {
            super(), this.map = { "x14:cfvo": this.cfvoXform = new o(), "x14:borderColor": this.borderColorXform = new s("x14:borderColor"), "x14:negativeBorderColor": this.negativeBorderColorXform = new s("x14:negativeBorderColor"), "x14:negativeFillColor": this.negativeFillColorXform = new s("x14:negativeFillColor"), "x14:axisColor": this.axisColorXform = new s("x14:axisColor") };
          }
          static isExt(e2) {
            return !e2.gradient;
          }
          get tag() {
            return "x14:dataBar";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { minLength: n.toIntAttribute(t3.minLength, 0, true), maxLength: n.toIntAttribute(t3.maxLength, 100, true), border: n.toBoolAttribute(t3.border, false), gradient: n.toBoolAttribute(t3.gradient, true), negativeBarColorSameAsPositive: n.toBoolAttribute(t3.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: n.toBoolAttribute(t3.negativeBarBorderColorSameAsPositive, true), axisPosition: n.toAttribute(t3.axisPosition, "auto"), direction: n.toAttribute(t3.direction, "leftToRight") }), t3.cfvo.forEach((t4) => {
              this.cfvoXform.render(e2, t4);
            }), this.borderColorXform.render(e2, t3.borderColor), this.negativeBorderColorXform.render(e2, t3.negativeBorderColor), this.negativeFillColorXform.render(e2, t3.negativeFillColor), this.axisColorXform.render(e2, t3.axisColor), e2.closeNode();
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { cfvo: [], minLength: n.toIntValue(t3.minLength, 0), maxLength: n.toIntValue(t3.maxLength, 100), border: n.toBoolValue(t3.border, false), gradient: n.toBoolValue(t3.gradient, true), negativeBarColorSameAsPositive: n.toBoolValue(t3.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: n.toBoolValue(t3.negativeBarBorderColorSameAsPositive, true), axisPosition: n.toStringValue(t3.axisPosition, "auto"), direction: n.toStringValue(t3.direction, "leftToRight") };
          }
          onParserClose(e2, t3) {
            const [, r2] = e2.split(":");
            switch (r2) {
              case "cfvo":
                this.model.cfvo.push(t3.model);
                break;
              default:
                this.model[r2] = t3.model;
            }
          }
        };
      }, { "../../base-xform": 32, "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-ext-xform": 76 }], 80: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "xm:f";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, null, t3);
          }
          parseOpen() {
            this.model = "";
          }
          parseText(e2) {
            this.model += e2;
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        };
      }, { "../../base-xform": 32 }], 81: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("../../composite-xform"), s = e("./cfvo-ext-xform"), o = e("./cf-icon-ext-xform");
        t2.exports = class extends i {
          constructor() {
            super(), this.map = { "x14:cfvo": this.cfvoXform = new s(), "x14:cfIcon": this.cfIconXform = new o() };
          }
          get tag() {
            return "x14:iconSet";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { iconSet: n.toStringAttribute(t3.iconSet), reverse: n.toBoolAttribute(t3.reverse, false), showValue: n.toBoolAttribute(t3.showValue, true), custom: n.toBoolAttribute(t3.icons, false) }), t3.cfvo.forEach((t4) => {
              this.cfvoXform.render(e2, t4);
            }), t3.icons && t3.icons.forEach((t4, r2) => {
              t4.iconId = r2, this.cfIconXform.render(e2, t4);
            }), e2.closeNode();
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { cfvo: [], iconSet: n.toStringValue(t3.iconSet, "3TrafficLights"), reverse: n.toBoolValue(t3.reverse, false), showValue: n.toBoolValue(t3.showValue, true) };
          }
          onParserClose(e2, t3) {
            const [, r2] = e2.split(":");
            switch (r2) {
              case "cfvo":
                this.model.cfvo.push(t3.model);
                break;
              case "cfIcon":
                this.model.icons || (this.model.icons = []), this.model.icons.push(t3.model);
                break;
              default:
                this.model[r2] = t3.model;
            }
          }
        };
      }, { "../../base-xform": 32, "../../composite-xform": 48, "./cf-icon-ext-xform": 74, "./cfvo-ext-xform": 76 }], 82: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "xm:sqref";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, null, t3);
          }
          parseOpen() {
            this.model = "";
          }
          parseText(e2) {
            this.model += e2;
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        };
      }, { "../../base-xform": 32 }], 83: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("../../composite-xform"), s = e("../../../../doc/range"), o = e("./databar-xform"), a = e("./ext-lst-ref-xform"), l = e("./formula-xform"), c = e("./color-scale-xform"), u = e("./icon-set-xform"), h = { "3Triangles": true, "3Stars": true, "5Boxes": true }, f = (e2) => {
          const { type: t3, operator: r2 } = e2;
          switch (t3) {
            case "containsText":
            case "containsBlanks":
            case "notContainsBlanks":
            case "containsErrors":
            case "notContainsErrors":
              return { type: "containsText", operator: t3 };
            default:
              return { type: t3, operator: r2 };
          }
        };
        class d extends i {
          constructor() {
            super(), this.map = { dataBar: this.databarXform = new o(), extLst: this.extLstRefXform = new a(), formula: this.formulaXform = new l(), colorScale: this.colorScaleXform = new c(), iconSet: this.iconSetXform = new u() };
          }
          get tag() {
            return "cfRule";
          }
          static isPrimitive(e2) {
            return "iconSet" !== e2.type || !e2.custom && !h[e2.iconSet];
          }
          render(e2, t3) {
            switch (t3.type) {
              case "expression":
                this.renderExpression(e2, t3);
                break;
              case "cellIs":
                this.renderCellIs(e2, t3);
                break;
              case "top10":
                this.renderTop10(e2, t3);
                break;
              case "aboveAverage":
                this.renderAboveAverage(e2, t3);
                break;
              case "dataBar":
                this.renderDataBar(e2, t3);
                break;
              case "colorScale":
                this.renderColorScale(e2, t3);
                break;
              case "iconSet":
                this.renderIconSet(e2, t3);
                break;
              case "containsText":
                this.renderText(e2, t3);
                break;
              case "timePeriod":
                this.renderTimePeriod(e2, t3);
            }
          }
          renderExpression(e2, t3) {
            e2.openNode(this.tag, { type: "expression", dxfId: t3.dxfId, priority: t3.priority }), this.formulaXform.render(e2, t3.formulae[0]), e2.closeNode();
          }
          renderCellIs(e2, t3) {
            e2.openNode(this.tag, { type: "cellIs", dxfId: t3.dxfId, priority: t3.priority, operator: t3.operator }), t3.formulae.forEach((t4) => {
              this.formulaXform.render(e2, t4);
            }), e2.closeNode();
          }
          renderTop10(e2, t3) {
            e2.leafNode(this.tag, { type: "top10", dxfId: t3.dxfId, priority: t3.priority, percent: n.toBoolAttribute(t3.percent, false), bottom: n.toBoolAttribute(t3.bottom, false), rank: n.toIntValue(t3.rank, 10, true) });
          }
          renderAboveAverage(e2, t3) {
            e2.leafNode(this.tag, { type: "aboveAverage", dxfId: t3.dxfId, priority: t3.priority, aboveAverage: n.toBoolAttribute(t3.aboveAverage, true) });
          }
          renderDataBar(e2, t3) {
            e2.openNode(this.tag, { type: "dataBar", priority: t3.priority }), this.databarXform.render(e2, t3), this.extLstRefXform.render(e2, t3), e2.closeNode();
          }
          renderColorScale(e2, t3) {
            e2.openNode(this.tag, { type: "colorScale", priority: t3.priority }), this.colorScaleXform.render(e2, t3), e2.closeNode();
          }
          renderIconSet(e2, t3) {
            d.isPrimitive(t3) && (e2.openNode(this.tag, { type: "iconSet", priority: t3.priority }), this.iconSetXform.render(e2, t3), e2.closeNode());
          }
          renderText(e2, t3) {
            e2.openNode(this.tag, { type: t3.operator, dxfId: t3.dxfId, priority: t3.priority, operator: n.toStringAttribute(t3.operator, "containsText") });
            const r2 = ((e3) => {
              if (e3.formulae && e3.formulae[0]) return e3.formulae[0];
              const t4 = new s(e3.ref), { tl: r3 } = t4;
              switch (e3.operator) {
                case "containsText":
                  return `NOT(ISERROR(SEARCH("${e3.text}",${r3})))`;
                case "containsBlanks":
                  return `LEN(TRIM(${r3}))=0`;
                case "notContainsBlanks":
                  return `LEN(TRIM(${r3}))>0`;
                case "containsErrors":
                  return `ISERROR(${r3})`;
                case "notContainsErrors":
                  return `NOT(ISERROR(${r3}))`;
                default:
                  return;
              }
            })(t3);
            r2 && this.formulaXform.render(e2, r2), e2.closeNode();
          }
          renderTimePeriod(e2, t3) {
            e2.openNode(this.tag, { type: "timePeriod", dxfId: t3.dxfId, priority: t3.priority, timePeriod: t3.timePeriod });
            const r2 = ((e3) => {
              if (e3.formulae && e3.formulae[0]) return e3.formulae[0];
              const t4 = new s(e3.ref), { tl: r3 } = t4;
              switch (e3.timePeriod) {
                case "thisWeek":
                  return `AND(TODAY()-ROUNDDOWN(${r3},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${r3},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
                case "lastWeek":
                  return `AND(TODAY()-ROUNDDOWN(${r3},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${r3},0)<(WEEKDAY(TODAY())+7))`;
                case "nextWeek":
                  return `AND(ROUNDDOWN(${r3},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${r3},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
                case "yesterday":
                  return `FLOOR(${r3},1)=TODAY()-1`;
                case "today":
                  return `FLOOR(${r3},1)=TODAY()`;
                case "tomorrow":
                  return `FLOOR(${r3},1)=TODAY()+1`;
                case "last7Days":
                  return `AND(TODAY()-FLOOR(${r3},1)<=6,FLOOR(${r3},1)<=TODAY())`;
                case "lastMonth":
                  return `AND(MONTH(${r3})=MONTH(EDATE(TODAY(),0-1)),YEAR(${r3})=YEAR(EDATE(TODAY(),0-1)))`;
                case "thisMonth":
                  return `AND(MONTH(${r3})=MONTH(TODAY()),YEAR(${r3})=YEAR(TODAY()))`;
                case "nextMonth":
                  return `AND(MONTH(${r3})=MONTH(EDATE(TODAY(),0+1)),YEAR(${r3})=YEAR(EDATE(TODAY(),0+1)))`;
                default:
                  return;
              }
            })(t3);
            r2 && this.formulaXform.render(e2, r2), e2.closeNode();
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { ...f(t3), dxfId: n.toIntValue(t3.dxfId), priority: n.toIntValue(t3.priority), timePeriod: t3.timePeriod, percent: n.toBoolValue(t3.percent), bottom: n.toBoolValue(t3.bottom), rank: n.toIntValue(t3.rank), aboveAverage: n.toBoolValue(t3.aboveAverage) };
          }
          onParserClose(e2, t3) {
            switch (e2) {
              case "dataBar":
              case "extLst":
              case "colorScale":
              case "iconSet":
                Object.assign(this.model, t3.model);
                break;
              case "formula":
                this.model.formulae = this.model.formulae || [], this.model.formulae.push(t3.model);
            }
          }
        }
        t2.exports = d;
      }, { "../../../../doc/range": 10, "../../base-xform": 32, "../../composite-xform": 48, "./color-scale-xform": 85, "./databar-xform": 88, "./ext-lst-ref-xform": 89, "./formula-xform": 90, "./icon-set-xform": 91 }], 84: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "cfvo";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, { type: t3.type, val: t3.value });
          }
          parseOpen(e2) {
            this.model = { type: e2.attributes.type, value: n.toFloatValue(e2.attributes.val) };
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        };
      }, { "../../base-xform": 32 }], 85: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("../../style/color-xform"), s = e("./cfvo-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { cfvo: this.cfvoXform = new s(), color: this.colorXform = new i() };
          }
          get tag() {
            return "colorScale";
          }
          render(e2, t3) {
            e2.openNode(this.tag), t3.cfvo.forEach((t4) => {
              this.cfvoXform.render(e2, t4);
            }), t3.color.forEach((t4) => {
              this.colorXform.render(e2, t4);
            }), e2.closeNode();
          }
          createNewModel(e2) {
            return { cfvo: [], color: [] };
          }
          onParserClose(e2, t3) {
            this.model[e2].push(t3.model);
          }
        };
      }, { "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-xform": 84 }], 86: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("./cf-rule-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { cfRule: new i() };
          }
          get tag() {
            return "conditionalFormatting";
          }
          render(e2, t3) {
            t3.rules.some(i.isPrimitive) && (e2.openNode(this.tag, { sqref: t3.ref }), t3.rules.forEach((r2) => {
              i.isPrimitive(r2) && (r2.ref = t3.ref, this.map.cfRule.render(e2, r2));
            }), e2.closeNode());
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { ref: t3.sqref, rules: [] };
          }
          onParserClose(e2, t3) {
            this.model.rules.push(t3.model);
          }
        };
      }, { "../../composite-xform": 48, "./cf-rule-xform": 83 }], 87: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("./conditional-formatting-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.cfXform = new i();
          }
          get tag() {
            return "conditionalFormatting";
          }
          reset() {
            this.model = [];
          }
          prepare(e2, t3) {
            let r2 = e2.reduce((e3, t4) => Math.max(e3, ...t4.rules.map((e4) => e4.priority || 0)), 1);
            e2.forEach((e3) => {
              e3.rules.forEach((e4) => {
                e4.priority || (e4.priority = r2++), e4.style && (e4.dxfId = t3.styles.addDxfStyle(e4.style));
              });
            });
          }
          render(e2, t3) {
            t3.forEach((t4) => {
              this.cfXform.render(e2, t4);
            });
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "conditionalFormatting":
                return this.parser = this.cfXform, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return !!this.parser && (!!this.parser.parseClose(e2) || (this.model.push(this.parser.model), this.parser = void 0, false));
          }
          reconcile(e2, t3) {
            e2.forEach((e3) => {
              e3.rules.forEach((e4) => {
                void 0 !== e4.dxfId && (e4.style = t3.styles.getDxfStyle(e4.dxfId), delete e4.dxfId);
              });
            });
          }
        };
      }, { "../../base-xform": 32, "./conditional-formatting-xform": 86 }], 88: [function(e, t2, r) {
        const n = e("../../composite-xform"), i = e("../../style/color-xform"), s = e("./cfvo-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { cfvo: this.cfvoXform = new s(), color: this.colorXform = new i() };
          }
          get tag() {
            return "dataBar";
          }
          render(e2, t3) {
            e2.openNode(this.tag), t3.cfvo.forEach((t4) => {
              this.cfvoXform.render(e2, t4);
            }), this.colorXform.render(e2, t3.color), e2.closeNode();
          }
          createNewModel() {
            return { cfvo: [] };
          }
          onParserClose(e2, t3) {
            switch (e2) {
              case "cfvo":
                this.model.cfvo.push(t3.model);
                break;
              case "color":
                this.model.color = t3.model;
            }
          }
        };
      }, { "../../composite-xform": 48, "../../style/color-xform": 128, "./cfvo-xform": 84 }], 89: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("../../composite-xform");
        class s extends n {
          get tag() {
            return "x14:id";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, null, t3);
          }
          parseOpen() {
            this.model = "";
          }
          parseText(e2) {
            this.model += e2;
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        }
        class o extends i {
          constructor() {
            super(), this.map = { "x14:id": this.idXform = new s() };
          }
          get tag() {
            return "ext";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }), this.idXform.render(e2, t3.x14Id), e2.closeNode();
          }
          createNewModel() {
            return {};
          }
          onParserClose(e2, t3) {
            this.model.x14Id = t3.model;
          }
        }
        t2.exports = class extends i {
          constructor() {
            super(), this.map = { ext: new o() };
          }
          get tag() {
            return "extLst";
          }
          render(e2, t3) {
            e2.openNode(this.tag), this.map.ext.render(e2, t3), e2.closeNode();
          }
          createNewModel() {
            return {};
          }
          onParserClose(e2, t3) {
            Object.assign(this.model, t3.model);
          }
        };
      }, { "../../base-xform": 32, "../../composite-xform": 48 }], 90: [function(e, t2, r) {
        const n = e("../../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "formula";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, null, t3);
          }
          parseOpen() {
            this.model = "";
          }
          parseText(e2) {
            this.model += e2;
          }
          parseClose(e2) {
            return e2 !== this.tag;
          }
        };
      }, { "../../base-xform": 32 }], 91: [function(e, t2, r) {
        const n = e("../../base-xform"), i = e("../../composite-xform"), s = e("./cfvo-xform");
        t2.exports = class extends i {
          constructor() {
            super(), this.map = { cfvo: this.cfvoXform = new s() };
          }
          get tag() {
            return "iconSet";
          }
          render(e2, t3) {
            e2.openNode(this.tag, { iconSet: n.toStringAttribute(t3.iconSet, "3TrafficLights"), reverse: n.toBoolAttribute(t3.reverse, false), showValue: n.toBoolAttribute(t3.showValue, true) }), t3.cfvo.forEach((t4) => {
              this.cfvoXform.render(e2, t4);
            }), e2.closeNode();
          }
          createNewModel(e2) {
            let { attributes: t3 } = e2;
            return { iconSet: n.toStringValue(t3.iconSet, "3TrafficLights"), reverse: n.toBoolValue(t3.reverse), showValue: n.toBoolValue(t3.showValue), cfvo: [] };
          }
          onParserClose(e2, t3) {
            this.model[e2].push(t3.model);
          }
        };
      }, { "../../base-xform": 32, "../../composite-xform": 48, "./cfvo-xform": 84 }], 92: [function(e, t2, r) {
        const n = e("../../../utils/utils"), i = e("../base-xform");
        t2.exports = class extends i {
          get tag() {
            return "col";
          }
          prepare(e2, t3) {
            const r2 = t3.styles.addStyleModel(e2.style || {});
            r2 && (e2.styleId = r2);
          }
          render(e2, t3) {
            e2.openNode("col"), e2.addAttribute("min", t3.min), e2.addAttribute("max", t3.max), t3.width && e2.addAttribute("width", t3.width), t3.styleId && e2.addAttribute("style", t3.styleId), t3.hidden && e2.addAttribute("hidden", "1"), t3.bestFit && e2.addAttribute("bestFit", "1"), t3.outlineLevel && e2.addAttribute("outlineLevel", t3.outlineLevel), t3.collapsed && e2.addAttribute("collapsed", "1"), e2.addAttribute("customWidth", "1"), e2.closeNode();
          }
          parseOpen(e2) {
            if ("col" === e2.name) {
              const t3 = this.model = { min: parseInt(e2.attributes.min || "0", 10), max: parseInt(e2.attributes.max || "0", 10), width: void 0 === e2.attributes.width ? void 0 : parseFloat(e2.attributes.width || "0") };
              return e2.attributes.style && (t3.styleId = parseInt(e2.attributes.style, 10)), n.parseBoolean(e2.attributes.hidden) && (t3.hidden = true), n.parseBoolean(e2.attributes.bestFit) && (t3.bestFit = true), e2.attributes.outlineLevel && (t3.outlineLevel = parseInt(e2.attributes.outlineLevel, 10)), n.parseBoolean(e2.attributes.collapsed) && (t3.collapsed = true), true;
            }
            return false;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
          reconcile(e2, t3) {
            e2.styleId && (e2.style = t3.styles.getStyleModel(e2.styleId));
          }
        };
      }, { "../../../utils/utils": 27, "../base-xform": 32 }], 93: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../../../utils/utils"), s = e("../../../utils/col-cache"), o = e("../base-xform"), a = e("../../../doc/range");
        function l(e2, t3, r2, n2) {
          const i2 = t3[r2];
          void 0 !== i2 ? e2[r2] = i2 : void 0 !== n2 && (e2[r2] = n2);
        }
        function c(e2, t3, r2, n2) {
          const s2 = t3[r2];
          void 0 !== s2 ? e2[r2] = i.parseBoolean(s2) : void 0 !== n2;
        }
        t2.exports = class extends o {
          get tag() {
            return "dataValidations";
          }
          render(e2, t3) {
            const r2 = (function(e3) {
              const t4 = n.map(e3, (e4, t5) => ({ address: t5, dataValidation: e4, marked: false })).sort((e4, t5) => n.strcmp(e4.address, t5.address)), r3 = n.keyBy(t4, "address"), i2 = (t5, r4, i3) => {
                for (let o2 = 0; o2 < r4; o2++) {
                  const r5 = s.encodeAddress(t5.row + o2, i3);
                  if (!e3[r5] || !n.isEqual(e3[t5.address], e3[r5])) return false;
                }
                return true;
              };
              return t4.map((t5) => {
                if (!t5.marked) {
                  const o2 = s.decodeEx(t5.address);
                  if (o2.dimensions) return r3[o2.dimensions].marked = true, { ...t5.dataValidation, sqref: t5.address };
                  let a2 = 1, l2 = s.encodeAddress(o2.row + a2, o2.col);
                  for (; e3[l2] && n.isEqual(t5.dataValidation, e3[l2]); ) a2++, l2 = s.encodeAddress(o2.row + a2, o2.col);
                  let c2 = 1;
                  for (; i2(o2, a2, o2.col + c2); ) c2++;
                  for (let e4 = 0; e4 < a2; e4++) for (let t6 = 0; t6 < c2; t6++) l2 = s.encodeAddress(o2.row + e4, o2.col + t6), r3[l2].marked = true;
                  if (a2 > 1 || c2 > 1) {
                    const e4 = o2.row + (a2 - 1), r4 = o2.col + (c2 - 1);
                    return { ...t5.dataValidation, sqref: `${t5.address}:${s.encodeAddress(e4, r4)}` };
                  }
                  return { ...t5.dataValidation, sqref: t5.address };
                }
                return null;
              }).filter(Boolean);
            })(t3);
            r2.length && (e2.openNode("dataValidations", { count: r2.length }), r2.forEach((t4) => {
              e2.openNode("dataValidation"), "any" !== t4.type && (e2.addAttribute("type", t4.type), t4.operator && "list" !== t4.type && "between" !== t4.operator && e2.addAttribute("operator", t4.operator), t4.allowBlank && e2.addAttribute("allowBlank", "1")), t4.showInputMessage && e2.addAttribute("showInputMessage", "1"), t4.promptTitle && e2.addAttribute("promptTitle", t4.promptTitle), t4.prompt && e2.addAttribute("prompt", t4.prompt), t4.showErrorMessage && e2.addAttribute("showErrorMessage", "1"), t4.errorStyle && e2.addAttribute("errorStyle", t4.errorStyle), t4.errorTitle && e2.addAttribute("errorTitle", t4.errorTitle), t4.error && e2.addAttribute("error", t4.error), e2.addAttribute("sqref", t4.sqref), (t4.formulae || []).forEach((r3, n2) => {
                e2.openNode("formula" + (n2 + 1)), "date" === t4.type ? e2.writeText(i.dateToExcel(new Date(r3))) : e2.writeText(r3), e2.closeNode();
              }), e2.closeNode();
            }), e2.closeNode());
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "dataValidations":
                return this.model = {}, true;
              case "dataValidation": {
                this._address = e2.attributes.sqref;
                const t3 = { type: e2.attributes.type || "any", formulae: [] };
                switch (e2.attributes.type && c(t3, e2.attributes, "allowBlank"), c(t3, e2.attributes, "showInputMessage"), c(t3, e2.attributes, "showErrorMessage"), t3.type) {
                  case "any":
                  case "list":
                  case "custom":
                    break;
                  default:
                    l(t3, e2.attributes, "operator", "between");
                }
                return l(t3, e2.attributes, "promptTitle"), l(t3, e2.attributes, "prompt"), l(t3, e2.attributes, "errorStyle"), l(t3, e2.attributes, "errorTitle"), l(t3, e2.attributes, "error"), this._dataValidation = t3, true;
              }
              case "formula1":
              case "formula2":
                return this._formula = [], true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this._formula && this._formula.push(e2);
          }
          parseClose(e2) {
            switch (e2) {
              case "dataValidations":
                return false;
              case "dataValidation":
                this._dataValidation.formulae && this._dataValidation.formulae.length || (delete this._dataValidation.formulae, delete this._dataValidation.operator);
                return (this._address.split(/\s+/g) || []).forEach((e3) => {
                  if (e3.includes(":")) {
                    new a(e3).forEachAddress((e4) => {
                      this.model[e4] = this._dataValidation;
                    });
                  } else this.model[e3] = this._dataValidation;
                }), true;
              case "formula1":
              case "formula2": {
                let e3 = this._formula.join("");
                switch (this._dataValidation.type) {
                  case "whole":
                  case "textLength":
                    e3 = parseInt(e3, 10);
                    break;
                  case "decimal":
                    e3 = parseFloat(e3);
                    break;
                  case "date":
                    e3 = i.excelToDate(parseFloat(e3));
                }
                return this._dataValidation.formulae.push(e3), this._formula = void 0, true;
              }
              default:
                return true;
            }
          }
        };
      }, { "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/utils": 27, "../base-xform": 32 }], 94: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "dimension";
          }
          render(e2, t3) {
            t3 && e2.leafNode("dimension", { ref: t3 });
          }
          parseOpen(e2) {
            return "dimension" === e2.name && (this.model = e2.attributes.ref, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 95: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "drawing";
          }
          render(e2, t3) {
            t3 && e2.leafNode(this.tag, { "r:id": t3.rId });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { rId: e2.attributes["r:id"] }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 96: [function(e, t2, r) {
        const n = e("../composite-xform"), i = e("./cf-ext/conditional-formattings-ext-xform");
        class s extends n {
          constructor() {
            super(), this.map = { "x14:conditionalFormattings": this.conditionalFormattings = new i() };
          }
          get tag() {
            return "ext";
          }
          hasContent(e2) {
            return this.conditionalFormattings.hasContent(e2.conditionalFormattings);
          }
          prepare(e2, t3) {
            this.conditionalFormattings.prepare(e2.conditionalFormattings, t3);
          }
          render(e2, t3) {
            e2.openNode("ext", { uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }), this.conditionalFormattings.render(e2, t3.conditionalFormattings), e2.closeNode();
          }
          createNewModel() {
            return {};
          }
          onParserClose(e2, t3) {
            this.model[e2] = t3.model;
          }
        }
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { ext: this.ext = new s() };
          }
          get tag() {
            return "extLst";
          }
          prepare(e2, t3) {
            this.ext.prepare(e2, t3);
          }
          hasContent(e2) {
            return this.ext.hasContent(e2);
          }
          render(e2, t3) {
            this.hasContent(t3) && (e2.openNode("extLst"), this.ext.render(e2, t3), e2.closeNode());
          }
          createNewModel() {
            return {};
          }
          onParserClose(e2, t3) {
            Object.assign(this.model, t3.model);
          }
        };
      }, { "../composite-xform": 48, "./cf-ext/conditional-formattings-ext-xform": 78 }], 97: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "headerFooter";
          }
          render(e2, t3) {
            if (t3) {
              e2.addRollback();
              let r2 = false;
              e2.openNode("headerFooter"), t3.differentFirst && (e2.addAttribute("differentFirst", "1"), r2 = true), t3.differentOddEven && (e2.addAttribute("differentOddEven", "1"), r2 = true), t3.oddHeader && "string" == typeof t3.oddHeader && (e2.leafNode("oddHeader", null, t3.oddHeader), r2 = true), t3.oddFooter && "string" == typeof t3.oddFooter && (e2.leafNode("oddFooter", null, t3.oddFooter), r2 = true), t3.evenHeader && "string" == typeof t3.evenHeader && (e2.leafNode("evenHeader", null, t3.evenHeader), r2 = true), t3.evenFooter && "string" == typeof t3.evenFooter && (e2.leafNode("evenFooter", null, t3.evenFooter), r2 = true), t3.firstHeader && "string" == typeof t3.firstHeader && (e2.leafNode("firstHeader", null, t3.firstHeader), r2 = true), t3.firstFooter && "string" == typeof t3.firstFooter && (e2.leafNode("firstFooter", null, t3.firstFooter), r2 = true), r2 ? (e2.closeNode(), e2.commit()) : e2.rollback();
            }
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "headerFooter":
                return this.model = {}, e2.attributes.differentFirst && (this.model.differentFirst = 1 === parseInt(e2.attributes.differentFirst, 0)), e2.attributes.differentOddEven && (this.model.differentOddEven = 1 === parseInt(e2.attributes.differentOddEven, 0)), true;
              case "oddHeader":
                return this.currentNode = "oddHeader", true;
              case "oddFooter":
                return this.currentNode = "oddFooter", true;
              case "evenHeader":
                return this.currentNode = "evenHeader", true;
              case "evenFooter":
                return this.currentNode = "evenFooter", true;
              case "firstHeader":
                return this.currentNode = "firstHeader", true;
              case "firstFooter":
                return this.currentNode = "firstFooter", true;
              default:
                return false;
            }
          }
          parseText(e2) {
            switch (this.currentNode) {
              case "oddHeader":
                this.model.oddHeader = e2;
                break;
              case "oddFooter":
                this.model.oddFooter = e2;
                break;
              case "evenHeader":
                this.model.evenHeader = e2;
                break;
              case "evenFooter":
                this.model.evenFooter = e2;
                break;
              case "firstHeader":
                this.model.firstHeader = e2;
                break;
              case "firstFooter":
                this.model.firstFooter = e2;
            }
          }
          parseClose() {
            switch (this.currentNode) {
              case "oddHeader":
              case "oddFooter":
              case "evenHeader":
              case "evenFooter":
              case "firstHeader":
              case "firstFooter":
                return this.currentNode = void 0, true;
              default:
                return false;
            }
          }
        };
      }, { "../base-xform": 32 }], 98: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "hyperlink";
          }
          render(e2, t3) {
            this.isInternalLink(t3) ? e2.leafNode("hyperlink", { ref: t3.address, "r:id": t3.rId, tooltip: t3.tooltip, location: t3.target }) : e2.leafNode("hyperlink", { ref: t3.address, "r:id": t3.rId, tooltip: t3.tooltip });
          }
          parseOpen(e2) {
            return "hyperlink" === e2.name && (this.model = { address: e2.attributes.ref, rId: e2.attributes["r:id"], tooltip: e2.attributes.tooltip }, e2.attributes.location && (this.model.target = e2.attributes.location), true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
          isInternalLink(e2) {
            return e2.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(e2.target);
          }
        };
      }, { "../base-xform": 32 }], 99: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "mergeCell";
          }
          render(e2, t3) {
            e2.leafNode("mergeCell", { ref: t3 });
          }
          parseOpen(e2) {
            return "mergeCell" === e2.name && (this.model = e2.attributes.ref, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 100: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../../../doc/range"), s = e("../../../utils/col-cache"), o = e("../../../doc/enums");
        t2.exports = class {
          constructor() {
            this.merges = {};
          }
          add(e2) {
            if (this.merges[e2.master]) this.merges[e2.master].expandToAddress(e2.address);
            else {
              const t3 = `${e2.master}:${e2.address}`;
              this.merges[e2.master] = new i(t3);
            }
          }
          get mergeCells() {
            return n.map(this.merges, (e2) => e2.range);
          }
          reconcile(e2, t3) {
            n.each(e2, (e3) => {
              const r2 = s.decode(e3);
              for (let e4 = r2.top; e4 <= r2.bottom; e4++) {
                const n2 = t3[e4 - 1];
                for (let t4 = r2.left; t4 <= r2.right; t4++) {
                  const i2 = n2.cells[t4 - 1];
                  i2 ? i2.type === o.ValueType.Merge && (i2.master = r2.tl) : n2.cells[t4] = { type: o.ValueType.Null, address: s.encodeAddress(e4, t4) };
                }
              }
            });
          }
          getMasterAddress(e2) {
            const t3 = this.hash[e2];
            return t3 && t3.tl;
          }
        };
      }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 26 }], 101: [function(e, t2, r) {
        const n = e("../base-xform"), i = (e2) => void 0 !== e2;
        t2.exports = class extends n {
          get tag() {
            return "outlinePr";
          }
          render(e2, t3) {
            return !(!t3 || !i(t3.summaryBelow) && !i(t3.summaryRight)) && (e2.leafNode(this.tag, { summaryBelow: i(t3.summaryBelow) ? Number(t3.summaryBelow) : void 0, summaryRight: i(t3.summaryRight) ? Number(t3.summaryRight) : void 0 }), true);
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.model = { summaryBelow: i(e2.attributes.summaryBelow) ? Boolean(Number(e2.attributes.summaryBelow)) : void 0, summaryRight: i(e2.attributes.summaryRight) ? Boolean(Number(e2.attributes.summaryRight)) : void 0 }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 102: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "brk";
          }
          render(e2, t3) {
            e2.leafNode("brk", t3);
          }
          parseOpen(e2) {
            return "brk" === e2.name && (this.model = e2.attributes.ref, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 103: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../base-xform");
        t2.exports = class extends i {
          get tag() {
            return "pageMargins";
          }
          render(e2, t3) {
            if (t3) {
              const r2 = { left: t3.left, right: t3.right, top: t3.top, bottom: t3.bottom, header: t3.header, footer: t3.footer };
              n.some(r2, (e3) => void 0 !== e3) && e2.leafNode(this.tag, r2);
            }
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { left: parseFloat(e2.attributes.left || 0.7), right: parseFloat(e2.attributes.right || 0.7), top: parseFloat(e2.attributes.top || 0.75), bottom: parseFloat(e2.attributes.bottom || 0.75), header: parseFloat(e2.attributes.header || 0.3), footer: parseFloat(e2.attributes.footer || 0.3) }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 104: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "pageSetUpPr";
          }
          render(e2, t3) {
            return !(!t3 || !t3.fitToPage) && (e2.leafNode(this.tag, { fitToPage: t3.fitToPage ? "1" : void 0 }), true);
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.model = { fitToPage: "1" === e2.attributes.fitToPage }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 105: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../base-xform");
        function s(e2) {
          return e2 ? "1" : void 0;
        }
        function o(e2) {
          switch (e2) {
            case "overThenDown":
              return e2;
            default:
              return;
          }
        }
        function a(e2) {
          switch (e2) {
            case "atEnd":
            case "asDisplyed":
              return e2;
            default:
              return;
          }
        }
        function l(e2) {
          switch (e2) {
            case "dash":
            case "blank":
            case "NA":
              return e2;
            default:
              return;
          }
        }
        t2.exports = class extends i {
          get tag() {
            return "pageSetup";
          }
          render(e2, t3) {
            if (t3) {
              const r2 = { paperSize: t3.paperSize, orientation: t3.orientation, horizontalDpi: t3.horizontalDpi, verticalDpi: t3.verticalDpi, pageOrder: o(t3.pageOrder), blackAndWhite: s(t3.blackAndWhite), draft: s(t3.draft), cellComments: a(t3.cellComments), errors: l(t3.errors), scale: t3.scale, fitToWidth: t3.fitToWidth, fitToHeight: t3.fitToHeight, firstPageNumber: t3.firstPageNumber, useFirstPageNumber: s(t3.firstPageNumber), usePrinterDefaults: s(t3.usePrinterDefaults), copies: t3.copies };
              n.some(r2, (e3) => void 0 !== e3) && e2.leafNode(this.tag, r2);
            }
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { paperSize: (t3 = e2.attributes.paperSize, void 0 !== t3 ? parseInt(t3, 10) : void 0), orientation: e2.attributes.orientation || "portrait", horizontalDpi: parseInt(e2.attributes.horizontalDpi || "4294967295", 10), verticalDpi: parseInt(e2.attributes.verticalDpi || "4294967295", 10), pageOrder: e2.attributes.pageOrder || "downThenOver", blackAndWhite: "1" === e2.attributes.blackAndWhite, draft: "1" === e2.attributes.draft, cellComments: e2.attributes.cellComments || "None", errors: e2.attributes.errors || "displayed", scale: parseInt(e2.attributes.scale || "100", 10), fitToWidth: parseInt(e2.attributes.fitToWidth || "1", 10), fitToHeight: parseInt(e2.attributes.fitToHeight || "1", 10), firstPageNumber: parseInt(e2.attributes.firstPageNumber || "1", 10), useFirstPageNumber: "1" === e2.attributes.useFirstPageNumber, usePrinterDefaults: "1" === e2.attributes.usePrinterDefaults, copies: parseInt(e2.attributes.copies || "1", 10) }, true;
              default:
                return false;
            }
            var t3;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 106: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "picture";
          }
          render(e2, t3) {
            t3 && e2.leafNode(this.tag, { "r:id": t3.rId });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { rId: e2.attributes["r:id"] }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 107: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../base-xform");
        function s(e2) {
          return e2 ? "1" : void 0;
        }
        t2.exports = class extends i {
          get tag() {
            return "printOptions";
          }
          render(e2, t3) {
            if (t3) {
              const r2 = { headings: s(t3.showRowColHeaders), gridLines: s(t3.showGridLines), horizontalCentered: s(t3.horizontalCentered), verticalCentered: s(t3.verticalCentered) };
              n.some(r2, (e3) => void 0 !== e3) && e2.leafNode(this.tag, r2);
            }
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { showRowColHeaders: "1" === e2.attributes.headings, showGridLines: "1" === e2.attributes.gridLines, horizontalCentered: "1" === e2.attributes.horizontalCentered, verticalCentered: "1" === e2.attributes.verticalCentered }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 108: [function(e, t2, r) {
        const n = e("./page-breaks-xform"), i = e("../list-xform");
        t2.exports = class extends i {
          constructor() {
            super({ tag: "rowBreaks", count: true, childXform: new n() });
          }
          render(e2, t3) {
            if (t3 && t3.length) {
              e2.openNode(this.tag, this.$), this.count && (e2.addAttribute(this.$count, t3.length), e2.addAttribute("manualBreakCount", t3.length));
              const { childXform: r2 } = this;
              t3.forEach((t4) => {
                r2.render(e2, t4);
              }), e2.closeNode();
            } else this.empty && e2.leafNode(this.tag);
          }
        };
      }, { "../list-xform": 71, "./page-breaks-xform": 102 }], 109: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../../../utils/utils"), s = e("./cell-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.maxItems = e2 && e2.maxItems, this.map = { c: new s() };
          }
          get tag() {
            return "row";
          }
          prepare(e2, t3) {
            const r2 = t3.styles.addStyleModel(e2.style);
            r2 && (e2.styleId = r2);
            const n2 = this.map.c;
            e2.cells.forEach((e3) => {
              n2.prepare(e3, t3);
            });
          }
          render(e2, t3, r2) {
            e2.openNode("row"), e2.addAttribute("r", t3.number), t3.height && (e2.addAttribute("ht", t3.height), e2.addAttribute("customHeight", "1")), t3.hidden && e2.addAttribute("hidden", "1"), t3.min > 0 && t3.max > 0 && t3.min <= t3.max && e2.addAttribute("spans", `${t3.min}:${t3.max}`), t3.styleId && (e2.addAttribute("s", t3.styleId), e2.addAttribute("customFormat", "1")), e2.addAttribute("x14ac:dyDescent", "0.25"), t3.outlineLevel && e2.addAttribute("outlineLevel", t3.outlineLevel), t3.collapsed && e2.addAttribute("collapsed", "1");
            const n2 = this.map.c;
            t3.cells.forEach((t4) => {
              n2.render(e2, t4, r2);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            if ("row" === e2.name) {
              this.numRowsSeen += 1;
              const t3 = e2.attributes.spans ? e2.attributes.spans.split(":").map((e3) => parseInt(e3, 10)) : [void 0, void 0], r2 = this.model = { number: parseInt(e2.attributes.r, 10), min: t3[0], max: t3[1], cells: [] };
              return e2.attributes.s && (r2.styleId = parseInt(e2.attributes.s, 10)), i.parseBoolean(e2.attributes.hidden) && (r2.hidden = true), i.parseBoolean(e2.attributes.bestFit) && (r2.bestFit = true), e2.attributes.ht && (r2.height = parseFloat(e2.attributes.ht)), e2.attributes.outlineLevel && (r2.outlineLevel = parseInt(e2.attributes.outlineLevel, 10)), i.parseBoolean(e2.attributes.collapsed) && (r2.collapsed = true), true;
            }
            return this.parser = this.map[e2.name], !!this.parser && (this.parser.parseOpen(e2), true);
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) {
              if (!this.parser.parseClose(e2)) {
                if (this.model.cells.push(this.parser.model), this.maxItems && this.model.cells.length > this.maxItems) throw new Error(`Max column count (${this.maxItems}) exceeded`);
                this.parser = void 0;
              }
              return true;
            }
            return false;
          }
          reconcile(e2, t3) {
            e2.style = e2.styleId ? t3.styles.getStyleModel(e2.styleId) : {}, void 0 !== e2.styleId && (e2.styleId = void 0);
            const r2 = this.map.c;
            e2.cells.forEach((e3) => {
              r2.reconcile(e3, t3);
            });
          }
        };
      }, { "../../../utils/utils": 27, "../base-xform": 32, "./cell-xform": 73 }], 110: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../base-xform");
        t2.exports = class extends i {
          get tag() {
            return "sheetFormatPr";
          }
          render(e2, t3) {
            if (t3) {
              const r2 = { defaultRowHeight: t3.defaultRowHeight, outlineLevelRow: t3.outlineLevelRow, outlineLevelCol: t3.outlineLevelCol, "x14ac:dyDescent": t3.dyDescent };
              t3.defaultColWidth && (r2.defaultColWidth = t3.defaultColWidth), t3.defaultRowHeight && 15 === t3.defaultRowHeight || (r2.customHeight = "1"), n.some(r2, (e3) => void 0 !== e3) && e2.leafNode("sheetFormatPr", r2);
            }
          }
          parseOpen(e2) {
            return "sheetFormatPr" === e2.name && (this.model = { defaultRowHeight: parseFloat(e2.attributes.defaultRowHeight || "0"), dyDescent: parseFloat(e2.attributes["x14ac:dyDescent"] || "0"), outlineLevelRow: parseInt(e2.attributes.outlineLevelRow || "0", 10), outlineLevelCol: parseInt(e2.attributes.outlineLevelCol || "0", 10) }, e2.attributes.defaultColWidth && (this.model.defaultColWidth = parseFloat(e2.attributes.defaultColWidth)), true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 111: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../style/color-xform"), s = e("./page-setup-properties-xform"), o = e("./outline-properties-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { tabColor: new i("tabColor"), pageSetUpPr: new s(), outlinePr: new o() };
          }
          get tag() {
            return "sheetPr";
          }
          render(e2, t3) {
            if (t3) {
              e2.addRollback(), e2.openNode("sheetPr");
              let r2 = false;
              r2 = this.map.tabColor.render(e2, t3.tabColor) || r2, r2 = this.map.pageSetUpPr.render(e2, t3.pageSetup) || r2, r2 = this.map.outlinePr.render(e2, t3.outlineProperties) || r2, r2 ? (e2.closeNode(), e2.commit()) : e2.rollback();
            }
          }
          parseOpen(e2) {
            return this.parser ? (this.parser.parseOpen(e2), true) : e2.name === this.tag ? (this.reset(), true) : !!this.map[e2.name] && (this.parser = this.map[e2.name], this.parser.parseOpen(e2), true);
          }
          parseText(e2) {
            return !!this.parser && (this.parser.parseText(e2), true);
          }
          parseClose(e2) {
            return this.parser ? (this.parser.parseClose(e2) || (this.parser = void 0), true) : (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model ? (this.model = {}, this.map.tabColor.model && (this.model.tabColor = this.map.tabColor.model), this.map.pageSetUpPr.model && (this.model.pageSetup = this.map.pageSetUpPr.model), this.map.outlinePr.model && (this.model.outlineProperties = this.map.outlinePr.model)) : this.model = null, false);
          }
        };
      }, { "../base-xform": 32, "../style/color-xform": 128, "./outline-properties-xform": 101, "./page-setup-properties-xform": 104 }], 112: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../base-xform");
        function s(e2, t3) {
          return e2 ? t3 : void 0;
        }
        function o(e2, t3) {
          return e2 === t3 || void 0;
        }
        t2.exports = class extends i {
          get tag() {
            return "sheetProtection";
          }
          render(e2, t3) {
            if (t3) {
              const r2 = { sheet: s(t3.sheet, "1"), selectLockedCells: false === t3.selectLockedCells ? "1" : void 0, selectUnlockedCells: false === t3.selectUnlockedCells ? "1" : void 0, formatCells: s(t3.formatCells, "0"), formatColumns: s(t3.formatColumns, "0"), formatRows: s(t3.formatRows, "0"), insertColumns: s(t3.insertColumns, "0"), insertRows: s(t3.insertRows, "0"), insertHyperlinks: s(t3.insertHyperlinks, "0"), deleteColumns: s(t3.deleteColumns, "0"), deleteRows: s(t3.deleteRows, "0"), sort: s(t3.sort, "0"), autoFilter: s(t3.autoFilter, "0"), pivotTables: s(t3.pivotTables, "0") };
              t3.sheet && (r2.algorithmName = t3.algorithmName, r2.hashValue = t3.hashValue, r2.saltValue = t3.saltValue, r2.spinCount = t3.spinCount, r2.objects = s(false === t3.objects, "1"), r2.scenarios = s(false === t3.scenarios, "1")), n.some(r2, (e3) => void 0 !== e3) && e2.leafNode(this.tag, r2);
            }
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { sheet: o(e2.attributes.sheet, "1"), objects: "1" !== e2.attributes.objects && void 0, scenarios: "1" !== e2.attributes.scenarios && void 0, selectLockedCells: "1" !== e2.attributes.selectLockedCells && void 0, selectUnlockedCells: "1" !== e2.attributes.selectUnlockedCells && void 0, formatCells: o(e2.attributes.formatCells, "0"), formatColumns: o(e2.attributes.formatColumns, "0"), formatRows: o(e2.attributes.formatRows, "0"), insertColumns: o(e2.attributes.insertColumns, "0"), insertRows: o(e2.attributes.insertRows, "0"), insertHyperlinks: o(e2.attributes.insertHyperlinks, "0"), deleteColumns: o(e2.attributes.deleteColumns, "0"), deleteRows: o(e2.attributes.deleteRows, "0"), sort: o(e2.attributes.sort, "0"), autoFilter: o(e2.attributes.autoFilter, "0"), pivotTables: o(e2.attributes.pivotTables, "0") }, e2.attributes.algorithmName && (this.model.algorithmName = e2.attributes.algorithmName, this.model.hashValue = e2.attributes.hashValue, this.model.saltValue = e2.attributes.saltValue, this.model.spinCount = parseInt(e2.attributes.spinCount, 10)), true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../utils/under-dash": 26, "../base-xform": 32 }], 113: [function(e, t2, r) {
        const n = e("../../../utils/col-cache"), i = e("../base-xform"), s = { frozen: "frozen", frozenSplit: "frozen", split: "split" };
        t2.exports = class extends i {
          get tag() {
            return "sheetView";
          }
          prepare(e2) {
            switch (e2.state) {
              case "frozen":
              case "split":
                break;
              default:
                e2.state = "normal";
            }
          }
          render(e2, t3) {
            e2.openNode("sheetView", { workbookViewId: t3.workbookViewId || 0 });
            const r2 = function(t4, r3, n2) {
              n2 && e2.addAttribute(t4, r3);
            };
            let i2, s2, o, a;
            switch (r2("rightToLeft", "1", true === t3.rightToLeft), r2("tabSelected", "1", t3.tabSelected), r2("showRuler", "0", false === t3.showRuler), r2("showRowColHeaders", "0", false === t3.showRowColHeaders), r2("showGridLines", "0", false === t3.showGridLines), r2("zoomScale", t3.zoomScale, t3.zoomScale), r2("zoomScaleNormal", t3.zoomScaleNormal, t3.zoomScaleNormal), r2("view", t3.style, t3.style), t3.state) {
              case "frozen":
                s2 = t3.xSplit || 0, o = t3.ySplit || 0, i2 = t3.topLeftCell || n.getAddress(o + 1, s2 + 1).address, a = (t3.xSplit && t3.ySplit ? "bottomRight" : t3.xSplit && "topRight") || "bottomLeft", e2.leafNode("pane", { xSplit: t3.xSplit || void 0, ySplit: t3.ySplit || void 0, topLeftCell: i2, activePane: a, state: "frozen" }), e2.leafNode("selection", { pane: a, activeCell: t3.activeCell, sqref: t3.activeCell });
                break;
              case "split":
                "topLeft" === t3.activePane && (t3.activePane = void 0), e2.leafNode("pane", { xSplit: t3.xSplit || void 0, ySplit: t3.ySplit || void 0, topLeftCell: t3.topLeftCell, activePane: t3.activePane }), e2.leafNode("selection", { pane: t3.activePane, activeCell: t3.activeCell, sqref: t3.activeCell });
                break;
              case "normal":
                t3.activeCell && e2.leafNode("selection", { activeCell: t3.activeCell, sqref: t3.activeCell });
            }
            e2.closeNode();
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "sheetView":
                return this.sheetView = { workbookViewId: parseInt(e2.attributes.workbookViewId, 10), rightToLeft: "1" === e2.attributes.rightToLeft, tabSelected: "1" === e2.attributes.tabSelected, showRuler: !("0" === e2.attributes.showRuler), showRowColHeaders: !("0" === e2.attributes.showRowColHeaders), showGridLines: !("0" === e2.attributes.showGridLines), zoomScale: parseInt(e2.attributes.zoomScale || "100", 10), zoomScaleNormal: parseInt(e2.attributes.zoomScaleNormal || "100", 10), style: e2.attributes.view }, this.pane = void 0, this.selections = {}, true;
              case "pane":
                return this.pane = { xSplit: parseInt(e2.attributes.xSplit || "0", 10), ySplit: parseInt(e2.attributes.ySplit || "0", 10), topLeftCell: e2.attributes.topLeftCell, activePane: e2.attributes.activePane || "topLeft", state: e2.attributes.state }, true;
              case "selection": {
                const t3 = e2.attributes.pane || "topLeft";
                return this.selections[t3] = { pane: t3, activeCell: e2.attributes.activeCell }, true;
              }
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            let t3, r2;
            switch (e2) {
              case "sheetView":
                return this.sheetView && this.pane ? (t3 = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: s[this.pane.state] || "split", xSplit: this.pane.xSplit, ySplit: this.pane.ySplit, topLeftCell: this.pane.topLeftCell, showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal }, "split" === this.model.state && (t3.activePane = this.pane.activePane), r2 = this.selections[this.pane.activePane], r2 && r2.activeCell && (t3.activeCell = r2.activeCell), this.sheetView.style && (t3.style = this.sheetView.style)) : (t3 = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: "normal", showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal }, r2 = this.selections.topLeft, r2 && r2.activeCell && (t3.activeCell = r2.activeCell), this.sheetView.style && (t3.style = this.sheetView.style)), false;
              default:
                return true;
            }
          }
          reconcile() {
          }
        };
      }, { "../../../utils/col-cache": 19, "../base-xform": 32 }], 114: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "tablePart";
          }
          render(e2, t3) {
            t3 && e2.leafNode(this.tag, { "r:id": t3.rId });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case this.tag:
                return this.model = { rId: e2.attributes["r:id"] }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 115: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../../../utils/col-cache"), s = e("../../../utils/xml-stream"), o = e("../../rel-type"), a = e("./merges"), l = e("../base-xform"), c = e("../list-xform"), u = e("./row-xform"), h = e("./col-xform"), f = e("./dimension-xform"), d = e("./hyperlink-xform"), p = e("./merge-cell-xform"), m = e("./data-validations-xform"), b = e("./sheet-properties-xform"), g = e("./sheet-format-properties-xform"), y = e("./sheet-view-xform"), v = e("./sheet-protection-xform"), w = e("./page-margins-xform"), _ = e("./page-setup-xform"), x = e("./print-options-xform"), k = e("./auto-filter-xform"), S = e("./picture-xform"), M = e("./drawing-xform"), C2 = e("./table-part-xform"), T = e("./row-breaks-xform"), E = e("./header-footer-xform"), A = e("./cf/conditional-formattings-xform"), R = e("./ext-lst-xform"), O = (e2, t3) => {
          if (!t3 || !t3.length) return e2;
          if (!e2 || !e2.length) return t3;
          const r2 = {}, n2 = {};
          return e2.forEach((e3) => {
            r2[e3.ref] = e3, e3.rules.forEach((e4) => {
              const { x14Id: t4 } = e4;
              t4 && (n2[t4] = e4);
            });
          }), t3.forEach((t4) => {
            t4.rules.forEach((i2) => {
              const s2 = n2[i2.x14Id];
              s2 ? ((e3, t5) => {
                Object.keys(t5).forEach((r3) => {
                  const n3 = e3[r3], i3 = t5[r3];
                  void 0 === n3 && void 0 !== i3 && (e3[r3] = i3);
                });
              })(s2, i2) : r2[t4.ref] ? r2[t4.ref].rules.push(i2) : e2.push({ ref: t4.ref, rules: [i2] });
            });
          }), e2;
        };
        class j extends l {
          constructor(e2) {
            super();
            const { maxRows: t3, maxCols: r2, ignoreNodes: n2 } = e2 || {};
            this.ignoreNodes = n2 || [], this.map = { sheetPr: new b(), dimension: new f(), sheetViews: new c({ tag: "sheetViews", count: false, childXform: new y() }), sheetFormatPr: new g(), cols: new c({ tag: "cols", count: false, childXform: new h() }), sheetData: new c({ tag: "sheetData", count: false, empty: true, childXform: new u({ maxItems: r2 }), maxItems: t3 }), autoFilter: new k(), mergeCells: new c({ tag: "mergeCells", count: true, childXform: new p() }), rowBreaks: new T(), hyperlinks: new c({ tag: "hyperlinks", count: false, childXform: new d() }), pageMargins: new w(), dataValidations: new m(), pageSetup: new _(), headerFooter: new E(), printOptions: new x(), picture: new S(), drawing: new M(), sheetProtection: new v(), tableParts: new c({ tag: "tableParts", count: true, childXform: new C2() }), conditionalFormatting: new A(), extLst: new R() };
          }
          prepare(e2, t3) {
            t3.merges = new a(), e2.hyperlinks = t3.hyperlinks = [], e2.comments = t3.comments = [], t3.formulae = {}, t3.siFormulae = 0, this.map.cols.prepare(e2.cols, t3), this.map.sheetData.prepare(e2.rows, t3), this.map.conditionalFormatting.prepare(e2.conditionalFormattings, t3), e2.mergeCells = t3.merges.mergeCells;
            const r2 = e2.rels = [];
            function n2(e3) {
              return "rId" + (e3.length + 1);
            }
            if (e2.hyperlinks.forEach((e3) => {
              const t4 = n2(r2);
              e3.rId = t4, r2.push({ Id: t4, Type: o.Hyperlink, Target: e3.target, TargetMode: "External" });
            }), e2.comments.length > 0) {
              const s3 = { Id: n2(r2), Type: o.Comments, Target: `../comments${e2.id}.xml` };
              r2.push(s3);
              const a2 = { Id: n2(r2), Type: o.VmlDrawing, Target: `../drawings/vmlDrawing${e2.id}.vml` };
              r2.push(a2), e2.comments.forEach((e3) => {
                e3.refAddress = i.decodeAddress(e3.ref);
              }), t3.commentRefs.push({ commentName: "comments" + e2.id, vmlDrawing: "vmlDrawing" + e2.id });
            }
            const s2 = [];
            let l2;
            e2.media.forEach((i2) => {
              if ("background" === i2.type) {
                const s3 = n2(r2);
                l2 = t3.media[i2.imageId], r2.push({ Id: s3, Type: o.Image, Target: `../media/${l2.name}.${l2.extension}` }), e2.background = { rId: s3 }, e2.image = t3.media[i2.imageId];
              } else if ("image" === i2.type) {
                let { drawing: a2 } = e2;
                l2 = t3.media[i2.imageId], a2 || (a2 = e2.drawing = { rId: n2(r2), name: "drawing" + ++t3.drawingsCount, anchors: [], rels: [] }, t3.drawings.push(a2), r2.push({ Id: a2.rId, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing", Target: `../drawings/${a2.name}.xml` }));
                let c2 = this.preImageId === i2.imageId ? s2[i2.imageId] : s2[a2.rels.length];
                c2 || (c2 = n2(a2.rels), s2[a2.rels.length] = c2, a2.rels.push({ Id: c2, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", Target: `../media/${l2.name}.${l2.extension}` }));
                const u2 = { picture: { rId: c2 }, range: i2.range };
                if (i2.hyperlinks && i2.hyperlinks.hyperlink) {
                  const e3 = n2(a2.rels);
                  s2[a2.rels.length] = e3, u2.picture.hyperlinks = { tooltip: i2.hyperlinks.tooltip, rId: e3 }, a2.rels.push({ Id: e3, Type: o.Hyperlink, Target: i2.hyperlinks.hyperlink, TargetMode: "External" });
                }
                this.preImageId = i2.imageId, a2.anchors.push(u2);
              }
            }), e2.tables.forEach((e3) => {
              const i2 = n2(r2);
              e3.rId = i2, r2.push({ Id: i2, Type: o.Table, Target: "../tables/" + e3.target }), e3.columns.forEach((e4) => {
                const { style: r3 } = e4;
                r3 && (e4.dxfId = t3.styles.addDxfStyle(r3));
              });
            }), this.map.extLst.prepare(e2, t3);
          }
          render(e2, t3) {
            e2.openXml(s.StdDocAttributes), e2.openNode("worksheet", j.WORKSHEET_ATTRIBUTES);
            const r2 = t3.properties ? { defaultRowHeight: t3.properties.defaultRowHeight, dyDescent: t3.properties.dyDescent, outlineLevelCol: t3.properties.outlineLevelCol, outlineLevelRow: t3.properties.outlineLevelRow } : void 0;
            t3.properties && t3.properties.defaultColWidth && (r2.defaultColWidth = t3.properties.defaultColWidth);
            const n2 = { outlineProperties: t3.properties && t3.properties.outlineProperties, tabColor: t3.properties && t3.properties.tabColor, pageSetup: t3.pageSetup && t3.pageSetup.fitToPage ? { fitToPage: t3.pageSetup.fitToPage } : void 0 }, i2 = t3.pageSetup && t3.pageSetup.margins, a2 = { showRowColHeaders: t3.pageSetup && t3.pageSetup.showRowColHeaders, showGridLines: t3.pageSetup && t3.pageSetup.showGridLines, horizontalCentered: t3.pageSetup && t3.pageSetup.horizontalCentered, verticalCentered: t3.pageSetup && t3.pageSetup.verticalCentered }, l2 = t3.sheetProtection;
            this.map.sheetPr.render(e2, n2), this.map.dimension.render(e2, t3.dimensions), this.map.sheetViews.render(e2, t3.views), this.map.sheetFormatPr.render(e2, r2), this.map.cols.render(e2, t3.cols), this.map.sheetData.render(e2, t3.rows), this.map.sheetProtection.render(e2, l2), this.map.autoFilter.render(e2, t3.autoFilter), this.map.mergeCells.render(e2, t3.mergeCells), this.map.conditionalFormatting.render(e2, t3.conditionalFormattings), this.map.dataValidations.render(e2, t3.dataValidations), this.map.hyperlinks.render(e2, t3.hyperlinks), this.map.printOptions.render(e2, a2), this.map.pageMargins.render(e2, i2), this.map.pageSetup.render(e2, t3.pageSetup), this.map.headerFooter.render(e2, t3.headerFooter), this.map.rowBreaks.render(e2, t3.rowBreaks), this.map.drawing.render(e2, t3.drawing), this.map.picture.render(e2, t3.background), this.map.tableParts.render(e2, t3.tables), this.map.extLst.render(e2, t3), t3.rels && t3.rels.forEach((t4) => {
              t4.Type === o.VmlDrawing && e2.leafNode("legacyDrawing", { "r:id": t4.Id });
            }), e2.closeNode();
          }
          parseOpen(e2) {
            return this.parser ? (this.parser.parseOpen(e2), true) : "worksheet" === e2.name ? (n.each(this.map, (e3) => {
              e3.reset();
            }), true) : (this.map[e2.name] && !this.ignoreNodes.includes(e2.name) && (this.parser = this.map[e2.name], this.parser.parseOpen(e2)), true);
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case "worksheet": {
                const e3 = this.map.sheetFormatPr.model || {};
                this.map.sheetPr.model && this.map.sheetPr.model.tabColor && (e3.tabColor = this.map.sheetPr.model.tabColor), this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties && (e3.outlineProperties = this.map.sheetPr.model.outlineProperties);
                const t3 = { fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false, margins: this.map.pageMargins.model }, r2 = Object.assign(t3, this.map.pageSetup.model, this.map.printOptions.model), n2 = O(this.map.conditionalFormatting.model, this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]);
                return this.model = { dimensions: this.map.dimension.model, cols: this.map.cols.model, rows: this.map.sheetData.model, mergeCells: this.map.mergeCells.model, hyperlinks: this.map.hyperlinks.model, dataValidations: this.map.dataValidations.model, properties: e3, views: this.map.sheetViews.model, pageSetup: r2, headerFooter: this.map.headerFooter.model, background: this.map.picture.model, drawing: this.map.drawing.model, tables: this.map.tableParts.model, conditionalFormattings: n2 }, this.map.autoFilter.model && (this.model.autoFilter = this.map.autoFilter.model), this.map.sheetProtection.model && (this.model.sheetProtection = this.map.sheetProtection.model), false;
              }
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            const r2 = (e2.relationships || []).reduce((r3, n3) => {
              if (r3[n3.Id] = n3, n3.Type === o.Comments && (e2.comments = t3.comments[n3.Target].comments), n3.Type === o.VmlDrawing && e2.comments && e2.comments.length) {
                const r4 = t3.vmlDrawings[n3.Target].comments;
                e2.comments.forEach((e3, t4) => {
                  e3.note = Object.assign({}, e3.note, r4[t4]);
                });
              }
              return r3;
            }, {});
            if (t3.commentsMap = (e2.comments || []).reduce((e3, t4) => (t4.ref && (e3[t4.ref] = t4), e3), {}), t3.hyperlinkMap = (e2.hyperlinks || []).reduce((e3, t4) => (t4.rId && (e3[t4.address] = r2[t4.rId].Target), e3), {}), t3.formulae = {}, e2.rows = e2.rows && e2.rows.filter(Boolean) || [], e2.rows.forEach((e3) => {
              e3.cells = e3.cells && e3.cells.filter(Boolean) || [];
            }), this.map.cols.reconcile(e2.cols, t3), this.map.sheetData.reconcile(e2.rows, t3), this.map.conditionalFormatting.reconcile(e2.conditionalFormattings, t3), e2.media = [], e2.drawing) {
              const n3 = r2[e2.drawing.rId].Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
              if (n3) {
                const r3 = n3[1];
                t3.drawings[r3].anchors.forEach((t4) => {
                  if (t4.medium) {
                    const r4 = { type: "image", imageId: t4.medium.index, range: t4.range, hyperlinks: t4.picture.hyperlinks };
                    e2.media.push(r4);
                  }
                });
              }
            }
            const n2 = e2.background && r2[e2.background.rId];
            if (n2) {
              const r3 = n2.Target.split("/media/")[1], i2 = t3.mediaIndex && t3.mediaIndex[r3];
              void 0 !== i2 && e2.media.push({ type: "background", imageId: i2 });
            }
            e2.tables = (e2.tables || []).map((e3) => {
              const n3 = r2[e3.rId];
              return t3.tables[n3.Target];
            }), delete e2.relationships, delete e2.hyperlinks, delete e2.comments;
          }
        }
        j.WORKSHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" }, t2.exports = j;
      }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 26, "../../../utils/xml-stream": 28, "../../rel-type": 31, "../base-xform": 32, "../list-xform": 71, "./auto-filter-xform": 72, "./cf/conditional-formattings-xform": 87, "./col-xform": 92, "./data-validations-xform": 93, "./dimension-xform": 94, "./drawing-xform": 95, "./ext-lst-xform": 96, "./header-footer-xform": 97, "./hyperlink-xform": 98, "./merge-cell-xform": 99, "./merges": 100, "./page-margins-xform": 103, "./page-setup-xform": 105, "./picture-xform": 106, "./print-options-xform": 107, "./row-breaks-xform": 108, "./row-xform": 109, "./sheet-format-properties-xform": 110, "./sheet-properties-xform": 111, "./sheet-protection-xform": 112, "./sheet-view-xform": 113, "./table-part-xform": 114 }], 116: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.attr = e2.attr;
          }
          render(e2, t3) {
            t3 && (e2.openNode(this.tag), e2.closeNode());
          }
          parseOpen(e2) {
            e2.name === this.tag && (this.model = true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 117: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.attr = e2.attr, this.attrs = e2.attrs, this._format = e2.format || function(e3) {
              try {
                return Number.isNaN(e3.getTime()) ? "" : e3.toISOString();
              } catch (e4) {
                return "";
              }
            }, this._parse = e2.parse || function(e3) {
              return new Date(e3);
            };
          }
          render(e2, t3) {
            t3 && (e2.openNode(this.tag), this.attrs && e2.addAttributes(this.attrs), this.attr ? e2.addAttribute(this.attr, this._format(t3)) : e2.writeText(this._format(t3)), e2.closeNode());
          }
          parseOpen(e2) {
            e2.name === this.tag && (this.attr ? this.model = this._parse(e2.attributes[this.attr]) : this.text = []);
          }
          parseText(e2) {
            this.attr || this.text.push(e2);
          }
          parseClose() {
            return this.attr || (this.model = this._parse(this.text.join(""))), false;
          }
        };
      }, { "../base-xform": 32 }], 118: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.attr = e2.attr, this.attrs = e2.attrs, this.zero = e2.zero;
          }
          render(e2, t3) {
            (t3 || this.zero) && (e2.openNode(this.tag), this.attrs && e2.addAttributes(this.attrs), this.attr ? e2.addAttribute(this.attr, t3) : e2.writeText(t3), e2.closeNode());
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.attr ? this.model = parseInt(e2.attributes[this.attr], 10) : this.text = [], true);
          }
          parseText(e2) {
            this.attr || this.text.push(e2);
          }
          parseClose() {
            return this.attr || (this.model = parseInt(this.text.join("") || 0, 10)), false;
          }
        };
      }, { "../base-xform": 32 }], 119: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.tag = e2.tag, this.attr = e2.attr, this.attrs = e2.attrs;
          }
          render(e2, t3) {
            void 0 !== t3 && (e2.openNode(this.tag), this.attrs && e2.addAttributes(this.attrs), this.attr ? e2.addAttribute(this.attr, t3) : e2.writeText(t3), e2.closeNode());
          }
          parseOpen(e2) {
            e2.name === this.tag && (this.attr ? this.model = e2.attributes[this.attr] : this.text = []);
          }
          parseText(e2) {
            this.attr || this.text.push(e2);
          }
          parseClose() {
            return this.attr || (this.model = this.text.join("")), false;
          }
        };
      }, { "../base-xform": 32 }], 120: [function(e, t2, r) {
        const n = e("./base-xform"), i = e("../../utils/xml-stream");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this._model = e2;
          }
          render(e2) {
            if (!this._xml) {
              const e3 = new i();
              !(function e4(t3, r2) {
                t3.openNode(r2.tag, r2.$), r2.c && r2.c.forEach((r3) => {
                  e4(t3, r3);
                }), r2.t && t3.writeText(r2.t), t3.closeNode();
              })(e3, this._model), this._xml = e3.xml;
            }
            e2.writeXml(this._xml);
          }
          parseOpen() {
            return true;
          }
          parseText() {
          }
          parseClose(e2) {
            switch (e2) {
              case this._model.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../../utils/xml-stream": 28, "./base-xform": 32 }], 121: [function(e, t2, r) {
        const n = e("./text-xform"), i = e("./rich-text-xform"), s = e("../base-xform");
        t2.exports = class extends s {
          constructor() {
            super(), this.map = { r: new i(), t: new n() };
          }
          get tag() {
            return "rPh";
          }
          render(e2, t3) {
            if (e2.openNode(this.tag, { sb: t3.sb || 0, eb: t3.eb || 0 }), t3 && t3.hasOwnProperty("richText") && t3.richText) {
              const { r: r2 } = this.map;
              t3.richText.forEach((t4) => {
                r2.render(e2, t4);
              });
            } else t3 && this.map.t.render(e2, t3.text);
            e2.closeNode();
          }
          parseOpen(e2) {
            const { name: t3 } = e2;
            return this.parser ? (this.parser.parseOpen(e2), true) : t3 === this.tag ? (this.model = { sb: parseInt(e2.attributes.sb, 10), eb: parseInt(e2.attributes.eb, 10) }, true) : (this.parser = this.map[t3], !!this.parser && (this.parser.parseOpen(e2), true));
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) {
              if (!this.parser.parseClose(e2)) {
                switch (e2) {
                  case "r": {
                    let e3 = this.model.richText;
                    e3 || (e3 = this.model.richText = []), e3.push(this.parser.model);
                    break;
                  }
                  case "t":
                    this.model.text = this.parser.model;
                }
                this.parser = void 0;
              }
              return true;
            }
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "./rich-text-xform": 122, "./text-xform": 125 }], 122: [function(e, t2, r) {
        const n = e("./text-xform"), i = e("../style/font-xform"), s = e("../base-xform");
        class o extends s {
          constructor(e2) {
            super(), this.model = e2;
          }
          get tag() {
            return "r";
          }
          get textXform() {
            return this._textXform || (this._textXform = new n());
          }
          get fontXform() {
            return this._fontXform || (this._fontXform = new i(o.FONT_OPTIONS));
          }
          render(e2, t3) {
            t3 = t3 || this.model, e2.openNode("r"), t3.font && this.fontXform.render(e2, t3.font), this.textXform.render(e2, t3.text), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "r":
                return this.model = {}, true;
              case "t":
                return this.parser = this.textXform, this.parser.parseOpen(e2), true;
              case "rPr":
                return this.parser = this.fontXform, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            switch (e2) {
              case "r":
                return false;
              case "t":
                return this.model.text = this.parser.model, this.parser = void 0, true;
              case "rPr":
                return this.model.font = this.parser.model, this.parser = void 0, true;
              default:
                return this.parser && this.parser.parseClose(e2), true;
            }
          }
        }
        o.FONT_OPTIONS = { tagName: "rPr", fontNameTag: "rFont" }, t2.exports = o;
      }, { "../base-xform": 32, "../style/font-xform": 131, "./text-xform": 125 }], 123: [function(e, t2, r) {
        const n = e("./text-xform"), i = e("./rich-text-xform"), s = e("./phonetic-text-xform"), o = e("../base-xform");
        t2.exports = class extends o {
          constructor(e2) {
            super(), this.model = e2, this.map = { r: new i(), t: new n(), rPh: new s() };
          }
          get tag() {
            return "si";
          }
          render(e2, t3) {
            e2.openNode(this.tag), t3 && t3.hasOwnProperty("richText") && t3.richText ? t3.richText.length ? t3.richText.forEach((t4) => {
              this.map.r.render(e2, t4);
            }) : this.map.t.render(e2, "") : null != t3 && this.map.t.render(e2, t3), e2.closeNode();
          }
          parseOpen(e2) {
            const { name: t3 } = e2;
            return this.parser ? (this.parser.parseOpen(e2), true) : t3 === this.tag ? (this.model = {}, true) : (this.parser = this.map[t3], !!this.parser && (this.parser.parseOpen(e2), true));
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) {
              if (!this.parser.parseClose(e2)) {
                switch (e2) {
                  case "r": {
                    let e3 = this.model.richText;
                    e3 || (e3 = this.model.richText = []), e3.push(this.parser.model);
                    break;
                  }
                  case "t":
                    this.model = this.parser.model;
                }
                this.parser = void 0;
              }
              return true;
            }
            switch (e2) {
              case this.tag:
                return false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "./phonetic-text-xform": 121, "./rich-text-xform": 122, "./text-xform": 125 }], 124: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("./shared-string-xform");
        t2.exports = class extends i {
          constructor(e2) {
            super(), this.model = e2 || { values: [], count: 0 }, this.hash = /* @__PURE__ */ Object.create(null), this.rich = /* @__PURE__ */ Object.create(null);
          }
          get sharedStringXform() {
            return this._sharedStringXform || (this._sharedStringXform = new s());
          }
          get values() {
            return this.model.values;
          }
          get uniqueCount() {
            return this.model.values.length;
          }
          get count() {
            return this.model.count;
          }
          getString(e2) {
            return this.model.values[e2];
          }
          add(e2) {
            return e2.richText ? this.addRichText(e2) : this.addText(e2);
          }
          addText(e2) {
            let t3 = this.hash[e2];
            return void 0 === t3 && (t3 = this.hash[e2] = this.model.values.length, this.model.values.push(e2)), this.model.count++, t3;
          }
          addRichText(e2) {
            const t3 = this.sharedStringXform.toXml(e2);
            let r2 = this.rich[t3];
            return void 0 === r2 && (r2 = this.rich[t3] = this.model.values.length, this.model.values.push(e2)), this.model.count++, r2;
          }
          render(e2, t3) {
            t3 = t3 || this._values, e2.openXml(n.StdDocAttributes), e2.openNode("sst", { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", count: t3.count, uniqueCount: t3.values.length });
            const r2 = this.sharedStringXform;
            t3.values.forEach((t4) => {
              r2.render(e2, t4);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "sst":
                return true;
              case "si":
                return this.parser = this.sharedStringXform, this.parser.parseOpen(e2), true;
              default:
                throw new Error("Unexpected xml node in parseOpen: " + JSON.stringify(e2));
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.model.values.push(this.parser.model), this.model.count++, this.parser = void 0), true;
            switch (e2) {
              case "sst":
                return false;
              default:
                throw new Error("Unexpected xml node in parseClose: " + e2);
            }
          }
        };
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "./shared-string-xform": 123 }], 125: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "t";
          }
          render(e2, t3) {
            e2.openNode("t"), /^\s|\n|\s$/.test(t3) && e2.addAttribute("xml:space", "preserve"), e2.writeText(t3), e2.closeNode();
          }
          get model() {
            return this._text.join("").replace(/_x([0-9A-F]{4})_/g, (e2, t3) => String.fromCharCode(parseInt(t3, 16)));
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "t":
                return this._text = [], true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this._text.push(e2);
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 126: [function(e, t2, r) {
        const n = e("../../../doc/enums"), i = e("../../../utils/utils"), s = e("../base-xform"), o = { horizontalValues: ["left", "center", "right", "fill", "centerContinuous", "distributed", "justify"].reduce((e2, t3) => (e2[t3] = true, e2), {}), horizontal(e2) {
          return this.horizontalValues[e2] ? e2 : void 0;
        }, verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce((e2, t3) => (e2[t3] = true, e2), {}), vertical(e2) {
          return "middle" === e2 ? "center" : this.verticalValues[e2] ? e2 : void 0;
        }, wrapText: (e2) => !!e2 || void 0, shrinkToFit: (e2) => !!e2 || void 0, textRotation(e2) {
          switch (e2) {
            case "vertical":
              return e2;
            default:
              return (e2 = i.validInt(e2)) >= -90 && e2 <= 90 ? e2 : void 0;
          }
        }, indent: (e2) => (e2 = i.validInt(e2), Math.max(0, e2)), readingOrder(e2) {
          switch (e2) {
            case "ltr":
              return n.ReadingOrder.LeftToRight;
            case "rtl":
              return n.ReadingOrder.RightToLeft;
            default:
              return;
          }
        } }, a = { toXml(e2) {
          if (e2 = o.textRotation(e2)) {
            if ("vertical" === e2) return 255;
            const t3 = Math.round(e2);
            if (t3 >= 0 && t3 <= 90) return t3;
            if (t3 < 0 && t3 >= -90) return 90 - t3;
          }
        }, toModel(e2) {
          const t3 = i.validInt(e2);
          if (void 0 !== t3) {
            if (255 === t3) return "vertical";
            if (t3 >= 0 && t3 <= 90) return t3;
            if (t3 > 90 && t3 <= 180) return 90 - t3;
          }
        } };
        t2.exports = class extends s {
          get tag() {
            return "alignment";
          }
          render(e2, t3) {
            e2.addRollback(), e2.openNode("alignment");
            let r2 = false;
            function n2(t4, n3) {
              n3 && (e2.addAttribute(t4, n3), r2 = true);
            }
            n2("horizontal", o.horizontal(t3.horizontal)), n2("vertical", o.vertical(t3.vertical)), n2("wrapText", !!o.wrapText(t3.wrapText) && "1"), n2("shrinkToFit", !!o.shrinkToFit(t3.shrinkToFit) && "1"), n2("indent", o.indent(t3.indent)), n2("textRotation", a.toXml(t3.textRotation)), n2("readingOrder", o.readingOrder(t3.readingOrder)), e2.closeNode(), r2 ? e2.commit() : e2.rollback();
          }
          parseOpen(e2) {
            const t3 = {};
            let r2 = false;
            function n2(e3, n3, i2) {
              e3 && (t3[n3] = i2, r2 = true);
            }
            n2(e2.attributes.horizontal, "horizontal", e2.attributes.horizontal), n2(e2.attributes.vertical, "vertical", "center" === e2.attributes.vertical ? "middle" : e2.attributes.vertical), n2(e2.attributes.wrapText, "wrapText", i.parseBoolean(e2.attributes.wrapText)), n2(e2.attributes.shrinkToFit, "shrinkToFit", i.parseBoolean(e2.attributes.shrinkToFit)), n2(e2.attributes.indent, "indent", parseInt(e2.attributes.indent, 10)), n2(e2.attributes.textRotation, "textRotation", a.toModel(e2.attributes.textRotation)), n2(e2.attributes.readingOrder, "readingOrder", "2" === e2.attributes.readingOrder ? "rtl" : "ltr"), this.model = r2 ? t3 : null;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../../../doc/enums": 7, "../../../utils/utils": 27, "../base-xform": 32 }], 127: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../../../utils/utils"), s = e("./color-xform");
        class o extends n {
          constructor(e2) {
            super(), this.name = e2, this.map = { color: new s() };
          }
          get tag() {
            return this.name;
          }
          render(e2, t3, r2) {
            const n2 = t3 && t3.color || r2 || this.defaultColor;
            e2.openNode(this.name), t3 && t3.style && (e2.addAttribute("style", t3.style), n2 && this.map.color.render(e2, n2)), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.name: {
                const { style: t3 } = e2.attributes;
                return this.model = t3 ? { style: t3 } : void 0, true;
              }
              case "color":
                return this.parser = this.map.color, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return this.parser ? (this.parser.parseClose(e2) || (this.parser = void 0), true) : (e2 === this.name && this.map.color.model && (this.model || (this.model = {}), this.model.color = this.map.color.model), false);
          }
          validStyle(e2) {
            return o.validStyleValues[e2];
          }
        }
        o.validStyleValues = ["thin", "dashed", "dotted", "dashDot", "hair", "dashDotDot", "slantDashDot", "mediumDashed", "mediumDashDotDot", "mediumDashDot", "medium", "double", "thick"].reduce((e2, t3) => (e2[t3] = true, e2), {});
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { top: new o("top"), left: new o("left"), bottom: new o("bottom"), right: new o("right"), diagonal: new o("diagonal") };
          }
          render(e2, t3) {
            const { color: r2 } = t3;
            function n2(n3, i2) {
              n3 && !n3.color && t3.color && (n3 = { ...n3, color: t3.color }), i2.render(e2, n3, r2);
            }
            e2.openNode("border"), t3.diagonal && t3.diagonal.style && (t3.diagonal.up && e2.addAttribute("diagonalUp", "1"), t3.diagonal.down && e2.addAttribute("diagonalDown", "1")), n2(t3.left, this.map.left), n2(t3.right, this.map.right), n2(t3.top, this.map.top), n2(t3.bottom, this.map.bottom), n2(t3.diagonal, this.map.diagonal), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "border":
                return this.reset(), this.diagonalUp = i.parseBoolean(e2.attributes.diagonalUp), this.diagonalDown = i.parseBoolean(e2.attributes.diagonalDown), true;
              default:
                return this.parser = this.map[e2.name], !!this.parser && (this.parser.parseOpen(e2), true);
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            if ("border" === e2) {
              const e3 = this.model = {}, t3 = function(t4, r2, n2) {
                r2 && (n2 && Object.assign(r2, n2), e3[t4] = r2);
              };
              t3("left", this.map.left.model), t3("right", this.map.right.model), t3("top", this.map.top.model), t3("bottom", this.map.bottom.model), t3("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
            }
            return false;
          }
        };
      }, { "../../../utils/utils": 27, "../base-xform": 32, "./color-xform": 128 }], 128: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.name = e2 || "color";
          }
          get tag() {
            return this.name;
          }
          render(e2, t3) {
            return !!t3 && (e2.openNode(this.name), t3.argb ? e2.addAttribute("rgb", t3.argb) : void 0 !== t3.theme ? (e2.addAttribute("theme", t3.theme), void 0 !== t3.tint && e2.addAttribute("tint", t3.tint)) : void 0 !== t3.indexed ? e2.addAttribute("indexed", t3.indexed) : e2.addAttribute("auto", "1"), e2.closeNode(), true);
          }
          parseOpen(e2) {
            return e2.name === this.name && (e2.attributes.rgb ? this.model = { argb: e2.attributes.rgb } : e2.attributes.theme ? (this.model = { theme: parseInt(e2.attributes.theme, 10) }, e2.attributes.tint && (this.model.tint = parseFloat(e2.attributes.tint))) : e2.attributes.indexed ? this.model = { indexed: parseInt(e2.attributes.indexed, 10) } : this.model = void 0, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 129: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./alignment-xform"), s = e("./border-xform"), o = e("./fill-xform"), a = e("./font-xform"), l = e("./numfmt-xform"), c = e("./protection-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { alignment: new i(), border: new s(), fill: new o(), font: new a(), numFmt: new l(), protection: new c() };
          }
          get tag() {
            return "dxf";
          }
          render(e2, t3) {
            if (e2.openNode(this.tag), t3.font && this.map.font.render(e2, t3.font), t3.numFmt && t3.numFmtId) {
              const r2 = { id: t3.numFmtId, formatCode: t3.numFmt };
              this.map.numFmt.render(e2, r2);
            }
            t3.fill && this.map.fill.render(e2, t3.fill), t3.alignment && this.map.alignment.render(e2, t3.alignment), t3.border && this.map.border.render(e2, t3.border), t3.protection && this.map.protection.render(e2, t3.protection), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                return this.reset(), true;
              default:
                return this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2), true;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return this.parser ? (this.parser.parseClose(e2) || (this.parser = void 0), true) : e2 !== this.tag || (this.model = { alignment: this.map.alignment.model, border: this.map.border.model, fill: this.map.fill.model, font: this.map.font.model, numFmt: this.map.numFmt.model, protection: this.map.protection.model }, false);
          }
        };
      }, { "../base-xform": 32, "./alignment-xform": 126, "./border-xform": 127, "./fill-xform": 130, "./font-xform": 131, "./numfmt-xform": 132, "./protection-xform": 133 }], 130: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./color-xform");
        class s extends n {
          constructor() {
            super(), this.map = { color: new i() };
          }
          get tag() {
            return "stop";
          }
          render(e2, t3) {
            e2.openNode("stop"), e2.addAttribute("position", t3.position), this.map.color.render(e2, t3.color), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "stop":
                return this.model = { position: parseFloat(e2.attributes.position) }, true;
              case "color":
                return this.parser = this.map.color, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose(e2) {
            return !!this.parser && (this.parser.parseClose(e2) || (this.model.color = this.parser.model, this.parser = void 0), true);
          }
        }
        class o extends n {
          constructor() {
            super(), this.map = { fgColor: new i("fgColor"), bgColor: new i("bgColor") };
          }
          get name() {
            return "pattern";
          }
          get tag() {
            return "patternFill";
          }
          render(e2, t3) {
            e2.openNode("patternFill"), e2.addAttribute("patternType", t3.pattern), t3.fgColor && this.map.fgColor.render(e2, t3.fgColor), t3.bgColor && this.map.bgColor.render(e2, t3.bgColor), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "patternFill":
                return this.model = { type: "pattern", pattern: e2.attributes.patternType }, true;
              default:
                return this.parser = this.map[e2.name], !!this.parser && (this.parser.parseOpen(e2), true);
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return !!this.parser && (this.parser.parseClose(e2) || (this.parser.model && (this.model[e2] = this.parser.model), this.parser = void 0), true);
          }
        }
        class a extends n {
          constructor() {
            super(), this.map = { stop: new s() };
          }
          get name() {
            return "gradient";
          }
          get tag() {
            return "gradientFill";
          }
          render(e2, t3) {
            switch (e2.openNode("gradientFill"), t3.gradient) {
              case "angle":
                e2.addAttribute("degree", t3.degree);
                break;
              case "path":
                e2.addAttribute("type", "path"), t3.center.left && (e2.addAttribute("left", t3.center.left), void 0 === t3.center.right && e2.addAttribute("right", t3.center.left)), t3.center.right && e2.addAttribute("right", t3.center.right), t3.center.top && (e2.addAttribute("top", t3.center.top), void 0 === t3.center.bottom && e2.addAttribute("bottom", t3.center.top)), t3.center.bottom && e2.addAttribute("bottom", t3.center.bottom);
            }
            const r2 = this.map.stop;
            t3.stops.forEach((t4) => {
              r2.render(e2, t4);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "gradientFill": {
                const t3 = this.model = { stops: [] };
                return e2.attributes.degree ? (t3.gradient = "angle", t3.degree = parseInt(e2.attributes.degree, 10)) : "path" === e2.attributes.type && (t3.gradient = "path", t3.center = { left: e2.attributes.left ? parseFloat(e2.attributes.left) : 0, top: e2.attributes.top ? parseFloat(e2.attributes.top) : 0 }, e2.attributes.right !== e2.attributes.left && (t3.center.right = e2.attributes.right ? parseFloat(e2.attributes.right) : 0), e2.attributes.bottom !== e2.attributes.top && (t3.center.bottom = e2.attributes.bottom ? parseFloat(e2.attributes.bottom) : 0)), true;
              }
              case "stop":
                return this.parser = this.map.stop, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return !!this.parser && (this.parser.parseClose(e2) || (this.model.stops.push(this.parser.model), this.parser = void 0), true);
          }
        }
        class l extends n {
          constructor() {
            super(), this.map = { patternFill: new o(), gradientFill: new a() };
          }
          get tag() {
            return "fill";
          }
          render(e2, t3) {
            switch (e2.addRollback(), e2.openNode("fill"), t3.type) {
              case "pattern":
                this.map.patternFill.render(e2, t3);
                break;
              case "gradient":
                this.map.gradientFill.render(e2, t3);
                break;
              default:
                return void e2.rollback();
            }
            e2.closeNode(), e2.commit();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "fill":
                return this.model = {}, true;
              default:
                return this.parser = this.map[e2.name], !!this.parser && (this.parser.parseOpen(e2), true);
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return !!this.parser && (this.parser.parseClose(e2) || (this.model = this.parser.model, this.model.type = this.parser.name, this.parser = void 0), true);
          }
          validStyle(e2) {
            return l.validPatternValues[e2];
          }
        }
        l.validPatternValues = ["none", "solid", "darkVertical", "darkGray", "mediumGray", "lightGray", "gray125", "gray0625", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "lightGrid"].reduce((e2, t3) => (e2[t3] = true, e2), {}), l.StopXform = s, l.PatternFillXform = o, l.GradientFillXform = a, t2.exports = l;
      }, { "../base-xform": 32, "./color-xform": 128 }], 131: [function(e, t2, r) {
        const n = e("./color-xform"), i = e("../simple/boolean-xform"), s = e("../simple/integer-xform"), o = e("../simple/string-xform"), a = e("./underline-xform"), l = e("../../../utils/under-dash"), c = e("../base-xform");
        class u extends c {
          constructor(e2) {
            super(), this.options = e2 || u.OPTIONS, this.map = { b: { prop: "bold", xform: new i({ tag: "b", attr: "val" }) }, i: { prop: "italic", xform: new i({ tag: "i", attr: "val" }) }, u: { prop: "underline", xform: new a() }, charset: { prop: "charset", xform: new s({ tag: "charset", attr: "val" }) }, color: { prop: "color", xform: new n() }, condense: { prop: "condense", xform: new i({ tag: "condense", attr: "val" }) }, extend: { prop: "extend", xform: new i({ tag: "extend", attr: "val" }) }, family: { prop: "family", xform: new s({ tag: "family", attr: "val" }) }, outline: { prop: "outline", xform: new i({ tag: "outline", attr: "val" }) }, vertAlign: { prop: "vertAlign", xform: new o({ tag: "vertAlign", attr: "val" }) }, scheme: { prop: "scheme", xform: new o({ tag: "scheme", attr: "val" }) }, shadow: { prop: "shadow", xform: new i({ tag: "shadow", attr: "val" }) }, strike: { prop: "strike", xform: new i({ tag: "strike", attr: "val" }) }, sz: { prop: "size", xform: new s({ tag: "sz", attr: "val" }) } }, this.map[this.options.fontNameTag] = { prop: "name", xform: new o({ tag: this.options.fontNameTag, attr: "val" }) };
          }
          get tag() {
            return this.options.tagName;
          }
          render(e2, t3) {
            const { map: r2 } = this;
            e2.openNode(this.options.tagName), l.each(this.map, (n2, i2) => {
              r2[i2].xform.render(e2, t3[n2.prop]);
            }), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            if (this.map[e2.name]) return this.parser = this.map[e2.name].xform, this.parser.parseOpen(e2);
            switch (e2.name) {
              case this.options.tagName:
                return this.model = {}, true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser && !this.parser.parseClose(e2)) {
              const t3 = this.map[e2];
              return this.parser.model && (this.model[t3.prop] = this.parser.model), this.parser = void 0, true;
            }
            switch (e2) {
              case this.options.tagName:
                return false;
              default:
                return true;
            }
          }
        }
        u.OPTIONS = { tagName: "font", fontNameTag: "name" }, t2.exports = u;
      }, { "../../../utils/under-dash": 26, "../base-xform": 32, "../simple/boolean-xform": 116, "../simple/integer-xform": 118, "../simple/string-xform": 119, "./color-xform": 128, "./underline-xform": 136 }], 132: [function(e, t2, r) {
        const n = e("../../../utils/under-dash"), i = e("../../defaultnumformats"), s = e("../base-xform");
        const o = (function() {
          const e2 = {};
          return n.each(i, (t3, r2) => {
            t3.f && (e2[t3.f] = parseInt(r2, 10));
          }), e2;
        })();
        class a extends s {
          constructor(e2, t3) {
            super(), this.id = e2, this.formatCode = t3;
          }
          get tag() {
            return "numFmt";
          }
          render(e2, t3) {
            e2.leafNode("numFmt", { numFmtId: t3.id, formatCode: t3.formatCode });
          }
          parseOpen(e2) {
            switch (e2.name) {
              case "numFmt":
                return this.model = { id: parseInt(e2.attributes.numFmtId, 10), formatCode: e2.attributes.formatCode.replace(/[\\](.)/g, "$1") }, true;
              default:
                return false;
            }
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        }
        a.getDefaultFmtId = function(e2) {
          return o[e2];
        }, a.getDefaultFmtCode = function(e2) {
          return i[e2] && i[e2].f;
        }, t2.exports = a;
      }, { "../../../utils/under-dash": 26, "../../defaultnumformats": 30, "../base-xform": 32 }], 133: [function(e, t2, r) {
        const n = e("../base-xform"), i = { boolean: (e2, t3) => void 0 === e2 ? t3 : e2 };
        t2.exports = class extends n {
          get tag() {
            return "protection";
          }
          render(e2, t3) {
            e2.addRollback(), e2.openNode("protection");
            let r2 = false;
            function n2(t4, n3) {
              void 0 !== n3 && (e2.addAttribute(t4, n3), r2 = true);
            }
            n2("locked", i.boolean(t3.locked, true) ? void 0 : "0"), n2("hidden", i.boolean(t3.hidden, false) ? "1" : void 0), e2.closeNode(), r2 ? e2.commit() : e2.rollback();
          }
          parseOpen(e2) {
            const t3 = { locked: !("0" === e2.attributes.locked), hidden: "1" === e2.attributes.hidden }, r2 = !t3.locked || t3.hidden;
            this.model = r2 ? t3 : null;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 134: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./alignment-xform"), s = e("./protection-xform");
        t2.exports = class extends n {
          constructor(e2) {
            super(), this.xfId = !(!e2 || !e2.xfId), this.map = { alignment: new i(), protection: new s() };
          }
          get tag() {
            return "xf";
          }
          render(e2, t3) {
            e2.openNode("xf", { numFmtId: t3.numFmtId || 0, fontId: t3.fontId || 0, fillId: t3.fillId || 0, borderId: t3.borderId || 0 }), this.xfId && e2.addAttribute("xfId", t3.xfId || 0), t3.numFmtId && e2.addAttribute("applyNumberFormat", "1"), t3.fontId && e2.addAttribute("applyFont", "1"), t3.fillId && e2.addAttribute("applyFill", "1"), t3.borderId && e2.addAttribute("applyBorder", "1"), t3.alignment && e2.addAttribute("applyAlignment", "1"), t3.protection && e2.addAttribute("applyProtection", "1"), t3.alignment && this.map.alignment.render(e2, t3.alignment), t3.protection && this.map.protection.render(e2, t3.protection), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "xf":
                return this.model = { numFmtId: parseInt(e2.attributes.numFmtId, 10), fontId: parseInt(e2.attributes.fontId, 10), fillId: parseInt(e2.attributes.fillId, 10), borderId: parseInt(e2.attributes.borderId, 10) }, this.xfId && (this.model.xfId = parseInt(e2.attributes.xfId, 10)), true;
              case "alignment":
                return this.parser = this.map.alignment, this.parser.parseOpen(e2), true;
              case "protection":
                return this.parser = this.map.protection, this.parser.parseOpen(e2), true;
              default:
                return false;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            return this.parser ? (this.parser.parseClose(e2) || (this.map.protection === this.parser ? this.model.protection = this.parser.model : this.model.alignment = this.parser.model, this.parser = void 0), true) : "xf" !== e2;
          }
        };
      }, { "../base-xform": 32, "./alignment-xform": 126, "./protection-xform": 133 }], 135: [function(e, t2, r) {
        const n = e("../../../doc/enums"), i = e("../../../utils/xml-stream"), s = e("../base-xform"), o = e("../static-xform"), a = e("../list-xform"), l = e("./font-xform"), c = e("./fill-xform"), u = e("./border-xform"), h = e("./numfmt-xform"), f = e("./style-xform"), d = e("./dxf-xform");
        class p extends s {
          constructor(e2) {
            super(), this.map = { numFmts: new a({ tag: "numFmts", count: true, childXform: new h() }), fonts: new a({ tag: "fonts", count: true, childXform: new l(), $: { "x14ac:knownFonts": 1 } }), fills: new a({ tag: "fills", count: true, childXform: new c() }), borders: new a({ tag: "borders", count: true, childXform: new u() }), cellStyleXfs: new a({ tag: "cellStyleXfs", count: true, childXform: new f() }), cellXfs: new a({ tag: "cellXfs", count: true, childXform: new f({ xfId: true }) }), dxfs: new a({ tag: "dxfs", always: true, count: true, childXform: new d() }), numFmt: new h(), font: new l(), fill: new c(), border: new u(), style: new f({ xfId: true }), cellStyles: p.STATIC_XFORMS.cellStyles, tableStyles: p.STATIC_XFORMS.tableStyles, extLst: p.STATIC_XFORMS.extLst }, e2 && this.init();
          }
          initIndex() {
            this.index = { style: {}, numFmt: {}, numFmtNextId: 164, font: {}, border: {}, fill: {} };
          }
          init() {
            this.model = { styles: [], numFmts: [], fonts: [], borders: [], fills: [], dxfs: [] }, this.initIndex(), this._addBorder({}), this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }), this._addFill({ type: "pattern", pattern: "none" }), this._addFill({ type: "pattern", pattern: "gray125" }), this.weakMap = /* @__PURE__ */ new WeakMap();
          }
          render(e2, t3) {
            t3 = t3 || this.model, e2.openXml(i.StdDocAttributes), e2.openNode("styleSheet", p.STYLESHEET_ATTRIBUTES), this.index ? (t3.numFmts && t3.numFmts.length && (e2.openNode("numFmts", { count: t3.numFmts.length }), t3.numFmts.forEach((t4) => {
              e2.writeXml(t4);
            }), e2.closeNode()), t3.fonts.length || this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }), e2.openNode("fonts", { count: t3.fonts.length, "x14ac:knownFonts": 1 }), t3.fonts.forEach((t4) => {
              e2.writeXml(t4);
            }), e2.closeNode(), e2.openNode("fills", { count: t3.fills.length }), t3.fills.forEach((t4) => {
              e2.writeXml(t4);
            }), e2.closeNode(), e2.openNode("borders", { count: t3.borders.length }), t3.borders.forEach((t4) => {
              e2.writeXml(t4);
            }), e2.closeNode(), this.map.cellStyleXfs.render(e2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]), e2.openNode("cellXfs", { count: t3.styles.length }), t3.styles.forEach((t4) => {
              e2.writeXml(t4);
            }), e2.closeNode()) : (this.map.numFmts.render(e2, t3.numFmts), this.map.fonts.render(e2, t3.fonts), this.map.fills.render(e2, t3.fills), this.map.borders.render(e2, t3.borders), this.map.cellStyleXfs.render(e2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]), this.map.cellXfs.render(e2, t3.styles)), p.STATIC_XFORMS.cellStyles.render(e2), this.map.dxfs.render(e2, t3.dxfs), p.STATIC_XFORMS.tableStyles.render(e2), p.STATIC_XFORMS.extLst.render(e2), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case "styleSheet":
                return this.initIndex(), true;
              default:
                return this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2), true;
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case "styleSheet": {
                this.model = {};
                const e3 = (e4, t3) => {
                  t3.model && t3.model.length && (this.model[e4] = t3.model);
                };
                if (e3("numFmts", this.map.numFmts), e3("fonts", this.map.fonts), e3("fills", this.map.fills), e3("borders", this.map.borders), e3("styles", this.map.cellXfs), e3("dxfs", this.map.dxfs), this.index = { model: [], numFmt: [] }, this.model.numFmts) {
                  const e4 = this.index.numFmt;
                  this.model.numFmts.forEach((t3) => {
                    e4[t3.id] = t3.formatCode;
                  });
                }
                return false;
              }
              default:
                return true;
            }
          }
          addStyleModel(e2, t3) {
            if (!e2) return 0;
            if (this.model.fonts.length || this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }), this.weakMap && this.weakMap.has(e2)) return this.weakMap.get(e2);
            const r2 = {};
            if (t3 = t3 || n.ValueType.Number, e2.numFmt) r2.numFmtId = this._addNumFmtStr(e2.numFmt);
            else switch (t3) {
              case n.ValueType.Number:
                r2.numFmtId = this._addNumFmtStr("General");
                break;
              case n.ValueType.Date:
                r2.numFmtId = this._addNumFmtStr("mm-dd-yy");
            }
            e2.font && (r2.fontId = this._addFont(e2.font)), e2.border && (r2.borderId = this._addBorder(e2.border)), e2.fill && (r2.fillId = this._addFill(e2.fill)), e2.alignment && (r2.alignment = e2.alignment), e2.protection && (r2.protection = e2.protection);
            const i2 = this._addStyle(r2);
            return this.weakMap && this.weakMap.set(e2, i2), i2;
          }
          getStyleModel(e2) {
            const t3 = this.model.styles[e2];
            if (!t3) return null;
            let r2 = this.index.model[e2];
            if (r2) return r2;
            if (r2 = this.index.model[e2] = {}, t3.numFmtId) {
              const e3 = this.index.numFmt[t3.numFmtId] || h.getDefaultFmtCode(t3.numFmtId);
              e3 && (r2.numFmt = e3);
            }
            function n2(e3, t4, n3) {
              if (n3 || 0 === n3) {
                const i2 = t4[n3];
                i2 && (r2[e3] = i2);
              }
            }
            return n2("font", this.model.fonts, t3.fontId), n2("border", this.model.borders, t3.borderId), n2("fill", this.model.fills, t3.fillId), t3.alignment && (r2.alignment = t3.alignment), t3.protection && (r2.protection = t3.protection), r2;
          }
          addDxfStyle(e2) {
            return e2.numFmt && (e2.numFmtId = this._addNumFmtStr(e2.numFmt)), this.model.dxfs.push(e2), this.model.dxfs.length - 1;
          }
          getDxfStyle(e2) {
            return this.model.dxfs[e2];
          }
          _addStyle(e2) {
            const t3 = this.map.style.toXml(e2);
            let r2 = this.index.style[t3];
            return void 0 === r2 && (r2 = this.index.style[t3] = this.model.styles.length, this.model.styles.push(t3)), r2;
          }
          _addNumFmtStr(e2) {
            let t3 = h.getDefaultFmtId(e2);
            if (void 0 !== t3) return t3;
            if (t3 = this.index.numFmt[e2], void 0 !== t3) return t3;
            t3 = this.index.numFmt[e2] = 164 + this.model.numFmts.length;
            const r2 = this.map.numFmt.toXml({ id: t3, formatCode: e2 });
            return this.model.numFmts.push(r2), t3;
          }
          _addFont(e2) {
            const t3 = this.map.font.toXml(e2);
            let r2 = this.index.font[t3];
            return void 0 === r2 && (r2 = this.index.font[t3] = this.model.fonts.length, this.model.fonts.push(t3)), r2;
          }
          _addBorder(e2) {
            const t3 = this.map.border.toXml(e2);
            let r2 = this.index.border[t3];
            return void 0 === r2 && (r2 = this.index.border[t3] = this.model.borders.length, this.model.borders.push(t3)), r2;
          }
          _addFill(e2) {
            const t3 = this.map.fill.toXml(e2);
            let r2 = this.index.fill[t3];
            return void 0 === r2 && (r2 = this.index.fill[t3] = this.model.fills.length, this.model.fills.push(t3)), r2;
          }
        }
        p.STYLESHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac x16r2", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac", "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" }, p.STATIC_XFORMS = { cellStyles: new o({ tag: "cellStyles", $: { count: 1 }, c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }] }), dxfs: new o({ tag: "dxfs", $: { count: 0 } }), tableStyles: new o({ tag: "tableStyles", $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" } }), extLst: new o({ tag: "extLst", c: [{ tag: "ext", $: { uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }, c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }] }, { tag: "ext", $: { uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }] }] }) };
        p.Mock = class extends p {
          constructor() {
            super(), this.model = { styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }], numFmts: [], fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }], borders: [{}], fills: [{ type: "pattern", pattern: "none" }, { type: "pattern", pattern: "gray125" }] };
          }
          parseStream(e2) {
            return e2.autodrain(), Promise.resolve();
          }
          addStyleModel(e2, t3) {
            switch (t3) {
              case n.ValueType.Date:
                return this.dateStyleId;
              default:
                return 0;
            }
          }
          get dateStyleId() {
            if (!this._dateStyleId) {
              const e2 = { numFmtId: h.getDefaultFmtId("mm-dd-yy") };
              this._dateStyleId = this.model.styles.length, this.model.styles.push(e2);
            }
            return this._dateStyleId;
          }
          getStyleModel() {
            return {};
          }
        }, t2.exports = p;
      }, { "../../../doc/enums": 7, "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "../static-xform": 120, "./border-xform": 127, "./dxf-xform": 129, "./fill-xform": 130, "./font-xform": 131, "./numfmt-xform": 132, "./style-xform": 134 }], 136: [function(e, t2, r) {
        const n = e("../base-xform");
        class i extends n {
          constructor(e2) {
            super(), this.model = e2;
          }
          get tag() {
            return "u";
          }
          render(e2, t3) {
            if (true === (t3 = t3 || this.model)) e2.leafNode("u");
            else {
              const r2 = i.Attributes[t3];
              r2 && e2.leafNode("u", r2);
            }
          }
          parseOpen(e2) {
            "u" === e2.name && (this.model = e2.attributes.val || true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        }
        i.Attributes = { single: {}, double: { val: "double" }, singleAccounting: { val: "singleAccounting" }, doubleAccounting: { val: "doubleAccounting" } }, t2.exports = i;
      }, { "../base-xform": 32 }], 137: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("./filter-column-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { filterColumn: new i() };
          }
          get tag() {
            return "autoFilter";
          }
          prepare(e2) {
            e2.columns.forEach((e3, t3) => {
              this.map.filterColumn.prepare(e3, { index: t3 });
            });
          }
          render(e2, t3) {
            return e2.openNode(this.tag, { ref: t3.autoFilterRef }), t3.columns.forEach((t4) => {
              this.map.filterColumn.render(e2, t4);
            }), e2.closeNode(), true;
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            switch (e2.name) {
              case this.tag:
                return this.model = { autoFilterRef: e2.attributes.ref, columns: [] }, true;
              default:
                if (this.parser = this.map[e2.name], this.parser) return this.parseOpen(e2), true;
                throw new Error("Unexpected xml node in parseOpen: " + JSON.stringify(e2));
            }
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.model.columns.push(this.parser.model), this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return false;
              default:
                throw new Error("Unexpected xml node in parseClose: " + e2);
            }
          }
        };
      }, { "../base-xform": 32, "./filter-column-xform": 139 }], 138: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "customFilter";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, { val: t3.val, operator: t3.operator });
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.model = { val: e2.attributes.val, operator: e2.attributes.operator }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 139: [function(e, t2, r) {
        const n = e("../base-xform"), i = e("../list-xform"), s = e("./custom-filter-xform"), o = e("./filter-xform");
        t2.exports = class extends n {
          constructor() {
            super(), this.map = { customFilters: new i({ tag: "customFilters", count: false, empty: true, childXform: new s() }), filters: new i({ tag: "filters", count: false, empty: true, childXform: new o() }) };
          }
          get tag() {
            return "filterColumn";
          }
          prepare(e2, t3) {
            e2.colId = t3.index.toString();
          }
          render(e2, t3) {
            return t3.customFilters ? (e2.openNode(this.tag, { colId: t3.colId, hiddenButton: t3.filterButton ? "0" : "1" }), this.map.customFilters.render(e2, t3.customFilters), e2.closeNode(), true) : (e2.leafNode(this.tag, { colId: t3.colId, hiddenButton: t3.filterButton ? "0" : "1" }), true);
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            const { attributes: t3 } = e2;
            switch (e2.name) {
              case this.tag:
                return this.model = { filterButton: "0" === t3.hiddenButton }, true;
              default:
                if (this.parser = this.map[e2.name], this.parser) return this.parseOpen(e2), true;
                throw new Error("Unexpected xml node in parseOpen: " + JSON.stringify(e2));
            }
          }
          parseText() {
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model.customFilters = this.map.customFilters.model, false;
              default:
                return true;
            }
          }
        };
      }, { "../base-xform": 32, "../list-xform": 71, "./custom-filter-xform": 138, "./filter-xform": 140 }], 140: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "filter";
          }
          render(e2, t3) {
            e2.leafNode(this.tag, { val: t3.val });
          }
          parseOpen(e2) {
            return e2.name === this.tag && (this.model = { val: e2.attributes.val }, true);
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 141: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "tableColumn";
          }
          prepare(e2, t3) {
            e2.id = t3.index + 1;
          }
          render(e2, t3) {
            return e2.leafNode(this.tag, { id: t3.id.toString(), name: t3.name, totalsRowLabel: t3.totalsRowLabel, totalsRowFunction: t3.totalsRowFunction, dxfId: t3.dxfId }), true;
          }
          parseOpen(e2) {
            if (e2.name === this.tag) {
              const { attributes: t3 } = e2;
              return this.model = { name: t3.name, totalsRowLabel: t3.totalsRowLabel, totalsRowFunction: t3.totalsRowFunction, dxfId: t3.dxfId }, true;
            }
            return false;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 142: [function(e, t2, r) {
        const n = e("../base-xform");
        t2.exports = class extends n {
          get tag() {
            return "tableStyleInfo";
          }
          render(e2, t3) {
            return e2.leafNode(this.tag, { name: t3.theme ? t3.theme : void 0, showFirstColumn: t3.showFirstColumn ? "1" : "0", showLastColumn: t3.showLastColumn ? "1" : "0", showRowStripes: t3.showRowStripes ? "1" : "0", showColumnStripes: t3.showColumnStripes ? "1" : "0" }), true;
          }
          parseOpen(e2) {
            if (e2.name === this.tag) {
              const { attributes: t3 } = e2;
              return this.model = { theme: t3.name ? t3.name : null, showFirstColumn: "1" === t3.showFirstColumn, showLastColumn: "1" === t3.showLastColumn, showRowStripes: "1" === t3.showRowStripes, showColumnStripes: "1" === t3.showColumnStripes }, true;
            }
            return false;
          }
          parseText() {
          }
          parseClose() {
            return false;
          }
        };
      }, { "../base-xform": 32 }], 143: [function(e, t2, r) {
        const n = e("../../../utils/xml-stream"), i = e("../base-xform"), s = e("../list-xform"), o = e("./auto-filter-xform"), a = e("./table-column-xform"), l = e("./table-style-info-xform");
        class c extends i {
          constructor() {
            super(), this.map = { autoFilter: new o(), tableColumns: new s({ tag: "tableColumns", count: true, empty: true, childXform: new a() }), tableStyleInfo: new l() };
          }
          prepare(e2, t3) {
            this.map.autoFilter.prepare(e2), this.map.tableColumns.prepare(e2.columns, t3);
          }
          get tag() {
            return "table";
          }
          render(e2, t3) {
            e2.openXml(n.StdDocAttributes), e2.openNode(this.tag, { ...c.TABLE_ATTRIBUTES, id: t3.id, name: t3.name, displayName: t3.displayName || t3.name, ref: t3.tableRef, totalsRowCount: t3.totalsRow ? "1" : void 0, totalsRowShown: t3.totalsRow ? void 0 : "1", headerRowCount: t3.headerRow ? "1" : "0" }), this.map.autoFilter.render(e2, t3), this.map.tableColumns.render(e2, t3.columns), this.map.tableStyleInfo.render(e2, t3.style), e2.closeNode();
          }
          parseOpen(e2) {
            if (this.parser) return this.parser.parseOpen(e2), true;
            const { name: t3, attributes: r2 } = e2;
            switch (t3) {
              case this.tag:
                this.reset(), this.model = { name: r2.name, displayName: r2.displayName || r2.name, tableRef: r2.ref, totalsRow: "1" === r2.totalsRowCount, headerRow: "1" === r2.headerRowCount };
                break;
              default:
                this.parser = this.map[e2.name], this.parser && this.parser.parseOpen(e2);
            }
            return true;
          }
          parseText(e2) {
            this.parser && this.parser.parseText(e2);
          }
          parseClose(e2) {
            if (this.parser) return this.parser.parseClose(e2) || (this.parser = void 0), true;
            switch (e2) {
              case this.tag:
                return this.model.columns = this.map.tableColumns.model, this.map.autoFilter.model && (this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef, this.map.autoFilter.model.columns.forEach((e3, t3) => {
                  this.model.columns[t3].filterButton = e3.filterButton;
                })), this.model.style = this.map.tableStyleInfo.model, false;
              default:
                return true;
            }
          }
          reconcile(e2, t3) {
            e2.columns.forEach((e3) => {
              void 0 !== e3.dxfId && (e3.style = t3.styles.getDxfStyle(e3.dxfId));
            });
          }
        }
        c.TABLE_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "xr xr3", "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision", "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" }, t2.exports = c;
      }, { "../../../utils/xml-stream": 28, "../base-xform": 32, "../list-xform": 71, "./auto-filter-xform": 137, "./table-column-xform": 141, "./table-style-info-xform": 142 }], 144: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            const i = e("fs"), s = e("jszip"), { PassThrough: o } = e("readable-stream"), a = e("../utils/zip-stream"), l = e("../utils/stream-buf"), c = e("../utils/utils"), u = e("../utils/xml-stream"), { bufferToString: h } = e("../utils/browser-buffer-decode"), f = e("./xform/style/styles-xform"), d = e("./xform/core/core-xform"), p = e("./xform/strings/shared-strings-xform"), m = e("./xform/core/relationships-xform"), b = e("./xform/core/content-types-xform"), g = e("./xform/core/app-xform"), y = e("./xform/book/workbook-xform"), v = e("./xform/sheet/worksheet-xform"), w = e("./xform/drawing/drawing-xform"), _ = e("./xform/table/table-xform"), x = e("./xform/comment/comments-xform"), k = e("./xform/comment/vml-notes-xform"), S = e("./xml/theme1");
            class M {
              constructor(e2) {
                this.workbook = e2;
              }
              async readFile(e2, t3) {
                if (!await c.fs.exists(e2)) throw new Error("File not found: " + e2);
                const r3 = i.createReadStream(e2);
                try {
                  const e3 = await this.read(r3, t3);
                  return r3.close(), e3;
                } catch (e3) {
                  throw r3.close(), e3;
                }
              }
              parseRels(e2) {
                return new m().parseStream(e2);
              }
              parseWorkbook(e2) {
                return new y().parseStream(e2);
              }
              parseSharedStrings(e2) {
                return new p().parseStream(e2);
              }
              reconcile(e2, t3) {
                const r3 = new y(), n2 = new v(t3), i2 = new w(), s2 = new _();
                r3.reconcile(e2);
                const o2 = { media: e2.media, mediaIndex: e2.mediaIndex };
                Object.keys(e2.drawings).forEach((t4) => {
                  const r4 = e2.drawings[t4], n3 = e2.drawingRels[t4];
                  n3 && (o2.rels = n3.reduce((e3, t5) => (e3[t5.Id] = t5, e3), {}), (r4.anchors || []).forEach((e3) => {
                    const t5 = e3.picture && e3.picture.hyperlinks;
                    t5 && o2.rels[t5.rId] && (t5.hyperlink = o2.rels[t5.rId].Target, delete t5.rId);
                  }), i2.reconcile(r4, o2));
                });
                const a2 = { styles: e2.styles };
                Object.values(e2.tables).forEach((e3) => {
                  s2.reconcile(e3, a2);
                });
                const l2 = { styles: e2.styles, sharedStrings: e2.sharedStrings, media: e2.media, mediaIndex: e2.mediaIndex, date1904: e2.properties && e2.properties.date1904, drawings: e2.drawings, comments: e2.comments, tables: e2.tables, vmlDrawings: e2.vmlDrawings };
                e2.worksheets.forEach((t4) => {
                  t4.relationships = e2.worksheetRels[t4.sheetNo], n2.reconcile(t4, l2);
                }), delete e2.worksheetHash, delete e2.worksheetRels, delete e2.globalRels, delete e2.sharedStrings, delete e2.workbookRels, delete e2.sheetDefs, delete e2.styles, delete e2.mediaIndex, delete e2.drawings, delete e2.drawingRels, delete e2.vmlDrawings;
              }
              async _processWorksheetEntry(e2, t3, r3, n2, i2) {
                const s2 = new v(n2), o2 = await s2.parseStream(e2);
                o2.sheetNo = r3, t3.worksheetHash[i2] = o2, t3.worksheets.push(o2);
              }
              async _processCommentEntry(e2, t3, r3) {
                const n2 = new x(), i2 = await n2.parseStream(e2);
                t3.comments[`../${r3}.xml`] = i2;
              }
              async _processTableEntry(e2, t3, r3) {
                const n2 = new _(), i2 = await n2.parseStream(e2);
                t3.tables[`../tables/${r3}.xml`] = i2;
              }
              async _processWorksheetRelsEntry(e2, t3, r3) {
                const n2 = new m(), i2 = await n2.parseStream(e2);
                t3.worksheetRels[r3] = i2;
              }
              async _processMediaEntry(e2, t3, r3) {
                const n2 = r3.lastIndexOf(".");
                if (n2 >= 1) {
                  const i2 = r3.substr(n2 + 1), s2 = r3.substr(0, n2);
                  await new Promise((n3, o2) => {
                    const a2 = new l();
                    a2.on("finish", () => {
                      t3.mediaIndex[r3] = t3.media.length, t3.mediaIndex[s2] = t3.media.length;
                      const e3 = { type: "image", name: s2, extension: i2, buffer: a2.toBuffer() };
                      t3.media.push(e3), n3();
                    }), e2.on("error", (e3) => {
                      o2(e3);
                    }), e2.pipe(a2);
                  });
                }
              }
              async _processDrawingEntry(e2, t3, r3) {
                const n2 = new w(), i2 = await n2.parseStream(e2);
                t3.drawings[r3] = i2;
              }
              async _processDrawingRelsEntry(e2, t3, r3) {
                const n2 = new m(), i2 = await n2.parseStream(e2);
                t3.drawingRels[r3] = i2;
              }
              async _processVmlDrawingEntry(e2, t3, r3) {
                const n2 = new k(), i2 = await n2.parseStream(e2);
                t3.vmlDrawings[`../drawings/${r3}.vml`] = i2;
              }
              async _processThemeEntry(e2, t3, r3) {
                await new Promise((n2, i2) => {
                  const s2 = new l();
                  e2.on("error", i2), s2.on("error", i2), s2.on("finish", () => {
                    t3.themes[r3] = s2.read().toString(), n2();
                  }), e2.pipe(s2);
                });
              }
              createInputStream() {
                throw new Error("`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
              }
              async read(e2, t3) {
                !e2[Symbol.asyncIterator] && e2.pipe && (e2 = e2.pipe(new o()));
                const r3 = [];
                for await (const t4 of e2) r3.push(t4);
                return this.load(n.concat(r3), t3);
              }
              async load(e2, t3) {
                let i2;
                i2 = t3 && t3.base64 ? n.from(e2.toString(), "base64") : e2;
                const a2 = { worksheets: [], worksheetHash: {}, worksheetRels: [], themes: {}, media: [], mediaIndex: {}, drawings: {}, drawingRels: {}, comments: {}, tables: {}, vmlDrawings: {} }, l2 = await s.loadAsync(i2);
                for (const e3 of Object.values(l2.files)) if (!e3.dir) {
                  let n2, i3 = e3.name;
                  if ("/" === i3[0] && (i3 = i3.substr(1)), i3.match(/xl\/media\//) || i3.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) n2 = new o(), n2.write(await e3.async("nodebuffer"));
                  else {
                    let t4;
                    n2 = new o({ writableObjectMode: true, readableObjectMode: true }), t4 = r2.browser ? h(await e3.async("nodebuffer")) : await e3.async("string");
                    const i4 = 16384;
                    for (let e4 = 0; e4 < t4.length; e4 += i4) n2.write(t4.substring(e4, e4 + i4));
                  }
                  switch (n2.end(), i3) {
                    case "_rels/.rels":
                      a2.globalRels = await this.parseRels(n2);
                      break;
                    case "xl/workbook.xml": {
                      const e4 = await this.parseWorkbook(n2);
                      a2.sheets = e4.sheets, a2.definedNames = e4.definedNames, a2.views = e4.views, a2.properties = e4.properties, a2.calcProperties = e4.calcProperties;
                      break;
                    }
                    case "xl/_rels/workbook.xml.rels":
                      a2.workbookRels = await this.parseRels(n2);
                      break;
                    case "xl/sharedStrings.xml":
                      a2.sharedStrings = new p(), await a2.sharedStrings.parseStream(n2);
                      break;
                    case "xl/styles.xml":
                      a2.styles = new f(), await a2.styles.parseStream(n2);
                      break;
                    case "docProps/app.xml": {
                      const e4 = new g(), t4 = await e4.parseStream(n2);
                      a2.company = t4.company, a2.manager = t4.manager;
                      break;
                    }
                    case "docProps/core.xml": {
                      const e4 = new d(), t4 = await e4.parseStream(n2);
                      Object.assign(a2, t4);
                      break;
                    }
                    default: {
                      let e4 = i3.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                      if (e4) {
                        await this._processWorksheetEntry(n2, a2, e4[1], t3, i3);
                        break;
                      }
                      if (e4 = i3.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/), e4) {
                        await this._processWorksheetRelsEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/), e4) {
                        await this._processThemeEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/), e4) {
                        await this._processMediaEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/), e4) {
                        await this._processDrawingEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/(comments\d+)[.]xml/), e4) {
                        await this._processCommentEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/tables\/(table\d+)[.]xml/), e4) {
                        await this._processTableEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/), e4) {
                        await this._processDrawingRelsEntry(n2, a2, e4[1]);
                        break;
                      }
                      if (e4 = i3.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/), e4) {
                        await this._processVmlDrawingEntry(n2, a2, e4[1]);
                        break;
                      }
                    }
                  }
                }
                return this.reconcile(a2, t3), this.workbook.model = a2, this.workbook;
              }
              async addMedia(e2, t3) {
                await Promise.all(t3.media.map(async (t4) => {
                  if ("image" === t4.type) {
                    const r3 = `xl/media/${t4.name}.${t4.extension}`;
                    if (t4.filename) {
                      const n2 = await (function(e3, t5) {
                        return new Promise((r4, n3) => {
                          i.readFile(e3, t5, (e4, t6) => {
                            e4 ? n3(e4) : r4(t6);
                          });
                        });
                      })(t4.filename);
                      return e2.append(n2, { name: r3 });
                    }
                    if (t4.buffer) return e2.append(t4.buffer, { name: r3 });
                    if (t4.base64) {
                      const n2 = t4.base64, i2 = n2.substring(n2.indexOf(",") + 1);
                      return e2.append(i2, { name: r3, base64: true });
                    }
                  }
                  throw new Error("Unsupported media");
                }));
              }
              addDrawings(e2, t3) {
                const r3 = new w(), n2 = new m();
                t3.worksheets.forEach((t4) => {
                  const { drawing: i2 } = t4;
                  if (i2) {
                    r3.prepare(i2, {});
                    let t5 = r3.toXml(i2);
                    e2.append(t5, { name: `xl/drawings/${i2.name}.xml` }), t5 = n2.toXml(i2.rels), e2.append(t5, { name: `xl/drawings/_rels/${i2.name}.xml.rels` });
                  }
                });
              }
              addTables(e2, t3) {
                const r3 = new _();
                t3.worksheets.forEach((t4) => {
                  const { tables: n2 } = t4;
                  n2.forEach((t5) => {
                    r3.prepare(t5, {});
                    const n3 = r3.toXml(t5);
                    e2.append(n3, { name: "xl/tables/" + t5.target });
                  });
                });
              }
              async addContentTypes(e2, t3) {
                const r3 = new b().toXml(t3);
                e2.append(r3, { name: "[Content_Types].xml" });
              }
              async addApp(e2, t3) {
                const r3 = new g().toXml(t3);
                e2.append(r3, { name: "docProps/app.xml" });
              }
              async addCore(e2, t3) {
                const r3 = new d();
                e2.append(r3.toXml(t3), { name: "docProps/core.xml" });
              }
              async addThemes(e2, t3) {
                const r3 = t3.themes || { theme1: S };
                Object.keys(r3).forEach((t4) => {
                  const n2 = r3[t4], i2 = `xl/theme/${t4}.xml`;
                  e2.append(n2, { name: i2 });
                });
              }
              async addOfficeRels(e2) {
                const t3 = new m().toXml([{ Id: "rId1", Type: M.RelType.OfficeDocument, Target: "xl/workbook.xml" }, { Id: "rId2", Type: M.RelType.CoreProperties, Target: "docProps/core.xml" }, { Id: "rId3", Type: M.RelType.ExtenderProperties, Target: "docProps/app.xml" }]);
                e2.append(t3, { name: "_rels/.rels" });
              }
              async addWorkbookRels(e2, t3) {
                let r3 = 1;
                const n2 = [{ Id: "rId" + r3++, Type: M.RelType.Styles, Target: "styles.xml" }, { Id: "rId" + r3++, Type: M.RelType.Theme, Target: "theme/theme1.xml" }];
                t3.sharedStrings.count && n2.push({ Id: "rId" + r3++, Type: M.RelType.SharedStrings, Target: "sharedStrings.xml" }), t3.worksheets.forEach((e3) => {
                  e3.rId = "rId" + r3++, n2.push({ Id: e3.rId, Type: M.RelType.Worksheet, Target: `worksheets/sheet${e3.id}.xml` });
                });
                const i2 = new m().toXml(n2);
                e2.append(i2, { name: "xl/_rels/workbook.xml.rels" });
              }
              async addSharedStrings(e2, t3) {
                t3.sharedStrings && t3.sharedStrings.count && e2.append(t3.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
              }
              async addStyles(e2, t3) {
                const { xml: r3 } = t3.styles;
                r3 && e2.append(r3, { name: "xl/styles.xml" });
              }
              async addWorkbook(e2, t3) {
                const r3 = new y();
                e2.append(r3.toXml(t3), { name: "xl/workbook.xml" });
              }
              async addWorksheets(e2, t3) {
                const r3 = new v(), n2 = new m(), i2 = new x(), s2 = new k();
                t3.worksheets.forEach((t4) => {
                  let o2 = new u();
                  r3.render(o2, t4), e2.append(o2.xml, { name: `xl/worksheets/sheet${t4.id}.xml` }), t4.rels && t4.rels.length && (o2 = new u(), n2.render(o2, t4.rels), e2.append(o2.xml, { name: `xl/worksheets/_rels/sheet${t4.id}.xml.rels` })), t4.comments.length > 0 && (o2 = new u(), i2.render(o2, t4), e2.append(o2.xml, { name: `xl/comments${t4.id}.xml` }), o2 = new u(), s2.render(o2, t4), e2.append(o2.xml, { name: `xl/drawings/vmlDrawing${t4.id}.vml` }));
                });
              }
              _finalize(e2) {
                return new Promise((t3, r3) => {
                  e2.on("finish", () => {
                    t3(this);
                  }), e2.on("error", r3), e2.finalize();
                });
              }
              prepareModel(e2, t3) {
                e2.creator = e2.creator || "ExcelJS", e2.lastModifiedBy = e2.lastModifiedBy || "ExcelJS", e2.created = e2.created || /* @__PURE__ */ new Date(), e2.modified = e2.modified || /* @__PURE__ */ new Date(), e2.useSharedStrings = void 0 === t3.useSharedStrings || t3.useSharedStrings, e2.useStyles = void 0 === t3.useStyles || t3.useStyles, e2.sharedStrings = new p(), e2.styles = e2.useStyles ? new f(true) : new f.Mock();
                const r3 = new y(), n2 = new v();
                r3.prepare(e2);
                const i2 = { sharedStrings: e2.sharedStrings, styles: e2.styles, date1904: e2.properties.date1904, drawingsCount: 0, media: e2.media };
                i2.drawings = e2.drawings = [], i2.commentRefs = e2.commentRefs = [];
                let s2 = 0;
                e2.tables = [], e2.worksheets.forEach((t4) => {
                  t4.tables.forEach((t5) => {
                    s2++, t5.target = `table${s2}.xml`, t5.id = s2, e2.tables.push(t5);
                  }), n2.prepare(t4, i2);
                });
              }
              async write(e2, t3) {
                t3 = t3 || {};
                const { model: r3 } = this.workbook, n2 = new a.ZipWriter(t3.zip);
                return n2.pipe(e2), this.prepareModel(r3, t3), await this.addContentTypes(n2, r3), await this.addOfficeRels(n2, r3), await this.addWorkbookRels(n2, r3), await this.addWorksheets(n2, r3), await this.addSharedStrings(n2, r3), await this.addDrawings(n2, r3), await this.addTables(n2, r3), await Promise.all([this.addThemes(n2, r3), this.addStyles(n2, r3)]), await this.addMedia(n2, r3), await Promise.all([this.addApp(n2, r3), this.addCore(n2, r3)]), await this.addWorkbook(n2, r3), this._finalize(n2);
              }
              writeFile(e2, t3) {
                const r3 = i.createWriteStream(e2);
                return new Promise((e3, n2) => {
                  r3.on("finish", () => {
                    e3();
                  }), r3.on("error", (e4) => {
                    n2(e4);
                  }), this.write(r3, t3).then(() => {
                    r3.end();
                  }).catch((e4) => {
                    n2(e4);
                  });
                });
              }
              async writeBuffer(e2) {
                const t3 = new l();
                return await this.write(t3, e2), t3.read();
              }
            }
            M.RelType = e("./rel-type"), t2.exports = M;
          }).call(this);
        }).call(this, e("_process"), e("buffer").Buffer);
      }, { "../utils/browser-buffer-decode": 16, "../utils/stream-buf": 24, "../utils/utils": 27, "../utils/xml-stream": 28, "../utils/zip-stream": 29, "./rel-type": 31, "./xform/book/workbook-xform": 38, "./xform/comment/comments-xform": 40, "./xform/comment/vml-notes-xform": 45, "./xform/core/app-xform": 51, "./xform/core/content-types-xform": 52, "./xform/core/core-xform": 53, "./xform/core/relationships-xform": 55, "./xform/drawing/drawing-xform": 62, "./xform/sheet/worksheet-xform": 115, "./xform/strings/shared-strings-xform": 124, "./xform/style/styles-xform": 135, "./xform/table/table-xform": 143, "./xml/theme1": 145, _process: 467, buffer: 220, fs: 216, jszip: 441, "readable-stream": 491 }], 145: [function(e, t2, r) {
        t2.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/> <a:font script="Hang" typeface="맑은 고딕"/> <a:font script="Hans" typeface="宋体"/> <a:font script="Hant" typeface="新細明體"/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/> <a:font script="Hang" typeface="맑은 고딕"/> <a:font script="Hans" typeface="宋体"/> <a:font script="Hant" typeface="新細明體"/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
      }, {}], 146: [function(e, t2, r) {
        (function(t3) {
          (function() {
            Object.defineProperty(r, "__esModule", { value: true }), r.CsvFormatterStream = void 0;
            const n = e("stream"), i = e("./formatter");
            class s extends n.Transform {
              constructor(e2) {
                super({ writableObjectMode: e2.objectMode }), this.hasWrittenBOM = false, this.formatterOptions = e2, this.rowFormatter = new i.RowFormatter(e2), this.hasWrittenBOM = !e2.writeBOM;
              }
              transform(e2) {
                return this.rowFormatter.rowTransform = e2, this;
              }
              _transform(e2, r2, n2) {
                let i2 = false;
                try {
                  this.hasWrittenBOM || (this.push(this.formatterOptions.BOM), this.hasWrittenBOM = true), this.rowFormatter.format(e2, (e3, r3) => e3 ? (i2 = true, n2(e3)) : (r3 && r3.forEach((e4) => {
                    this.push(t3.from(e4, "utf8"));
                  }), i2 = true, n2()));
                } catch (e3) {
                  if (i2) throw e3;
                  n2(e3);
                }
              }
              _flush(e2) {
                this.rowFormatter.finish((r2, n2) => r2 ? e2(r2) : (n2 && n2.forEach((e3) => {
                  this.push(t3.from(e3, "utf8"));
                }), e2()));
              }
            }
            r.CsvFormatterStream = s;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./formatter": 150, buffer: 220, stream: 505 }], 147: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.FormatterOptions = void 0;
        r.FormatterOptions = class {
          constructor() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            var t3;
            this.objectMode = true, this.delimiter = ",", this.rowDelimiter = "\n", this.quote = '"', this.escape = this.quote, this.quoteColumns = false, this.quoteHeaders = this.quoteColumns, this.headers = null, this.includeEndRowDelimiter = false, this.writeBOM = false, this.BOM = "\uFEFF", this.alwaysWriteHeaders = false, Object.assign(this, e2 || {}), void 0 === (null == e2 ? void 0 : e2.quoteHeaders) && (this.quoteHeaders = this.quoteColumns), true === (null == e2 ? void 0 : e2.quote) ? this.quote = '"' : false === (null == e2 ? void 0 : e2.quote) && (this.quote = ""), "string" != typeof (null == e2 ? void 0 : e2.escape) && (this.escape = this.quote), this.shouldWriteHeaders = !!this.headers && (null === (t3 = e2.writeHeaders) || void 0 === t3 || t3), this.headers = Array.isArray(this.headers) ? this.headers : null, this.escapedQuote = `${this.escape}${this.quote}`;
          }
        };
      }, {}], 148: [function(e, t2, r) {
        var n = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.FieldFormatter = void 0;
        const i = n(e("lodash.isboolean")), s = n(e("lodash.isnil")), o = n(e("lodash.escaperegexp"));
        r.FieldFormatter = class {
          constructor(e2) {
            this._headers = null, this.formatterOptions = e2, null !== e2.headers && (this.headers = e2.headers), this.REPLACE_REGEXP = new RegExp(e2.quote, "g");
            const t3 = `[${e2.delimiter}${o.default(e2.rowDelimiter)}|\r|
]`;
            this.ESCAPE_REGEXP = new RegExp(t3);
          }
          set headers(e2) {
            this._headers = e2;
          }
          shouldQuote(e2, t3) {
            const r2 = t3 ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
            return i.default(r2) ? r2 : Array.isArray(r2) ? r2[e2] : null !== this._headers && r2[this._headers[e2]];
          }
          format(e2, t3, r2) {
            const n2 = ("" + (s.default(e2) ? "" : e2)).replace(/\0/g, ""), { formatterOptions: i2 } = this;
            if ("" !== i2.quote) {
              if (-1 !== n2.indexOf(i2.quote)) return this.quoteField(n2.replace(this.REPLACE_REGEXP, i2.escapedQuote));
            }
            return -1 !== n2.search(this.ESCAPE_REGEXP) || this.shouldQuote(t3, r2) ? this.quoteField(n2) : n2;
          }
          quoteField(e2) {
            const { quote: t3 } = this.formatterOptions;
            return `${t3}${e2}${t3}`;
          }
        };
      }, { "lodash.escaperegexp": 442, "lodash.isboolean": 444, "lodash.isnil": 447 }], 149: [function(e, t2, r) {
        var n = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.RowFormatter = void 0;
        const i = n(e("lodash.isfunction")), s = n(e("lodash.isequal")), o = e("./FieldFormatter"), a = e("../types");
        class l {
          constructor(e2) {
            this.rowCount = 0, this.formatterOptions = e2, this.fieldFormatter = new o.FieldFormatter(e2), this.headers = e2.headers, this.shouldWriteHeaders = e2.shouldWriteHeaders, this.hasWrittenHeaders = false, null !== this.headers && (this.fieldFormatter.headers = this.headers), e2.transform && (this.rowTransform = e2.transform);
          }
          static isRowHashArray(e2) {
            return !!Array.isArray(e2) && (Array.isArray(e2[0]) && 2 === e2[0].length);
          }
          static isRowArray(e2) {
            return Array.isArray(e2) && !this.isRowHashArray(e2);
          }
          static gatherHeaders(e2) {
            return l.isRowHashArray(e2) ? e2.map((e3) => e3[0]) : Array.isArray(e2) ? e2 : Object.keys(e2);
          }
          static createTransform(e2) {
            return a.isSyncTransform(e2) ? (t3, r2) => {
              let n2 = null;
              try {
                n2 = e2(t3);
              } catch (e3) {
                return r2(e3);
              }
              return r2(null, n2);
            } : (t3, r2) => {
              e2(t3, r2);
            };
          }
          set rowTransform(e2) {
            if (!i.default(e2)) throw new TypeError("The transform should be a function");
            this._rowTransform = l.createTransform(e2);
          }
          format(e2, t3) {
            this.callTransformer(e2, (r2, n2) => {
              if (r2) return t3(r2);
              if (!e2) return t3(null);
              const i2 = [];
              if (n2) {
                const { shouldFormatColumns: e3, headers: t4 } = this.checkHeaders(n2);
                if (this.shouldWriteHeaders && t4 && !this.hasWrittenHeaders && (i2.push(this.formatColumns(t4, true)), this.hasWrittenHeaders = true), e3) {
                  const e4 = this.gatherColumns(n2);
                  i2.push(this.formatColumns(e4, false));
                }
              }
              return t3(null, i2);
            });
          }
          finish(e2) {
            const t3 = [];
            if (this.formatterOptions.alwaysWriteHeaders && 0 === this.rowCount) {
              if (!this.headers) return e2(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
              t3.push(this.formatColumns(this.headers, true));
            }
            return this.formatterOptions.includeEndRowDelimiter && t3.push(this.formatterOptions.rowDelimiter), e2(null, t3);
          }
          checkHeaders(e2) {
            if (this.headers) return { shouldFormatColumns: true, headers: this.headers };
            const t3 = l.gatherHeaders(e2);
            return this.headers = t3, this.fieldFormatter.headers = t3, this.shouldWriteHeaders ? { shouldFormatColumns: !s.default(t3, e2), headers: t3 } : { shouldFormatColumns: true, headers: null };
          }
          gatherColumns(e2) {
            if (null === this.headers) throw new Error("Headers is currently null");
            return Array.isArray(e2) ? l.isRowHashArray(e2) ? this.headers.map((t3, r2) => {
              const n2 = e2[r2];
              return n2 ? n2[1] : "";
            }) : l.isRowArray(e2) && !this.shouldWriteHeaders ? e2 : this.headers.map((t3, r2) => e2[r2]) : this.headers.map((t3) => e2[t3]);
          }
          callTransformer(e2, t3) {
            return this._rowTransform ? this._rowTransform(e2, t3) : t3(null, e2);
          }
          formatColumns(e2, t3) {
            const r2 = e2.map((e3, r3) => this.fieldFormatter.format(e3, r3, t3)).join(this.formatterOptions.delimiter), { rowCount: n2 } = this;
            return this.rowCount += 1, n2 ? [this.formatterOptions.rowDelimiter, r2].join("") : r2;
          }
        }
        r.RowFormatter = l;
      }, { "../types": 152, "./FieldFormatter": 148, "lodash.isequal": 445, "lodash.isfunction": 446 }], 150: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.FieldFormatter = r.RowFormatter = void 0;
        var n = e("./RowFormatter");
        Object.defineProperty(r, "RowFormatter", { enumerable: true, get: function() {
          return n.RowFormatter;
        } });
        var i = e("./FieldFormatter");
        Object.defineProperty(r, "FieldFormatter", { enumerable: true, get: function() {
          return i.FieldFormatter;
        } });
      }, { "./FieldFormatter": 148, "./RowFormatter": 149 }], 151: [function(e, t2, r) {
        (function(t3) {
          (function() {
            var n = Object.create ? function(e2, t4, r2, n2) {
              void 0 === n2 && (n2 = r2), Object.defineProperty(e2, n2, { enumerable: true, get: function() {
                return t4[r2];
              } });
            } : function(e2, t4, r2, n2) {
              void 0 === n2 && (n2 = r2), e2[n2] = t4[r2];
            }, i = Object.create ? function(e2, t4) {
              Object.defineProperty(e2, "default", { enumerable: true, value: t4 });
            } : function(e2, t4) {
              e2.default = t4;
            }, s = function(e2) {
              if (e2 && e2.__esModule) return e2;
              var t4 = {};
              if (null != e2) for (var r2 in e2) "default" !== r2 && Object.prototype.hasOwnProperty.call(e2, r2) && n(t4, e2, r2);
              return i(t4, e2), t4;
            }, o = function(e2, t4) {
              for (var r2 in e2) "default" === r2 || Object.prototype.hasOwnProperty.call(t4, r2) || n(t4, e2, r2);
            };
            Object.defineProperty(r, "__esModule", { value: true }), r.writeToPath = r.writeToString = r.writeToBuffer = r.writeToStream = r.write = r.format = r.FormatterOptions = r.CsvFormatterStream = void 0;
            const a = e("util"), l = e("stream"), c = s(e("fs")), u = e("./FormatterOptions"), h = e("./CsvFormatterStream");
            o(e("./types"), r);
            var f = e("./CsvFormatterStream");
            Object.defineProperty(r, "CsvFormatterStream", { enumerable: true, get: function() {
              return f.CsvFormatterStream;
            } });
            var d = e("./FormatterOptions");
            Object.defineProperty(r, "FormatterOptions", { enumerable: true, get: function() {
              return d.FormatterOptions;
            } }), r.format = (e2) => new h.CsvFormatterStream(new u.FormatterOptions(e2)), r.write = (e2, t4) => {
              const n2 = r.format(t4), i2 = a.promisify((e3, t5) => {
                n2.write(e3, void 0, t5);
              });
              return e2.reduce((e3, t5) => e3.then(() => i2(t5)), Promise.resolve()).then(() => n2.end()).catch((e3) => {
                n2.emit("error", e3);
              }), n2;
            }, r.writeToStream = (e2, t4, n2) => r.write(t4, n2).pipe(e2), r.writeToBuffer = function(e2) {
              let n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              const i2 = [], s2 = new l.Writable({ write(e3, t4, r2) {
                i2.push(e3), r2();
              } });
              return new Promise((o2, a2) => {
                s2.on("error", a2).on("finish", () => o2(t3.concat(i2))), r.write(e2, n2).pipe(s2);
              });
            }, r.writeToString = (e2, t4) => r.writeToBuffer(e2, t4).then((e3) => e3.toString()), r.writeToPath = (e2, t4, n2) => {
              const i2 = c.createWriteStream(e2, { encoding: "utf8" });
              return r.write(t4, n2).pipe(i2);
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./CsvFormatterStream": 146, "./FormatterOptions": 147, "./types": 152, buffer: 220, fs: 216, stream: 505, util: 527 }], 152: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.isSyncTransform = void 0, r.isSyncTransform = (e2) => 1 === e2.length;
      }, {}], 153: [function(e, t2, r) {
        (function(t3) {
          (function() {
            Object.defineProperty(r, "__esModule", { value: true }), r.CsvParserStream = void 0;
            const n = e("string_decoder"), i = e("stream"), s = e("./transforms"), o = e("./parser");
            class a extends i.Transform {
              constructor(e2) {
                super({ objectMode: e2.objectMode }), this.lines = "", this.rowCount = 0, this.parsedRowCount = 0, this.parsedLineCount = 0, this.endEmitted = false, this.headersEmitted = false, this.parserOptions = e2, this.parser = new o.Parser(e2), this.headerTransformer = new s.HeaderTransformer(e2), this.decoder = new n.StringDecoder(e2.encoding), this.rowTransformerValidator = new s.RowTransformerValidator();
              }
              get hasHitRowLimit() {
                return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
              }
              get shouldEmitRows() {
                return this.parsedRowCount > this.parserOptions.skipRows;
              }
              get shouldSkipLine() {
                return this.parsedLineCount <= this.parserOptions.skipLines;
              }
              transform(e2) {
                return this.rowTransformerValidator.rowTransform = e2, this;
              }
              validate(e2) {
                return this.rowTransformerValidator.rowValidator = e2, this;
              }
              emit(e2) {
                if ("end" === e2) return this.endEmitted || (this.endEmitted = true, super.emit("end", this.rowCount)), false;
                for (var t4 = arguments.length, r2 = new Array(t4 > 1 ? t4 - 1 : 0), n2 = 1; n2 < t4; n2++) r2[n2 - 1] = arguments[n2];
                return super.emit(e2, ...r2);
              }
              _transform(e2, t4, r2) {
                if (this.hasHitRowLimit) return r2();
                const n2 = a.wrapDoneCallback(r2);
                try {
                  const { lines: t5 } = this, r3 = t5 + this.decoder.write(e2), i2 = this.parse(r3, true);
                  return this.processRows(i2, n2);
                } catch (e3) {
                  return n2(e3);
                }
              }
              _flush(e2) {
                const t4 = a.wrapDoneCallback(e2);
                if (this.hasHitRowLimit) return t4();
                try {
                  const e3 = this.lines + this.decoder.end(), r2 = this.parse(e3, false);
                  return this.processRows(r2, t4);
                } catch (e3) {
                  return t4(e3);
                }
              }
              parse(e2, t4) {
                if (!e2) return [];
                const { line: r2, rows: n2 } = this.parser.parse(e2, t4);
                return this.lines = r2, n2;
              }
              processRows(e2, r2) {
                const n2 = e2.length, i2 = (s2) => {
                  const o2 = (e3) => e3 ? r2(e3) : s2 % 100 != 0 ? i2(s2 + 1) : void t3(() => i2(s2 + 1));
                  if (this.checkAndEmitHeaders(), s2 >= n2 || this.hasHitRowLimit) return r2();
                  if (this.parsedLineCount += 1, this.shouldSkipLine) return o2();
                  const a2 = e2[s2];
                  this.rowCount += 1, this.parsedRowCount += 1;
                  const l = this.rowCount;
                  return this.transformRow(a2, (e3, t4) => {
                    if (e3) return this.rowCount -= 1, o2(e3);
                    if (!t4) return o2(new Error("expected transform result"));
                    if (t4.isValid) {
                      if (t4.row) return this.pushRow(t4.row, o2);
                    } else this.emit("data-invalid", t4.row, l, t4.reason);
                    return o2();
                  });
                };
                i2(0);
              }
              transformRow(e2, t4) {
                try {
                  this.headerTransformer.transform(e2, (r2, n2) => r2 ? t4(r2) : n2 ? n2.isValid ? n2.row ? this.shouldEmitRows ? this.rowTransformerValidator.transformAndValidate(n2.row, t4) : this.skipRow(t4) : (this.rowCount -= 1, this.parsedRowCount -= 1, t4(null, { row: null, isValid: true })) : this.shouldEmitRows ? t4(null, { isValid: false, row: e2 }) : this.skipRow(t4) : t4(new Error("Expected result from header transform")));
                } catch (e3) {
                  t4(e3);
                }
              }
              checkAndEmitHeaders() {
                !this.headersEmitted && this.headerTransformer.headers && (this.headersEmitted = true, this.emit("headers", this.headerTransformer.headers));
              }
              skipRow(e2) {
                return this.rowCount -= 1, e2(null, { row: null, isValid: true });
              }
              pushRow(e2, t4) {
                try {
                  this.parserOptions.objectMode ? this.push(e2) : this.push(JSON.stringify(e2)), t4();
                } catch (e3) {
                  t4(e3);
                }
              }
              static wrapDoneCallback(e2) {
                let t4 = false;
                return function(r2) {
                  if (r2) {
                    if (t4) throw r2;
                    return t4 = true, void e2(r2);
                  }
                  for (var n2 = arguments.length, i2 = new Array(n2 > 1 ? n2 - 1 : 0), s2 = 1; s2 < n2; s2++) i2[s2 - 1] = arguments[s2];
                  e2(...i2);
                };
              }
            }
            r.CsvParserStream = a;
          }).call(this);
        }).call(this, e("timers").setImmediate);
      }, { "./parser": 165, "./transforms": 168, stream: 505, string_decoder: 218, timers: 523 }], 154: [function(e, t2, r) {
        var n = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.ParserOptions = void 0;
        const i = n(e("lodash.escaperegexp")), s = n(e("lodash.isnil"));
        r.ParserOptions = class {
          constructor(e2) {
            var t3;
            if (this.objectMode = true, this.delimiter = ",", this.ignoreEmpty = false, this.quote = '"', this.escape = null, this.escapeChar = this.quote, this.comment = null, this.supportsComments = false, this.ltrim = false, this.rtrim = false, this.trim = false, this.headers = null, this.renameHeaders = false, this.strictColumnHandling = false, this.discardUnmappedColumns = false, this.carriageReturn = "\r", this.encoding = "utf8", this.limitRows = false, this.maxRows = 0, this.skipLines = 0, this.skipRows = 0, Object.assign(this, e2 || {}), this.delimiter.length > 1) throw new Error("delimiter option must be one character long");
            this.escapedDelimiter = i.default(this.delimiter), this.escapeChar = null !== (t3 = this.escape) && void 0 !== t3 ? t3 : this.quote, this.supportsComments = !s.default(this.comment), this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`), this.maxRows > 0 && (this.limitRows = true);
          }
        };
      }, { "lodash.escaperegexp": 442, "lodash.isnil": 447 }], 155: [function(e, t2, r) {
        var n = Object.create ? function(e2, t3, r2, n2) {
          void 0 === n2 && (n2 = r2), Object.defineProperty(e2, n2, { enumerable: true, get: function() {
            return t3[r2];
          } });
        } : function(e2, t3, r2, n2) {
          void 0 === n2 && (n2 = r2), e2[n2] = t3[r2];
        }, i = Object.create ? function(e2, t3) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t3 });
        } : function(e2, t3) {
          e2.default = t3;
        }, s = function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t3 = {};
          if (null != e2) for (var r2 in e2) "default" !== r2 && Object.prototype.hasOwnProperty.call(e2, r2) && n(t3, e2, r2);
          return i(t3, e2), t3;
        }, o = function(e2, t3) {
          for (var r2 in e2) "default" === r2 || Object.prototype.hasOwnProperty.call(t3, r2) || n(t3, e2, r2);
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.parseString = r.parseFile = r.parseStream = r.parse = r.ParserOptions = r.CsvParserStream = void 0;
        const a = s(e("fs")), l = e("stream"), c = e("./ParserOptions"), u = e("./CsvParserStream");
        o(e("./types"), r);
        var h = e("./CsvParserStream");
        Object.defineProperty(r, "CsvParserStream", { enumerable: true, get: function() {
          return h.CsvParserStream;
        } });
        var f = e("./ParserOptions");
        Object.defineProperty(r, "ParserOptions", { enumerable: true, get: function() {
          return f.ParserOptions;
        } }), r.parse = (e2) => new u.CsvParserStream(new c.ParserOptions(e2)), r.parseStream = (e2, t3) => e2.pipe(new u.CsvParserStream(new c.ParserOptions(t3))), r.parseFile = function(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return a.createReadStream(e2).pipe(new u.CsvParserStream(new c.ParserOptions(t3)));
        }, r.parseString = (e2, t3) => {
          const r2 = new l.Readable();
          return r2.push(e2), r2.push(null), r2.pipe(new u.CsvParserStream(new c.ParserOptions(t3)));
        };
      }, { "./CsvParserStream": 153, "./ParserOptions": 154, "./types": 169, fs: 216, stream: 505 }], 156: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.Parser = void 0;
        const n = e("./Scanner"), i = e("./RowParser"), s = e("./Token");
        class o {
          constructor(e2) {
            this.parserOptions = e2, this.rowParser = new i.RowParser(this.parserOptions);
          }
          static removeBOM(e2) {
            return e2 && 65279 === e2.charCodeAt(0) ? e2.slice(1) : e2;
          }
          parse(e2, t3) {
            const r2 = new n.Scanner({ line: o.removeBOM(e2), parserOptions: this.parserOptions, hasMoreData: t3 });
            return this.parserOptions.supportsComments ? this.parseWithComments(r2) : this.parseWithoutComments(r2);
          }
          parseWithoutComments(e2) {
            const t3 = [];
            let r2 = true;
            for (; r2; ) r2 = this.parseRow(e2, t3);
            return { line: e2.line, rows: t3 };
          }
          parseWithComments(e2) {
            const { parserOptions: t3 } = this, r2 = [];
            for (let n2 = e2.nextCharacterToken; null !== n2; n2 = e2.nextCharacterToken) if (s.Token.isTokenComment(n2, t3)) {
              if (null === e2.advancePastLine()) return { line: e2.lineFromCursor, rows: r2 };
              if (!e2.hasMoreCharacters) return { line: e2.lineFromCursor, rows: r2 };
              e2.truncateToCursor();
            } else if (!this.parseRow(e2, r2)) break;
            return { line: e2.line, rows: r2 };
          }
          parseRow(e2, t3) {
            if (!e2.nextNonSpaceToken) return false;
            const r2 = this.rowParser.parse(e2);
            return null !== r2 && (this.parserOptions.ignoreEmpty && i.RowParser.isEmptyRow(r2) || t3.push(r2), true);
          }
        }
        r.Parser = o;
      }, { "./RowParser": 157, "./Scanner": 158, "./Token": 159 }], 157: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.RowParser = void 0;
        const n = e("./column"), i = e("./Token");
        r.RowParser = class {
          constructor(e2) {
            this.parserOptions = e2, this.columnParser = new n.ColumnParser(e2);
          }
          static isEmptyRow(e2) {
            return "" === e2.join("").replace(/\s+/g, "");
          }
          parse(e2) {
            const { parserOptions: t3 } = this, { hasMoreData: r2 } = e2, n2 = e2, s = [];
            let o = this.getStartToken(n2, s);
            for (; o; ) {
              if (i.Token.isTokenRowDelimiter(o)) return n2.advancePastToken(o), !n2.hasMoreCharacters && i.Token.isTokenCarriageReturn(o, t3) && r2 ? null : (n2.truncateToCursor(), s);
              if (!this.shouldSkipColumnParse(n2, o, s)) {
                const e3 = this.columnParser.parse(n2);
                if (null === e3) return null;
                s.push(e3);
              }
              o = n2.nextNonSpaceToken;
            }
            return r2 ? null : (n2.truncateToCursor(), s);
          }
          getStartToken(e2, t3) {
            const r2 = e2.nextNonSpaceToken;
            return null !== r2 && i.Token.isTokenDelimiter(r2, this.parserOptions) ? (t3.push(""), e2.nextNonSpaceToken) : r2;
          }
          shouldSkipColumnParse(e2, t3, r2) {
            const { parserOptions: n2 } = this;
            if (i.Token.isTokenDelimiter(t3, n2)) {
              e2.advancePastToken(t3);
              const s = e2.nextCharacterToken;
              if (!e2.hasMoreCharacters || null !== s && i.Token.isTokenRowDelimiter(s)) return r2.push(""), true;
              if (null !== s && i.Token.isTokenDelimiter(s, n2)) return r2.push(""), true;
            }
            return false;
          }
        };
      }, { "./Token": 159, "./column": 164 }], 158: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.Scanner = void 0;
        const n = e("./Token"), i = /((?:\r\n)|\n|\r)/;
        r.Scanner = class {
          constructor(e2) {
            this.cursor = 0, this.line = e2.line, this.lineLength = this.line.length, this.parserOptions = e2.parserOptions, this.hasMoreData = e2.hasMoreData, this.cursor = e2.cursor || 0;
          }
          get hasMoreCharacters() {
            return this.lineLength > this.cursor;
          }
          get nextNonSpaceToken() {
            const { lineFromCursor: e2 } = this, t3 = this.parserOptions.NEXT_TOKEN_REGEXP;
            if (-1 === e2.search(t3)) return null;
            const r2 = t3.exec(e2);
            if (null == r2) return null;
            const i2 = r2[1], s = this.cursor + (r2.index || 0);
            return new n.Token({ token: i2, startCursor: s, endCursor: s + i2.length - 1 });
          }
          get nextCharacterToken() {
            const { cursor: e2, lineLength: t3 } = this;
            return t3 <= e2 ? null : new n.Token({ token: this.line[e2], startCursor: e2, endCursor: e2 });
          }
          get lineFromCursor() {
            return this.line.substr(this.cursor);
          }
          advancePastLine() {
            const e2 = i.exec(this.lineFromCursor);
            return e2 ? (this.cursor += (e2.index || 0) + e2[0].length, this) : this.hasMoreData ? null : (this.cursor = this.lineLength, this);
          }
          advanceTo(e2) {
            return this.cursor = e2, this;
          }
          advanceToToken(e2) {
            return this.cursor = e2.startCursor, this;
          }
          advancePastToken(e2) {
            return this.cursor = e2.endCursor + 1, this;
          }
          truncateToCursor() {
            return this.line = this.lineFromCursor, this.lineLength = this.line.length, this.cursor = 0, this;
          }
        };
      }, { "./Token": 159 }], 159: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.Token = void 0;
        r.Token = class {
          constructor(e2) {
            this.token = e2.token, this.startCursor = e2.startCursor, this.endCursor = e2.endCursor;
          }
          static isTokenRowDelimiter(e2) {
            const t3 = e2.token;
            return "\r" === t3 || "\n" === t3 || "\r\n" === t3;
          }
          static isTokenCarriageReturn(e2, t3) {
            return e2.token === t3.carriageReturn;
          }
          static isTokenComment(e2, t3) {
            return t3.supportsComments && !!e2 && e2.token === t3.comment;
          }
          static isTokenEscapeCharacter(e2, t3) {
            return e2.token === t3.escapeChar;
          }
          static isTokenQuote(e2, t3) {
            return e2.token === t3.quote;
          }
          static isTokenDelimiter(e2, t3) {
            return e2.token === t3.delimiter;
          }
        };
      }, {}], 160: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.ColumnFormatter = void 0;
        r.ColumnFormatter = class {
          constructor(e2) {
            e2.trim ? this.format = (e3) => e3.trim() : e2.ltrim ? this.format = (e3) => e3.trimLeft() : e2.rtrim ? this.format = (e3) => e3.trimRight() : this.format = (e3) => e3;
          }
        };
      }, {}], 161: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.ColumnParser = void 0;
        const n = e("./NonQuotedColumnParser"), i = e("./QuotedColumnParser"), s = e("../Token");
        r.ColumnParser = class {
          constructor(e2) {
            this.parserOptions = e2, this.quotedColumnParser = new i.QuotedColumnParser(e2), this.nonQuotedColumnParser = new n.NonQuotedColumnParser(e2);
          }
          parse(e2) {
            const { nextNonSpaceToken: t3 } = e2;
            return null !== t3 && s.Token.isTokenQuote(t3, this.parserOptions) ? (e2.advanceToToken(t3), this.quotedColumnParser.parse(e2)) : this.nonQuotedColumnParser.parse(e2);
          }
        };
      }, { "../Token": 159, "./NonQuotedColumnParser": 162, "./QuotedColumnParser": 163 }], 162: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.NonQuotedColumnParser = void 0;
        const n = e("./ColumnFormatter"), i = e("../Token");
        r.NonQuotedColumnParser = class {
          constructor(e2) {
            this.parserOptions = e2, this.columnFormatter = new n.ColumnFormatter(e2);
          }
          parse(e2) {
            if (!e2.hasMoreCharacters) return null;
            const { parserOptions: t3 } = this, r2 = [];
            let n2 = e2.nextCharacterToken;
            for (; n2 && (!i.Token.isTokenDelimiter(n2, t3) && !i.Token.isTokenRowDelimiter(n2)); n2 = e2.nextCharacterToken) r2.push(n2.token), e2.advancePastToken(n2);
            return this.columnFormatter.format(r2.join(""));
          }
        };
      }, { "../Token": 159, "./ColumnFormatter": 160 }], 163: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.QuotedColumnParser = void 0;
        const n = e("./ColumnFormatter"), i = e("../Token");
        r.QuotedColumnParser = class {
          constructor(e2) {
            this.parserOptions = e2, this.columnFormatter = new n.ColumnFormatter(e2);
          }
          parse(e2) {
            if (!e2.hasMoreCharacters) return null;
            const t3 = e2.cursor, { foundClosingQuote: r2, col: n2 } = this.gatherDataBetweenQuotes(e2);
            if (!r2) {
              if (e2.advanceTo(t3), !e2.hasMoreData) throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ""}' in line: at '${e2.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
              return null;
            }
            return this.checkForMalformedColumn(e2), n2;
          }
          gatherDataBetweenQuotes(e2) {
            const { parserOptions: t3 } = this;
            let r2 = false, n2 = false;
            const s = [];
            let o = e2.nextCharacterToken;
            for (; !n2 && null !== o; o = e2.nextCharacterToken) {
              const a = i.Token.isTokenQuote(o, t3);
              if (!r2 && a) r2 = true;
              else if (r2) if (i.Token.isTokenEscapeCharacter(o, t3)) {
                e2.advancePastToken(o);
                const r3 = e2.nextCharacterToken;
                null !== r3 && (i.Token.isTokenQuote(r3, t3) || i.Token.isTokenEscapeCharacter(r3, t3)) ? (s.push(r3.token), o = r3) : a ? n2 = true : s.push(o.token);
              } else a ? n2 = true : s.push(o.token);
              e2.advancePastToken(o);
            }
            return { col: this.columnFormatter.format(s.join("")), foundClosingQuote: n2 };
          }
          checkForMalformedColumn(e2) {
            const { parserOptions: t3 } = this, { nextNonSpaceToken: r2 } = e2;
            if (r2) {
              const n2 = i.Token.isTokenDelimiter(r2, t3), s = i.Token.isTokenRowDelimiter(r2);
              if (!n2 && !s) {
                const n3 = e2.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
                throw new Error(`Parse Error: expected: '${t3.escapedDelimiter}' OR new line got: '${r2.token}'. at '${n3}`);
              }
              e2.advanceToToken(r2);
            } else e2.hasMoreData || e2.advancePastLine();
          }
        };
      }, { "../Token": 159, "./ColumnFormatter": 160 }], 164: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.ColumnFormatter = r.QuotedColumnParser = r.NonQuotedColumnParser = r.ColumnParser = void 0;
        var n = e("./ColumnParser");
        Object.defineProperty(r, "ColumnParser", { enumerable: true, get: function() {
          return n.ColumnParser;
        } });
        var i = e("./NonQuotedColumnParser");
        Object.defineProperty(r, "NonQuotedColumnParser", { enumerable: true, get: function() {
          return i.NonQuotedColumnParser;
        } });
        var s = e("./QuotedColumnParser");
        Object.defineProperty(r, "QuotedColumnParser", { enumerable: true, get: function() {
          return s.QuotedColumnParser;
        } });
        var o = e("./ColumnFormatter");
        Object.defineProperty(r, "ColumnFormatter", { enumerable: true, get: function() {
          return o.ColumnFormatter;
        } });
      }, { "./ColumnFormatter": 160, "./ColumnParser": 161, "./NonQuotedColumnParser": 162, "./QuotedColumnParser": 163 }], 165: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.QuotedColumnParser = r.NonQuotedColumnParser = r.ColumnParser = r.Token = r.Scanner = r.RowParser = r.Parser = void 0;
        var n = e("./Parser");
        Object.defineProperty(r, "Parser", { enumerable: true, get: function() {
          return n.Parser;
        } });
        var i = e("./RowParser");
        Object.defineProperty(r, "RowParser", { enumerable: true, get: function() {
          return i.RowParser;
        } });
        var s = e("./Scanner");
        Object.defineProperty(r, "Scanner", { enumerable: true, get: function() {
          return s.Scanner;
        } });
        var o = e("./Token");
        Object.defineProperty(r, "Token", { enumerable: true, get: function() {
          return o.Token;
        } });
        var a = e("./column");
        Object.defineProperty(r, "ColumnParser", { enumerable: true, get: function() {
          return a.ColumnParser;
        } }), Object.defineProperty(r, "NonQuotedColumnParser", { enumerable: true, get: function() {
          return a.NonQuotedColumnParser;
        } }), Object.defineProperty(r, "QuotedColumnParser", { enumerable: true, get: function() {
          return a.QuotedColumnParser;
        } });
      }, { "./Parser": 156, "./RowParser": 157, "./Scanner": 158, "./Token": 159, "./column": 164 }], 166: [function(e, t2, r) {
        var n = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.HeaderTransformer = void 0;
        const i = n(e("lodash.isundefined")), s = n(e("lodash.isfunction")), o = n(e("lodash.uniq")), a = n(e("lodash.groupby"));
        r.HeaderTransformer = class {
          constructor(e2) {
            this.headers = null, this.receivedHeaders = false, this.shouldUseFirstRow = false, this.processedFirstRow = false, this.headersLength = 0, this.parserOptions = e2, true === e2.headers ? this.shouldUseFirstRow = true : Array.isArray(e2.headers) ? this.setHeaders(e2.headers) : s.default(e2.headers) && (this.headersTransform = e2.headers);
          }
          transform(e2, t3) {
            return this.shouldMapRow(e2) ? t3(null, this.processRow(e2)) : t3(null, { row: null, isValid: true });
          }
          shouldMapRow(e2) {
            const { parserOptions: t3 } = this;
            if (!this.headersTransform && t3.renameHeaders && !this.processedFirstRow) {
              if (!this.receivedHeaders) throw new Error("Error renaming headers: new headers must be provided in an array");
              return this.processedFirstRow = true, false;
            }
            if (!this.receivedHeaders && Array.isArray(e2)) {
              if (this.headersTransform) this.setHeaders(this.headersTransform(e2));
              else {
                if (!this.shouldUseFirstRow) return true;
                this.setHeaders(e2);
              }
              return false;
            }
            return true;
          }
          processRow(e2) {
            if (!this.headers) return { row: e2, isValid: true };
            const { parserOptions: t3 } = this;
            if (!t3.discardUnmappedColumns && e2.length > this.headersLength) {
              if (!t3.strictColumnHandling) throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${e2.length}`);
              return { row: e2, isValid: false, reason: `Column header mismatch expected: ${this.headersLength} columns got: ${e2.length}` };
            }
            return t3.strictColumnHandling && e2.length < this.headersLength ? { row: e2, isValid: false, reason: `Column header mismatch expected: ${this.headersLength} columns got: ${e2.length}` } : { row: this.mapHeaders(e2), isValid: true };
          }
          mapHeaders(e2) {
            const t3 = {}, { headers: r2, headersLength: n2 } = this;
            for (let s2 = 0; s2 < n2; s2 += 1) {
              const n3 = r2[s2];
              if (!i.default(n3)) {
                const r3 = e2[s2];
                i.default(r3) ? t3[n3] = "" : t3[n3] = r3;
              }
            }
            return t3;
          }
          setHeaders(e2) {
            var t3;
            const r2 = e2.filter((e3) => !!e3);
            if (o.default(r2).length !== r2.length) {
              const e3 = a.default(r2), t4 = Object.keys(e3).filter((t5) => e3[t5].length > 1);
              throw new Error("Duplicate headers found " + JSON.stringify(t4));
            }
            this.headers = e2, this.receivedHeaders = true, this.headersLength = (null === (t3 = this.headers) || void 0 === t3 ? void 0 : t3.length) || 0;
          }
        };
      }, { "lodash.groupby": 443, "lodash.isfunction": 446, "lodash.isundefined": 448, "lodash.uniq": 449 }], 167: [function(e, t2, r) {
        var n = function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(r, "__esModule", { value: true }), r.RowTransformerValidator = void 0;
        const i = n(e("lodash.isfunction")), s = e("../types");
        class o {
          constructor() {
            this._rowTransform = null, this._rowValidator = null;
          }
          static createTransform(e2) {
            return s.isSyncTransform(e2) ? (t3, r2) => {
              let n2 = null;
              try {
                n2 = e2(t3);
              } catch (e3) {
                return r2(e3);
              }
              return r2(null, n2);
            } : e2;
          }
          static createValidator(e2) {
            return s.isSyncValidate(e2) ? (t3, r2) => {
              r2(null, { row: t3, isValid: e2(t3) });
            } : (t3, r2) => {
              e2(t3, (e3, n2, i2) => e3 ? r2(e3) : r2(null, n2 ? { row: t3, isValid: n2, reason: i2 } : { row: t3, isValid: false, reason: i2 }));
            };
          }
          set rowTransform(e2) {
            if (!i.default(e2)) throw new TypeError("The transform should be a function");
            this._rowTransform = o.createTransform(e2);
          }
          set rowValidator(e2) {
            if (!i.default(e2)) throw new TypeError("The validate should be a function");
            this._rowValidator = o.createValidator(e2);
          }
          transformAndValidate(e2, t3) {
            return this.callTransformer(e2, (e3, r2) => e3 ? t3(e3) : r2 ? this.callValidator(r2, (e4, n2) => e4 ? t3(e4) : n2 && !n2.isValid ? t3(null, { row: r2, isValid: false, reason: n2.reason }) : t3(null, { row: r2, isValid: true })) : t3(null, { row: null, isValid: true }));
          }
          callTransformer(e2, t3) {
            return this._rowTransform ? this._rowTransform(e2, t3) : t3(null, e2);
          }
          callValidator(e2, t3) {
            return this._rowValidator ? this._rowValidator(e2, t3) : t3(null, { row: e2, isValid: true });
          }
        }
        r.RowTransformerValidator = o;
      }, { "../types": 169, "lodash.isfunction": 446 }], 168: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.HeaderTransformer = r.RowTransformerValidator = void 0;
        var n = e("./RowTransformerValidator");
        Object.defineProperty(r, "RowTransformerValidator", { enumerable: true, get: function() {
          return n.RowTransformerValidator;
        } });
        var i = e("./HeaderTransformer");
        Object.defineProperty(r, "HeaderTransformer", { enumerable: true, get: function() {
          return i.HeaderTransformer;
        } });
      }, { "./HeaderTransformer": 166, "./RowTransformerValidator": 167 }], 169: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.isSyncValidate = r.isSyncTransform = void 0, r.isSyncTransform = (e2) => 1 === e2.length, r.isSyncValidate = (e2) => 1 === e2.length;
      }, {}], 170: [function(e, t2, r) {
        const n = r;
        n.bignum = e("bn.js"), n.define = e("./asn1/api").define, n.base = e("./asn1/base"), n.constants = e("./asn1/constants"), n.decoders = e("./asn1/decoders"), n.encoders = e("./asn1/encoders");
      }, { "./asn1/api": 171, "./asn1/base": 173, "./asn1/constants": 177, "./asn1/decoders": 179, "./asn1/encoders": 182, "bn.js": 184 }], 171: [function(e, t2, r) {
        const n = e("./encoders"), i = e("./decoders"), s = e("inherits");
        function o(e2, t3) {
          this.name = e2, this.body = t3, this.decoders = {}, this.encoders = {};
        }
        r.define = function(e2, t3) {
          return new o(e2, t3);
        }, o.prototype._createNamed = function(e2) {
          const t3 = this.name;
          function r2(e3) {
            this._initNamed(e3, t3);
          }
          return s(r2, e2), r2.prototype._initNamed = function(t4, r3) {
            e2.call(this, t4, r3);
          }, new r2(this);
        }, o.prototype._getDecoder = function(e2) {
          return e2 = e2 || "der", this.decoders.hasOwnProperty(e2) || (this.decoders[e2] = this._createNamed(i[e2])), this.decoders[e2];
        }, o.prototype.decode = function(e2, t3, r2) {
          return this._getDecoder(t3).decode(e2, r2);
        }, o.prototype._getEncoder = function(e2) {
          return e2 = e2 || "der", this.encoders.hasOwnProperty(e2) || (this.encoders[e2] = this._createNamed(n[e2])), this.encoders[e2];
        }, o.prototype.encode = function(e2, t3, r2) {
          return this._getEncoder(t3).encode(e2, r2);
        };
      }, { "./decoders": 179, "./encoders": 182, inherits: 440 }], 172: [function(e, t2, r) {
        const n = e("inherits"), i = e("../base/reporter").Reporter, s = e("safer-buffer").Buffer;
        function o(e2, t3) {
          i.call(this, t3), s.isBuffer(e2) ? (this.base = e2, this.offset = 0, this.length = e2.length) : this.error("Input not Buffer");
        }
        function a(e2, t3) {
          if (Array.isArray(e2)) this.length = 0, this.value = e2.map((function(e3) {
            return a.isEncoderBuffer(e3) || (e3 = new a(e3, t3)), this.length += e3.length, e3;
          }), this);
          else if ("number" == typeof e2) {
            if (!(0 <= e2 && e2 <= 255)) return t3.error("non-byte EncoderBuffer value");
            this.value = e2, this.length = 1;
          } else if ("string" == typeof e2) this.value = e2, this.length = s.byteLength(e2);
          else {
            if (!s.isBuffer(e2)) return t3.error("Unsupported type: " + typeof e2);
            this.value = e2, this.length = e2.length;
          }
        }
        n(o, i), r.DecoderBuffer = o, o.isDecoderBuffer = function(e2) {
          if (e2 instanceof o) return true;
          return "object" == typeof e2 && s.isBuffer(e2.base) && "DecoderBuffer" === e2.constructor.name && "number" == typeof e2.offset && "number" == typeof e2.length && "function" == typeof e2.save && "function" == typeof e2.restore && "function" == typeof e2.isEmpty && "function" == typeof e2.readUInt8 && "function" == typeof e2.skip && "function" == typeof e2.raw;
        }, o.prototype.save = function() {
          return { offset: this.offset, reporter: i.prototype.save.call(this) };
        }, o.prototype.restore = function(e2) {
          const t3 = new o(this.base);
          return t3.offset = e2.offset, t3.length = this.offset, this.offset = e2.offset, i.prototype.restore.call(this, e2.reporter), t3;
        }, o.prototype.isEmpty = function() {
          return this.offset === this.length;
        }, o.prototype.readUInt8 = function(e2) {
          return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e2 || "DecoderBuffer overrun");
        }, o.prototype.skip = function(e2, t3) {
          if (!(this.offset + e2 <= this.length)) return this.error(t3 || "DecoderBuffer overrun");
          const r2 = new o(this.base);
          return r2._reporterState = this._reporterState, r2.offset = this.offset, r2.length = this.offset + e2, this.offset += e2, r2;
        }, o.prototype.raw = function(e2) {
          return this.base.slice(e2 ? e2.offset : this.offset, this.length);
        }, r.EncoderBuffer = a, a.isEncoderBuffer = function(e2) {
          if (e2 instanceof a) return true;
          return "object" == typeof e2 && "EncoderBuffer" === e2.constructor.name && "number" == typeof e2.length && "function" == typeof e2.join;
        }, a.prototype.join = function(e2, t3) {
          return e2 || (e2 = s.alloc(this.length)), t3 || (t3 = 0), 0 === this.length || (Array.isArray(this.value) ? this.value.forEach((function(r2) {
            r2.join(e2, t3), t3 += r2.length;
          })) : ("number" == typeof this.value ? e2[t3] = this.value : "string" == typeof this.value ? e2.write(this.value, t3) : s.isBuffer(this.value) && this.value.copy(e2, t3), t3 += this.length)), e2;
        };
      }, { "../base/reporter": 175, inherits: 440, "safer-buffer": 495 }], 173: [function(e, t2, r) {
        const n = r;
        n.Reporter = e("./reporter").Reporter, n.DecoderBuffer = e("./buffer").DecoderBuffer, n.EncoderBuffer = e("./buffer").EncoderBuffer, n.Node = e("./node");
      }, { "./buffer": 172, "./node": 174, "./reporter": 175 }], 174: [function(e, t2, r) {
        const n = e("../base/reporter").Reporter, i = e("../base/buffer").EncoderBuffer, s = e("../base/buffer").DecoderBuffer, o = e("minimalistic-assert"), a = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], l = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(a);
        function c(e2, t3, r2) {
          const n2 = {};
          this._baseState = n2, n2.name = r2, n2.enc = e2, n2.parent = t3 || null, n2.children = null, n2.tag = null, n2.args = null, n2.reverseArgs = null, n2.choice = null, n2.optional = false, n2.any = false, n2.obj = false, n2.use = null, n2.useDecoder = null, n2.key = null, n2.default = null, n2.explicit = null, n2.implicit = null, n2.contains = null, n2.parent || (n2.children = [], this._wrap());
        }
        t2.exports = c;
        const u = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
        c.prototype.clone = function() {
          const e2 = this._baseState, t3 = {};
          u.forEach((function(r3) {
            t3[r3] = e2[r3];
          }));
          const r2 = new this.constructor(t3.parent);
          return r2._baseState = t3, r2;
        }, c.prototype._wrap = function() {
          const e2 = this._baseState;
          l.forEach((function(t3) {
            this[t3] = function() {
              const r2 = new this.constructor(this);
              return e2.children.push(r2), r2[t3].apply(r2, arguments);
            };
          }), this);
        }, c.prototype._init = function(e2) {
          const t3 = this._baseState;
          o(null === t3.parent), e2.call(this), t3.children = t3.children.filter((function(e3) {
            return e3._baseState.parent === this;
          }), this), o.equal(t3.children.length, 1, "Root node can have only one child");
        }, c.prototype._useArgs = function(e2) {
          const t3 = this._baseState, r2 = e2.filter((function(e3) {
            return e3 instanceof this.constructor;
          }), this);
          e2 = e2.filter((function(e3) {
            return !(e3 instanceof this.constructor);
          }), this), 0 !== r2.length && (o(null === t3.children), t3.children = r2, r2.forEach((function(e3) {
            e3._baseState.parent = this;
          }), this)), 0 !== e2.length && (o(null === t3.args), t3.args = e2, t3.reverseArgs = e2.map((function(e3) {
            if ("object" != typeof e3 || e3.constructor !== Object) return e3;
            const t4 = {};
            return Object.keys(e3).forEach((function(r3) {
              r3 == (0 | r3) && (r3 |= 0);
              const n2 = e3[r3];
              t4[n2] = r3;
            })), t4;
          })));
        }, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach((function(e2) {
          c.prototype[e2] = function() {
            const t3 = this._baseState;
            throw new Error(e2 + " not implemented for encoding: " + t3.enc);
          };
        })), a.forEach((function(e2) {
          c.prototype[e2] = function() {
            const t3 = this._baseState, r2 = Array.prototype.slice.call(arguments);
            return o(null === t3.tag), t3.tag = e2, this._useArgs(r2), this;
          };
        })), c.prototype.use = function(e2) {
          o(e2);
          const t3 = this._baseState;
          return o(null === t3.use), t3.use = e2, this;
        }, c.prototype.optional = function() {
          return this._baseState.optional = true, this;
        }, c.prototype.def = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.default), t3.default = e2, t3.optional = true, this;
        }, c.prototype.explicit = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.explicit && null === t3.implicit), t3.explicit = e2, this;
        }, c.prototype.implicit = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.explicit && null === t3.implicit), t3.implicit = e2, this;
        }, c.prototype.obj = function() {
          const e2 = this._baseState, t3 = Array.prototype.slice.call(arguments);
          return e2.obj = true, 0 !== t3.length && this._useArgs(t3), this;
        }, c.prototype.key = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.key), t3.key = e2, this;
        }, c.prototype.any = function() {
          return this._baseState.any = true, this;
        }, c.prototype.choice = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.choice), t3.choice = e2, this._useArgs(Object.keys(e2).map((function(t4) {
            return e2[t4];
          }))), this;
        }, c.prototype.contains = function(e2) {
          const t3 = this._baseState;
          return o(null === t3.use), t3.contains = e2, this;
        }, c.prototype._decode = function(e2, t3) {
          const r2 = this._baseState;
          if (null === r2.parent) return e2.wrapResult(r2.children[0]._decode(e2, t3));
          let n2, i2 = r2.default, o2 = true, a2 = null;
          if (null !== r2.key && (a2 = e2.enterKey(r2.key)), r2.optional) {
            let n3 = null;
            if (null !== r2.explicit ? n3 = r2.explicit : null !== r2.implicit ? n3 = r2.implicit : null !== r2.tag && (n3 = r2.tag), null !== n3 || r2.any) {
              if (o2 = this._peekTag(e2, n3, r2.any), e2.isError(o2)) return o2;
            } else {
              const n4 = e2.save();
              try {
                null === r2.choice ? this._decodeGeneric(r2.tag, e2, t3) : this._decodeChoice(e2, t3), o2 = true;
              } catch (e3) {
                o2 = false;
              }
              e2.restore(n4);
            }
          }
          if (r2.obj && o2 && (n2 = e2.enterObject()), o2) {
            if (null !== r2.explicit) {
              const t4 = this._decodeTag(e2, r2.explicit);
              if (e2.isError(t4)) return t4;
              e2 = t4;
            }
            const n3 = e2.offset;
            if (null === r2.use && null === r2.choice) {
              let t4;
              r2.any && (t4 = e2.save());
              const n4 = this._decodeTag(e2, null !== r2.implicit ? r2.implicit : r2.tag, r2.any);
              if (e2.isError(n4)) return n4;
              r2.any ? i2 = e2.raw(t4) : e2 = n4;
            }
            if (t3 && t3.track && null !== r2.tag && t3.track(e2.path(), n3, e2.length, "tagged"), t3 && t3.track && null !== r2.tag && t3.track(e2.path(), e2.offset, e2.length, "content"), r2.any || (i2 = null === r2.choice ? this._decodeGeneric(r2.tag, e2, t3) : this._decodeChoice(e2, t3)), e2.isError(i2)) return i2;
            if (r2.any || null !== r2.choice || null === r2.children || r2.children.forEach((function(r3) {
              r3._decode(e2, t3);
            })), r2.contains && ("octstr" === r2.tag || "bitstr" === r2.tag)) {
              const n4 = new s(i2);
              i2 = this._getUse(r2.contains, e2._reporterState.obj)._decode(n4, t3);
            }
          }
          return r2.obj && o2 && (i2 = e2.leaveObject(n2)), null === r2.key || null === i2 && true !== o2 ? null !== a2 && e2.exitKey(a2) : e2.leaveKey(a2, r2.key, i2), i2;
        }, c.prototype._decodeGeneric = function(e2, t3, r2) {
          const n2 = this._baseState;
          return "seq" === e2 || "set" === e2 ? null : "seqof" === e2 || "setof" === e2 ? this._decodeList(t3, e2, n2.args[0], r2) : /str$/.test(e2) ? this._decodeStr(t3, e2, r2) : "objid" === e2 && n2.args ? this._decodeObjid(t3, n2.args[0], n2.args[1], r2) : "objid" === e2 ? this._decodeObjid(t3, null, null, r2) : "gentime" === e2 || "utctime" === e2 ? this._decodeTime(t3, e2, r2) : "null_" === e2 ? this._decodeNull(t3, r2) : "bool" === e2 ? this._decodeBool(t3, r2) : "objDesc" === e2 ? this._decodeStr(t3, e2, r2) : "int" === e2 || "enum" === e2 ? this._decodeInt(t3, n2.args && n2.args[0], r2) : null !== n2.use ? this._getUse(n2.use, t3._reporterState.obj)._decode(t3, r2) : t3.error("unknown tag: " + e2);
        }, c.prototype._getUse = function(e2, t3) {
          const r2 = this._baseState;
          return r2.useDecoder = this._use(e2, t3), o(null === r2.useDecoder._baseState.parent), r2.useDecoder = r2.useDecoder._baseState.children[0], r2.implicit !== r2.useDecoder._baseState.implicit && (r2.useDecoder = r2.useDecoder.clone(), r2.useDecoder._baseState.implicit = r2.implicit), r2.useDecoder;
        }, c.prototype._decodeChoice = function(e2, t3) {
          const r2 = this._baseState;
          let n2 = null, i2 = false;
          return Object.keys(r2.choice).some((function(s2) {
            const o2 = e2.save(), a2 = r2.choice[s2];
            try {
              const r3 = a2._decode(e2, t3);
              if (e2.isError(r3)) return false;
              n2 = { type: s2, value: r3 }, i2 = true;
            } catch (t4) {
              return e2.restore(o2), false;
            }
            return true;
          }), this), i2 ? n2 : e2.error("Choice not matched");
        }, c.prototype._createEncoderBuffer = function(e2) {
          return new i(e2, this.reporter);
        }, c.prototype._encode = function(e2, t3, r2) {
          const n2 = this._baseState;
          if (null !== n2.default && n2.default === e2) return;
          const i2 = this._encodeValue(e2, t3, r2);
          return void 0 === i2 || this._skipDefault(i2, t3, r2) ? void 0 : i2;
        }, c.prototype._encodeValue = function(e2, t3, r2) {
          const i2 = this._baseState;
          if (null === i2.parent) return i2.children[0]._encode(e2, t3 || new n());
          let s2 = null;
          if (this.reporter = t3, i2.optional && void 0 === e2) {
            if (null === i2.default) return;
            e2 = i2.default;
          }
          let o2 = null, a2 = false;
          if (i2.any) s2 = this._createEncoderBuffer(e2);
          else if (i2.choice) s2 = this._encodeChoice(e2, t3);
          else if (i2.contains) o2 = this._getUse(i2.contains, r2)._encode(e2, t3), a2 = true;
          else if (i2.children) o2 = i2.children.map((function(r3) {
            if ("null_" === r3._baseState.tag) return r3._encode(null, t3, e2);
            if (null === r3._baseState.key) return t3.error("Child should have a key");
            const n2 = t3.enterKey(r3._baseState.key);
            if ("object" != typeof e2) return t3.error("Child expected, but input is not object");
            const i3 = r3._encode(e2[r3._baseState.key], t3, e2);
            return t3.leaveKey(n2), i3;
          }), this).filter((function(e3) {
            return e3;
          })), o2 = this._createEncoderBuffer(o2);
          else if ("seqof" === i2.tag || "setof" === i2.tag) {
            if (!i2.args || 1 !== i2.args.length) return t3.error("Too many args for : " + i2.tag);
            if (!Array.isArray(e2)) return t3.error("seqof/setof, but data is not Array");
            const r3 = this.clone();
            r3._baseState.implicit = null, o2 = this._createEncoderBuffer(e2.map((function(r4) {
              const n2 = this._baseState;
              return this._getUse(n2.args[0], e2)._encode(r4, t3);
            }), r3));
          } else null !== i2.use ? s2 = this._getUse(i2.use, r2)._encode(e2, t3) : (o2 = this._encodePrimitive(i2.tag, e2), a2 = true);
          if (!i2.any && null === i2.choice) {
            const e3 = null !== i2.implicit ? i2.implicit : i2.tag, r3 = null === i2.implicit ? "universal" : "context";
            null === e3 ? null === i2.use && t3.error("Tag could be omitted only for .use()") : null === i2.use && (s2 = this._encodeComposite(e3, a2, r3, o2));
          }
          return null !== i2.explicit && (s2 = this._encodeComposite(i2.explicit, false, "context", s2)), s2;
        }, c.prototype._encodeChoice = function(e2, t3) {
          const r2 = this._baseState, n2 = r2.choice[e2.type];
          return n2 || o(false, e2.type + " not found in " + JSON.stringify(Object.keys(r2.choice))), n2._encode(e2.value, t3);
        }, c.prototype._encodePrimitive = function(e2, t3) {
          const r2 = this._baseState;
          if (/str$/.test(e2)) return this._encodeStr(t3, e2);
          if ("objid" === e2 && r2.args) return this._encodeObjid(t3, r2.reverseArgs[0], r2.args[1]);
          if ("objid" === e2) return this._encodeObjid(t3, null, null);
          if ("gentime" === e2 || "utctime" === e2) return this._encodeTime(t3, e2);
          if ("null_" === e2) return this._encodeNull();
          if ("int" === e2 || "enum" === e2) return this._encodeInt(t3, r2.args && r2.reverseArgs[0]);
          if ("bool" === e2) return this._encodeBool(t3);
          if ("objDesc" === e2) return this._encodeStr(t3, e2);
          throw new Error("Unsupported tag: " + e2);
        }, c.prototype._isNumstr = function(e2) {
          return /^[0-9 ]*$/.test(e2);
        }, c.prototype._isPrintstr = function(e2) {
          return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e2);
        };
      }, { "../base/buffer": 172, "../base/reporter": 175, "minimalistic-assert": 453 }], 175: [function(e, t2, r) {
        const n = e("inherits");
        function i(e2) {
          this._reporterState = { obj: null, path: [], options: e2 || {}, errors: [] };
        }
        function s(e2, t3) {
          this.path = e2, this.rethrow(t3);
        }
        r.Reporter = i, i.prototype.isError = function(e2) {
          return e2 instanceof s;
        }, i.prototype.save = function() {
          const e2 = this._reporterState;
          return { obj: e2.obj, pathLen: e2.path.length };
        }, i.prototype.restore = function(e2) {
          const t3 = this._reporterState;
          t3.obj = e2.obj, t3.path = t3.path.slice(0, e2.pathLen);
        }, i.prototype.enterKey = function(e2) {
          return this._reporterState.path.push(e2);
        }, i.prototype.exitKey = function(e2) {
          const t3 = this._reporterState;
          t3.path = t3.path.slice(0, e2 - 1);
        }, i.prototype.leaveKey = function(e2, t3, r2) {
          const n2 = this._reporterState;
          this.exitKey(e2), null !== n2.obj && (n2.obj[t3] = r2);
        }, i.prototype.path = function() {
          return this._reporterState.path.join("/");
        }, i.prototype.enterObject = function() {
          const e2 = this._reporterState, t3 = e2.obj;
          return e2.obj = {}, t3;
        }, i.prototype.leaveObject = function(e2) {
          const t3 = this._reporterState, r2 = t3.obj;
          return t3.obj = e2, r2;
        }, i.prototype.error = function(e2) {
          let t3;
          const r2 = this._reporterState, n2 = e2 instanceof s;
          if (t3 = n2 ? e2 : new s(r2.path.map((function(e3) {
            return "[" + JSON.stringify(e3) + "]";
          })).join(""), e2.message || e2, e2.stack), !r2.options.partial) throw t3;
          return n2 || r2.errors.push(t3), t3;
        }, i.prototype.wrapResult = function(e2) {
          const t3 = this._reporterState;
          return t3.options.partial ? { result: this.isError(e2) ? null : e2, errors: t3.errors } : e2;
        }, n(s, Error), s.prototype.rethrow = function(e2) {
          if (this.message = e2 + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, s), !this.stack) try {
            throw new Error(this.message);
          } catch (e3) {
            this.stack = e3.stack;
          }
          return this;
        };
      }, { inherits: 440 }], 176: [function(e, t2, r) {
        function n(e2) {
          const t3 = {};
          return Object.keys(e2).forEach((function(r2) {
            (0 | r2) == r2 && (r2 |= 0);
            const n2 = e2[r2];
            t3[n2] = r2;
          })), t3;
        }
        r.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, r.tagClassByName = n(r.tagClass), r.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, r.tagByName = n(r.tag);
      }, {}], 177: [function(e, t2, r) {
        const n = r;
        n._reverse = function(e2) {
          const t3 = {};
          return Object.keys(e2).forEach((function(r2) {
            (0 | r2) == r2 && (r2 |= 0);
            const n2 = e2[r2];
            t3[n2] = r2;
          })), t3;
        }, n.der = e("./der");
      }, { "./der": 176 }], 178: [function(e, t2, r) {
        const n = e("inherits"), i = e("bn.js"), s = e("../base/buffer").DecoderBuffer, o = e("../base/node"), a = e("../constants/der");
        function l(e2) {
          this.enc = "der", this.name = e2.name, this.entity = e2, this.tree = new c(), this.tree._init(e2.body);
        }
        function c(e2) {
          o.call(this, "der", e2);
        }
        function u(e2, t3) {
          let r2 = e2.readUInt8(t3);
          if (e2.isError(r2)) return r2;
          const n2 = a.tagClass[r2 >> 6], i2 = 0 == (32 & r2);
          if (31 == (31 & r2)) {
            let n3 = r2;
            for (r2 = 0; 128 == (128 & n3); ) {
              if (n3 = e2.readUInt8(t3), e2.isError(n3)) return n3;
              r2 <<= 7, r2 |= 127 & n3;
            }
          } else r2 &= 31;
          return { cls: n2, primitive: i2, tag: r2, tagStr: a.tag[r2] };
        }
        function h(e2, t3, r2) {
          let n2 = e2.readUInt8(r2);
          if (e2.isError(n2)) return n2;
          if (!t3 && 128 === n2) return null;
          if (0 == (128 & n2)) return n2;
          const i2 = 127 & n2;
          if (i2 > 4) return e2.error("length octect is too long");
          n2 = 0;
          for (let t4 = 0; t4 < i2; t4++) {
            n2 <<= 8;
            const t5 = e2.readUInt8(r2);
            if (e2.isError(t5)) return t5;
            n2 |= t5;
          }
          return n2;
        }
        t2.exports = l, l.prototype.decode = function(e2, t3) {
          return s.isDecoderBuffer(e2) || (e2 = new s(e2, t3)), this.tree._decode(e2, t3);
        }, n(c, o), c.prototype._peekTag = function(e2, t3, r2) {
          if (e2.isEmpty()) return false;
          const n2 = e2.save(), i2 = u(e2, 'Failed to peek tag: "' + t3 + '"');
          return e2.isError(i2) ? i2 : (e2.restore(n2), i2.tag === t3 || i2.tagStr === t3 || i2.tagStr + "of" === t3 || r2);
        }, c.prototype._decodeTag = function(e2, t3, r2) {
          const n2 = u(e2, 'Failed to decode tag of "' + t3 + '"');
          if (e2.isError(n2)) return n2;
          let i2 = h(e2, n2.primitive, 'Failed to get length of "' + t3 + '"');
          if (e2.isError(i2)) return i2;
          if (!r2 && n2.tag !== t3 && n2.tagStr !== t3 && n2.tagStr + "of" !== t3) return e2.error('Failed to match tag: "' + t3 + '"');
          if (n2.primitive || null !== i2) return e2.skip(i2, 'Failed to match body of: "' + t3 + '"');
          const s2 = e2.save(), o2 = this._skipUntilEnd(e2, 'Failed to skip indefinite length body: "' + this.tag + '"');
          return e2.isError(o2) ? o2 : (i2 = e2.offset - s2.offset, e2.restore(s2), e2.skip(i2, 'Failed to match body of: "' + t3 + '"'));
        }, c.prototype._skipUntilEnd = function(e2, t3) {
          for (; ; ) {
            const r2 = u(e2, t3);
            if (e2.isError(r2)) return r2;
            const n2 = h(e2, r2.primitive, t3);
            if (e2.isError(n2)) return n2;
            let i2;
            if (i2 = r2.primitive || null !== n2 ? e2.skip(n2) : this._skipUntilEnd(e2, t3), e2.isError(i2)) return i2;
            if ("end" === r2.tagStr) break;
          }
        }, c.prototype._decodeList = function(e2, t3, r2, n2) {
          const i2 = [];
          for (; !e2.isEmpty(); ) {
            const t4 = this._peekTag(e2, "end");
            if (e2.isError(t4)) return t4;
            const s2 = r2.decode(e2, "der", n2);
            if (e2.isError(s2) && t4) break;
            i2.push(s2);
          }
          return i2;
        }, c.prototype._decodeStr = function(e2, t3) {
          if ("bitstr" === t3) {
            const t4 = e2.readUInt8();
            return e2.isError(t4) ? t4 : { unused: t4, data: e2.raw() };
          }
          if ("bmpstr" === t3) {
            const t4 = e2.raw();
            if (t4.length % 2 == 1) return e2.error("Decoding of string type: bmpstr length mismatch");
            let r2 = "";
            for (let e3 = 0; e3 < t4.length / 2; e3++) r2 += String.fromCharCode(t4.readUInt16BE(2 * e3));
            return r2;
          }
          if ("numstr" === t3) {
            const t4 = e2.raw().toString("ascii");
            return this._isNumstr(t4) ? t4 : e2.error("Decoding of string type: numstr unsupported characters");
          }
          if ("octstr" === t3) return e2.raw();
          if ("objDesc" === t3) return e2.raw();
          if ("printstr" === t3) {
            const t4 = e2.raw().toString("ascii");
            return this._isPrintstr(t4) ? t4 : e2.error("Decoding of string type: printstr unsupported characters");
          }
          return /str$/.test(t3) ? e2.raw().toString() : e2.error("Decoding of string type: " + t3 + " unsupported");
        }, c.prototype._decodeObjid = function(e2, t3, r2) {
          let n2;
          const i2 = [];
          let s2 = 0, o2 = 0;
          for (; !e2.isEmpty(); ) o2 = e2.readUInt8(), s2 <<= 7, s2 |= 127 & o2, 0 == (128 & o2) && (i2.push(s2), s2 = 0);
          128 & o2 && i2.push(s2);
          const a2 = i2[0] / 40 | 0, l2 = i2[0] % 40;
          if (n2 = r2 ? i2 : [a2, l2].concat(i2.slice(1)), t3) {
            let e3 = t3[n2.join(" ")];
            void 0 === e3 && (e3 = t3[n2.join(".")]), void 0 !== e3 && (n2 = e3);
          }
          return n2;
        }, c.prototype._decodeTime = function(e2, t3) {
          const r2 = e2.raw().toString();
          let n2, i2, s2, o2, a2, l2;
          if ("gentime" === t3) n2 = 0 | r2.slice(0, 4), i2 = 0 | r2.slice(4, 6), s2 = 0 | r2.slice(6, 8), o2 = 0 | r2.slice(8, 10), a2 = 0 | r2.slice(10, 12), l2 = 0 | r2.slice(12, 14);
          else {
            if ("utctime" !== t3) return e2.error("Decoding " + t3 + " time is not supported yet");
            n2 = 0 | r2.slice(0, 2), i2 = 0 | r2.slice(2, 4), s2 = 0 | r2.slice(4, 6), o2 = 0 | r2.slice(6, 8), a2 = 0 | r2.slice(8, 10), l2 = 0 | r2.slice(10, 12), n2 = n2 < 70 ? 2e3 + n2 : 1900 + n2;
          }
          return Date.UTC(n2, i2 - 1, s2, o2, a2, l2, 0);
        }, c.prototype._decodeNull = function() {
          return null;
        }, c.prototype._decodeBool = function(e2) {
          const t3 = e2.readUInt8();
          return e2.isError(t3) ? t3 : 0 !== t3;
        }, c.prototype._decodeInt = function(e2, t3) {
          const r2 = e2.raw();
          let n2 = new i(r2);
          return t3 && (n2 = t3[n2.toString(10)] || n2), n2;
        }, c.prototype._use = function(e2, t3) {
          return "function" == typeof e2 && (e2 = e2(t3)), e2._getDecoder("der").tree;
        };
      }, { "../base/buffer": 172, "../base/node": 174, "../constants/der": 176, "bn.js": 184, inherits: 440 }], 179: [function(e, t2, r) {
        const n = r;
        n.der = e("./der"), n.pem = e("./pem");
      }, { "./der": 178, "./pem": 180 }], 180: [function(e, t2, r) {
        const n = e("inherits"), i = e("safer-buffer").Buffer, s = e("./der");
        function o(e2) {
          s.call(this, e2), this.enc = "pem";
        }
        n(o, s), t2.exports = o, o.prototype.decode = function(e2, t3) {
          const r2 = e2.toString().split(/[\r\n]+/g), n2 = t3.label.toUpperCase(), o2 = /^-----(BEGIN|END) ([^-]+)-----$/;
          let a = -1, l = -1;
          for (let e3 = 0; e3 < r2.length; e3++) {
            const t4 = r2[e3].match(o2);
            if (null !== t4 && t4[2] === n2) {
              if (-1 !== a) {
                if ("END" !== t4[1]) break;
                l = e3;
                break;
              }
              if ("BEGIN" !== t4[1]) break;
              a = e3;
            }
          }
          if (-1 === a || -1 === l) throw new Error("PEM section not found for: " + n2);
          const c = r2.slice(a + 1, l).join("");
          c.replace(/[^a-z0-9+/=]+/gi, "");
          const u = i.from(c, "base64");
          return s.prototype.decode.call(this, u, t3);
        };
      }, { "./der": 178, inherits: 440, "safer-buffer": 495 }], 181: [function(e, t2, r) {
        const n = e("inherits"), i = e("safer-buffer").Buffer, s = e("../base/node"), o = e("../constants/der");
        function a(e2) {
          this.enc = "der", this.name = e2.name, this.entity = e2, this.tree = new l(), this.tree._init(e2.body);
        }
        function l(e2) {
          s.call(this, "der", e2);
        }
        function c(e2) {
          return e2 < 10 ? "0" + e2 : e2;
        }
        t2.exports = a, a.prototype.encode = function(e2, t3) {
          return this.tree._encode(e2, t3).join();
        }, n(l, s), l.prototype._encodeComposite = function(e2, t3, r2, n2) {
          const s2 = (function(e3, t4, r3, n3) {
            let i2;
            "seqof" === e3 ? e3 = "seq" : "setof" === e3 && (e3 = "set");
            if (o.tagByName.hasOwnProperty(e3)) i2 = o.tagByName[e3];
            else {
              if ("number" != typeof e3 || (0 | e3) !== e3) return n3.error("Unknown tag: " + e3);
              i2 = e3;
            }
            if (i2 >= 31) return n3.error("Multi-octet tag encoding unsupported");
            t4 || (i2 |= 32);
            return i2 |= o.tagClassByName[r3 || "universal"] << 6, i2;
          })(e2, t3, r2, this.reporter);
          if (n2.length < 128) {
            const e3 = i.alloc(2);
            return e3[0] = s2, e3[1] = n2.length, this._createEncoderBuffer([e3, n2]);
          }
          let a2 = 1;
          for (let e3 = n2.length; e3 >= 256; e3 >>= 8) a2++;
          const l2 = i.alloc(2 + a2);
          l2[0] = s2, l2[1] = 128 | a2;
          for (let e3 = 1 + a2, t4 = n2.length; t4 > 0; e3--, t4 >>= 8) l2[e3] = 255 & t4;
          return this._createEncoderBuffer([l2, n2]);
        }, l.prototype._encodeStr = function(e2, t3) {
          if ("bitstr" === t3) return this._createEncoderBuffer([0 | e2.unused, e2.data]);
          if ("bmpstr" === t3) {
            const t4 = i.alloc(2 * e2.length);
            for (let r2 = 0; r2 < e2.length; r2++) t4.writeUInt16BE(e2.charCodeAt(r2), 2 * r2);
            return this._createEncoderBuffer(t4);
          }
          return "numstr" === t3 ? this._isNumstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === t3 ? this._isPrintstr(e2) ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t3) || "objDesc" === t3 ? this._createEncoderBuffer(e2) : this.reporter.error("Encoding of string type: " + t3 + " unsupported");
        }, l.prototype._encodeObjid = function(e2, t3, r2) {
          if ("string" == typeof e2) {
            if (!t3) return this.reporter.error("string objid given, but no values map found");
            if (!t3.hasOwnProperty(e2)) return this.reporter.error("objid not found in values map");
            e2 = t3[e2].split(/[\s.]+/g);
            for (let t4 = 0; t4 < e2.length; t4++) e2[t4] |= 0;
          } else if (Array.isArray(e2)) {
            e2 = e2.slice();
            for (let t4 = 0; t4 < e2.length; t4++) e2[t4] |= 0;
          }
          if (!Array.isArray(e2)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e2));
          if (!r2) {
            if (e2[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            e2.splice(0, 2, 40 * e2[0] + e2[1]);
          }
          let n2 = 0;
          for (let t4 = 0; t4 < e2.length; t4++) {
            let r3 = e2[t4];
            for (n2++; r3 >= 128; r3 >>= 7) n2++;
          }
          const s2 = i.alloc(n2);
          let o2 = s2.length - 1;
          for (let t4 = e2.length - 1; t4 >= 0; t4--) {
            let r3 = e2[t4];
            for (s2[o2--] = 127 & r3; (r3 >>= 7) > 0; ) s2[o2--] = 128 | 127 & r3;
          }
          return this._createEncoderBuffer(s2);
        }, l.prototype._encodeTime = function(e2, t3) {
          let r2;
          const n2 = new Date(e2);
          return "gentime" === t3 ? r2 = [c(n2.getUTCFullYear()), c(n2.getUTCMonth() + 1), c(n2.getUTCDate()), c(n2.getUTCHours()), c(n2.getUTCMinutes()), c(n2.getUTCSeconds()), "Z"].join("") : "utctime" === t3 ? r2 = [c(n2.getUTCFullYear() % 100), c(n2.getUTCMonth() + 1), c(n2.getUTCDate()), c(n2.getUTCHours()), c(n2.getUTCMinutes()), c(n2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + t3 + " time is not supported yet"), this._encodeStr(r2, "octstr");
        }, l.prototype._encodeNull = function() {
          return this._createEncoderBuffer("");
        }, l.prototype._encodeInt = function(e2, t3) {
          if ("string" == typeof e2) {
            if (!t3) return this.reporter.error("String int or enum given, but no values map");
            if (!t3.hasOwnProperty(e2)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e2));
            e2 = t3[e2];
          }
          if ("number" != typeof e2 && !i.isBuffer(e2)) {
            const t4 = e2.toArray();
            !e2.sign && 128 & t4[0] && t4.unshift(0), e2 = i.from(t4);
          }
          if (i.isBuffer(e2)) {
            let t4 = e2.length;
            0 === e2.length && t4++;
            const r3 = i.alloc(t4);
            return e2.copy(r3), 0 === e2.length && (r3[0] = 0), this._createEncoderBuffer(r3);
          }
          if (e2 < 128) return this._createEncoderBuffer(e2);
          if (e2 < 256) return this._createEncoderBuffer([0, e2]);
          let r2 = 1;
          for (let t4 = e2; t4 >= 256; t4 >>= 8) r2++;
          const n2 = new Array(r2);
          for (let t4 = n2.length - 1; t4 >= 0; t4--) n2[t4] = 255 & e2, e2 >>= 8;
          return 128 & n2[0] && n2.unshift(0), this._createEncoderBuffer(i.from(n2));
        }, l.prototype._encodeBool = function(e2) {
          return this._createEncoderBuffer(e2 ? 255 : 0);
        }, l.prototype._use = function(e2, t3) {
          return "function" == typeof e2 && (e2 = e2(t3)), e2._getEncoder("der").tree;
        }, l.prototype._skipDefault = function(e2, t3, r2) {
          const n2 = this._baseState;
          let i2;
          if (null === n2.default) return false;
          const s2 = e2.join();
          if (void 0 === n2.defaultBuffer && (n2.defaultBuffer = this._encodeValue(n2.default, t3, r2).join()), s2.length !== n2.defaultBuffer.length) return false;
          for (i2 = 0; i2 < s2.length; i2++) if (s2[i2] !== n2.defaultBuffer[i2]) return false;
          return true;
        };
      }, { "../base/node": 174, "../constants/der": 176, inherits: 440, "safer-buffer": 495 }], 182: [function(e, t2, r) {
        const n = r;
        n.der = e("./der"), n.pem = e("./pem");
      }, { "./der": 181, "./pem": 183 }], 183: [function(e, t2, r) {
        const n = e("inherits"), i = e("./der");
        function s(e2) {
          i.call(this, e2), this.enc = "pem";
        }
        n(s, i), t2.exports = s, s.prototype.encode = function(e2, t3) {
          const r2 = i.prototype.encode.call(this, e2).toString("base64"), n2 = ["-----BEGIN " + t3.label + "-----"];
          for (let e3 = 0; e3 < r2.length; e3 += 64) n2.push(r2.slice(e3, e3 + 64));
          return n2.push("-----END " + t3.label + "-----"), n2.join("\n");
        };
      }, { "./der": 181, inherits: 440 }], 184: [function(e, t2, r) {
        !(function(t3, r2) {
          function n(e2, t4) {
            if (!e2) throw new Error(t4 || "Assertion failed");
          }
          function i(e2, t4) {
            e2.super_ = t4;
            var r3 = function() {
            };
            r3.prototype = t4.prototype, e2.prototype = new r3(), e2.prototype.constructor = e2;
          }
          function s(e2, t4, r3) {
            if (s.isBN(e2)) return e2;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e2 && ("le" !== t4 && "be" !== t4 || (r3 = t4, t4 = 10), this._init(e2 || 0, t4 || 10, r3 || "be"));
          }
          var o;
          "object" == typeof t3 ? t3.exports = s : (void 0).BN = s, s.BN = s, s.wordSize = 26;
          try {
            o = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : e("buffer").Buffer;
          } catch (e2) {
          }
          function a(e2, t4) {
            var r3 = e2.charCodeAt(t4);
            return r3 >= 65 && r3 <= 70 ? r3 - 55 : r3 >= 97 && r3 <= 102 ? r3 - 87 : r3 - 48 & 15;
          }
          function l(e2, t4, r3) {
            var n2 = a(e2, r3);
            return r3 - 1 >= t4 && (n2 |= a(e2, r3 - 1) << 4), n2;
          }
          function c(e2, t4, r3, n2) {
            for (var i2 = 0, s2 = Math.min(e2.length, r3), o2 = t4; o2 < s2; o2++) {
              var a2 = e2.charCodeAt(o2) - 48;
              i2 *= n2, i2 += a2 >= 49 ? a2 - 49 + 10 : a2 >= 17 ? a2 - 17 + 10 : a2;
            }
            return i2;
          }
          s.isBN = function(e2) {
            return e2 instanceof s || null !== e2 && "object" == typeof e2 && e2.constructor.wordSize === s.wordSize && Array.isArray(e2.words);
          }, s.max = function(e2, t4) {
            return e2.cmp(t4) > 0 ? e2 : t4;
          }, s.min = function(e2, t4) {
            return e2.cmp(t4) < 0 ? e2 : t4;
          }, s.prototype._init = function(e2, t4, r3) {
            if ("number" == typeof e2) return this._initNumber(e2, t4, r3);
            if ("object" == typeof e2) return this._initArray(e2, t4, r3);
            "hex" === t4 && (t4 = 16), n(t4 === (0 | t4) && t4 >= 2 && t4 <= 36);
            var i2 = 0;
            "-" === (e2 = e2.toString().replace(/\s+/g, ""))[0] && (i2++, this.negative = 1), i2 < e2.length && (16 === t4 ? this._parseHex(e2, i2, r3) : (this._parseBase(e2, t4, i2), "le" === r3 && this._initArray(this.toArray(), t4, r3)));
          }, s.prototype._initNumber = function(e2, t4, r3) {
            e2 < 0 && (this.negative = 1, e2 = -e2), e2 < 67108864 ? (this.words = [67108863 & e2], this.length = 1) : e2 < 4503599627370496 ? (this.words = [67108863 & e2, e2 / 67108864 & 67108863], this.length = 2) : (n(e2 < 9007199254740992), this.words = [67108863 & e2, e2 / 67108864 & 67108863, 1], this.length = 3), "le" === r3 && this._initArray(this.toArray(), t4, r3);
          }, s.prototype._initArray = function(e2, t4, r3) {
            if (n("number" == typeof e2.length), e2.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(e2.length / 3), this.words = new Array(this.length);
            for (var i2 = 0; i2 < this.length; i2++) this.words[i2] = 0;
            var s2, o2, a2 = 0;
            if ("be" === r3) for (i2 = e2.length - 1, s2 = 0; i2 >= 0; i2 -= 3) o2 = e2[i2] | e2[i2 - 1] << 8 | e2[i2 - 2] << 16, this.words[s2] |= o2 << a2 & 67108863, this.words[s2 + 1] = o2 >>> 26 - a2 & 67108863, (a2 += 24) >= 26 && (a2 -= 26, s2++);
            else if ("le" === r3) for (i2 = 0, s2 = 0; i2 < e2.length; i2 += 3) o2 = e2[i2] | e2[i2 + 1] << 8 | e2[i2 + 2] << 16, this.words[s2] |= o2 << a2 & 67108863, this.words[s2 + 1] = o2 >>> 26 - a2 & 67108863, (a2 += 24) >= 26 && (a2 -= 26, s2++);
            return this.strip();
          }, s.prototype._parseHex = function(e2, t4, r3) {
            this.length = Math.ceil((e2.length - t4) / 6), this.words = new Array(this.length);
            for (var n2 = 0; n2 < this.length; n2++) this.words[n2] = 0;
            var i2, s2 = 0, o2 = 0;
            if ("be" === r3) for (n2 = e2.length - 1; n2 >= t4; n2 -= 2) i2 = l(e2, t4, n2) << s2, this.words[o2] |= 67108863 & i2, s2 >= 18 ? (s2 -= 18, o2 += 1, this.words[o2] |= i2 >>> 26) : s2 += 8;
            else for (n2 = (e2.length - t4) % 2 == 0 ? t4 + 1 : t4; n2 < e2.length; n2 += 2) i2 = l(e2, t4, n2) << s2, this.words[o2] |= 67108863 & i2, s2 >= 18 ? (s2 -= 18, o2 += 1, this.words[o2] |= i2 >>> 26) : s2 += 8;
            this.strip();
          }, s.prototype._parseBase = function(e2, t4, r3) {
            this.words = [0], this.length = 1;
            for (var n2 = 0, i2 = 1; i2 <= 67108863; i2 *= t4) n2++;
            n2--, i2 = i2 / t4 | 0;
            for (var s2 = e2.length - r3, o2 = s2 % n2, a2 = Math.min(s2, s2 - o2) + r3, l2 = 0, u2 = r3; u2 < a2; u2 += n2) l2 = c(e2, u2, u2 + n2, t4), this.imuln(i2), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
            if (0 !== o2) {
              var h2 = 1;
              for (l2 = c(e2, u2, e2.length, t4), u2 = 0; u2 < o2; u2++) h2 *= t4;
              this.imuln(h2), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
            }
            this.strip();
          }, s.prototype.copy = function(e2) {
            e2.words = new Array(this.length);
            for (var t4 = 0; t4 < this.length; t4++) e2.words[t4] = this.words[t4];
            e2.length = this.length, e2.negative = this.negative, e2.red = this.red;
          }, s.prototype.clone = function() {
            var e2 = new s(null);
            return this.copy(e2), e2;
          }, s.prototype._expand = function(e2) {
            for (; this.length < e2; ) this.words[this.length++] = 0;
            return this;
          }, s.prototype.strip = function() {
            for (; this.length > 1 && 0 === this.words[this.length - 1]; ) this.length--;
            return this._normSign();
          }, s.prototype._normSign = function() {
            return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
          }, s.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          };
          var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], f = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
          function d(e2, t4, r3) {
            r3.negative = t4.negative ^ e2.negative;
            var n2 = e2.length + t4.length | 0;
            r3.length = n2, n2 = n2 - 1 | 0;
            var i2 = 0 | e2.words[0], s2 = 0 | t4.words[0], o2 = i2 * s2, a2 = 67108863 & o2, l2 = o2 / 67108864 | 0;
            r3.words[0] = a2;
            for (var c2 = 1; c2 < n2; c2++) {
              for (var u2 = l2 >>> 26, h2 = 67108863 & l2, f2 = Math.min(c2, t4.length - 1), d2 = Math.max(0, c2 - e2.length + 1); d2 <= f2; d2++) {
                var p2 = c2 - d2 | 0;
                u2 += (o2 = (i2 = 0 | e2.words[p2]) * (s2 = 0 | t4.words[d2]) + h2) / 67108864 | 0, h2 = 67108863 & o2;
              }
              r3.words[c2] = 0 | h2, l2 = 0 | u2;
            }
            return 0 !== l2 ? r3.words[c2] = 0 | l2 : r3.length--, r3.strip();
          }
          s.prototype.toString = function(e2, t4) {
            var r3;
            if (t4 = 0 | t4 || 1, 16 === (e2 = e2 || 10) || "hex" === e2) {
              r3 = "";
              for (var i2 = 0, s2 = 0, o2 = 0; o2 < this.length; o2++) {
                var a2 = this.words[o2], l2 = (16777215 & (a2 << i2 | s2)).toString(16);
                r3 = 0 !== (s2 = a2 >>> 24 - i2 & 16777215) || o2 !== this.length - 1 ? u[6 - l2.length] + l2 + r3 : l2 + r3, (i2 += 2) >= 26 && (i2 -= 26, o2--);
              }
              for (0 !== s2 && (r3 = s2.toString(16) + r3); r3.length % t4 != 0; ) r3 = "0" + r3;
              return 0 !== this.negative && (r3 = "-" + r3), r3;
            }
            if (e2 === (0 | e2) && e2 >= 2 && e2 <= 36) {
              var c2 = h[e2], d2 = f[e2];
              r3 = "";
              var p2 = this.clone();
              for (p2.negative = 0; !p2.isZero(); ) {
                var m2 = p2.modn(d2).toString(e2);
                r3 = (p2 = p2.idivn(d2)).isZero() ? m2 + r3 : u[c2 - m2.length] + m2 + r3;
              }
              for (this.isZero() && (r3 = "0" + r3); r3.length % t4 != 0; ) r3 = "0" + r3;
              return 0 !== this.negative && (r3 = "-" + r3), r3;
            }
            n(false, "Base should be between 2 and 36");
          }, s.prototype.toNumber = function() {
            var e2 = this.words[0];
            return 2 === this.length ? e2 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e2 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e2 : e2;
          }, s.prototype.toJSON = function() {
            return this.toString(16);
          }, s.prototype.toBuffer = function(e2, t4) {
            return n(void 0 !== o), this.toArrayLike(o, e2, t4);
          }, s.prototype.toArray = function(e2, t4) {
            return this.toArrayLike(Array, e2, t4);
          }, s.prototype.toArrayLike = function(e2, t4, r3) {
            var i2 = this.byteLength(), s2 = r3 || Math.max(1, i2);
            n(i2 <= s2, "byte array longer than desired length"), n(s2 > 0, "Requested array length <= 0"), this.strip();
            var o2, a2, l2 = "le" === t4, c2 = new e2(s2), u2 = this.clone();
            if (l2) {
              for (a2 = 0; !u2.isZero(); a2++) o2 = u2.andln(255), u2.iushrn(8), c2[a2] = o2;
              for (; a2 < s2; a2++) c2[a2] = 0;
            } else {
              for (a2 = 0; a2 < s2 - i2; a2++) c2[a2] = 0;
              for (a2 = 0; !u2.isZero(); a2++) o2 = u2.andln(255), u2.iushrn(8), c2[s2 - a2 - 1] = o2;
            }
            return c2;
          }, Math.clz32 ? s.prototype._countBits = function(e2) {
            return 32 - Math.clz32(e2);
          } : s.prototype._countBits = function(e2) {
            var t4 = e2, r3 = 0;
            return t4 >= 4096 && (r3 += 13, t4 >>>= 13), t4 >= 64 && (r3 += 7, t4 >>>= 7), t4 >= 8 && (r3 += 4, t4 >>>= 4), t4 >= 2 && (r3 += 2, t4 >>>= 2), r3 + t4;
          }, s.prototype._zeroBits = function(e2) {
            if (0 === e2) return 26;
            var t4 = e2, r3 = 0;
            return 0 == (8191 & t4) && (r3 += 13, t4 >>>= 13), 0 == (127 & t4) && (r3 += 7, t4 >>>= 7), 0 == (15 & t4) && (r3 += 4, t4 >>>= 4), 0 == (3 & t4) && (r3 += 2, t4 >>>= 2), 0 == (1 & t4) && r3++, r3;
          }, s.prototype.bitLength = function() {
            var e2 = this.words[this.length - 1], t4 = this._countBits(e2);
            return 26 * (this.length - 1) + t4;
          }, s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var e2 = 0, t4 = 0; t4 < this.length; t4++) {
              var r3 = this._zeroBits(this.words[t4]);
              if (e2 += r3, 26 !== r3) break;
            }
            return e2;
          }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
          }, s.prototype.toTwos = function(e2) {
            return 0 !== this.negative ? this.abs().inotn(e2).iaddn(1) : this.clone();
          }, s.prototype.fromTwos = function(e2) {
            return this.testn(e2 - 1) ? this.notn(e2).iaddn(1).ineg() : this.clone();
          }, s.prototype.isNeg = function() {
            return 0 !== this.negative;
          }, s.prototype.neg = function() {
            return this.clone().ineg();
          }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
          }, s.prototype.iuor = function(e2) {
            for (; this.length < e2.length; ) this.words[this.length++] = 0;
            for (var t4 = 0; t4 < e2.length; t4++) this.words[t4] = this.words[t4] | e2.words[t4];
            return this.strip();
          }, s.prototype.ior = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuor(e2);
          }, s.prototype.or = function(e2) {
            return this.length > e2.length ? this.clone().ior(e2) : e2.clone().ior(this);
          }, s.prototype.uor = function(e2) {
            return this.length > e2.length ? this.clone().iuor(e2) : e2.clone().iuor(this);
          }, s.prototype.iuand = function(e2) {
            var t4;
            t4 = this.length > e2.length ? e2 : this;
            for (var r3 = 0; r3 < t4.length; r3++) this.words[r3] = this.words[r3] & e2.words[r3];
            return this.length = t4.length, this.strip();
          }, s.prototype.iand = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuand(e2);
          }, s.prototype.and = function(e2) {
            return this.length > e2.length ? this.clone().iand(e2) : e2.clone().iand(this);
          }, s.prototype.uand = function(e2) {
            return this.length > e2.length ? this.clone().iuand(e2) : e2.clone().iuand(this);
          }, s.prototype.iuxor = function(e2) {
            var t4, r3;
            this.length > e2.length ? (t4 = this, r3 = e2) : (t4 = e2, r3 = this);
            for (var n2 = 0; n2 < r3.length; n2++) this.words[n2] = t4.words[n2] ^ r3.words[n2];
            if (this !== t4) for (; n2 < t4.length; n2++) this.words[n2] = t4.words[n2];
            return this.length = t4.length, this.strip();
          }, s.prototype.ixor = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuxor(e2);
          }, s.prototype.xor = function(e2) {
            return this.length > e2.length ? this.clone().ixor(e2) : e2.clone().ixor(this);
          }, s.prototype.uxor = function(e2) {
            return this.length > e2.length ? this.clone().iuxor(e2) : e2.clone().iuxor(this);
          }, s.prototype.inotn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = 0 | Math.ceil(e2 / 26), r3 = e2 % 26;
            this._expand(t4), r3 > 0 && t4--;
            for (var i2 = 0; i2 < t4; i2++) this.words[i2] = 67108863 & ~this.words[i2];
            return r3 > 0 && (this.words[i2] = ~this.words[i2] & 67108863 >> 26 - r3), this.strip();
          }, s.prototype.notn = function(e2) {
            return this.clone().inotn(e2);
          }, s.prototype.setn = function(e2, t4) {
            n("number" == typeof e2 && e2 >= 0);
            var r3 = e2 / 26 | 0, i2 = e2 % 26;
            return this._expand(r3 + 1), this.words[r3] = t4 ? this.words[r3] | 1 << i2 : this.words[r3] & ~(1 << i2), this.strip();
          }, s.prototype.iadd = function(e2) {
            var t4, r3, n2;
            if (0 !== this.negative && 0 === e2.negative) return this.negative = 0, t4 = this.isub(e2), this.negative ^= 1, this._normSign();
            if (0 === this.negative && 0 !== e2.negative) return e2.negative = 0, t4 = this.isub(e2), e2.negative = 1, t4._normSign();
            this.length > e2.length ? (r3 = this, n2 = e2) : (r3 = e2, n2 = this);
            for (var i2 = 0, s2 = 0; s2 < n2.length; s2++) t4 = (0 | r3.words[s2]) + (0 | n2.words[s2]) + i2, this.words[s2] = 67108863 & t4, i2 = t4 >>> 26;
            for (; 0 !== i2 && s2 < r3.length; s2++) t4 = (0 | r3.words[s2]) + i2, this.words[s2] = 67108863 & t4, i2 = t4 >>> 26;
            if (this.length = r3.length, 0 !== i2) this.words[this.length] = i2, this.length++;
            else if (r3 !== this) for (; s2 < r3.length; s2++) this.words[s2] = r3.words[s2];
            return this;
          }, s.prototype.add = function(e2) {
            var t4;
            return 0 !== e2.negative && 0 === this.negative ? (e2.negative = 0, t4 = this.sub(e2), e2.negative ^= 1, t4) : 0 === e2.negative && 0 !== this.negative ? (this.negative = 0, t4 = e2.sub(this), this.negative = 1, t4) : this.length > e2.length ? this.clone().iadd(e2) : e2.clone().iadd(this);
          }, s.prototype.isub = function(e2) {
            if (0 !== e2.negative) {
              e2.negative = 0;
              var t4 = this.iadd(e2);
              return e2.negative = 1, t4._normSign();
            }
            if (0 !== this.negative) return this.negative = 0, this.iadd(e2), this.negative = 1, this._normSign();
            var r3, n2, i2 = this.cmp(e2);
            if (0 === i2) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            i2 > 0 ? (r3 = this, n2 = e2) : (r3 = e2, n2 = this);
            for (var s2 = 0, o2 = 0; o2 < n2.length; o2++) s2 = (t4 = (0 | r3.words[o2]) - (0 | n2.words[o2]) + s2) >> 26, this.words[o2] = 67108863 & t4;
            for (; 0 !== s2 && o2 < r3.length; o2++) s2 = (t4 = (0 | r3.words[o2]) + s2) >> 26, this.words[o2] = 67108863 & t4;
            if (0 === s2 && o2 < r3.length && r3 !== this) for (; o2 < r3.length; o2++) this.words[o2] = r3.words[o2];
            return this.length = Math.max(this.length, o2), r3 !== this && (this.negative = 1), this.strip();
          }, s.prototype.sub = function(e2) {
            return this.clone().isub(e2);
          };
          var p = function(e2, t4, r3) {
            var n2, i2, s2, o2 = e2.words, a2 = t4.words, l2 = r3.words, c2 = 0, u2 = 0 | o2[0], h2 = 8191 & u2, f2 = u2 >>> 13, d2 = 0 | o2[1], p2 = 8191 & d2, m2 = d2 >>> 13, b2 = 0 | o2[2], g2 = 8191 & b2, y2 = b2 >>> 13, v2 = 0 | o2[3], w2 = 8191 & v2, _2 = v2 >>> 13, x2 = 0 | o2[4], k2 = 8191 & x2, S2 = x2 >>> 13, M = 0 | o2[5], C2 = 8191 & M, T = M >>> 13, E = 0 | o2[6], A = 8191 & E, R = E >>> 13, O = 0 | o2[7], j = 8191 & O, I = O >>> 13, N = 0 | o2[8], P = 8191 & N, B = N >>> 13, D = 0 | o2[9], F = 8191 & D, L = D >>> 13, z = 0 | a2[0], U = 8191 & z, $ = z >>> 13, H = 0 | a2[1], V = 8191 & H, q = H >>> 13, W = 0 | a2[2], X = 8191 & W, K = W >>> 13, Y = 0 | a2[3], Z = 8191 & Y, G = Y >>> 13, J = 0 | a2[4], Q = 8191 & J, ee = J >>> 13, te = 0 | a2[5], re = 8191 & te, ne = te >>> 13, ie2 = 0 | a2[6], se = 8191 & ie2, oe = ie2 >>> 13, ae = 0 | a2[7], le = 8191 & ae, ce = ae >>> 13, ue = 0 | a2[8], he = 8191 & ue, fe = ue >>> 13, de = 0 | a2[9], pe = 8191 & de, me = de >>> 13;
            r3.negative = e2.negative ^ t4.negative, r3.length = 19;
            var be = (c2 + (n2 = Math.imul(h2, U)) | 0) + ((8191 & (i2 = (i2 = Math.imul(h2, $)) + Math.imul(f2, U) | 0)) << 13) | 0;
            c2 = ((s2 = Math.imul(f2, $)) + (i2 >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, n2 = Math.imul(p2, U), i2 = (i2 = Math.imul(p2, $)) + Math.imul(m2, U) | 0, s2 = Math.imul(m2, $);
            var ge = (c2 + (n2 = n2 + Math.imul(h2, V) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, q) | 0) + Math.imul(f2, V) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, q) | 0) + (i2 >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, n2 = Math.imul(g2, U), i2 = (i2 = Math.imul(g2, $)) + Math.imul(y2, U) | 0, s2 = Math.imul(y2, $), n2 = n2 + Math.imul(p2, V) | 0, i2 = (i2 = i2 + Math.imul(p2, q) | 0) + Math.imul(m2, V) | 0, s2 = s2 + Math.imul(m2, q) | 0;
            var ye = (c2 + (n2 = n2 + Math.imul(h2, X) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, K) | 0) + Math.imul(f2, X) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, K) | 0) + (i2 >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, n2 = Math.imul(w2, U), i2 = (i2 = Math.imul(w2, $)) + Math.imul(_2, U) | 0, s2 = Math.imul(_2, $), n2 = n2 + Math.imul(g2, V) | 0, i2 = (i2 = i2 + Math.imul(g2, q) | 0) + Math.imul(y2, V) | 0, s2 = s2 + Math.imul(y2, q) | 0, n2 = n2 + Math.imul(p2, X) | 0, i2 = (i2 = i2 + Math.imul(p2, K) | 0) + Math.imul(m2, X) | 0, s2 = s2 + Math.imul(m2, K) | 0;
            var ve = (c2 + (n2 = n2 + Math.imul(h2, Z) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, G) | 0) + Math.imul(f2, Z) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, G) | 0) + (i2 >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, n2 = Math.imul(k2, U), i2 = (i2 = Math.imul(k2, $)) + Math.imul(S2, U) | 0, s2 = Math.imul(S2, $), n2 = n2 + Math.imul(w2, V) | 0, i2 = (i2 = i2 + Math.imul(w2, q) | 0) + Math.imul(_2, V) | 0, s2 = s2 + Math.imul(_2, q) | 0, n2 = n2 + Math.imul(g2, X) | 0, i2 = (i2 = i2 + Math.imul(g2, K) | 0) + Math.imul(y2, X) | 0, s2 = s2 + Math.imul(y2, K) | 0, n2 = n2 + Math.imul(p2, Z) | 0, i2 = (i2 = i2 + Math.imul(p2, G) | 0) + Math.imul(m2, Z) | 0, s2 = s2 + Math.imul(m2, G) | 0;
            var we = (c2 + (n2 = n2 + Math.imul(h2, Q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ee) | 0) + Math.imul(f2, Q) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ee) | 0) + (i2 >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, n2 = Math.imul(C2, U), i2 = (i2 = Math.imul(C2, $)) + Math.imul(T, U) | 0, s2 = Math.imul(T, $), n2 = n2 + Math.imul(k2, V) | 0, i2 = (i2 = i2 + Math.imul(k2, q) | 0) + Math.imul(S2, V) | 0, s2 = s2 + Math.imul(S2, q) | 0, n2 = n2 + Math.imul(w2, X) | 0, i2 = (i2 = i2 + Math.imul(w2, K) | 0) + Math.imul(_2, X) | 0, s2 = s2 + Math.imul(_2, K) | 0, n2 = n2 + Math.imul(g2, Z) | 0, i2 = (i2 = i2 + Math.imul(g2, G) | 0) + Math.imul(y2, Z) | 0, s2 = s2 + Math.imul(y2, G) | 0, n2 = n2 + Math.imul(p2, Q) | 0, i2 = (i2 = i2 + Math.imul(p2, ee) | 0) + Math.imul(m2, Q) | 0, s2 = s2 + Math.imul(m2, ee) | 0;
            var _e = (c2 + (n2 = n2 + Math.imul(h2, re) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ne) | 0) + Math.imul(f2, re) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ne) | 0) + (i2 >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, n2 = Math.imul(A, U), i2 = (i2 = Math.imul(A, $)) + Math.imul(R, U) | 0, s2 = Math.imul(R, $), n2 = n2 + Math.imul(C2, V) | 0, i2 = (i2 = i2 + Math.imul(C2, q) | 0) + Math.imul(T, V) | 0, s2 = s2 + Math.imul(T, q) | 0, n2 = n2 + Math.imul(k2, X) | 0, i2 = (i2 = i2 + Math.imul(k2, K) | 0) + Math.imul(S2, X) | 0, s2 = s2 + Math.imul(S2, K) | 0, n2 = n2 + Math.imul(w2, Z) | 0, i2 = (i2 = i2 + Math.imul(w2, G) | 0) + Math.imul(_2, Z) | 0, s2 = s2 + Math.imul(_2, G) | 0, n2 = n2 + Math.imul(g2, Q) | 0, i2 = (i2 = i2 + Math.imul(g2, ee) | 0) + Math.imul(y2, Q) | 0, s2 = s2 + Math.imul(y2, ee) | 0, n2 = n2 + Math.imul(p2, re) | 0, i2 = (i2 = i2 + Math.imul(p2, ne) | 0) + Math.imul(m2, re) | 0, s2 = s2 + Math.imul(m2, ne) | 0;
            var xe = (c2 + (n2 = n2 + Math.imul(h2, se) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, oe) | 0) + Math.imul(f2, se) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, oe) | 0) + (i2 >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, n2 = Math.imul(j, U), i2 = (i2 = Math.imul(j, $)) + Math.imul(I, U) | 0, s2 = Math.imul(I, $), n2 = n2 + Math.imul(A, V) | 0, i2 = (i2 = i2 + Math.imul(A, q) | 0) + Math.imul(R, V) | 0, s2 = s2 + Math.imul(R, q) | 0, n2 = n2 + Math.imul(C2, X) | 0, i2 = (i2 = i2 + Math.imul(C2, K) | 0) + Math.imul(T, X) | 0, s2 = s2 + Math.imul(T, K) | 0, n2 = n2 + Math.imul(k2, Z) | 0, i2 = (i2 = i2 + Math.imul(k2, G) | 0) + Math.imul(S2, Z) | 0, s2 = s2 + Math.imul(S2, G) | 0, n2 = n2 + Math.imul(w2, Q) | 0, i2 = (i2 = i2 + Math.imul(w2, ee) | 0) + Math.imul(_2, Q) | 0, s2 = s2 + Math.imul(_2, ee) | 0, n2 = n2 + Math.imul(g2, re) | 0, i2 = (i2 = i2 + Math.imul(g2, ne) | 0) + Math.imul(y2, re) | 0, s2 = s2 + Math.imul(y2, ne) | 0, n2 = n2 + Math.imul(p2, se) | 0, i2 = (i2 = i2 + Math.imul(p2, oe) | 0) + Math.imul(m2, se) | 0, s2 = s2 + Math.imul(m2, oe) | 0;
            var ke = (c2 + (n2 = n2 + Math.imul(h2, le) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ce) | 0) + Math.imul(f2, le) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ce) | 0) + (i2 >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, n2 = Math.imul(P, U), i2 = (i2 = Math.imul(P, $)) + Math.imul(B, U) | 0, s2 = Math.imul(B, $), n2 = n2 + Math.imul(j, V) | 0, i2 = (i2 = i2 + Math.imul(j, q) | 0) + Math.imul(I, V) | 0, s2 = s2 + Math.imul(I, q) | 0, n2 = n2 + Math.imul(A, X) | 0, i2 = (i2 = i2 + Math.imul(A, K) | 0) + Math.imul(R, X) | 0, s2 = s2 + Math.imul(R, K) | 0, n2 = n2 + Math.imul(C2, Z) | 0, i2 = (i2 = i2 + Math.imul(C2, G) | 0) + Math.imul(T, Z) | 0, s2 = s2 + Math.imul(T, G) | 0, n2 = n2 + Math.imul(k2, Q) | 0, i2 = (i2 = i2 + Math.imul(k2, ee) | 0) + Math.imul(S2, Q) | 0, s2 = s2 + Math.imul(S2, ee) | 0, n2 = n2 + Math.imul(w2, re) | 0, i2 = (i2 = i2 + Math.imul(w2, ne) | 0) + Math.imul(_2, re) | 0, s2 = s2 + Math.imul(_2, ne) | 0, n2 = n2 + Math.imul(g2, se) | 0, i2 = (i2 = i2 + Math.imul(g2, oe) | 0) + Math.imul(y2, se) | 0, s2 = s2 + Math.imul(y2, oe) | 0, n2 = n2 + Math.imul(p2, le) | 0, i2 = (i2 = i2 + Math.imul(p2, ce) | 0) + Math.imul(m2, le) | 0, s2 = s2 + Math.imul(m2, ce) | 0;
            var Se = (c2 + (n2 = n2 + Math.imul(h2, he) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, fe) | 0) + Math.imul(f2, he) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, fe) | 0) + (i2 >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, n2 = Math.imul(F, U), i2 = (i2 = Math.imul(F, $)) + Math.imul(L, U) | 0, s2 = Math.imul(L, $), n2 = n2 + Math.imul(P, V) | 0, i2 = (i2 = i2 + Math.imul(P, q) | 0) + Math.imul(B, V) | 0, s2 = s2 + Math.imul(B, q) | 0, n2 = n2 + Math.imul(j, X) | 0, i2 = (i2 = i2 + Math.imul(j, K) | 0) + Math.imul(I, X) | 0, s2 = s2 + Math.imul(I, K) | 0, n2 = n2 + Math.imul(A, Z) | 0, i2 = (i2 = i2 + Math.imul(A, G) | 0) + Math.imul(R, Z) | 0, s2 = s2 + Math.imul(R, G) | 0, n2 = n2 + Math.imul(C2, Q) | 0, i2 = (i2 = i2 + Math.imul(C2, ee) | 0) + Math.imul(T, Q) | 0, s2 = s2 + Math.imul(T, ee) | 0, n2 = n2 + Math.imul(k2, re) | 0, i2 = (i2 = i2 + Math.imul(k2, ne) | 0) + Math.imul(S2, re) | 0, s2 = s2 + Math.imul(S2, ne) | 0, n2 = n2 + Math.imul(w2, se) | 0, i2 = (i2 = i2 + Math.imul(w2, oe) | 0) + Math.imul(_2, se) | 0, s2 = s2 + Math.imul(_2, oe) | 0, n2 = n2 + Math.imul(g2, le) | 0, i2 = (i2 = i2 + Math.imul(g2, ce) | 0) + Math.imul(y2, le) | 0, s2 = s2 + Math.imul(y2, ce) | 0, n2 = n2 + Math.imul(p2, he) | 0, i2 = (i2 = i2 + Math.imul(p2, fe) | 0) + Math.imul(m2, he) | 0, s2 = s2 + Math.imul(m2, fe) | 0;
            var Me = (c2 + (n2 = n2 + Math.imul(h2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, me) | 0) + Math.imul(f2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, me) | 0) + (i2 >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, n2 = Math.imul(F, V), i2 = (i2 = Math.imul(F, q)) + Math.imul(L, V) | 0, s2 = Math.imul(L, q), n2 = n2 + Math.imul(P, X) | 0, i2 = (i2 = i2 + Math.imul(P, K) | 0) + Math.imul(B, X) | 0, s2 = s2 + Math.imul(B, K) | 0, n2 = n2 + Math.imul(j, Z) | 0, i2 = (i2 = i2 + Math.imul(j, G) | 0) + Math.imul(I, Z) | 0, s2 = s2 + Math.imul(I, G) | 0, n2 = n2 + Math.imul(A, Q) | 0, i2 = (i2 = i2 + Math.imul(A, ee) | 0) + Math.imul(R, Q) | 0, s2 = s2 + Math.imul(R, ee) | 0, n2 = n2 + Math.imul(C2, re) | 0, i2 = (i2 = i2 + Math.imul(C2, ne) | 0) + Math.imul(T, re) | 0, s2 = s2 + Math.imul(T, ne) | 0, n2 = n2 + Math.imul(k2, se) | 0, i2 = (i2 = i2 + Math.imul(k2, oe) | 0) + Math.imul(S2, se) | 0, s2 = s2 + Math.imul(S2, oe) | 0, n2 = n2 + Math.imul(w2, le) | 0, i2 = (i2 = i2 + Math.imul(w2, ce) | 0) + Math.imul(_2, le) | 0, s2 = s2 + Math.imul(_2, ce) | 0, n2 = n2 + Math.imul(g2, he) | 0, i2 = (i2 = i2 + Math.imul(g2, fe) | 0) + Math.imul(y2, he) | 0, s2 = s2 + Math.imul(y2, fe) | 0;
            var Ce = (c2 + (n2 = n2 + Math.imul(p2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(p2, me) | 0) + Math.imul(m2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(m2, me) | 0) + (i2 >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, n2 = Math.imul(F, X), i2 = (i2 = Math.imul(F, K)) + Math.imul(L, X) | 0, s2 = Math.imul(L, K), n2 = n2 + Math.imul(P, Z) | 0, i2 = (i2 = i2 + Math.imul(P, G) | 0) + Math.imul(B, Z) | 0, s2 = s2 + Math.imul(B, G) | 0, n2 = n2 + Math.imul(j, Q) | 0, i2 = (i2 = i2 + Math.imul(j, ee) | 0) + Math.imul(I, Q) | 0, s2 = s2 + Math.imul(I, ee) | 0, n2 = n2 + Math.imul(A, re) | 0, i2 = (i2 = i2 + Math.imul(A, ne) | 0) + Math.imul(R, re) | 0, s2 = s2 + Math.imul(R, ne) | 0, n2 = n2 + Math.imul(C2, se) | 0, i2 = (i2 = i2 + Math.imul(C2, oe) | 0) + Math.imul(T, se) | 0, s2 = s2 + Math.imul(T, oe) | 0, n2 = n2 + Math.imul(k2, le) | 0, i2 = (i2 = i2 + Math.imul(k2, ce) | 0) + Math.imul(S2, le) | 0, s2 = s2 + Math.imul(S2, ce) | 0, n2 = n2 + Math.imul(w2, he) | 0, i2 = (i2 = i2 + Math.imul(w2, fe) | 0) + Math.imul(_2, he) | 0, s2 = s2 + Math.imul(_2, fe) | 0;
            var Te = (c2 + (n2 = n2 + Math.imul(g2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(g2, me) | 0) + Math.imul(y2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(y2, me) | 0) + (i2 >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, n2 = Math.imul(F, Z), i2 = (i2 = Math.imul(F, G)) + Math.imul(L, Z) | 0, s2 = Math.imul(L, G), n2 = n2 + Math.imul(P, Q) | 0, i2 = (i2 = i2 + Math.imul(P, ee) | 0) + Math.imul(B, Q) | 0, s2 = s2 + Math.imul(B, ee) | 0, n2 = n2 + Math.imul(j, re) | 0, i2 = (i2 = i2 + Math.imul(j, ne) | 0) + Math.imul(I, re) | 0, s2 = s2 + Math.imul(I, ne) | 0, n2 = n2 + Math.imul(A, se) | 0, i2 = (i2 = i2 + Math.imul(A, oe) | 0) + Math.imul(R, se) | 0, s2 = s2 + Math.imul(R, oe) | 0, n2 = n2 + Math.imul(C2, le) | 0, i2 = (i2 = i2 + Math.imul(C2, ce) | 0) + Math.imul(T, le) | 0, s2 = s2 + Math.imul(T, ce) | 0, n2 = n2 + Math.imul(k2, he) | 0, i2 = (i2 = i2 + Math.imul(k2, fe) | 0) + Math.imul(S2, he) | 0, s2 = s2 + Math.imul(S2, fe) | 0;
            var Ee = (c2 + (n2 = n2 + Math.imul(w2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(w2, me) | 0) + Math.imul(_2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(_2, me) | 0) + (i2 >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, n2 = Math.imul(F, Q), i2 = (i2 = Math.imul(F, ee)) + Math.imul(L, Q) | 0, s2 = Math.imul(L, ee), n2 = n2 + Math.imul(P, re) | 0, i2 = (i2 = i2 + Math.imul(P, ne) | 0) + Math.imul(B, re) | 0, s2 = s2 + Math.imul(B, ne) | 0, n2 = n2 + Math.imul(j, se) | 0, i2 = (i2 = i2 + Math.imul(j, oe) | 0) + Math.imul(I, se) | 0, s2 = s2 + Math.imul(I, oe) | 0, n2 = n2 + Math.imul(A, le) | 0, i2 = (i2 = i2 + Math.imul(A, ce) | 0) + Math.imul(R, le) | 0, s2 = s2 + Math.imul(R, ce) | 0, n2 = n2 + Math.imul(C2, he) | 0, i2 = (i2 = i2 + Math.imul(C2, fe) | 0) + Math.imul(T, he) | 0, s2 = s2 + Math.imul(T, fe) | 0;
            var Ae = (c2 + (n2 = n2 + Math.imul(k2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(k2, me) | 0) + Math.imul(S2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(S2, me) | 0) + (i2 >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, n2 = Math.imul(F, re), i2 = (i2 = Math.imul(F, ne)) + Math.imul(L, re) | 0, s2 = Math.imul(L, ne), n2 = n2 + Math.imul(P, se) | 0, i2 = (i2 = i2 + Math.imul(P, oe) | 0) + Math.imul(B, se) | 0, s2 = s2 + Math.imul(B, oe) | 0, n2 = n2 + Math.imul(j, le) | 0, i2 = (i2 = i2 + Math.imul(j, ce) | 0) + Math.imul(I, le) | 0, s2 = s2 + Math.imul(I, ce) | 0, n2 = n2 + Math.imul(A, he) | 0, i2 = (i2 = i2 + Math.imul(A, fe) | 0) + Math.imul(R, he) | 0, s2 = s2 + Math.imul(R, fe) | 0;
            var Re = (c2 + (n2 = n2 + Math.imul(C2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(C2, me) | 0) + Math.imul(T, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(T, me) | 0) + (i2 >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, n2 = Math.imul(F, se), i2 = (i2 = Math.imul(F, oe)) + Math.imul(L, se) | 0, s2 = Math.imul(L, oe), n2 = n2 + Math.imul(P, le) | 0, i2 = (i2 = i2 + Math.imul(P, ce) | 0) + Math.imul(B, le) | 0, s2 = s2 + Math.imul(B, ce) | 0, n2 = n2 + Math.imul(j, he) | 0, i2 = (i2 = i2 + Math.imul(j, fe) | 0) + Math.imul(I, he) | 0, s2 = s2 + Math.imul(I, fe) | 0;
            var Oe = (c2 + (n2 = n2 + Math.imul(A, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(A, me) | 0) + Math.imul(R, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(R, me) | 0) + (i2 >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, n2 = Math.imul(F, le), i2 = (i2 = Math.imul(F, ce)) + Math.imul(L, le) | 0, s2 = Math.imul(L, ce), n2 = n2 + Math.imul(P, he) | 0, i2 = (i2 = i2 + Math.imul(P, fe) | 0) + Math.imul(B, he) | 0, s2 = s2 + Math.imul(B, fe) | 0;
            var je = (c2 + (n2 = n2 + Math.imul(j, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(j, me) | 0) + Math.imul(I, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(I, me) | 0) + (i2 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, n2 = Math.imul(F, he), i2 = (i2 = Math.imul(F, fe)) + Math.imul(L, he) | 0, s2 = Math.imul(L, fe);
            var Ie = (c2 + (n2 = n2 + Math.imul(P, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(P, me) | 0) + Math.imul(B, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(B, me) | 0) + (i2 >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863;
            var Ne = (c2 + (n2 = Math.imul(F, pe)) | 0) + ((8191 & (i2 = (i2 = Math.imul(F, me)) + Math.imul(L, pe) | 0)) << 13) | 0;
            return c2 = ((s2 = Math.imul(L, me)) + (i2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, l2[0] = be, l2[1] = ge, l2[2] = ye, l2[3] = ve, l2[4] = we, l2[5] = _e, l2[6] = xe, l2[7] = ke, l2[8] = Se, l2[9] = Me, l2[10] = Ce, l2[11] = Te, l2[12] = Ee, l2[13] = Ae, l2[14] = Re, l2[15] = Oe, l2[16] = je, l2[17] = Ie, l2[18] = Ne, 0 !== c2 && (l2[19] = c2, r3.length++), r3;
          };
          function m(e2, t4, r3) {
            return new b().mulp(e2, t4, r3);
          }
          function b(e2, t4) {
            this.x = e2, this.y = t4;
          }
          Math.imul || (p = d), s.prototype.mulTo = function(e2, t4) {
            var r3 = this.length + e2.length;
            return 10 === this.length && 10 === e2.length ? p(this, e2, t4) : r3 < 63 ? d(this, e2, t4) : r3 < 1024 ? (function(e3, t5, r4) {
              r4.negative = t5.negative ^ e3.negative, r4.length = e3.length + t5.length;
              for (var n2 = 0, i2 = 0, s2 = 0; s2 < r4.length - 1; s2++) {
                var o2 = i2;
                i2 = 0;
                for (var a2 = 67108863 & n2, l2 = Math.min(s2, t5.length - 1), c2 = Math.max(0, s2 - e3.length + 1); c2 <= l2; c2++) {
                  var u2 = s2 - c2, h2 = (0 | e3.words[u2]) * (0 | t5.words[c2]), f2 = 67108863 & h2;
                  a2 = 67108863 & (f2 = f2 + a2 | 0), i2 += (o2 = (o2 = o2 + (h2 / 67108864 | 0) | 0) + (f2 >>> 26) | 0) >>> 26, o2 &= 67108863;
                }
                r4.words[s2] = a2, n2 = o2, o2 = i2;
              }
              return 0 !== n2 ? r4.words[s2] = n2 : r4.length--, r4.strip();
            })(this, e2, t4) : m(this, e2, t4);
          }, b.prototype.makeRBT = function(e2) {
            for (var t4 = new Array(e2), r3 = s.prototype._countBits(e2) - 1, n2 = 0; n2 < e2; n2++) t4[n2] = this.revBin(n2, r3, e2);
            return t4;
          }, b.prototype.revBin = function(e2, t4, r3) {
            if (0 === e2 || e2 === r3 - 1) return e2;
            for (var n2 = 0, i2 = 0; i2 < t4; i2++) n2 |= (1 & e2) << t4 - i2 - 1, e2 >>= 1;
            return n2;
          }, b.prototype.permute = function(e2, t4, r3, n2, i2, s2) {
            for (var o2 = 0; o2 < s2; o2++) n2[o2] = t4[e2[o2]], i2[o2] = r3[e2[o2]];
          }, b.prototype.transform = function(e2, t4, r3, n2, i2, s2) {
            this.permute(s2, e2, t4, r3, n2, i2);
            for (var o2 = 1; o2 < i2; o2 <<= 1) for (var a2 = o2 << 1, l2 = Math.cos(2 * Math.PI / a2), c2 = Math.sin(2 * Math.PI / a2), u2 = 0; u2 < i2; u2 += a2) for (var h2 = l2, f2 = c2, d2 = 0; d2 < o2; d2++) {
              var p2 = r3[u2 + d2], m2 = n2[u2 + d2], b2 = r3[u2 + d2 + o2], g2 = n2[u2 + d2 + o2], y2 = h2 * b2 - f2 * g2;
              g2 = h2 * g2 + f2 * b2, b2 = y2, r3[u2 + d2] = p2 + b2, n2[u2 + d2] = m2 + g2, r3[u2 + d2 + o2] = p2 - b2, n2[u2 + d2 + o2] = m2 - g2, d2 !== a2 && (y2 = l2 * h2 - c2 * f2, f2 = l2 * f2 + c2 * h2, h2 = y2);
            }
          }, b.prototype.guessLen13b = function(e2, t4) {
            var r3 = 1 | Math.max(t4, e2), n2 = 1 & r3, i2 = 0;
            for (r3 = r3 / 2 | 0; r3; r3 >>>= 1) i2++;
            return 1 << i2 + 1 + n2;
          }, b.prototype.conjugate = function(e2, t4, r3) {
            if (!(r3 <= 1)) for (var n2 = 0; n2 < r3 / 2; n2++) {
              var i2 = e2[n2];
              e2[n2] = e2[r3 - n2 - 1], e2[r3 - n2 - 1] = i2, i2 = t4[n2], t4[n2] = -t4[r3 - n2 - 1], t4[r3 - n2 - 1] = -i2;
            }
          }, b.prototype.normalize13b = function(e2, t4) {
            for (var r3 = 0, n2 = 0; n2 < t4 / 2; n2++) {
              var i2 = 8192 * Math.round(e2[2 * n2 + 1] / t4) + Math.round(e2[2 * n2] / t4) + r3;
              e2[n2] = 67108863 & i2, r3 = i2 < 67108864 ? 0 : i2 / 67108864 | 0;
            }
            return e2;
          }, b.prototype.convert13b = function(e2, t4, r3, i2) {
            for (var s2 = 0, o2 = 0; o2 < t4; o2++) s2 += 0 | e2[o2], r3[2 * o2] = 8191 & s2, s2 >>>= 13, r3[2 * o2 + 1] = 8191 & s2, s2 >>>= 13;
            for (o2 = 2 * t4; o2 < i2; ++o2) r3[o2] = 0;
            n(0 === s2), n(0 == (-8192 & s2));
          }, b.prototype.stub = function(e2) {
            for (var t4 = new Array(e2), r3 = 0; r3 < e2; r3++) t4[r3] = 0;
            return t4;
          }, b.prototype.mulp = function(e2, t4, r3) {
            var n2 = 2 * this.guessLen13b(e2.length, t4.length), i2 = this.makeRBT(n2), s2 = this.stub(n2), o2 = new Array(n2), a2 = new Array(n2), l2 = new Array(n2), c2 = new Array(n2), u2 = new Array(n2), h2 = new Array(n2), f2 = r3.words;
            f2.length = n2, this.convert13b(e2.words, e2.length, o2, n2), this.convert13b(t4.words, t4.length, c2, n2), this.transform(o2, s2, a2, l2, n2, i2), this.transform(c2, s2, u2, h2, n2, i2);
            for (var d2 = 0; d2 < n2; d2++) {
              var p2 = a2[d2] * u2[d2] - l2[d2] * h2[d2];
              l2[d2] = a2[d2] * h2[d2] + l2[d2] * u2[d2], a2[d2] = p2;
            }
            return this.conjugate(a2, l2, n2), this.transform(a2, l2, f2, s2, n2, i2), this.conjugate(f2, s2, n2), this.normalize13b(f2, n2), r3.negative = e2.negative ^ t4.negative, r3.length = e2.length + t4.length, r3.strip();
          }, s.prototype.mul = function(e2) {
            var t4 = new s(null);
            return t4.words = new Array(this.length + e2.length), this.mulTo(e2, t4);
          }, s.prototype.mulf = function(e2) {
            var t4 = new s(null);
            return t4.words = new Array(this.length + e2.length), m(this, e2, t4);
          }, s.prototype.imul = function(e2) {
            return this.clone().mulTo(e2, this);
          }, s.prototype.imuln = function(e2) {
            n("number" == typeof e2), n(e2 < 67108864);
            for (var t4 = 0, r3 = 0; r3 < this.length; r3++) {
              var i2 = (0 | this.words[r3]) * e2, s2 = (67108863 & i2) + (67108863 & t4);
              t4 >>= 26, t4 += i2 / 67108864 | 0, t4 += s2 >>> 26, this.words[r3] = 67108863 & s2;
            }
            return 0 !== t4 && (this.words[r3] = t4, this.length++), this;
          }, s.prototype.muln = function(e2) {
            return this.clone().imuln(e2);
          }, s.prototype.sqr = function() {
            return this.mul(this);
          }, s.prototype.isqr = function() {
            return this.imul(this.clone());
          }, s.prototype.pow = function(e2) {
            var t4 = (function(e3) {
              for (var t5 = new Array(e3.bitLength()), r4 = 0; r4 < t5.length; r4++) {
                var n3 = r4 / 26 | 0, i3 = r4 % 26;
                t5[r4] = (e3.words[n3] & 1 << i3) >>> i3;
              }
              return t5;
            })(e2);
            if (0 === t4.length) return new s(1);
            for (var r3 = this, n2 = 0; n2 < t4.length && 0 === t4[n2]; n2++, r3 = r3.sqr()) ;
            if (++n2 < t4.length) for (var i2 = r3.sqr(); n2 < t4.length; n2++, i2 = i2.sqr()) 0 !== t4[n2] && (r3 = r3.mul(i2));
            return r3;
          }, s.prototype.iushln = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4, r3 = e2 % 26, i2 = (e2 - r3) / 26, s2 = 67108863 >>> 26 - r3 << 26 - r3;
            if (0 !== r3) {
              var o2 = 0;
              for (t4 = 0; t4 < this.length; t4++) {
                var a2 = this.words[t4] & s2, l2 = (0 | this.words[t4]) - a2 << r3;
                this.words[t4] = l2 | o2, o2 = a2 >>> 26 - r3;
              }
              o2 && (this.words[t4] = o2, this.length++);
            }
            if (0 !== i2) {
              for (t4 = this.length - 1; t4 >= 0; t4--) this.words[t4 + i2] = this.words[t4];
              for (t4 = 0; t4 < i2; t4++) this.words[t4] = 0;
              this.length += i2;
            }
            return this.strip();
          }, s.prototype.ishln = function(e2) {
            return n(0 === this.negative), this.iushln(e2);
          }, s.prototype.iushrn = function(e2, t4, r3) {
            var i2;
            n("number" == typeof e2 && e2 >= 0), i2 = t4 ? (t4 - t4 % 26) / 26 : 0;
            var s2 = e2 % 26, o2 = Math.min((e2 - s2) / 26, this.length), a2 = 67108863 ^ 67108863 >>> s2 << s2, l2 = r3;
            if (i2 -= o2, i2 = Math.max(0, i2), l2) {
              for (var c2 = 0; c2 < o2; c2++) l2.words[c2] = this.words[c2];
              l2.length = o2;
            }
            if (0 === o2) ;
            else if (this.length > o2) for (this.length -= o2, c2 = 0; c2 < this.length; c2++) this.words[c2] = this.words[c2 + o2];
            else this.words[0] = 0, this.length = 1;
            var u2 = 0;
            for (c2 = this.length - 1; c2 >= 0 && (0 !== u2 || c2 >= i2); c2--) {
              var h2 = 0 | this.words[c2];
              this.words[c2] = u2 << 26 - s2 | h2 >>> s2, u2 = h2 & a2;
            }
            return l2 && 0 !== u2 && (l2.words[l2.length++] = u2), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
          }, s.prototype.ishrn = function(e2, t4, r3) {
            return n(0 === this.negative), this.iushrn(e2, t4, r3);
          }, s.prototype.shln = function(e2) {
            return this.clone().ishln(e2);
          }, s.prototype.ushln = function(e2) {
            return this.clone().iushln(e2);
          }, s.prototype.shrn = function(e2) {
            return this.clone().ishrn(e2);
          }, s.prototype.ushrn = function(e2) {
            return this.clone().iushrn(e2);
          }, s.prototype.testn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26, i2 = 1 << t4;
            return !(this.length <= r3) && !!(this.words[r3] & i2);
          }, s.prototype.imaskn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26;
            if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r3) return this;
            if (0 !== t4 && r3++, this.length = Math.min(r3, this.length), 0 !== t4) {
              var i2 = 67108863 ^ 67108863 >>> t4 << t4;
              this.words[this.length - 1] &= i2;
            }
            return this.strip();
          }, s.prototype.maskn = function(e2) {
            return this.clone().imaskn(e2);
          }, s.prototype.iaddn = function(e2) {
            return n("number" == typeof e2), n(e2 < 67108864), e2 < 0 ? this.isubn(-e2) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < e2 ? (this.words[0] = e2 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e2), this.negative = 1, this) : this._iaddn(e2);
          }, s.prototype._iaddn = function(e2) {
            this.words[0] += e2;
            for (var t4 = 0; t4 < this.length && this.words[t4] >= 67108864; t4++) this.words[t4] -= 67108864, t4 === this.length - 1 ? this.words[t4 + 1] = 1 : this.words[t4 + 1]++;
            return this.length = Math.max(this.length, t4 + 1), this;
          }, s.prototype.isubn = function(e2) {
            if (n("number" == typeof e2), n(e2 < 67108864), e2 < 0) return this.iaddn(-e2);
            if (0 !== this.negative) return this.negative = 0, this.iaddn(e2), this.negative = 1, this;
            if (this.words[0] -= e2, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else for (var t4 = 0; t4 < this.length && this.words[t4] < 0; t4++) this.words[t4] += 67108864, this.words[t4 + 1] -= 1;
            return this.strip();
          }, s.prototype.addn = function(e2) {
            return this.clone().iaddn(e2);
          }, s.prototype.subn = function(e2) {
            return this.clone().isubn(e2);
          }, s.prototype.iabs = function() {
            return this.negative = 0, this;
          }, s.prototype.abs = function() {
            return this.clone().iabs();
          }, s.prototype._ishlnsubmul = function(e2, t4, r3) {
            var i2, s2, o2 = e2.length + r3;
            this._expand(o2);
            var a2 = 0;
            for (i2 = 0; i2 < e2.length; i2++) {
              s2 = (0 | this.words[i2 + r3]) + a2;
              var l2 = (0 | e2.words[i2]) * t4;
              a2 = ((s2 -= 67108863 & l2) >> 26) - (l2 / 67108864 | 0), this.words[i2 + r3] = 67108863 & s2;
            }
            for (; i2 < this.length - r3; i2++) a2 = (s2 = (0 | this.words[i2 + r3]) + a2) >> 26, this.words[i2 + r3] = 67108863 & s2;
            if (0 === a2) return this.strip();
            for (n(-1 === a2), a2 = 0, i2 = 0; i2 < this.length; i2++) a2 = (s2 = -(0 | this.words[i2]) + a2) >> 26, this.words[i2] = 67108863 & s2;
            return this.negative = 1, this.strip();
          }, s.prototype._wordDiv = function(e2, t4) {
            var r3 = (this.length, e2.length), n2 = this.clone(), i2 = e2, o2 = 0 | i2.words[i2.length - 1];
            0 !== (r3 = 26 - this._countBits(o2)) && (i2 = i2.ushln(r3), n2.iushln(r3), o2 = 0 | i2.words[i2.length - 1]);
            var a2, l2 = n2.length - i2.length;
            if ("mod" !== t4) {
              (a2 = new s(null)).length = l2 + 1, a2.words = new Array(a2.length);
              for (var c2 = 0; c2 < a2.length; c2++) a2.words[c2] = 0;
            }
            var u2 = n2.clone()._ishlnsubmul(i2, 1, l2);
            0 === u2.negative && (n2 = u2, a2 && (a2.words[l2] = 1));
            for (var h2 = l2 - 1; h2 >= 0; h2--) {
              var f2 = 67108864 * (0 | n2.words[i2.length + h2]) + (0 | n2.words[i2.length + h2 - 1]);
              for (f2 = Math.min(f2 / o2 | 0, 67108863), n2._ishlnsubmul(i2, f2, h2); 0 !== n2.negative; ) f2--, n2.negative = 0, n2._ishlnsubmul(i2, 1, h2), n2.isZero() || (n2.negative ^= 1);
              a2 && (a2.words[h2] = f2);
            }
            return a2 && a2.strip(), n2.strip(), "div" !== t4 && 0 !== r3 && n2.iushrn(r3), { div: a2 || null, mod: n2 };
          }, s.prototype.divmod = function(e2, t4, r3) {
            return n(!e2.isZero()), this.isZero() ? { div: new s(0), mod: new s(0) } : 0 !== this.negative && 0 === e2.negative ? (a2 = this.neg().divmod(e2, t4), "mod" !== t4 && (i2 = a2.div.neg()), "div" !== t4 && (o2 = a2.mod.neg(), r3 && 0 !== o2.negative && o2.iadd(e2)), { div: i2, mod: o2 }) : 0 === this.negative && 0 !== e2.negative ? (a2 = this.divmod(e2.neg(), t4), "mod" !== t4 && (i2 = a2.div.neg()), { div: i2, mod: a2.mod }) : 0 != (this.negative & e2.negative) ? (a2 = this.neg().divmod(e2.neg(), t4), "div" !== t4 && (o2 = a2.mod.neg(), r3 && 0 !== o2.negative && o2.isub(e2)), { div: a2.div, mod: o2 }) : e2.length > this.length || this.cmp(e2) < 0 ? { div: new s(0), mod: this } : 1 === e2.length ? "div" === t4 ? { div: this.divn(e2.words[0]), mod: null } : "mod" === t4 ? { div: null, mod: new s(this.modn(e2.words[0])) } : { div: this.divn(e2.words[0]), mod: new s(this.modn(e2.words[0])) } : this._wordDiv(e2, t4);
            var i2, o2, a2;
          }, s.prototype.div = function(e2) {
            return this.divmod(e2, "div", false).div;
          }, s.prototype.mod = function(e2) {
            return this.divmod(e2, "mod", false).mod;
          }, s.prototype.umod = function(e2) {
            return this.divmod(e2, "mod", true).mod;
          }, s.prototype.divRound = function(e2) {
            var t4 = this.divmod(e2);
            if (t4.mod.isZero()) return t4.div;
            var r3 = 0 !== t4.div.negative ? t4.mod.isub(e2) : t4.mod, n2 = e2.ushrn(1), i2 = e2.andln(1), s2 = r3.cmp(n2);
            return s2 < 0 || 1 === i2 && 0 === s2 ? t4.div : 0 !== t4.div.negative ? t4.div.isubn(1) : t4.div.iaddn(1);
          }, s.prototype.modn = function(e2) {
            n(e2 <= 67108863);
            for (var t4 = (1 << 26) % e2, r3 = 0, i2 = this.length - 1; i2 >= 0; i2--) r3 = (t4 * r3 + (0 | this.words[i2])) % e2;
            return r3;
          }, s.prototype.idivn = function(e2) {
            n(e2 <= 67108863);
            for (var t4 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
              var i2 = (0 | this.words[r3]) + 67108864 * t4;
              this.words[r3] = i2 / e2 | 0, t4 = i2 % e2;
            }
            return this.strip();
          }, s.prototype.divn = function(e2) {
            return this.clone().idivn(e2);
          }, s.prototype.egcd = function(e2) {
            n(0 === e2.negative), n(!e2.isZero());
            var t4 = this, r3 = e2.clone();
            t4 = 0 !== t4.negative ? t4.umod(e2) : t4.clone();
            for (var i2 = new s(1), o2 = new s(0), a2 = new s(0), l2 = new s(1), c2 = 0; t4.isEven() && r3.isEven(); ) t4.iushrn(1), r3.iushrn(1), ++c2;
            for (var u2 = r3.clone(), h2 = t4.clone(); !t4.isZero(); ) {
              for (var f2 = 0, d2 = 1; 0 == (t4.words[0] & d2) && f2 < 26; ++f2, d2 <<= 1) ;
              if (f2 > 0) for (t4.iushrn(f2); f2-- > 0; ) (i2.isOdd() || o2.isOdd()) && (i2.iadd(u2), o2.isub(h2)), i2.iushrn(1), o2.iushrn(1);
              for (var p2 = 0, m2 = 1; 0 == (r3.words[0] & m2) && p2 < 26; ++p2, m2 <<= 1) ;
              if (p2 > 0) for (r3.iushrn(p2); p2-- > 0; ) (a2.isOdd() || l2.isOdd()) && (a2.iadd(u2), l2.isub(h2)), a2.iushrn(1), l2.iushrn(1);
              t4.cmp(r3) >= 0 ? (t4.isub(r3), i2.isub(a2), o2.isub(l2)) : (r3.isub(t4), a2.isub(i2), l2.isub(o2));
            }
            return { a: a2, b: l2, gcd: r3.iushln(c2) };
          }, s.prototype._invmp = function(e2) {
            n(0 === e2.negative), n(!e2.isZero());
            var t4 = this, r3 = e2.clone();
            t4 = 0 !== t4.negative ? t4.umod(e2) : t4.clone();
            for (var i2, o2 = new s(1), a2 = new s(0), l2 = r3.clone(); t4.cmpn(1) > 0 && r3.cmpn(1) > 0; ) {
              for (var c2 = 0, u2 = 1; 0 == (t4.words[0] & u2) && c2 < 26; ++c2, u2 <<= 1) ;
              if (c2 > 0) for (t4.iushrn(c2); c2-- > 0; ) o2.isOdd() && o2.iadd(l2), o2.iushrn(1);
              for (var h2 = 0, f2 = 1; 0 == (r3.words[0] & f2) && h2 < 26; ++h2, f2 <<= 1) ;
              if (h2 > 0) for (r3.iushrn(h2); h2-- > 0; ) a2.isOdd() && a2.iadd(l2), a2.iushrn(1);
              t4.cmp(r3) >= 0 ? (t4.isub(r3), o2.isub(a2)) : (r3.isub(t4), a2.isub(o2));
            }
            return (i2 = 0 === t4.cmpn(1) ? o2 : a2).cmpn(0) < 0 && i2.iadd(e2), i2;
          }, s.prototype.gcd = function(e2) {
            if (this.isZero()) return e2.abs();
            if (e2.isZero()) return this.abs();
            var t4 = this.clone(), r3 = e2.clone();
            t4.negative = 0, r3.negative = 0;
            for (var n2 = 0; t4.isEven() && r3.isEven(); n2++) t4.iushrn(1), r3.iushrn(1);
            for (; ; ) {
              for (; t4.isEven(); ) t4.iushrn(1);
              for (; r3.isEven(); ) r3.iushrn(1);
              var i2 = t4.cmp(r3);
              if (i2 < 0) {
                var s2 = t4;
                t4 = r3, r3 = s2;
              } else if (0 === i2 || 0 === r3.cmpn(1)) break;
              t4.isub(r3);
            }
            return r3.iushln(n2);
          }, s.prototype.invm = function(e2) {
            return this.egcd(e2).a.umod(e2);
          }, s.prototype.isEven = function() {
            return 0 == (1 & this.words[0]);
          }, s.prototype.isOdd = function() {
            return 1 == (1 & this.words[0]);
          }, s.prototype.andln = function(e2) {
            return this.words[0] & e2;
          }, s.prototype.bincn = function(e2) {
            n("number" == typeof e2);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26, i2 = 1 << t4;
            if (this.length <= r3) return this._expand(r3 + 1), this.words[r3] |= i2, this;
            for (var s2 = i2, o2 = r3; 0 !== s2 && o2 < this.length; o2++) {
              var a2 = 0 | this.words[o2];
              s2 = (a2 += s2) >>> 26, a2 &= 67108863, this.words[o2] = a2;
            }
            return 0 !== s2 && (this.words[o2] = s2, this.length++), this;
          }, s.prototype.isZero = function() {
            return 1 === this.length && 0 === this.words[0];
          }, s.prototype.cmpn = function(e2) {
            var t4, r3 = e2 < 0;
            if (0 !== this.negative && !r3) return -1;
            if (0 === this.negative && r3) return 1;
            if (this.strip(), this.length > 1) t4 = 1;
            else {
              r3 && (e2 = -e2), n(e2 <= 67108863, "Number is too big");
              var i2 = 0 | this.words[0];
              t4 = i2 === e2 ? 0 : i2 < e2 ? -1 : 1;
            }
            return 0 !== this.negative ? 0 | -t4 : t4;
          }, s.prototype.cmp = function(e2) {
            if (0 !== this.negative && 0 === e2.negative) return -1;
            if (0 === this.negative && 0 !== e2.negative) return 1;
            var t4 = this.ucmp(e2);
            return 0 !== this.negative ? 0 | -t4 : t4;
          }, s.prototype.ucmp = function(e2) {
            if (this.length > e2.length) return 1;
            if (this.length < e2.length) return -1;
            for (var t4 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
              var n2 = 0 | this.words[r3], i2 = 0 | e2.words[r3];
              if (n2 !== i2) {
                n2 < i2 ? t4 = -1 : n2 > i2 && (t4 = 1);
                break;
              }
            }
            return t4;
          }, s.prototype.gtn = function(e2) {
            return 1 === this.cmpn(e2);
          }, s.prototype.gt = function(e2) {
            return 1 === this.cmp(e2);
          }, s.prototype.gten = function(e2) {
            return this.cmpn(e2) >= 0;
          }, s.prototype.gte = function(e2) {
            return this.cmp(e2) >= 0;
          }, s.prototype.ltn = function(e2) {
            return -1 === this.cmpn(e2);
          }, s.prototype.lt = function(e2) {
            return -1 === this.cmp(e2);
          }, s.prototype.lten = function(e2) {
            return this.cmpn(e2) <= 0;
          }, s.prototype.lte = function(e2) {
            return this.cmp(e2) <= 0;
          }, s.prototype.eqn = function(e2) {
            return 0 === this.cmpn(e2);
          }, s.prototype.eq = function(e2) {
            return 0 === this.cmp(e2);
          }, s.red = function(e2) {
            return new k(e2);
          }, s.prototype.toRed = function(e2) {
            return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), e2.convertTo(this)._forceRed(e2);
          }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
          }, s.prototype._forceRed = function(e2) {
            return this.red = e2, this;
          }, s.prototype.forceRed = function(e2) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(e2);
          }, s.prototype.redAdd = function(e2) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, e2);
          }, s.prototype.redIAdd = function(e2) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e2);
          }, s.prototype.redSub = function(e2) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, e2);
          }, s.prototype.redISub = function(e2) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, e2);
          }, s.prototype.redShl = function(e2) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, e2);
          }, s.prototype.redMul = function(e2) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e2), this.red.mul(this, e2);
          }, s.prototype.redIMul = function(e2) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e2), this.red.imul(this, e2);
          }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
          }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
          }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
          }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
          }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
          }, s.prototype.redPow = function(e2) {
            return n(this.red && !e2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e2);
          };
          var g = { k256: null, p224: null, p192: null, p25519: null };
          function y(e2, t4) {
            this.name = e2, this.p = new s(t4, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
          }
          function v() {
            y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
          }
          function w() {
            y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
          }
          function _() {
            y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
          }
          function x() {
            y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
          }
          function k(e2) {
            if ("string" == typeof e2) {
              var t4 = s._prime(e2);
              this.m = t4.p, this.prime = t4;
            } else n(e2.gtn(1), "modulus must be greater than 1"), this.m = e2, this.prime = null;
          }
          function S(e2) {
            k.call(this, e2), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
          }
          y.prototype._tmp = function() {
            var e2 = new s(null);
            return e2.words = new Array(Math.ceil(this.n / 13)), e2;
          }, y.prototype.ireduce = function(e2) {
            var t4, r3 = e2;
            do {
              this.split(r3, this.tmp), t4 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
            } while (t4 > this.n);
            var n2 = t4 < this.n ? -1 : r3.ucmp(this.p);
            return 0 === n2 ? (r3.words[0] = 0, r3.length = 1) : n2 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
          }, y.prototype.split = function(e2, t4) {
            e2.iushrn(this.n, 0, t4);
          }, y.prototype.imulK = function(e2) {
            return e2.imul(this.k);
          }, i(v, y), v.prototype.split = function(e2, t4) {
            for (var r3 = Math.min(e2.length, 9), n2 = 0; n2 < r3; n2++) t4.words[n2] = e2.words[n2];
            if (t4.length = r3, e2.length <= 9) return e2.words[0] = 0, void (e2.length = 1);
            var i2 = e2.words[9];
            for (t4.words[t4.length++] = 4194303 & i2, n2 = 10; n2 < e2.length; n2++) {
              var s2 = 0 | e2.words[n2];
              e2.words[n2 - 10] = (4194303 & s2) << 4 | i2 >>> 22, i2 = s2;
            }
            i2 >>>= 22, e2.words[n2 - 10] = i2, 0 === i2 && e2.length > 10 ? e2.length -= 10 : e2.length -= 9;
          }, v.prototype.imulK = function(e2) {
            e2.words[e2.length] = 0, e2.words[e2.length + 1] = 0, e2.length += 2;
            for (var t4 = 0, r3 = 0; r3 < e2.length; r3++) {
              var n2 = 0 | e2.words[r3];
              t4 += 977 * n2, e2.words[r3] = 67108863 & t4, t4 = 64 * n2 + (t4 / 67108864 | 0);
            }
            return 0 === e2.words[e2.length - 1] && (e2.length--, 0 === e2.words[e2.length - 1] && e2.length--), e2;
          }, i(w, y), i(_, y), i(x, y), x.prototype.imulK = function(e2) {
            for (var t4 = 0, r3 = 0; r3 < e2.length; r3++) {
              var n2 = 19 * (0 | e2.words[r3]) + t4, i2 = 67108863 & n2;
              n2 >>>= 26, e2.words[r3] = i2, t4 = n2;
            }
            return 0 !== t4 && (e2.words[e2.length++] = t4), e2;
          }, s._prime = function(e2) {
            if (g[e2]) return g[e2];
            var t4;
            if ("k256" === e2) t4 = new v();
            else if ("p224" === e2) t4 = new w();
            else if ("p192" === e2) t4 = new _();
            else {
              if ("p25519" !== e2) throw new Error("Unknown prime " + e2);
              t4 = new x();
            }
            return g[e2] = t4, t4;
          }, k.prototype._verify1 = function(e2) {
            n(0 === e2.negative, "red works only with positives"), n(e2.red, "red works only with red numbers");
          }, k.prototype._verify2 = function(e2, t4) {
            n(0 == (e2.negative | t4.negative), "red works only with positives"), n(e2.red && e2.red === t4.red, "red works only with red numbers");
          }, k.prototype.imod = function(e2) {
            return this.prime ? this.prime.ireduce(e2)._forceRed(this) : e2.umod(this.m)._forceRed(this);
          }, k.prototype.neg = function(e2) {
            return e2.isZero() ? e2.clone() : this.m.sub(e2)._forceRed(this);
          }, k.prototype.add = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.add(t4);
            return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
          }, k.prototype.iadd = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.iadd(t4);
            return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
          }, k.prototype.sub = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.sub(t4);
            return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
          }, k.prototype.isub = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.isub(t4);
            return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
          }, k.prototype.shl = function(e2, t4) {
            return this._verify1(e2), this.imod(e2.ushln(t4));
          }, k.prototype.imul = function(e2, t4) {
            return this._verify2(e2, t4), this.imod(e2.imul(t4));
          }, k.prototype.mul = function(e2, t4) {
            return this._verify2(e2, t4), this.imod(e2.mul(t4));
          }, k.prototype.isqr = function(e2) {
            return this.imul(e2, e2.clone());
          }, k.prototype.sqr = function(e2) {
            return this.mul(e2, e2);
          }, k.prototype.sqrt = function(e2) {
            if (e2.isZero()) return e2.clone();
            var t4 = this.m.andln(3);
            if (n(t4 % 2 == 1), 3 === t4) {
              var r3 = this.m.add(new s(1)).iushrn(2);
              return this.pow(e2, r3);
            }
            for (var i2 = this.m.subn(1), o2 = 0; !i2.isZero() && 0 === i2.andln(1); ) o2++, i2.iushrn(1);
            n(!i2.isZero());
            var a2 = new s(1).toRed(this), l2 = a2.redNeg(), c2 = this.m.subn(1).iushrn(1), u2 = this.m.bitLength();
            for (u2 = new s(2 * u2 * u2).toRed(this); 0 !== this.pow(u2, c2).cmp(l2); ) u2.redIAdd(l2);
            for (var h2 = this.pow(u2, i2), f2 = this.pow(e2, i2.addn(1).iushrn(1)), d2 = this.pow(e2, i2), p2 = o2; 0 !== d2.cmp(a2); ) {
              for (var m2 = d2, b2 = 0; 0 !== m2.cmp(a2); b2++) m2 = m2.redSqr();
              n(b2 < p2);
              var g2 = this.pow(h2, new s(1).iushln(p2 - b2 - 1));
              f2 = f2.redMul(g2), h2 = g2.redSqr(), d2 = d2.redMul(h2), p2 = b2;
            }
            return f2;
          }, k.prototype.invm = function(e2) {
            var t4 = e2._invmp(this.m);
            return 0 !== t4.negative ? (t4.negative = 0, this.imod(t4).redNeg()) : this.imod(t4);
          }, k.prototype.pow = function(e2, t4) {
            if (t4.isZero()) return new s(1).toRed(this);
            if (0 === t4.cmpn(1)) return e2.clone();
            var r3 = new Array(16);
            r3[0] = new s(1).toRed(this), r3[1] = e2;
            for (var n2 = 2; n2 < r3.length; n2++) r3[n2] = this.mul(r3[n2 - 1], e2);
            var i2 = r3[0], o2 = 0, a2 = 0, l2 = t4.bitLength() % 26;
            for (0 === l2 && (l2 = 26), n2 = t4.length - 1; n2 >= 0; n2--) {
              for (var c2 = t4.words[n2], u2 = l2 - 1; u2 >= 0; u2--) {
                var h2 = c2 >> u2 & 1;
                i2 !== r3[0] && (i2 = this.sqr(i2)), 0 !== h2 || 0 !== o2 ? (o2 <<= 1, o2 |= h2, (4 === ++a2 || 0 === n2 && 0 === u2) && (i2 = this.mul(i2, r3[o2]), a2 = 0, o2 = 0)) : a2 = 0;
              }
              l2 = 26;
            }
            return i2;
          }, k.prototype.convertTo = function(e2) {
            var t4 = e2.umod(this.m);
            return t4 === e2 ? t4.clone() : t4;
          }, k.prototype.convertFrom = function(e2) {
            var t4 = e2.clone();
            return t4.red = null, t4;
          }, s.mont = function(e2) {
            return new S(e2);
          }, i(S, k), S.prototype.convertTo = function(e2) {
            return this.imod(e2.ushln(this.shift));
          }, S.prototype.convertFrom = function(e2) {
            var t4 = this.imod(e2.mul(this.rinv));
            return t4.red = null, t4;
          }, S.prototype.imul = function(e2, t4) {
            if (e2.isZero() || t4.isZero()) return e2.words[0] = 0, e2.length = 1, e2;
            var r3 = e2.imul(t4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), s2 = i2;
            return i2.cmp(this.m) >= 0 ? s2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (s2 = i2.iadd(this.m)), s2._forceRed(this);
          }, S.prototype.mul = function(e2, t4) {
            if (e2.isZero() || t4.isZero()) return new s(0)._forceRed(this);
            var r3 = e2.mul(t4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
            return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
          }, S.prototype.invm = function(e2) {
            return this.imod(e2._invmp(this.m).mul(this.r2))._forceRed(this);
          };
        })(void 0 === t2 || t2);
      }, { buffer: 188 }], 185: [function(e, t2, r) {
        r.byteLength = function(e2) {
          var t3 = c(e2), r2 = t3[0], n2 = t3[1];
          return 3 * (r2 + n2) / 4 - n2;
        }, r.toByteArray = function(e2) {
          var t3, r2, n2 = c(e2), o2 = n2[0], a2 = n2[1], l2 = new s((function(e3, t4, r3) {
            return 3 * (t4 + r3) / 4 - r3;
          })(0, o2, a2)), u2 = 0, h = a2 > 0 ? o2 - 4 : o2;
          for (r2 = 0; r2 < h; r2 += 4) t3 = i[e2.charCodeAt(r2)] << 18 | i[e2.charCodeAt(r2 + 1)] << 12 | i[e2.charCodeAt(r2 + 2)] << 6 | i[e2.charCodeAt(r2 + 3)], l2[u2++] = t3 >> 16 & 255, l2[u2++] = t3 >> 8 & 255, l2[u2++] = 255 & t3;
          2 === a2 && (t3 = i[e2.charCodeAt(r2)] << 2 | i[e2.charCodeAt(r2 + 1)] >> 4, l2[u2++] = 255 & t3);
          1 === a2 && (t3 = i[e2.charCodeAt(r2)] << 10 | i[e2.charCodeAt(r2 + 1)] << 4 | i[e2.charCodeAt(r2 + 2)] >> 2, l2[u2++] = t3 >> 8 & 255, l2[u2++] = 255 & t3);
          return l2;
        }, r.fromByteArray = function(e2) {
          for (var t3, r2 = e2.length, i2 = r2 % 3, s2 = [], o2 = 0, a2 = r2 - i2; o2 < a2; o2 += 16383) s2.push(u(e2, o2, o2 + 16383 > a2 ? a2 : o2 + 16383));
          1 === i2 ? (t3 = e2[r2 - 1], s2.push(n[t3 >> 2] + n[t3 << 4 & 63] + "==")) : 2 === i2 && (t3 = (e2[r2 - 2] << 8) + e2[r2 - 1], s2.push(n[t3 >> 10] + n[t3 >> 4 & 63] + n[t3 << 2 & 63] + "="));
          return s2.join("");
        };
        for (var n = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = o.length; a < l; ++a) n[a] = o[a], i[o.charCodeAt(a)] = a;
        function c(e2) {
          var t3 = e2.length;
          if (t3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r2 = e2.indexOf("=");
          return -1 === r2 && (r2 = t3), [r2, r2 === t3 ? 0 : 4 - r2 % 4];
        }
        function u(e2, t3, r2) {
          for (var i2, s2, o2 = [], a2 = t3; a2 < r2; a2 += 3) i2 = (e2[a2] << 16 & 16711680) + (e2[a2 + 1] << 8 & 65280) + (255 & e2[a2 + 2]), o2.push(n[(s2 = i2) >> 18 & 63] + n[s2 >> 12 & 63] + n[s2 >> 6 & 63] + n[63 & s2]);
          return o2.join("");
        }
        i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
      }, {}], 186: [function(e, t2, r) {
        !(function(t3, r2) {
          function n(e2, t4) {
            if (!e2) throw new Error(t4 || "Assertion failed");
          }
          function i(e2, t4) {
            e2.super_ = t4;
            var r3 = function() {
            };
            r3.prototype = t4.prototype, e2.prototype = new r3(), e2.prototype.constructor = e2;
          }
          function s(e2, t4, r3) {
            if (s.isBN(e2)) return e2;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e2 && ("le" !== t4 && "be" !== t4 || (r3 = t4, t4 = 10), this._init(e2 || 0, t4 || 10, r3 || "be"));
          }
          var o;
          "object" == typeof t3 ? t3.exports = s : (void 0).BN = s, s.BN = s, s.wordSize = 26;
          try {
            o = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : e("buffer").Buffer;
          } catch (e2) {
          }
          function a(e2, t4) {
            var r3 = e2.charCodeAt(t4);
            return r3 >= 48 && r3 <= 57 ? r3 - 48 : r3 >= 65 && r3 <= 70 ? r3 - 55 : r3 >= 97 && r3 <= 102 ? r3 - 87 : void n(false, "Invalid character in " + e2);
          }
          function l(e2, t4, r3) {
            var n2 = a(e2, r3);
            return r3 - 1 >= t4 && (n2 |= a(e2, r3 - 1) << 4), n2;
          }
          function c(e2, t4, r3, i2) {
            for (var s2 = 0, o2 = 0, a2 = Math.min(e2.length, r3), l2 = t4; l2 < a2; l2++) {
              var c2 = e2.charCodeAt(l2) - 48;
              s2 *= i2, o2 = c2 >= 49 ? c2 - 49 + 10 : c2 >= 17 ? c2 - 17 + 10 : c2, n(c2 >= 0 && o2 < i2, "Invalid character"), s2 += o2;
            }
            return s2;
          }
          function u(e2, t4) {
            e2.words = t4.words, e2.length = t4.length, e2.negative = t4.negative, e2.red = t4.red;
          }
          if (s.isBN = function(e2) {
            return e2 instanceof s || null !== e2 && "object" == typeof e2 && e2.constructor.wordSize === s.wordSize && Array.isArray(e2.words);
          }, s.max = function(e2, t4) {
            return e2.cmp(t4) > 0 ? e2 : t4;
          }, s.min = function(e2, t4) {
            return e2.cmp(t4) < 0 ? e2 : t4;
          }, s.prototype._init = function(e2, t4, r3) {
            if ("number" == typeof e2) return this._initNumber(e2, t4, r3);
            if ("object" == typeof e2) return this._initArray(e2, t4, r3);
            "hex" === t4 && (t4 = 16), n(t4 === (0 | t4) && t4 >= 2 && t4 <= 36);
            var i2 = 0;
            "-" === (e2 = e2.toString().replace(/\s+/g, ""))[0] && (i2++, this.negative = 1), i2 < e2.length && (16 === t4 ? this._parseHex(e2, i2, r3) : (this._parseBase(e2, t4, i2), "le" === r3 && this._initArray(this.toArray(), t4, r3)));
          }, s.prototype._initNumber = function(e2, t4, r3) {
            e2 < 0 && (this.negative = 1, e2 = -e2), e2 < 67108864 ? (this.words = [67108863 & e2], this.length = 1) : e2 < 4503599627370496 ? (this.words = [67108863 & e2, e2 / 67108864 & 67108863], this.length = 2) : (n(e2 < 9007199254740992), this.words = [67108863 & e2, e2 / 67108864 & 67108863, 1], this.length = 3), "le" === r3 && this._initArray(this.toArray(), t4, r3);
          }, s.prototype._initArray = function(e2, t4, r3) {
            if (n("number" == typeof e2.length), e2.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(e2.length / 3), this.words = new Array(this.length);
            for (var i2 = 0; i2 < this.length; i2++) this.words[i2] = 0;
            var s2, o2, a2 = 0;
            if ("be" === r3) for (i2 = e2.length - 1, s2 = 0; i2 >= 0; i2 -= 3) o2 = e2[i2] | e2[i2 - 1] << 8 | e2[i2 - 2] << 16, this.words[s2] |= o2 << a2 & 67108863, this.words[s2 + 1] = o2 >>> 26 - a2 & 67108863, (a2 += 24) >= 26 && (a2 -= 26, s2++);
            else if ("le" === r3) for (i2 = 0, s2 = 0; i2 < e2.length; i2 += 3) o2 = e2[i2] | e2[i2 + 1] << 8 | e2[i2 + 2] << 16, this.words[s2] |= o2 << a2 & 67108863, this.words[s2 + 1] = o2 >>> 26 - a2 & 67108863, (a2 += 24) >= 26 && (a2 -= 26, s2++);
            return this._strip();
          }, s.prototype._parseHex = function(e2, t4, r3) {
            this.length = Math.ceil((e2.length - t4) / 6), this.words = new Array(this.length);
            for (var n2 = 0; n2 < this.length; n2++) this.words[n2] = 0;
            var i2, s2 = 0, o2 = 0;
            if ("be" === r3) for (n2 = e2.length - 1; n2 >= t4; n2 -= 2) i2 = l(e2, t4, n2) << s2, this.words[o2] |= 67108863 & i2, s2 >= 18 ? (s2 -= 18, o2 += 1, this.words[o2] |= i2 >>> 26) : s2 += 8;
            else for (n2 = (e2.length - t4) % 2 == 0 ? t4 + 1 : t4; n2 < e2.length; n2 += 2) i2 = l(e2, t4, n2) << s2, this.words[o2] |= 67108863 & i2, s2 >= 18 ? (s2 -= 18, o2 += 1, this.words[o2] |= i2 >>> 26) : s2 += 8;
            this._strip();
          }, s.prototype._parseBase = function(e2, t4, r3) {
            this.words = [0], this.length = 1;
            for (var n2 = 0, i2 = 1; i2 <= 67108863; i2 *= t4) n2++;
            n2--, i2 = i2 / t4 | 0;
            for (var s2 = e2.length - r3, o2 = s2 % n2, a2 = Math.min(s2, s2 - o2) + r3, l2 = 0, u2 = r3; u2 < a2; u2 += n2) l2 = c(e2, u2, u2 + n2, t4), this.imuln(i2), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
            if (0 !== o2) {
              var h2 = 1;
              for (l2 = c(e2, u2, e2.length, t4), u2 = 0; u2 < o2; u2++) h2 *= t4;
              this.imuln(h2), this.words[0] + l2 < 67108864 ? this.words[0] += l2 : this._iaddn(l2);
            }
            this._strip();
          }, s.prototype.copy = function(e2) {
            e2.words = new Array(this.length);
            for (var t4 = 0; t4 < this.length; t4++) e2.words[t4] = this.words[t4];
            e2.length = this.length, e2.negative = this.negative, e2.red = this.red;
          }, s.prototype._move = function(e2) {
            u(e2, this);
          }, s.prototype.clone = function() {
            var e2 = new s(null);
            return this.copy(e2), e2;
          }, s.prototype._expand = function(e2) {
            for (; this.length < e2; ) this.words[this.length++] = 0;
            return this;
          }, s.prototype._strip = function() {
            for (; this.length > 1 && 0 === this.words[this.length - 1]; ) this.length--;
            return this._normSign();
          }, s.prototype._normSign = function() {
            return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
          }, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
            s.prototype[/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")] = h;
          } catch (e2) {
            s.prototype.inspect = h;
          }
          else s.prototype.inspect = h;
          function h() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
          s.prototype.toString = function(e2, t4) {
            var r3;
            if (t4 = 0 | t4 || 1, 16 === (e2 = e2 || 10) || "hex" === e2) {
              r3 = "";
              for (var i2 = 0, s2 = 0, o2 = 0; o2 < this.length; o2++) {
                var a2 = this.words[o2], l2 = (16777215 & (a2 << i2 | s2)).toString(16);
                s2 = a2 >>> 24 - i2 & 16777215, (i2 += 2) >= 26 && (i2 -= 26, o2--), r3 = 0 !== s2 || o2 !== this.length - 1 ? f[6 - l2.length] + l2 + r3 : l2 + r3;
              }
              for (0 !== s2 && (r3 = s2.toString(16) + r3); r3.length % t4 != 0; ) r3 = "0" + r3;
              return 0 !== this.negative && (r3 = "-" + r3), r3;
            }
            if (e2 === (0 | e2) && e2 >= 2 && e2 <= 36) {
              var c2 = d[e2], u2 = p[e2];
              r3 = "";
              var h2 = this.clone();
              for (h2.negative = 0; !h2.isZero(); ) {
                var m2 = h2.modrn(u2).toString(e2);
                r3 = (h2 = h2.idivn(u2)).isZero() ? m2 + r3 : f[c2 - m2.length] + m2 + r3;
              }
              for (this.isZero() && (r3 = "0" + r3); r3.length % t4 != 0; ) r3 = "0" + r3;
              return 0 !== this.negative && (r3 = "-" + r3), r3;
            }
            n(false, "Base should be between 2 and 36");
          }, s.prototype.toNumber = function() {
            var e2 = this.words[0];
            return 2 === this.length ? e2 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e2 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e2 : e2;
          }, s.prototype.toJSON = function() {
            return this.toString(16, 2);
          }, o && (s.prototype.toBuffer = function(e2, t4) {
            return this.toArrayLike(o, e2, t4);
          }), s.prototype.toArray = function(e2, t4) {
            return this.toArrayLike(Array, e2, t4);
          };
          function m(e2, t4, r3) {
            r3.negative = t4.negative ^ e2.negative;
            var n2 = e2.length + t4.length | 0;
            r3.length = n2, n2 = n2 - 1 | 0;
            var i2 = 0 | e2.words[0], s2 = 0 | t4.words[0], o2 = i2 * s2, a2 = 67108863 & o2, l2 = o2 / 67108864 | 0;
            r3.words[0] = a2;
            for (var c2 = 1; c2 < n2; c2++) {
              for (var u2 = l2 >>> 26, h2 = 67108863 & l2, f2 = Math.min(c2, t4.length - 1), d2 = Math.max(0, c2 - e2.length + 1); d2 <= f2; d2++) {
                var p2 = c2 - d2 | 0;
                u2 += (o2 = (i2 = 0 | e2.words[p2]) * (s2 = 0 | t4.words[d2]) + h2) / 67108864 | 0, h2 = 67108863 & o2;
              }
              r3.words[c2] = 0 | h2, l2 = 0 | u2;
            }
            return 0 !== l2 ? r3.words[c2] = 0 | l2 : r3.length--, r3._strip();
          }
          s.prototype.toArrayLike = function(e2, t4, r3) {
            this._strip();
            var i2 = this.byteLength(), s2 = r3 || Math.max(1, i2);
            n(i2 <= s2, "byte array longer than desired length"), n(s2 > 0, "Requested array length <= 0");
            var o2 = (function(e3, t5) {
              return e3.allocUnsafe ? e3.allocUnsafe(t5) : new e3(t5);
            })(e2, s2);
            return this["_toArrayLike" + ("le" === t4 ? "LE" : "BE")](o2, i2), o2;
          }, s.prototype._toArrayLikeLE = function(e2, t4) {
            for (var r3 = 0, n2 = 0, i2 = 0, s2 = 0; i2 < this.length; i2++) {
              var o2 = this.words[i2] << s2 | n2;
              e2[r3++] = 255 & o2, r3 < e2.length && (e2[r3++] = o2 >> 8 & 255), r3 < e2.length && (e2[r3++] = o2 >> 16 & 255), 6 === s2 ? (r3 < e2.length && (e2[r3++] = o2 >> 24 & 255), n2 = 0, s2 = 0) : (n2 = o2 >>> 24, s2 += 2);
            }
            if (r3 < e2.length) for (e2[r3++] = n2; r3 < e2.length; ) e2[r3++] = 0;
          }, s.prototype._toArrayLikeBE = function(e2, t4) {
            for (var r3 = e2.length - 1, n2 = 0, i2 = 0, s2 = 0; i2 < this.length; i2++) {
              var o2 = this.words[i2] << s2 | n2;
              e2[r3--] = 255 & o2, r3 >= 0 && (e2[r3--] = o2 >> 8 & 255), r3 >= 0 && (e2[r3--] = o2 >> 16 & 255), 6 === s2 ? (r3 >= 0 && (e2[r3--] = o2 >> 24 & 255), n2 = 0, s2 = 0) : (n2 = o2 >>> 24, s2 += 2);
            }
            if (r3 >= 0) for (e2[r3--] = n2; r3 >= 0; ) e2[r3--] = 0;
          }, Math.clz32 ? s.prototype._countBits = function(e2) {
            return 32 - Math.clz32(e2);
          } : s.prototype._countBits = function(e2) {
            var t4 = e2, r3 = 0;
            return t4 >= 4096 && (r3 += 13, t4 >>>= 13), t4 >= 64 && (r3 += 7, t4 >>>= 7), t4 >= 8 && (r3 += 4, t4 >>>= 4), t4 >= 2 && (r3 += 2, t4 >>>= 2), r3 + t4;
          }, s.prototype._zeroBits = function(e2) {
            if (0 === e2) return 26;
            var t4 = e2, r3 = 0;
            return 0 == (8191 & t4) && (r3 += 13, t4 >>>= 13), 0 == (127 & t4) && (r3 += 7, t4 >>>= 7), 0 == (15 & t4) && (r3 += 4, t4 >>>= 4), 0 == (3 & t4) && (r3 += 2, t4 >>>= 2), 0 == (1 & t4) && r3++, r3;
          }, s.prototype.bitLength = function() {
            var e2 = this.words[this.length - 1], t4 = this._countBits(e2);
            return 26 * (this.length - 1) + t4;
          }, s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var e2 = 0, t4 = 0; t4 < this.length; t4++) {
              var r3 = this._zeroBits(this.words[t4]);
              if (e2 += r3, 26 !== r3) break;
            }
            return e2;
          }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
          }, s.prototype.toTwos = function(e2) {
            return 0 !== this.negative ? this.abs().inotn(e2).iaddn(1) : this.clone();
          }, s.prototype.fromTwos = function(e2) {
            return this.testn(e2 - 1) ? this.notn(e2).iaddn(1).ineg() : this.clone();
          }, s.prototype.isNeg = function() {
            return 0 !== this.negative;
          }, s.prototype.neg = function() {
            return this.clone().ineg();
          }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
          }, s.prototype.iuor = function(e2) {
            for (; this.length < e2.length; ) this.words[this.length++] = 0;
            for (var t4 = 0; t4 < e2.length; t4++) this.words[t4] = this.words[t4] | e2.words[t4];
            return this._strip();
          }, s.prototype.ior = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuor(e2);
          }, s.prototype.or = function(e2) {
            return this.length > e2.length ? this.clone().ior(e2) : e2.clone().ior(this);
          }, s.prototype.uor = function(e2) {
            return this.length > e2.length ? this.clone().iuor(e2) : e2.clone().iuor(this);
          }, s.prototype.iuand = function(e2) {
            var t4;
            t4 = this.length > e2.length ? e2 : this;
            for (var r3 = 0; r3 < t4.length; r3++) this.words[r3] = this.words[r3] & e2.words[r3];
            return this.length = t4.length, this._strip();
          }, s.prototype.iand = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuand(e2);
          }, s.prototype.and = function(e2) {
            return this.length > e2.length ? this.clone().iand(e2) : e2.clone().iand(this);
          }, s.prototype.uand = function(e2) {
            return this.length > e2.length ? this.clone().iuand(e2) : e2.clone().iuand(this);
          }, s.prototype.iuxor = function(e2) {
            var t4, r3;
            this.length > e2.length ? (t4 = this, r3 = e2) : (t4 = e2, r3 = this);
            for (var n2 = 0; n2 < r3.length; n2++) this.words[n2] = t4.words[n2] ^ r3.words[n2];
            if (this !== t4) for (; n2 < t4.length; n2++) this.words[n2] = t4.words[n2];
            return this.length = t4.length, this._strip();
          }, s.prototype.ixor = function(e2) {
            return n(0 == (this.negative | e2.negative)), this.iuxor(e2);
          }, s.prototype.xor = function(e2) {
            return this.length > e2.length ? this.clone().ixor(e2) : e2.clone().ixor(this);
          }, s.prototype.uxor = function(e2) {
            return this.length > e2.length ? this.clone().iuxor(e2) : e2.clone().iuxor(this);
          }, s.prototype.inotn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = 0 | Math.ceil(e2 / 26), r3 = e2 % 26;
            this._expand(t4), r3 > 0 && t4--;
            for (var i2 = 0; i2 < t4; i2++) this.words[i2] = 67108863 & ~this.words[i2];
            return r3 > 0 && (this.words[i2] = ~this.words[i2] & 67108863 >> 26 - r3), this._strip();
          }, s.prototype.notn = function(e2) {
            return this.clone().inotn(e2);
          }, s.prototype.setn = function(e2, t4) {
            n("number" == typeof e2 && e2 >= 0);
            var r3 = e2 / 26 | 0, i2 = e2 % 26;
            return this._expand(r3 + 1), this.words[r3] = t4 ? this.words[r3] | 1 << i2 : this.words[r3] & ~(1 << i2), this._strip();
          }, s.prototype.iadd = function(e2) {
            var t4, r3, n2;
            if (0 !== this.negative && 0 === e2.negative) return this.negative = 0, t4 = this.isub(e2), this.negative ^= 1, this._normSign();
            if (0 === this.negative && 0 !== e2.negative) return e2.negative = 0, t4 = this.isub(e2), e2.negative = 1, t4._normSign();
            this.length > e2.length ? (r3 = this, n2 = e2) : (r3 = e2, n2 = this);
            for (var i2 = 0, s2 = 0; s2 < n2.length; s2++) t4 = (0 | r3.words[s2]) + (0 | n2.words[s2]) + i2, this.words[s2] = 67108863 & t4, i2 = t4 >>> 26;
            for (; 0 !== i2 && s2 < r3.length; s2++) t4 = (0 | r3.words[s2]) + i2, this.words[s2] = 67108863 & t4, i2 = t4 >>> 26;
            if (this.length = r3.length, 0 !== i2) this.words[this.length] = i2, this.length++;
            else if (r3 !== this) for (; s2 < r3.length; s2++) this.words[s2] = r3.words[s2];
            return this;
          }, s.prototype.add = function(e2) {
            var t4;
            return 0 !== e2.negative && 0 === this.negative ? (e2.negative = 0, t4 = this.sub(e2), e2.negative ^= 1, t4) : 0 === e2.negative && 0 !== this.negative ? (this.negative = 0, t4 = e2.sub(this), this.negative = 1, t4) : this.length > e2.length ? this.clone().iadd(e2) : e2.clone().iadd(this);
          }, s.prototype.isub = function(e2) {
            if (0 !== e2.negative) {
              e2.negative = 0;
              var t4 = this.iadd(e2);
              return e2.negative = 1, t4._normSign();
            }
            if (0 !== this.negative) return this.negative = 0, this.iadd(e2), this.negative = 1, this._normSign();
            var r3, n2, i2 = this.cmp(e2);
            if (0 === i2) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            i2 > 0 ? (r3 = this, n2 = e2) : (r3 = e2, n2 = this);
            for (var s2 = 0, o2 = 0; o2 < n2.length; o2++) s2 = (t4 = (0 | r3.words[o2]) - (0 | n2.words[o2]) + s2) >> 26, this.words[o2] = 67108863 & t4;
            for (; 0 !== s2 && o2 < r3.length; o2++) s2 = (t4 = (0 | r3.words[o2]) + s2) >> 26, this.words[o2] = 67108863 & t4;
            if (0 === s2 && o2 < r3.length && r3 !== this) for (; o2 < r3.length; o2++) this.words[o2] = r3.words[o2];
            return this.length = Math.max(this.length, o2), r3 !== this && (this.negative = 1), this._strip();
          }, s.prototype.sub = function(e2) {
            return this.clone().isub(e2);
          };
          var b = function(e2, t4, r3) {
            var n2, i2, s2, o2 = e2.words, a2 = t4.words, l2 = r3.words, c2 = 0, u2 = 0 | o2[0], h2 = 8191 & u2, f2 = u2 >>> 13, d2 = 0 | o2[1], p2 = 8191 & d2, m2 = d2 >>> 13, b2 = 0 | o2[2], g2 = 8191 & b2, y2 = b2 >>> 13, v = 0 | o2[3], w2 = 8191 & v, _2 = v >>> 13, x2 = 0 | o2[4], k2 = 8191 & x2, S2 = x2 >>> 13, M2 = 0 | o2[5], C3 = 8191 & M2, T2 = M2 >>> 13, E = 0 | o2[6], A = 8191 & E, R = E >>> 13, O = 0 | o2[7], j = 8191 & O, I = O >>> 13, N = 0 | o2[8], P = 8191 & N, B = N >>> 13, D = 0 | o2[9], F = 8191 & D, L = D >>> 13, z = 0 | a2[0], U = 8191 & z, $ = z >>> 13, H = 0 | a2[1], V = 8191 & H, q = H >>> 13, W = 0 | a2[2], X = 8191 & W, K = W >>> 13, Y = 0 | a2[3], Z = 8191 & Y, G = Y >>> 13, J = 0 | a2[4], Q = 8191 & J, ee = J >>> 13, te = 0 | a2[5], re = 8191 & te, ne = te >>> 13, ie2 = 0 | a2[6], se = 8191 & ie2, oe = ie2 >>> 13, ae = 0 | a2[7], le = 8191 & ae, ce = ae >>> 13, ue = 0 | a2[8], he = 8191 & ue, fe = ue >>> 13, de = 0 | a2[9], pe = 8191 & de, me = de >>> 13;
            r3.negative = e2.negative ^ t4.negative, r3.length = 19;
            var be = (c2 + (n2 = Math.imul(h2, U)) | 0) + ((8191 & (i2 = (i2 = Math.imul(h2, $)) + Math.imul(f2, U) | 0)) << 13) | 0;
            c2 = ((s2 = Math.imul(f2, $)) + (i2 >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, n2 = Math.imul(p2, U), i2 = (i2 = Math.imul(p2, $)) + Math.imul(m2, U) | 0, s2 = Math.imul(m2, $);
            var ge = (c2 + (n2 = n2 + Math.imul(h2, V) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, q) | 0) + Math.imul(f2, V) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, q) | 0) + (i2 >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, n2 = Math.imul(g2, U), i2 = (i2 = Math.imul(g2, $)) + Math.imul(y2, U) | 0, s2 = Math.imul(y2, $), n2 = n2 + Math.imul(p2, V) | 0, i2 = (i2 = i2 + Math.imul(p2, q) | 0) + Math.imul(m2, V) | 0, s2 = s2 + Math.imul(m2, q) | 0;
            var ye = (c2 + (n2 = n2 + Math.imul(h2, X) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, K) | 0) + Math.imul(f2, X) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, K) | 0) + (i2 >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, n2 = Math.imul(w2, U), i2 = (i2 = Math.imul(w2, $)) + Math.imul(_2, U) | 0, s2 = Math.imul(_2, $), n2 = n2 + Math.imul(g2, V) | 0, i2 = (i2 = i2 + Math.imul(g2, q) | 0) + Math.imul(y2, V) | 0, s2 = s2 + Math.imul(y2, q) | 0, n2 = n2 + Math.imul(p2, X) | 0, i2 = (i2 = i2 + Math.imul(p2, K) | 0) + Math.imul(m2, X) | 0, s2 = s2 + Math.imul(m2, K) | 0;
            var ve = (c2 + (n2 = n2 + Math.imul(h2, Z) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, G) | 0) + Math.imul(f2, Z) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, G) | 0) + (i2 >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, n2 = Math.imul(k2, U), i2 = (i2 = Math.imul(k2, $)) + Math.imul(S2, U) | 0, s2 = Math.imul(S2, $), n2 = n2 + Math.imul(w2, V) | 0, i2 = (i2 = i2 + Math.imul(w2, q) | 0) + Math.imul(_2, V) | 0, s2 = s2 + Math.imul(_2, q) | 0, n2 = n2 + Math.imul(g2, X) | 0, i2 = (i2 = i2 + Math.imul(g2, K) | 0) + Math.imul(y2, X) | 0, s2 = s2 + Math.imul(y2, K) | 0, n2 = n2 + Math.imul(p2, Z) | 0, i2 = (i2 = i2 + Math.imul(p2, G) | 0) + Math.imul(m2, Z) | 0, s2 = s2 + Math.imul(m2, G) | 0;
            var we = (c2 + (n2 = n2 + Math.imul(h2, Q) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ee) | 0) + Math.imul(f2, Q) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ee) | 0) + (i2 >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, n2 = Math.imul(C3, U), i2 = (i2 = Math.imul(C3, $)) + Math.imul(T2, U) | 0, s2 = Math.imul(T2, $), n2 = n2 + Math.imul(k2, V) | 0, i2 = (i2 = i2 + Math.imul(k2, q) | 0) + Math.imul(S2, V) | 0, s2 = s2 + Math.imul(S2, q) | 0, n2 = n2 + Math.imul(w2, X) | 0, i2 = (i2 = i2 + Math.imul(w2, K) | 0) + Math.imul(_2, X) | 0, s2 = s2 + Math.imul(_2, K) | 0, n2 = n2 + Math.imul(g2, Z) | 0, i2 = (i2 = i2 + Math.imul(g2, G) | 0) + Math.imul(y2, Z) | 0, s2 = s2 + Math.imul(y2, G) | 0, n2 = n2 + Math.imul(p2, Q) | 0, i2 = (i2 = i2 + Math.imul(p2, ee) | 0) + Math.imul(m2, Q) | 0, s2 = s2 + Math.imul(m2, ee) | 0;
            var _e = (c2 + (n2 = n2 + Math.imul(h2, re) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ne) | 0) + Math.imul(f2, re) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ne) | 0) + (i2 >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, n2 = Math.imul(A, U), i2 = (i2 = Math.imul(A, $)) + Math.imul(R, U) | 0, s2 = Math.imul(R, $), n2 = n2 + Math.imul(C3, V) | 0, i2 = (i2 = i2 + Math.imul(C3, q) | 0) + Math.imul(T2, V) | 0, s2 = s2 + Math.imul(T2, q) | 0, n2 = n2 + Math.imul(k2, X) | 0, i2 = (i2 = i2 + Math.imul(k2, K) | 0) + Math.imul(S2, X) | 0, s2 = s2 + Math.imul(S2, K) | 0, n2 = n2 + Math.imul(w2, Z) | 0, i2 = (i2 = i2 + Math.imul(w2, G) | 0) + Math.imul(_2, Z) | 0, s2 = s2 + Math.imul(_2, G) | 0, n2 = n2 + Math.imul(g2, Q) | 0, i2 = (i2 = i2 + Math.imul(g2, ee) | 0) + Math.imul(y2, Q) | 0, s2 = s2 + Math.imul(y2, ee) | 0, n2 = n2 + Math.imul(p2, re) | 0, i2 = (i2 = i2 + Math.imul(p2, ne) | 0) + Math.imul(m2, re) | 0, s2 = s2 + Math.imul(m2, ne) | 0;
            var xe = (c2 + (n2 = n2 + Math.imul(h2, se) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, oe) | 0) + Math.imul(f2, se) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, oe) | 0) + (i2 >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, n2 = Math.imul(j, U), i2 = (i2 = Math.imul(j, $)) + Math.imul(I, U) | 0, s2 = Math.imul(I, $), n2 = n2 + Math.imul(A, V) | 0, i2 = (i2 = i2 + Math.imul(A, q) | 0) + Math.imul(R, V) | 0, s2 = s2 + Math.imul(R, q) | 0, n2 = n2 + Math.imul(C3, X) | 0, i2 = (i2 = i2 + Math.imul(C3, K) | 0) + Math.imul(T2, X) | 0, s2 = s2 + Math.imul(T2, K) | 0, n2 = n2 + Math.imul(k2, Z) | 0, i2 = (i2 = i2 + Math.imul(k2, G) | 0) + Math.imul(S2, Z) | 0, s2 = s2 + Math.imul(S2, G) | 0, n2 = n2 + Math.imul(w2, Q) | 0, i2 = (i2 = i2 + Math.imul(w2, ee) | 0) + Math.imul(_2, Q) | 0, s2 = s2 + Math.imul(_2, ee) | 0, n2 = n2 + Math.imul(g2, re) | 0, i2 = (i2 = i2 + Math.imul(g2, ne) | 0) + Math.imul(y2, re) | 0, s2 = s2 + Math.imul(y2, ne) | 0, n2 = n2 + Math.imul(p2, se) | 0, i2 = (i2 = i2 + Math.imul(p2, oe) | 0) + Math.imul(m2, se) | 0, s2 = s2 + Math.imul(m2, oe) | 0;
            var ke = (c2 + (n2 = n2 + Math.imul(h2, le) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, ce) | 0) + Math.imul(f2, le) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, ce) | 0) + (i2 >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, n2 = Math.imul(P, U), i2 = (i2 = Math.imul(P, $)) + Math.imul(B, U) | 0, s2 = Math.imul(B, $), n2 = n2 + Math.imul(j, V) | 0, i2 = (i2 = i2 + Math.imul(j, q) | 0) + Math.imul(I, V) | 0, s2 = s2 + Math.imul(I, q) | 0, n2 = n2 + Math.imul(A, X) | 0, i2 = (i2 = i2 + Math.imul(A, K) | 0) + Math.imul(R, X) | 0, s2 = s2 + Math.imul(R, K) | 0, n2 = n2 + Math.imul(C3, Z) | 0, i2 = (i2 = i2 + Math.imul(C3, G) | 0) + Math.imul(T2, Z) | 0, s2 = s2 + Math.imul(T2, G) | 0, n2 = n2 + Math.imul(k2, Q) | 0, i2 = (i2 = i2 + Math.imul(k2, ee) | 0) + Math.imul(S2, Q) | 0, s2 = s2 + Math.imul(S2, ee) | 0, n2 = n2 + Math.imul(w2, re) | 0, i2 = (i2 = i2 + Math.imul(w2, ne) | 0) + Math.imul(_2, re) | 0, s2 = s2 + Math.imul(_2, ne) | 0, n2 = n2 + Math.imul(g2, se) | 0, i2 = (i2 = i2 + Math.imul(g2, oe) | 0) + Math.imul(y2, se) | 0, s2 = s2 + Math.imul(y2, oe) | 0, n2 = n2 + Math.imul(p2, le) | 0, i2 = (i2 = i2 + Math.imul(p2, ce) | 0) + Math.imul(m2, le) | 0, s2 = s2 + Math.imul(m2, ce) | 0;
            var Se = (c2 + (n2 = n2 + Math.imul(h2, he) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, fe) | 0) + Math.imul(f2, he) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, fe) | 0) + (i2 >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, n2 = Math.imul(F, U), i2 = (i2 = Math.imul(F, $)) + Math.imul(L, U) | 0, s2 = Math.imul(L, $), n2 = n2 + Math.imul(P, V) | 0, i2 = (i2 = i2 + Math.imul(P, q) | 0) + Math.imul(B, V) | 0, s2 = s2 + Math.imul(B, q) | 0, n2 = n2 + Math.imul(j, X) | 0, i2 = (i2 = i2 + Math.imul(j, K) | 0) + Math.imul(I, X) | 0, s2 = s2 + Math.imul(I, K) | 0, n2 = n2 + Math.imul(A, Z) | 0, i2 = (i2 = i2 + Math.imul(A, G) | 0) + Math.imul(R, Z) | 0, s2 = s2 + Math.imul(R, G) | 0, n2 = n2 + Math.imul(C3, Q) | 0, i2 = (i2 = i2 + Math.imul(C3, ee) | 0) + Math.imul(T2, Q) | 0, s2 = s2 + Math.imul(T2, ee) | 0, n2 = n2 + Math.imul(k2, re) | 0, i2 = (i2 = i2 + Math.imul(k2, ne) | 0) + Math.imul(S2, re) | 0, s2 = s2 + Math.imul(S2, ne) | 0, n2 = n2 + Math.imul(w2, se) | 0, i2 = (i2 = i2 + Math.imul(w2, oe) | 0) + Math.imul(_2, se) | 0, s2 = s2 + Math.imul(_2, oe) | 0, n2 = n2 + Math.imul(g2, le) | 0, i2 = (i2 = i2 + Math.imul(g2, ce) | 0) + Math.imul(y2, le) | 0, s2 = s2 + Math.imul(y2, ce) | 0, n2 = n2 + Math.imul(p2, he) | 0, i2 = (i2 = i2 + Math.imul(p2, fe) | 0) + Math.imul(m2, he) | 0, s2 = s2 + Math.imul(m2, fe) | 0;
            var Me = (c2 + (n2 = n2 + Math.imul(h2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(h2, me) | 0) + Math.imul(f2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(f2, me) | 0) + (i2 >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, n2 = Math.imul(F, V), i2 = (i2 = Math.imul(F, q)) + Math.imul(L, V) | 0, s2 = Math.imul(L, q), n2 = n2 + Math.imul(P, X) | 0, i2 = (i2 = i2 + Math.imul(P, K) | 0) + Math.imul(B, X) | 0, s2 = s2 + Math.imul(B, K) | 0, n2 = n2 + Math.imul(j, Z) | 0, i2 = (i2 = i2 + Math.imul(j, G) | 0) + Math.imul(I, Z) | 0, s2 = s2 + Math.imul(I, G) | 0, n2 = n2 + Math.imul(A, Q) | 0, i2 = (i2 = i2 + Math.imul(A, ee) | 0) + Math.imul(R, Q) | 0, s2 = s2 + Math.imul(R, ee) | 0, n2 = n2 + Math.imul(C3, re) | 0, i2 = (i2 = i2 + Math.imul(C3, ne) | 0) + Math.imul(T2, re) | 0, s2 = s2 + Math.imul(T2, ne) | 0, n2 = n2 + Math.imul(k2, se) | 0, i2 = (i2 = i2 + Math.imul(k2, oe) | 0) + Math.imul(S2, se) | 0, s2 = s2 + Math.imul(S2, oe) | 0, n2 = n2 + Math.imul(w2, le) | 0, i2 = (i2 = i2 + Math.imul(w2, ce) | 0) + Math.imul(_2, le) | 0, s2 = s2 + Math.imul(_2, ce) | 0, n2 = n2 + Math.imul(g2, he) | 0, i2 = (i2 = i2 + Math.imul(g2, fe) | 0) + Math.imul(y2, he) | 0, s2 = s2 + Math.imul(y2, fe) | 0;
            var Ce = (c2 + (n2 = n2 + Math.imul(p2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(p2, me) | 0) + Math.imul(m2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(m2, me) | 0) + (i2 >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, n2 = Math.imul(F, X), i2 = (i2 = Math.imul(F, K)) + Math.imul(L, X) | 0, s2 = Math.imul(L, K), n2 = n2 + Math.imul(P, Z) | 0, i2 = (i2 = i2 + Math.imul(P, G) | 0) + Math.imul(B, Z) | 0, s2 = s2 + Math.imul(B, G) | 0, n2 = n2 + Math.imul(j, Q) | 0, i2 = (i2 = i2 + Math.imul(j, ee) | 0) + Math.imul(I, Q) | 0, s2 = s2 + Math.imul(I, ee) | 0, n2 = n2 + Math.imul(A, re) | 0, i2 = (i2 = i2 + Math.imul(A, ne) | 0) + Math.imul(R, re) | 0, s2 = s2 + Math.imul(R, ne) | 0, n2 = n2 + Math.imul(C3, se) | 0, i2 = (i2 = i2 + Math.imul(C3, oe) | 0) + Math.imul(T2, se) | 0, s2 = s2 + Math.imul(T2, oe) | 0, n2 = n2 + Math.imul(k2, le) | 0, i2 = (i2 = i2 + Math.imul(k2, ce) | 0) + Math.imul(S2, le) | 0, s2 = s2 + Math.imul(S2, ce) | 0, n2 = n2 + Math.imul(w2, he) | 0, i2 = (i2 = i2 + Math.imul(w2, fe) | 0) + Math.imul(_2, he) | 0, s2 = s2 + Math.imul(_2, fe) | 0;
            var Te = (c2 + (n2 = n2 + Math.imul(g2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(g2, me) | 0) + Math.imul(y2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(y2, me) | 0) + (i2 >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, n2 = Math.imul(F, Z), i2 = (i2 = Math.imul(F, G)) + Math.imul(L, Z) | 0, s2 = Math.imul(L, G), n2 = n2 + Math.imul(P, Q) | 0, i2 = (i2 = i2 + Math.imul(P, ee) | 0) + Math.imul(B, Q) | 0, s2 = s2 + Math.imul(B, ee) | 0, n2 = n2 + Math.imul(j, re) | 0, i2 = (i2 = i2 + Math.imul(j, ne) | 0) + Math.imul(I, re) | 0, s2 = s2 + Math.imul(I, ne) | 0, n2 = n2 + Math.imul(A, se) | 0, i2 = (i2 = i2 + Math.imul(A, oe) | 0) + Math.imul(R, se) | 0, s2 = s2 + Math.imul(R, oe) | 0, n2 = n2 + Math.imul(C3, le) | 0, i2 = (i2 = i2 + Math.imul(C3, ce) | 0) + Math.imul(T2, le) | 0, s2 = s2 + Math.imul(T2, ce) | 0, n2 = n2 + Math.imul(k2, he) | 0, i2 = (i2 = i2 + Math.imul(k2, fe) | 0) + Math.imul(S2, he) | 0, s2 = s2 + Math.imul(S2, fe) | 0;
            var Ee = (c2 + (n2 = n2 + Math.imul(w2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(w2, me) | 0) + Math.imul(_2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(_2, me) | 0) + (i2 >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, n2 = Math.imul(F, Q), i2 = (i2 = Math.imul(F, ee)) + Math.imul(L, Q) | 0, s2 = Math.imul(L, ee), n2 = n2 + Math.imul(P, re) | 0, i2 = (i2 = i2 + Math.imul(P, ne) | 0) + Math.imul(B, re) | 0, s2 = s2 + Math.imul(B, ne) | 0, n2 = n2 + Math.imul(j, se) | 0, i2 = (i2 = i2 + Math.imul(j, oe) | 0) + Math.imul(I, se) | 0, s2 = s2 + Math.imul(I, oe) | 0, n2 = n2 + Math.imul(A, le) | 0, i2 = (i2 = i2 + Math.imul(A, ce) | 0) + Math.imul(R, le) | 0, s2 = s2 + Math.imul(R, ce) | 0, n2 = n2 + Math.imul(C3, he) | 0, i2 = (i2 = i2 + Math.imul(C3, fe) | 0) + Math.imul(T2, he) | 0, s2 = s2 + Math.imul(T2, fe) | 0;
            var Ae = (c2 + (n2 = n2 + Math.imul(k2, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(k2, me) | 0) + Math.imul(S2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(S2, me) | 0) + (i2 >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, n2 = Math.imul(F, re), i2 = (i2 = Math.imul(F, ne)) + Math.imul(L, re) | 0, s2 = Math.imul(L, ne), n2 = n2 + Math.imul(P, se) | 0, i2 = (i2 = i2 + Math.imul(P, oe) | 0) + Math.imul(B, se) | 0, s2 = s2 + Math.imul(B, oe) | 0, n2 = n2 + Math.imul(j, le) | 0, i2 = (i2 = i2 + Math.imul(j, ce) | 0) + Math.imul(I, le) | 0, s2 = s2 + Math.imul(I, ce) | 0, n2 = n2 + Math.imul(A, he) | 0, i2 = (i2 = i2 + Math.imul(A, fe) | 0) + Math.imul(R, he) | 0, s2 = s2 + Math.imul(R, fe) | 0;
            var Re = (c2 + (n2 = n2 + Math.imul(C3, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(C3, me) | 0) + Math.imul(T2, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(T2, me) | 0) + (i2 >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, n2 = Math.imul(F, se), i2 = (i2 = Math.imul(F, oe)) + Math.imul(L, se) | 0, s2 = Math.imul(L, oe), n2 = n2 + Math.imul(P, le) | 0, i2 = (i2 = i2 + Math.imul(P, ce) | 0) + Math.imul(B, le) | 0, s2 = s2 + Math.imul(B, ce) | 0, n2 = n2 + Math.imul(j, he) | 0, i2 = (i2 = i2 + Math.imul(j, fe) | 0) + Math.imul(I, he) | 0, s2 = s2 + Math.imul(I, fe) | 0;
            var Oe = (c2 + (n2 = n2 + Math.imul(A, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(A, me) | 0) + Math.imul(R, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(R, me) | 0) + (i2 >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, n2 = Math.imul(F, le), i2 = (i2 = Math.imul(F, ce)) + Math.imul(L, le) | 0, s2 = Math.imul(L, ce), n2 = n2 + Math.imul(P, he) | 0, i2 = (i2 = i2 + Math.imul(P, fe) | 0) + Math.imul(B, he) | 0, s2 = s2 + Math.imul(B, fe) | 0;
            var je = (c2 + (n2 = n2 + Math.imul(j, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(j, me) | 0) + Math.imul(I, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(I, me) | 0) + (i2 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, n2 = Math.imul(F, he), i2 = (i2 = Math.imul(F, fe)) + Math.imul(L, he) | 0, s2 = Math.imul(L, fe);
            var Ie = (c2 + (n2 = n2 + Math.imul(P, pe) | 0) | 0) + ((8191 & (i2 = (i2 = i2 + Math.imul(P, me) | 0) + Math.imul(B, pe) | 0)) << 13) | 0;
            c2 = ((s2 = s2 + Math.imul(B, me) | 0) + (i2 >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863;
            var Ne = (c2 + (n2 = Math.imul(F, pe)) | 0) + ((8191 & (i2 = (i2 = Math.imul(F, me)) + Math.imul(L, pe) | 0)) << 13) | 0;
            return c2 = ((s2 = Math.imul(L, me)) + (i2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, l2[0] = be, l2[1] = ge, l2[2] = ye, l2[3] = ve, l2[4] = we, l2[5] = _e, l2[6] = xe, l2[7] = ke, l2[8] = Se, l2[9] = Me, l2[10] = Ce, l2[11] = Te, l2[12] = Ee, l2[13] = Ae, l2[14] = Re, l2[15] = Oe, l2[16] = je, l2[17] = Ie, l2[18] = Ne, 0 !== c2 && (l2[19] = c2, r3.length++), r3;
          };
          function g(e2, t4, r3) {
            r3.negative = t4.negative ^ e2.negative, r3.length = e2.length + t4.length;
            for (var n2 = 0, i2 = 0, s2 = 0; s2 < r3.length - 1; s2++) {
              var o2 = i2;
              i2 = 0;
              for (var a2 = 67108863 & n2, l2 = Math.min(s2, t4.length - 1), c2 = Math.max(0, s2 - e2.length + 1); c2 <= l2; c2++) {
                var u2 = s2 - c2, h2 = (0 | e2.words[u2]) * (0 | t4.words[c2]), f2 = 67108863 & h2;
                a2 = 67108863 & (f2 = f2 + a2 | 0), i2 += (o2 = (o2 = o2 + (h2 / 67108864 | 0) | 0) + (f2 >>> 26) | 0) >>> 26, o2 &= 67108863;
              }
              r3.words[s2] = a2, n2 = o2, o2 = i2;
            }
            return 0 !== n2 ? r3.words[s2] = n2 : r3.length--, r3._strip();
          }
          function y(e2, t4, r3) {
            return g(e2, t4, r3);
          }
          Math.imul || (b = m), s.prototype.mulTo = function(e2, t4) {
            var r3 = this.length + e2.length;
            return 10 === this.length && 10 === e2.length ? b(this, e2, t4) : r3 < 63 ? m(this, e2, t4) : r3 < 1024 ? g(this, e2, t4) : y(this, e2, t4);
          }, s.prototype.mul = function(e2) {
            var t4 = new s(null);
            return t4.words = new Array(this.length + e2.length), this.mulTo(e2, t4);
          }, s.prototype.mulf = function(e2) {
            var t4 = new s(null);
            return t4.words = new Array(this.length + e2.length), y(this, e2, t4);
          }, s.prototype.imul = function(e2) {
            return this.clone().mulTo(e2, this);
          }, s.prototype.imuln = function(e2) {
            var t4 = e2 < 0;
            t4 && (e2 = -e2), n("number" == typeof e2), n(e2 < 67108864);
            for (var r3 = 0, i2 = 0; i2 < this.length; i2++) {
              var s2 = (0 | this.words[i2]) * e2, o2 = (67108863 & s2) + (67108863 & r3);
              r3 >>= 26, r3 += s2 / 67108864 | 0, r3 += o2 >>> 26, this.words[i2] = 67108863 & o2;
            }
            return 0 !== r3 && (this.words[i2] = r3, this.length++), t4 ? this.ineg() : this;
          }, s.prototype.muln = function(e2) {
            return this.clone().imuln(e2);
          }, s.prototype.sqr = function() {
            return this.mul(this);
          }, s.prototype.isqr = function() {
            return this.imul(this.clone());
          }, s.prototype.pow = function(e2) {
            var t4 = (function(e3) {
              for (var t5 = new Array(e3.bitLength()), r4 = 0; r4 < t5.length; r4++) {
                var n3 = r4 / 26 | 0, i3 = r4 % 26;
                t5[r4] = e3.words[n3] >>> i3 & 1;
              }
              return t5;
            })(e2);
            if (0 === t4.length) return new s(1);
            for (var r3 = this, n2 = 0; n2 < t4.length && 0 === t4[n2]; n2++, r3 = r3.sqr()) ;
            if (++n2 < t4.length) for (var i2 = r3.sqr(); n2 < t4.length; n2++, i2 = i2.sqr()) 0 !== t4[n2] && (r3 = r3.mul(i2));
            return r3;
          }, s.prototype.iushln = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4, r3 = e2 % 26, i2 = (e2 - r3) / 26, s2 = 67108863 >>> 26 - r3 << 26 - r3;
            if (0 !== r3) {
              var o2 = 0;
              for (t4 = 0; t4 < this.length; t4++) {
                var a2 = this.words[t4] & s2, l2 = (0 | this.words[t4]) - a2 << r3;
                this.words[t4] = l2 | o2, o2 = a2 >>> 26 - r3;
              }
              o2 && (this.words[t4] = o2, this.length++);
            }
            if (0 !== i2) {
              for (t4 = this.length - 1; t4 >= 0; t4--) this.words[t4 + i2] = this.words[t4];
              for (t4 = 0; t4 < i2; t4++) this.words[t4] = 0;
              this.length += i2;
            }
            return this._strip();
          }, s.prototype.ishln = function(e2) {
            return n(0 === this.negative), this.iushln(e2);
          }, s.prototype.iushrn = function(e2, t4, r3) {
            var i2;
            n("number" == typeof e2 && e2 >= 0), i2 = t4 ? (t4 - t4 % 26) / 26 : 0;
            var s2 = e2 % 26, o2 = Math.min((e2 - s2) / 26, this.length), a2 = 67108863 ^ 67108863 >>> s2 << s2, l2 = r3;
            if (i2 -= o2, i2 = Math.max(0, i2), l2) {
              for (var c2 = 0; c2 < o2; c2++) l2.words[c2] = this.words[c2];
              l2.length = o2;
            }
            if (0 === o2) ;
            else if (this.length > o2) for (this.length -= o2, c2 = 0; c2 < this.length; c2++) this.words[c2] = this.words[c2 + o2];
            else this.words[0] = 0, this.length = 1;
            var u2 = 0;
            for (c2 = this.length - 1; c2 >= 0 && (0 !== u2 || c2 >= i2); c2--) {
              var h2 = 0 | this.words[c2];
              this.words[c2] = u2 << 26 - s2 | h2 >>> s2, u2 = h2 & a2;
            }
            return l2 && 0 !== u2 && (l2.words[l2.length++] = u2), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
          }, s.prototype.ishrn = function(e2, t4, r3) {
            return n(0 === this.negative), this.iushrn(e2, t4, r3);
          }, s.prototype.shln = function(e2) {
            return this.clone().ishln(e2);
          }, s.prototype.ushln = function(e2) {
            return this.clone().iushln(e2);
          }, s.prototype.shrn = function(e2) {
            return this.clone().ishrn(e2);
          }, s.prototype.ushrn = function(e2) {
            return this.clone().iushrn(e2);
          }, s.prototype.testn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26, i2 = 1 << t4;
            return !(this.length <= r3) && !!(this.words[r3] & i2);
          }, s.prototype.imaskn = function(e2) {
            n("number" == typeof e2 && e2 >= 0);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26;
            if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r3) return this;
            if (0 !== t4 && r3++, this.length = Math.min(r3, this.length), 0 !== t4) {
              var i2 = 67108863 ^ 67108863 >>> t4 << t4;
              this.words[this.length - 1] &= i2;
            }
            return this._strip();
          }, s.prototype.maskn = function(e2) {
            return this.clone().imaskn(e2);
          }, s.prototype.iaddn = function(e2) {
            return n("number" == typeof e2), n(e2 < 67108864), e2 < 0 ? this.isubn(-e2) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= e2 ? (this.words[0] = e2 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e2), this.negative = 1, this) : this._iaddn(e2);
          }, s.prototype._iaddn = function(e2) {
            this.words[0] += e2;
            for (var t4 = 0; t4 < this.length && this.words[t4] >= 67108864; t4++) this.words[t4] -= 67108864, t4 === this.length - 1 ? this.words[t4 + 1] = 1 : this.words[t4 + 1]++;
            return this.length = Math.max(this.length, t4 + 1), this;
          }, s.prototype.isubn = function(e2) {
            if (n("number" == typeof e2), n(e2 < 67108864), e2 < 0) return this.iaddn(-e2);
            if (0 !== this.negative) return this.negative = 0, this.iaddn(e2), this.negative = 1, this;
            if (this.words[0] -= e2, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else for (var t4 = 0; t4 < this.length && this.words[t4] < 0; t4++) this.words[t4] += 67108864, this.words[t4 + 1] -= 1;
            return this._strip();
          }, s.prototype.addn = function(e2) {
            return this.clone().iaddn(e2);
          }, s.prototype.subn = function(e2) {
            return this.clone().isubn(e2);
          }, s.prototype.iabs = function() {
            return this.negative = 0, this;
          }, s.prototype.abs = function() {
            return this.clone().iabs();
          }, s.prototype._ishlnsubmul = function(e2, t4, r3) {
            var i2, s2, o2 = e2.length + r3;
            this._expand(o2);
            var a2 = 0;
            for (i2 = 0; i2 < e2.length; i2++) {
              s2 = (0 | this.words[i2 + r3]) + a2;
              var l2 = (0 | e2.words[i2]) * t4;
              a2 = ((s2 -= 67108863 & l2) >> 26) - (l2 / 67108864 | 0), this.words[i2 + r3] = 67108863 & s2;
            }
            for (; i2 < this.length - r3; i2++) a2 = (s2 = (0 | this.words[i2 + r3]) + a2) >> 26, this.words[i2 + r3] = 67108863 & s2;
            if (0 === a2) return this._strip();
            for (n(-1 === a2), a2 = 0, i2 = 0; i2 < this.length; i2++) a2 = (s2 = -(0 | this.words[i2]) + a2) >> 26, this.words[i2] = 67108863 & s2;
            return this.negative = 1, this._strip();
          }, s.prototype._wordDiv = function(e2, t4) {
            var r3 = (this.length, e2.length), n2 = this.clone(), i2 = e2, o2 = 0 | i2.words[i2.length - 1];
            0 !== (r3 = 26 - this._countBits(o2)) && (i2 = i2.ushln(r3), n2.iushln(r3), o2 = 0 | i2.words[i2.length - 1]);
            var a2, l2 = n2.length - i2.length;
            if ("mod" !== t4) {
              (a2 = new s(null)).length = l2 + 1, a2.words = new Array(a2.length);
              for (var c2 = 0; c2 < a2.length; c2++) a2.words[c2] = 0;
            }
            var u2 = n2.clone()._ishlnsubmul(i2, 1, l2);
            0 === u2.negative && (n2 = u2, a2 && (a2.words[l2] = 1));
            for (var h2 = l2 - 1; h2 >= 0; h2--) {
              var f2 = 67108864 * (0 | n2.words[i2.length + h2]) + (0 | n2.words[i2.length + h2 - 1]);
              for (f2 = Math.min(f2 / o2 | 0, 67108863), n2._ishlnsubmul(i2, f2, h2); 0 !== n2.negative; ) f2--, n2.negative = 0, n2._ishlnsubmul(i2, 1, h2), n2.isZero() || (n2.negative ^= 1);
              a2 && (a2.words[h2] = f2);
            }
            return a2 && a2._strip(), n2._strip(), "div" !== t4 && 0 !== r3 && n2.iushrn(r3), { div: a2 || null, mod: n2 };
          }, s.prototype.divmod = function(e2, t4, r3) {
            return n(!e2.isZero()), this.isZero() ? { div: new s(0), mod: new s(0) } : 0 !== this.negative && 0 === e2.negative ? (a2 = this.neg().divmod(e2, t4), "mod" !== t4 && (i2 = a2.div.neg()), "div" !== t4 && (o2 = a2.mod.neg(), r3 && 0 !== o2.negative && o2.iadd(e2)), { div: i2, mod: o2 }) : 0 === this.negative && 0 !== e2.negative ? (a2 = this.divmod(e2.neg(), t4), "mod" !== t4 && (i2 = a2.div.neg()), { div: i2, mod: a2.mod }) : 0 != (this.negative & e2.negative) ? (a2 = this.neg().divmod(e2.neg(), t4), "div" !== t4 && (o2 = a2.mod.neg(), r3 && 0 !== o2.negative && o2.isub(e2)), { div: a2.div, mod: o2 }) : e2.length > this.length || this.cmp(e2) < 0 ? { div: new s(0), mod: this } : 1 === e2.length ? "div" === t4 ? { div: this.divn(e2.words[0]), mod: null } : "mod" === t4 ? { div: null, mod: new s(this.modrn(e2.words[0])) } : { div: this.divn(e2.words[0]), mod: new s(this.modrn(e2.words[0])) } : this._wordDiv(e2, t4);
            var i2, o2, a2;
          }, s.prototype.div = function(e2) {
            return this.divmod(e2, "div", false).div;
          }, s.prototype.mod = function(e2) {
            return this.divmod(e2, "mod", false).mod;
          }, s.prototype.umod = function(e2) {
            return this.divmod(e2, "mod", true).mod;
          }, s.prototype.divRound = function(e2) {
            var t4 = this.divmod(e2);
            if (t4.mod.isZero()) return t4.div;
            var r3 = 0 !== t4.div.negative ? t4.mod.isub(e2) : t4.mod, n2 = e2.ushrn(1), i2 = e2.andln(1), s2 = r3.cmp(n2);
            return s2 < 0 || 1 === i2 && 0 === s2 ? t4.div : 0 !== t4.div.negative ? t4.div.isubn(1) : t4.div.iaddn(1);
          }, s.prototype.modrn = function(e2) {
            var t4 = e2 < 0;
            t4 && (e2 = -e2), n(e2 <= 67108863);
            for (var r3 = (1 << 26) % e2, i2 = 0, s2 = this.length - 1; s2 >= 0; s2--) i2 = (r3 * i2 + (0 | this.words[s2])) % e2;
            return t4 ? -i2 : i2;
          }, s.prototype.modn = function(e2) {
            return this.modrn(e2);
          }, s.prototype.idivn = function(e2) {
            var t4 = e2 < 0;
            t4 && (e2 = -e2), n(e2 <= 67108863);
            for (var r3 = 0, i2 = this.length - 1; i2 >= 0; i2--) {
              var s2 = (0 | this.words[i2]) + 67108864 * r3;
              this.words[i2] = s2 / e2 | 0, r3 = s2 % e2;
            }
            return this._strip(), t4 ? this.ineg() : this;
          }, s.prototype.divn = function(e2) {
            return this.clone().idivn(e2);
          }, s.prototype.egcd = function(e2) {
            n(0 === e2.negative), n(!e2.isZero());
            var t4 = this, r3 = e2.clone();
            t4 = 0 !== t4.negative ? t4.umod(e2) : t4.clone();
            for (var i2 = new s(1), o2 = new s(0), a2 = new s(0), l2 = new s(1), c2 = 0; t4.isEven() && r3.isEven(); ) t4.iushrn(1), r3.iushrn(1), ++c2;
            for (var u2 = r3.clone(), h2 = t4.clone(); !t4.isZero(); ) {
              for (var f2 = 0, d2 = 1; 0 == (t4.words[0] & d2) && f2 < 26; ++f2, d2 <<= 1) ;
              if (f2 > 0) for (t4.iushrn(f2); f2-- > 0; ) (i2.isOdd() || o2.isOdd()) && (i2.iadd(u2), o2.isub(h2)), i2.iushrn(1), o2.iushrn(1);
              for (var p2 = 0, m2 = 1; 0 == (r3.words[0] & m2) && p2 < 26; ++p2, m2 <<= 1) ;
              if (p2 > 0) for (r3.iushrn(p2); p2-- > 0; ) (a2.isOdd() || l2.isOdd()) && (a2.iadd(u2), l2.isub(h2)), a2.iushrn(1), l2.iushrn(1);
              t4.cmp(r3) >= 0 ? (t4.isub(r3), i2.isub(a2), o2.isub(l2)) : (r3.isub(t4), a2.isub(i2), l2.isub(o2));
            }
            return { a: a2, b: l2, gcd: r3.iushln(c2) };
          }, s.prototype._invmp = function(e2) {
            n(0 === e2.negative), n(!e2.isZero());
            var t4 = this, r3 = e2.clone();
            t4 = 0 !== t4.negative ? t4.umod(e2) : t4.clone();
            for (var i2, o2 = new s(1), a2 = new s(0), l2 = r3.clone(); t4.cmpn(1) > 0 && r3.cmpn(1) > 0; ) {
              for (var c2 = 0, u2 = 1; 0 == (t4.words[0] & u2) && c2 < 26; ++c2, u2 <<= 1) ;
              if (c2 > 0) for (t4.iushrn(c2); c2-- > 0; ) o2.isOdd() && o2.iadd(l2), o2.iushrn(1);
              for (var h2 = 0, f2 = 1; 0 == (r3.words[0] & f2) && h2 < 26; ++h2, f2 <<= 1) ;
              if (h2 > 0) for (r3.iushrn(h2); h2-- > 0; ) a2.isOdd() && a2.iadd(l2), a2.iushrn(1);
              t4.cmp(r3) >= 0 ? (t4.isub(r3), o2.isub(a2)) : (r3.isub(t4), a2.isub(o2));
            }
            return (i2 = 0 === t4.cmpn(1) ? o2 : a2).cmpn(0) < 0 && i2.iadd(e2), i2;
          }, s.prototype.gcd = function(e2) {
            if (this.isZero()) return e2.abs();
            if (e2.isZero()) return this.abs();
            var t4 = this.clone(), r3 = e2.clone();
            t4.negative = 0, r3.negative = 0;
            for (var n2 = 0; t4.isEven() && r3.isEven(); n2++) t4.iushrn(1), r3.iushrn(1);
            for (; ; ) {
              for (; t4.isEven(); ) t4.iushrn(1);
              for (; r3.isEven(); ) r3.iushrn(1);
              var i2 = t4.cmp(r3);
              if (i2 < 0) {
                var s2 = t4;
                t4 = r3, r3 = s2;
              } else if (0 === i2 || 0 === r3.cmpn(1)) break;
              t4.isub(r3);
            }
            return r3.iushln(n2);
          }, s.prototype.invm = function(e2) {
            return this.egcd(e2).a.umod(e2);
          }, s.prototype.isEven = function() {
            return 0 == (1 & this.words[0]);
          }, s.prototype.isOdd = function() {
            return 1 == (1 & this.words[0]);
          }, s.prototype.andln = function(e2) {
            return this.words[0] & e2;
          }, s.prototype.bincn = function(e2) {
            n("number" == typeof e2);
            var t4 = e2 % 26, r3 = (e2 - t4) / 26, i2 = 1 << t4;
            if (this.length <= r3) return this._expand(r3 + 1), this.words[r3] |= i2, this;
            for (var s2 = i2, o2 = r3; 0 !== s2 && o2 < this.length; o2++) {
              var a2 = 0 | this.words[o2];
              s2 = (a2 += s2) >>> 26, a2 &= 67108863, this.words[o2] = a2;
            }
            return 0 !== s2 && (this.words[o2] = s2, this.length++), this;
          }, s.prototype.isZero = function() {
            return 1 === this.length && 0 === this.words[0];
          }, s.prototype.cmpn = function(e2) {
            var t4, r3 = e2 < 0;
            if (0 !== this.negative && !r3) return -1;
            if (0 === this.negative && r3) return 1;
            if (this._strip(), this.length > 1) t4 = 1;
            else {
              r3 && (e2 = -e2), n(e2 <= 67108863, "Number is too big");
              var i2 = 0 | this.words[0];
              t4 = i2 === e2 ? 0 : i2 < e2 ? -1 : 1;
            }
            return 0 !== this.negative ? 0 | -t4 : t4;
          }, s.prototype.cmp = function(e2) {
            if (0 !== this.negative && 0 === e2.negative) return -1;
            if (0 === this.negative && 0 !== e2.negative) return 1;
            var t4 = this.ucmp(e2);
            return 0 !== this.negative ? 0 | -t4 : t4;
          }, s.prototype.ucmp = function(e2) {
            if (this.length > e2.length) return 1;
            if (this.length < e2.length) return -1;
            for (var t4 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
              var n2 = 0 | this.words[r3], i2 = 0 | e2.words[r3];
              if (n2 !== i2) {
                n2 < i2 ? t4 = -1 : n2 > i2 && (t4 = 1);
                break;
              }
            }
            return t4;
          }, s.prototype.gtn = function(e2) {
            return 1 === this.cmpn(e2);
          }, s.prototype.gt = function(e2) {
            return 1 === this.cmp(e2);
          }, s.prototype.gten = function(e2) {
            return this.cmpn(e2) >= 0;
          }, s.prototype.gte = function(e2) {
            return this.cmp(e2) >= 0;
          }, s.prototype.ltn = function(e2) {
            return -1 === this.cmpn(e2);
          }, s.prototype.lt = function(e2) {
            return -1 === this.cmp(e2);
          }, s.prototype.lten = function(e2) {
            return this.cmpn(e2) <= 0;
          }, s.prototype.lte = function(e2) {
            return this.cmp(e2) <= 0;
          }, s.prototype.eqn = function(e2) {
            return 0 === this.cmpn(e2);
          }, s.prototype.eq = function(e2) {
            return 0 === this.cmp(e2);
          }, s.red = function(e2) {
            return new C2(e2);
          }, s.prototype.toRed = function(e2) {
            return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), e2.convertTo(this)._forceRed(e2);
          }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
          }, s.prototype._forceRed = function(e2) {
            return this.red = e2, this;
          }, s.prototype.forceRed = function(e2) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(e2);
          }, s.prototype.redAdd = function(e2) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, e2);
          }, s.prototype.redIAdd = function(e2) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e2);
          }, s.prototype.redSub = function(e2) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, e2);
          }, s.prototype.redISub = function(e2) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, e2);
          }, s.prototype.redShl = function(e2) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, e2);
          }, s.prototype.redMul = function(e2) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e2), this.red.mul(this, e2);
          }, s.prototype.redIMul = function(e2) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, e2), this.red.imul(this, e2);
          }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
          }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
          }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
          }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
          }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
          }, s.prototype.redPow = function(e2) {
            return n(this.red && !e2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e2);
          };
          var w = { k256: null, p224: null, p192: null, p25519: null };
          function _(e2, t4) {
            this.name = e2, this.p = new s(t4, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
          }
          function x() {
            _.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
          }
          function k() {
            _.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
          }
          function S() {
            _.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
          }
          function M() {
            _.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
          }
          function C2(e2) {
            if ("string" == typeof e2) {
              var t4 = s._prime(e2);
              this.m = t4.p, this.prime = t4;
            } else n(e2.gtn(1), "modulus must be greater than 1"), this.m = e2, this.prime = null;
          }
          function T(e2) {
            C2.call(this, e2), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
          }
          _.prototype._tmp = function() {
            var e2 = new s(null);
            return e2.words = new Array(Math.ceil(this.n / 13)), e2;
          }, _.prototype.ireduce = function(e2) {
            var t4, r3 = e2;
            do {
              this.split(r3, this.tmp), t4 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
            } while (t4 > this.n);
            var n2 = t4 < this.n ? -1 : r3.ucmp(this.p);
            return 0 === n2 ? (r3.words[0] = 0, r3.length = 1) : n2 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
          }, _.prototype.split = function(e2, t4) {
            e2.iushrn(this.n, 0, t4);
          }, _.prototype.imulK = function(e2) {
            return e2.imul(this.k);
          }, i(x, _), x.prototype.split = function(e2, t4) {
            for (var r3 = Math.min(e2.length, 9), n2 = 0; n2 < r3; n2++) t4.words[n2] = e2.words[n2];
            if (t4.length = r3, e2.length <= 9) return e2.words[0] = 0, void (e2.length = 1);
            var i2 = e2.words[9];
            for (t4.words[t4.length++] = 4194303 & i2, n2 = 10; n2 < e2.length; n2++) {
              var s2 = 0 | e2.words[n2];
              e2.words[n2 - 10] = (4194303 & s2) << 4 | i2 >>> 22, i2 = s2;
            }
            i2 >>>= 22, e2.words[n2 - 10] = i2, 0 === i2 && e2.length > 10 ? e2.length -= 10 : e2.length -= 9;
          }, x.prototype.imulK = function(e2) {
            e2.words[e2.length] = 0, e2.words[e2.length + 1] = 0, e2.length += 2;
            for (var t4 = 0, r3 = 0; r3 < e2.length; r3++) {
              var n2 = 0 | e2.words[r3];
              t4 += 977 * n2, e2.words[r3] = 67108863 & t4, t4 = 64 * n2 + (t4 / 67108864 | 0);
            }
            return 0 === e2.words[e2.length - 1] && (e2.length--, 0 === e2.words[e2.length - 1] && e2.length--), e2;
          }, i(k, _), i(S, _), i(M, _), M.prototype.imulK = function(e2) {
            for (var t4 = 0, r3 = 0; r3 < e2.length; r3++) {
              var n2 = 19 * (0 | e2.words[r3]) + t4, i2 = 67108863 & n2;
              n2 >>>= 26, e2.words[r3] = i2, t4 = n2;
            }
            return 0 !== t4 && (e2.words[e2.length++] = t4), e2;
          }, s._prime = function(e2) {
            if (w[e2]) return w[e2];
            var t4;
            if ("k256" === e2) t4 = new x();
            else if ("p224" === e2) t4 = new k();
            else if ("p192" === e2) t4 = new S();
            else {
              if ("p25519" !== e2) throw new Error("Unknown prime " + e2);
              t4 = new M();
            }
            return w[e2] = t4, t4;
          }, C2.prototype._verify1 = function(e2) {
            n(0 === e2.negative, "red works only with positives"), n(e2.red, "red works only with red numbers");
          }, C2.prototype._verify2 = function(e2, t4) {
            n(0 == (e2.negative | t4.negative), "red works only with positives"), n(e2.red && e2.red === t4.red, "red works only with red numbers");
          }, C2.prototype.imod = function(e2) {
            return this.prime ? this.prime.ireduce(e2)._forceRed(this) : (u(e2, e2.umod(this.m)._forceRed(this)), e2);
          }, C2.prototype.neg = function(e2) {
            return e2.isZero() ? e2.clone() : this.m.sub(e2)._forceRed(this);
          }, C2.prototype.add = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.add(t4);
            return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
          }, C2.prototype.iadd = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.iadd(t4);
            return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
          }, C2.prototype.sub = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.sub(t4);
            return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
          }, C2.prototype.isub = function(e2, t4) {
            this._verify2(e2, t4);
            var r3 = e2.isub(t4);
            return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
          }, C2.prototype.shl = function(e2, t4) {
            return this._verify1(e2), this.imod(e2.ushln(t4));
          }, C2.prototype.imul = function(e2, t4) {
            return this._verify2(e2, t4), this.imod(e2.imul(t4));
          }, C2.prototype.mul = function(e2, t4) {
            return this._verify2(e2, t4), this.imod(e2.mul(t4));
          }, C2.prototype.isqr = function(e2) {
            return this.imul(e2, e2.clone());
          }, C2.prototype.sqr = function(e2) {
            return this.mul(e2, e2);
          }, C2.prototype.sqrt = function(e2) {
            if (e2.isZero()) return e2.clone();
            var t4 = this.m.andln(3);
            if (n(t4 % 2 == 1), 3 === t4) {
              var r3 = this.m.add(new s(1)).iushrn(2);
              return this.pow(e2, r3);
            }
            for (var i2 = this.m.subn(1), o2 = 0; !i2.isZero() && 0 === i2.andln(1); ) o2++, i2.iushrn(1);
            n(!i2.isZero());
            var a2 = new s(1).toRed(this), l2 = a2.redNeg(), c2 = this.m.subn(1).iushrn(1), u2 = this.m.bitLength();
            for (u2 = new s(2 * u2 * u2).toRed(this); 0 !== this.pow(u2, c2).cmp(l2); ) u2.redIAdd(l2);
            for (var h2 = this.pow(u2, i2), f2 = this.pow(e2, i2.addn(1).iushrn(1)), d2 = this.pow(e2, i2), p2 = o2; 0 !== d2.cmp(a2); ) {
              for (var m2 = d2, b2 = 0; 0 !== m2.cmp(a2); b2++) m2 = m2.redSqr();
              n(b2 < p2);
              var g2 = this.pow(h2, new s(1).iushln(p2 - b2 - 1));
              f2 = f2.redMul(g2), h2 = g2.redSqr(), d2 = d2.redMul(h2), p2 = b2;
            }
            return f2;
          }, C2.prototype.invm = function(e2) {
            var t4 = e2._invmp(this.m);
            return 0 !== t4.negative ? (t4.negative = 0, this.imod(t4).redNeg()) : this.imod(t4);
          }, C2.prototype.pow = function(e2, t4) {
            if (t4.isZero()) return new s(1).toRed(this);
            if (0 === t4.cmpn(1)) return e2.clone();
            var r3 = new Array(16);
            r3[0] = new s(1).toRed(this), r3[1] = e2;
            for (var n2 = 2; n2 < r3.length; n2++) r3[n2] = this.mul(r3[n2 - 1], e2);
            var i2 = r3[0], o2 = 0, a2 = 0, l2 = t4.bitLength() % 26;
            for (0 === l2 && (l2 = 26), n2 = t4.length - 1; n2 >= 0; n2--) {
              for (var c2 = t4.words[n2], u2 = l2 - 1; u2 >= 0; u2--) {
                var h2 = c2 >> u2 & 1;
                i2 !== r3[0] && (i2 = this.sqr(i2)), 0 !== h2 || 0 !== o2 ? (o2 <<= 1, o2 |= h2, (4 === ++a2 || 0 === n2 && 0 === u2) && (i2 = this.mul(i2, r3[o2]), a2 = 0, o2 = 0)) : a2 = 0;
              }
              l2 = 26;
            }
            return i2;
          }, C2.prototype.convertTo = function(e2) {
            var t4 = e2.umod(this.m);
            return t4 === e2 ? t4.clone() : t4;
          }, C2.prototype.convertFrom = function(e2) {
            var t4 = e2.clone();
            return t4.red = null, t4;
          }, s.mont = function(e2) {
            return new T(e2);
          }, i(T, C2), T.prototype.convertTo = function(e2) {
            return this.imod(e2.ushln(this.shift));
          }, T.prototype.convertFrom = function(e2) {
            var t4 = this.imod(e2.mul(this.rinv));
            return t4.red = null, t4;
          }, T.prototype.imul = function(e2, t4) {
            if (e2.isZero() || t4.isZero()) return e2.words[0] = 0, e2.length = 1, e2;
            var r3 = e2.imul(t4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), s2 = i2;
            return i2.cmp(this.m) >= 0 ? s2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (s2 = i2.iadd(this.m)), s2._forceRed(this);
          }, T.prototype.mul = function(e2, t4) {
            if (e2.isZero() || t4.isZero()) return new s(0)._forceRed(this);
            var r3 = e2.mul(t4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i2 = r3.isub(n2).iushrn(this.shift), o2 = i2;
            return i2.cmp(this.m) >= 0 ? o2 = i2.isub(this.m) : i2.cmpn(0) < 0 && (o2 = i2.iadd(this.m)), o2._forceRed(this);
          }, T.prototype.invm = function(e2) {
            return this.imod(e2._invmp(this.m).mul(this.r2))._forceRed(this);
          };
        })(void 0 === t2 || t2);
      }, { buffer: 188 }], 187: [function(e, t2, r) {
        var n;
        function i(e2) {
          this.rand = e2;
        }
        if (t2.exports = function(e2) {
          return n || (n = new i(null)), n.generate(e2);
        }, t2.exports.Rand = i, i.prototype.generate = function(e2) {
          return this._rand(e2);
        }, i.prototype._rand = function(e2) {
          if (this.rand.getBytes) return this.rand.getBytes(e2);
          for (var t3 = new Uint8Array(e2), r2 = 0; r2 < t3.length; r2++) t3[r2] = this.rand.getByte();
          return t3;
        }, "object" == typeof self) self.crypto && self.crypto.getRandomValues ? i.prototype._rand = function(e2) {
          var t3 = new Uint8Array(e2);
          return self.crypto.getRandomValues(t3), t3;
        } : self.msCrypto && self.msCrypto.getRandomValues ? i.prototype._rand = function(e2) {
          var t3 = new Uint8Array(e2);
          return self.msCrypto.getRandomValues(t3), t3;
        } : "object" == typeof window && (i.prototype._rand = function() {
          throw new Error("Not implemented yet");
        });
        else try {
          var s = e("crypto");
          if ("function" != typeof s.randomBytes) throw new Error("Not supported");
          i.prototype._rand = function(e2) {
            return s.randomBytes(e2);
          };
        } catch (e2) {
        }
      }, { crypto: 188 }], 188: [function(e, t2, r) {
      }, {}], 189: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer;
        function i(e2) {
          n.isBuffer(e2) || (e2 = n.from(e2));
          for (var t3 = e2.length / 4 | 0, r2 = new Array(t3), i2 = 0; i2 < t3; i2++) r2[i2] = e2.readUInt32BE(4 * i2);
          return r2;
        }
        function s(e2) {
          for (; 0 < e2.length; e2++) e2[0] = 0;
        }
        function o(e2, t3, r2, n2, i2) {
          for (var s2, o2, a2, l2, c2 = r2[0], u = r2[1], h = r2[2], f = r2[3], d = e2[0] ^ t3[0], p = e2[1] ^ t3[1], m = e2[2] ^ t3[2], b = e2[3] ^ t3[3], g = 4, y = 1; y < i2; y++) s2 = c2[d >>> 24] ^ u[p >>> 16 & 255] ^ h[m >>> 8 & 255] ^ f[255 & b] ^ t3[g++], o2 = c2[p >>> 24] ^ u[m >>> 16 & 255] ^ h[b >>> 8 & 255] ^ f[255 & d] ^ t3[g++], a2 = c2[m >>> 24] ^ u[b >>> 16 & 255] ^ h[d >>> 8 & 255] ^ f[255 & p] ^ t3[g++], l2 = c2[b >>> 24] ^ u[d >>> 16 & 255] ^ h[p >>> 8 & 255] ^ f[255 & m] ^ t3[g++], d = s2, p = o2, m = a2, b = l2;
          return s2 = (n2[d >>> 24] << 24 | n2[p >>> 16 & 255] << 16 | n2[m >>> 8 & 255] << 8 | n2[255 & b]) ^ t3[g++], o2 = (n2[p >>> 24] << 24 | n2[m >>> 16 & 255] << 16 | n2[b >>> 8 & 255] << 8 | n2[255 & d]) ^ t3[g++], a2 = (n2[m >>> 24] << 24 | n2[b >>> 16 & 255] << 16 | n2[d >>> 8 & 255] << 8 | n2[255 & p]) ^ t3[g++], l2 = (n2[b >>> 24] << 24 | n2[d >>> 16 & 255] << 16 | n2[p >>> 8 & 255] << 8 | n2[255 & m]) ^ t3[g++], [s2 >>>= 0, o2 >>>= 0, a2 >>>= 0, l2 >>>= 0];
        }
        var a = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], l = (function() {
          for (var e2 = new Array(256), t3 = 0; t3 < 256; t3++) e2[t3] = t3 < 128 ? t3 << 1 : t3 << 1 ^ 283;
          for (var r2 = [], n2 = [], i2 = [[], [], [], []], s2 = [[], [], [], []], o2 = 0, a2 = 0, l2 = 0; l2 < 256; ++l2) {
            var c2 = a2 ^ a2 << 1 ^ a2 << 2 ^ a2 << 3 ^ a2 << 4;
            c2 = c2 >>> 8 ^ 255 & c2 ^ 99, r2[o2] = c2, n2[c2] = o2;
            var u = e2[o2], h = e2[u], f = e2[h], d = 257 * e2[c2] ^ 16843008 * c2;
            i2[0][o2] = d << 24 | d >>> 8, i2[1][o2] = d << 16 | d >>> 16, i2[2][o2] = d << 8 | d >>> 24, i2[3][o2] = d, d = 16843009 * f ^ 65537 * h ^ 257 * u ^ 16843008 * o2, s2[0][c2] = d << 24 | d >>> 8, s2[1][c2] = d << 16 | d >>> 16, s2[2][c2] = d << 8 | d >>> 24, s2[3][c2] = d, 0 === o2 ? o2 = a2 = 1 : (o2 = u ^ e2[e2[e2[f ^ u]]], a2 ^= e2[e2[a2]]);
          }
          return { SBOX: r2, INV_SBOX: n2, SUB_MIX: i2, INV_SUB_MIX: s2 };
        })();
        function c(e2) {
          this._key = i(e2), this._reset();
        }
        c.blockSize = 16, c.keySize = 32, c.prototype.blockSize = c.blockSize, c.prototype.keySize = c.keySize, c.prototype._reset = function() {
          for (var e2 = this._key, t3 = e2.length, r2 = t3 + 6, n2 = 4 * (r2 + 1), i2 = [], s2 = 0; s2 < t3; s2++) i2[s2] = e2[s2];
          for (s2 = t3; s2 < n2; s2++) {
            var o2 = i2[s2 - 1];
            s2 % t3 == 0 ? (o2 = o2 << 8 | o2 >>> 24, o2 = l.SBOX[o2 >>> 24] << 24 | l.SBOX[o2 >>> 16 & 255] << 16 | l.SBOX[o2 >>> 8 & 255] << 8 | l.SBOX[255 & o2], o2 ^= a[s2 / t3 | 0] << 24) : t3 > 6 && s2 % t3 == 4 && (o2 = l.SBOX[o2 >>> 24] << 24 | l.SBOX[o2 >>> 16 & 255] << 16 | l.SBOX[o2 >>> 8 & 255] << 8 | l.SBOX[255 & o2]), i2[s2] = i2[s2 - t3] ^ o2;
          }
          for (var c2 = [], u = 0; u < n2; u++) {
            var h = n2 - u, f = i2[h - (u % 4 ? 0 : 4)];
            c2[u] = u < 4 || h <= 4 ? f : l.INV_SUB_MIX[0][l.SBOX[f >>> 24]] ^ l.INV_SUB_MIX[1][l.SBOX[f >>> 16 & 255]] ^ l.INV_SUB_MIX[2][l.SBOX[f >>> 8 & 255]] ^ l.INV_SUB_MIX[3][l.SBOX[255 & f]];
          }
          this._nRounds = r2, this._keySchedule = i2, this._invKeySchedule = c2;
        }, c.prototype.encryptBlockRaw = function(e2) {
          return o(e2 = i(e2), this._keySchedule, l.SUB_MIX, l.SBOX, this._nRounds);
        }, c.prototype.encryptBlock = function(e2) {
          var t3 = this.encryptBlockRaw(e2), r2 = n.allocUnsafe(16);
          return r2.writeUInt32BE(t3[0], 0), r2.writeUInt32BE(t3[1], 4), r2.writeUInt32BE(t3[2], 8), r2.writeUInt32BE(t3[3], 12), r2;
        }, c.prototype.decryptBlock = function(e2) {
          var t3 = (e2 = i(e2))[1];
          e2[1] = e2[3], e2[3] = t3;
          var r2 = o(e2, this._invKeySchedule, l.INV_SUB_MIX, l.INV_SBOX, this._nRounds), s2 = n.allocUnsafe(16);
          return s2.writeUInt32BE(r2[0], 0), s2.writeUInt32BE(r2[3], 4), s2.writeUInt32BE(r2[2], 8), s2.writeUInt32BE(r2[1], 12), s2;
        }, c.prototype.scrub = function() {
          s(this._keySchedule), s(this._invKeySchedule), s(this._key);
        }, t2.exports.AES = c;
      }, { "safe-buffer": 494 }], 190: [function(e, t2, r) {
        var n = e("./aes"), i = e("safe-buffer").Buffer, s = e("cipher-base"), o = e("inherits"), a = e("./ghash"), l = e("buffer-xor"), c = e("./incr32");
        function u(e2, t3, r2, o2) {
          s.call(this);
          var l2 = i.alloc(4, 0);
          this._cipher = new n.AES(t3);
          var u2 = this._cipher.encryptBlock(l2);
          this._ghash = new a(u2), r2 = (function(e3, t4, r3) {
            if (12 === t4.length) return e3._finID = i.concat([t4, i.from([0, 0, 0, 1])]), i.concat([t4, i.from([0, 0, 0, 2])]);
            var n2 = new a(r3), s2 = t4.length, o3 = s2 % 16;
            n2.update(t4), o3 && (o3 = 16 - o3, n2.update(i.alloc(o3, 0))), n2.update(i.alloc(8, 0));
            var l3 = 8 * s2, u3 = i.alloc(8);
            u3.writeUIntBE(l3, 0, 8), n2.update(u3), e3._finID = n2.state;
            var h = i.from(e3._finID);
            return c(h), h;
          })(this, r2, u2), this._prev = i.from(r2), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = o2, this._alen = 0, this._len = 0, this._mode = e2, this._authTag = null, this._called = false;
        }
        o(u, s), u.prototype._update = function(e2) {
          if (!this._called && this._alen) {
            var t3 = 16 - this._alen % 16;
            t3 < 16 && (t3 = i.alloc(t3, 0), this._ghash.update(t3));
          }
          this._called = true;
          var r2 = this._mode.encrypt(this, e2);
          return this._decrypt ? this._ghash.update(e2) : this._ghash.update(r2), this._len += e2.length, r2;
        }, u.prototype._final = function() {
          if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
          var e2 = l(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
          if (this._decrypt && (function(e3, t3) {
            var r2 = 0;
            e3.length !== t3.length && r2++;
            for (var n2 = Math.min(e3.length, t3.length), i2 = 0; i2 < n2; ++i2) r2 += e3[i2] ^ t3[i2];
            return r2;
          })(e2, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
          this._authTag = e2, this._cipher.scrub();
        }, u.prototype.getAuthTag = function() {
          if (this._decrypt || !i.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
          return this._authTag;
        }, u.prototype.setAuthTag = function(e2) {
          if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
          this._authTag = e2;
        }, u.prototype.setAAD = function(e2) {
          if (this._called) throw new Error("Attempting to set AAD in unsupported state");
          this._ghash.update(e2), this._alen += e2.length;
        }, t2.exports = u;
      }, { "./aes": 189, "./ghash": 194, "./incr32": 195, "buffer-xor": 219, "cipher-base": 221, inherits: 440, "safe-buffer": 494 }], 191: [function(e, t2, r) {
        var n = e("./encrypter"), i = e("./decrypter"), s = e("./modes/list.json");
        r.createCipher = r.Cipher = n.createCipher, r.createCipheriv = r.Cipheriv = n.createCipheriv, r.createDecipher = r.Decipher = i.createDecipher, r.createDecipheriv = r.Decipheriv = i.createDecipheriv, r.listCiphers = r.getCiphers = function() {
          return Object.keys(s);
        };
      }, { "./decrypter": 192, "./encrypter": 193, "./modes/list.json": 203 }], 192: [function(e, t2, r) {
        var n = e("./authCipher"), i = e("safe-buffer").Buffer, s = e("./modes"), o = e("./streamCipher"), a = e("cipher-base"), l = e("./aes"), c = e("evp_bytestokey");
        function u(e2, t3, r2) {
          a.call(this), this._cache = new h(), this._last = void 0, this._cipher = new l.AES(t3), this._prev = i.from(r2), this._mode = e2, this._autopadding = true;
        }
        function h() {
          this.cache = i.allocUnsafe(0);
        }
        function f(e2, t3, r2) {
          var a2 = s[e2.toLowerCase()];
          if (!a2) throw new TypeError("invalid suite type");
          if ("string" == typeof r2 && (r2 = i.from(r2)), "GCM" !== a2.mode && r2.length !== a2.iv) throw new TypeError("invalid iv length " + r2.length);
          if ("string" == typeof t3 && (t3 = i.from(t3)), t3.length !== a2.key / 8) throw new TypeError("invalid key length " + t3.length);
          return "stream" === a2.type ? new o(a2.module, t3, r2, true) : "auth" === a2.type ? new n(a2.module, t3, r2, true) : new u(a2.module, t3, r2);
        }
        e("inherits")(u, a), u.prototype._update = function(e2) {
          var t3, r2;
          this._cache.add(e2);
          for (var n2 = []; t3 = this._cache.get(this._autopadding); ) r2 = this._mode.decrypt(this, t3), n2.push(r2);
          return i.concat(n2);
        }, u.prototype._final = function() {
          var e2 = this._cache.flush();
          if (this._autopadding) return (function(e3) {
            var t3 = e3[15];
            if (t3 < 1 || t3 > 16) throw new Error("unable to decrypt data");
            var r2 = -1;
            for (; ++r2 < t3; ) if (e3[r2 + (16 - t3)] !== t3) throw new Error("unable to decrypt data");
            if (16 === t3) return;
            return e3.slice(0, 16 - t3);
          })(this._mode.decrypt(this, e2));
          if (e2) throw new Error("data not multiple of block length");
        }, u.prototype.setAutoPadding = function(e2) {
          return this._autopadding = !!e2, this;
        }, h.prototype.add = function(e2) {
          this.cache = i.concat([this.cache, e2]);
        }, h.prototype.get = function(e2) {
          var t3;
          if (e2) {
            if (this.cache.length > 16) return t3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t3;
          } else if (this.cache.length >= 16) return t3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t3;
          return null;
        }, h.prototype.flush = function() {
          if (this.cache.length) return this.cache;
        }, r.createDecipher = function(e2, t3) {
          var r2 = s[e2.toLowerCase()];
          if (!r2) throw new TypeError("invalid suite type");
          var n2 = c(t3, false, r2.key, r2.iv);
          return f(e2, n2.key, n2.iv);
        }, r.createDecipheriv = f;
      }, { "./aes": 189, "./authCipher": 190, "./modes": 202, "./streamCipher": 205, "cipher-base": 221, evp_bytestokey: 423, inherits: 440, "safe-buffer": 494 }], 193: [function(e, t2, r) {
        var n = e("./modes"), i = e("./authCipher"), s = e("safe-buffer").Buffer, o = e("./streamCipher"), a = e("cipher-base"), l = e("./aes"), c = e("evp_bytestokey");
        function u(e2, t3, r2) {
          a.call(this), this._cache = new f(), this._cipher = new l.AES(t3), this._prev = s.from(r2), this._mode = e2, this._autopadding = true;
        }
        e("inherits")(u, a), u.prototype._update = function(e2) {
          var t3, r2;
          this._cache.add(e2);
          for (var n2 = []; t3 = this._cache.get(); ) r2 = this._mode.encrypt(this, t3), n2.push(r2);
          return s.concat(n2);
        };
        var h = s.alloc(16, 16);
        function f() {
          this.cache = s.allocUnsafe(0);
        }
        function d(e2, t3, r2) {
          var a2 = n[e2.toLowerCase()];
          if (!a2) throw new TypeError("invalid suite type");
          if ("string" == typeof t3 && (t3 = s.from(t3)), t3.length !== a2.key / 8) throw new TypeError("invalid key length " + t3.length);
          if ("string" == typeof r2 && (r2 = s.from(r2)), "GCM" !== a2.mode && r2.length !== a2.iv) throw new TypeError("invalid iv length " + r2.length);
          return "stream" === a2.type ? new o(a2.module, t3, r2) : "auth" === a2.type ? new i(a2.module, t3, r2) : new u(a2.module, t3, r2);
        }
        u.prototype._final = function() {
          var e2 = this._cache.flush();
          if (this._autopadding) return e2 = this._mode.encrypt(this, e2), this._cipher.scrub(), e2;
          if (!e2.equals(h)) throw this._cipher.scrub(), new Error("data not multiple of block length");
        }, u.prototype.setAutoPadding = function(e2) {
          return this._autopadding = !!e2, this;
        }, f.prototype.add = function(e2) {
          this.cache = s.concat([this.cache, e2]);
        }, f.prototype.get = function() {
          if (this.cache.length > 15) {
            var e2 = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), e2;
          }
          return null;
        }, f.prototype.flush = function() {
          for (var e2 = 16 - this.cache.length, t3 = s.allocUnsafe(e2), r2 = -1; ++r2 < e2; ) t3.writeUInt8(e2, r2);
          return s.concat([this.cache, t3]);
        }, r.createCipheriv = d, r.createCipher = function(e2, t3) {
          var r2 = n[e2.toLowerCase()];
          if (!r2) throw new TypeError("invalid suite type");
          var i2 = c(t3, false, r2.key, r2.iv);
          return d(e2, i2.key, i2.iv);
        };
      }, { "./aes": 189, "./authCipher": 190, "./modes": 202, "./streamCipher": 205, "cipher-base": 221, evp_bytestokey: 423, inherits: 440, "safe-buffer": 494 }], 194: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = n.alloc(16, 0);
        function s(e2) {
          var t3 = n.allocUnsafe(16);
          return t3.writeUInt32BE(e2[0] >>> 0, 0), t3.writeUInt32BE(e2[1] >>> 0, 4), t3.writeUInt32BE(e2[2] >>> 0, 8), t3.writeUInt32BE(e2[3] >>> 0, 12), t3;
        }
        function o(e2) {
          this.h = e2, this.state = n.alloc(16, 0), this.cache = n.allocUnsafe(0);
        }
        o.prototype.ghash = function(e2) {
          for (var t3 = -1; ++t3 < e2.length; ) this.state[t3] ^= e2[t3];
          this._multiply();
        }, o.prototype._multiply = function() {
          for (var e2, t3, r2, n2 = [(e2 = this.h).readUInt32BE(0), e2.readUInt32BE(4), e2.readUInt32BE(8), e2.readUInt32BE(12)], i2 = [0, 0, 0, 0], o2 = -1; ++o2 < 128; ) {
            for (0 != (this.state[~~(o2 / 8)] & 1 << 7 - o2 % 8) && (i2[0] ^= n2[0], i2[1] ^= n2[1], i2[2] ^= n2[2], i2[3] ^= n2[3]), r2 = 0 != (1 & n2[3]), t3 = 3; t3 > 0; t3--) n2[t3] = n2[t3] >>> 1 | (1 & n2[t3 - 1]) << 31;
            n2[0] = n2[0] >>> 1, r2 && (n2[0] = n2[0] ^ 225 << 24);
          }
          this.state = s(i2);
        }, o.prototype.update = function(e2) {
          var t3;
          for (this.cache = n.concat([this.cache, e2]); this.cache.length >= 16; ) t3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t3);
        }, o.prototype.final = function(e2, t3) {
          return this.cache.length && this.ghash(n.concat([this.cache, i], 16)), this.ghash(s([0, e2, 0, t3])), this.state;
        }, t2.exports = o;
      }, { "safe-buffer": 494 }], 195: [function(e, t2, r) {
        t2.exports = function(e2) {
          for (var t3, r2 = e2.length; r2--; ) {
            if (255 !== (t3 = e2.readUInt8(r2))) {
              t3++, e2.writeUInt8(t3, r2);
              break;
            }
            e2.writeUInt8(0, r2);
          }
        };
      }, {}], 196: [function(e, t2, r) {
        var n = e("buffer-xor");
        r.encrypt = function(e2, t3) {
          var r2 = n(t3, e2._prev);
          return e2._prev = e2._cipher.encryptBlock(r2), e2._prev;
        }, r.decrypt = function(e2, t3) {
          var r2 = e2._prev;
          e2._prev = t3;
          var i = e2._cipher.decryptBlock(t3);
          return n(i, r2);
        };
      }, { "buffer-xor": 219 }], 197: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("buffer-xor");
        function s(e2, t3, r2) {
          var s2 = t3.length, o = i(t3, e2._cache);
          return e2._cache = e2._cache.slice(s2), e2._prev = n.concat([e2._prev, r2 ? t3 : o]), o;
        }
        r.encrypt = function(e2, t3, r2) {
          for (var i2, o = n.allocUnsafe(0); t3.length; ) {
            if (0 === e2._cache.length && (e2._cache = e2._cipher.encryptBlock(e2._prev), e2._prev = n.allocUnsafe(0)), !(e2._cache.length <= t3.length)) {
              o = n.concat([o, s(e2, t3, r2)]);
              break;
            }
            i2 = e2._cache.length, o = n.concat([o, s(e2, t3.slice(0, i2), r2)]), t3 = t3.slice(i2);
          }
          return o;
        };
      }, { "buffer-xor": 219, "safe-buffer": 494 }], 198: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer;
        function i(e2, t3, r2) {
          for (var n2, i2, o = -1, a = 0; ++o < 8; ) n2 = t3 & 1 << 7 - o ? 128 : 0, a += (128 & (i2 = e2._cipher.encryptBlock(e2._prev)[0] ^ n2)) >> o % 8, e2._prev = s(e2._prev, r2 ? n2 : i2);
          return a;
        }
        function s(e2, t3) {
          var r2 = e2.length, i2 = -1, s2 = n.allocUnsafe(e2.length);
          for (e2 = n.concat([e2, n.from([t3])]); ++i2 < r2; ) s2[i2] = e2[i2] << 1 | e2[i2 + 1] >> 7;
          return s2;
        }
        r.encrypt = function(e2, t3, r2) {
          for (var s2 = t3.length, o = n.allocUnsafe(s2), a = -1; ++a < s2; ) o[a] = i(e2, t3[a], r2);
          return o;
        };
      }, { "safe-buffer": 494 }], 199: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer;
        function i(e2, t3, r2) {
          var i2 = e2._cipher.encryptBlock(e2._prev)[0] ^ t3;
          return e2._prev = n.concat([e2._prev.slice(1), n.from([r2 ? t3 : i2])]), i2;
        }
        r.encrypt = function(e2, t3, r2) {
          for (var s = t3.length, o = n.allocUnsafe(s), a = -1; ++a < s; ) o[a] = i(e2, t3[a], r2);
          return o;
        };
      }, { "safe-buffer": 494 }], 200: [function(e, t2, r) {
        var n = e("buffer-xor"), i = e("safe-buffer").Buffer, s = e("../incr32");
        function o(e2) {
          var t3 = e2._cipher.encryptBlockRaw(e2._prev);
          return s(e2._prev), t3;
        }
        r.encrypt = function(e2, t3) {
          var r2 = Math.ceil(t3.length / 16), s2 = e2._cache.length;
          e2._cache = i.concat([e2._cache, i.allocUnsafe(16 * r2)]);
          for (var a = 0; a < r2; a++) {
            var l = o(e2), c = s2 + 16 * a;
            e2._cache.writeUInt32BE(l[0], c + 0), e2._cache.writeUInt32BE(l[1], c + 4), e2._cache.writeUInt32BE(l[2], c + 8), e2._cache.writeUInt32BE(l[3], c + 12);
          }
          var u = e2._cache.slice(0, t3.length);
          return e2._cache = e2._cache.slice(t3.length), n(t3, u);
        };
      }, { "../incr32": 195, "buffer-xor": 219, "safe-buffer": 494 }], 201: [function(e, t2, r) {
        r.encrypt = function(e2, t3) {
          return e2._cipher.encryptBlock(t3);
        }, r.decrypt = function(e2, t3) {
          return e2._cipher.decryptBlock(t3);
        };
      }, {}], 202: [function(e, t2, r) {
        var n = { ECB: e("./ecb"), CBC: e("./cbc"), CFB: e("./cfb"), CFB8: e("./cfb8"), CFB1: e("./cfb1"), OFB: e("./ofb"), CTR: e("./ctr"), GCM: e("./ctr") }, i = e("./list.json");
        for (var s in i) i[s].module = n[i[s].mode];
        t2.exports = i;
      }, { "./cbc": 196, "./cfb": 197, "./cfb1": 198, "./cfb8": 199, "./ctr": 200, "./ecb": 201, "./list.json": 203, "./ofb": 204 }], 203: [function(e, t2, r) {
        t2.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
      }, {}], 204: [function(e, t2, r) {
        (function(t3) {
          (function() {
            var n = e("buffer-xor");
            function i(e2) {
              return e2._prev = e2._cipher.encryptBlock(e2._prev), e2._prev;
            }
            r.encrypt = function(e2, r2) {
              for (; e2._cache.length < r2.length; ) e2._cache = t3.concat([e2._cache, i(e2)]);
              var s = e2._cache.slice(0, r2.length);
              return e2._cache = e2._cache.slice(r2.length), n(r2, s);
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 220, "buffer-xor": 219 }], 205: [function(e, t2, r) {
        var n = e("./aes"), i = e("safe-buffer").Buffer, s = e("cipher-base");
        function o(e2, t3, r2, o2) {
          s.call(this), this._cipher = new n.AES(t3), this._prev = i.from(r2), this._cache = i.allocUnsafe(0), this._secCache = i.allocUnsafe(0), this._decrypt = o2, this._mode = e2;
        }
        e("inherits")(o, s), o.prototype._update = function(e2) {
          return this._mode.encrypt(this, e2, this._decrypt);
        }, o.prototype._final = function() {
          this._cipher.scrub();
        }, t2.exports = o;
      }, { "./aes": 189, "cipher-base": 221, inherits: 440, "safe-buffer": 494 }], 206: [function(e, t2, r) {
        var n = e("browserify-des"), i = e("browserify-aes/browser"), s = e("browserify-aes/modes"), o = e("browserify-des/modes"), a = e("evp_bytestokey");
        function l(e2, t3, r2) {
          if (e2 = e2.toLowerCase(), s[e2]) return i.createCipheriv(e2, t3, r2);
          if (o[e2]) return new n({ key: t3, iv: r2, mode: e2 });
          throw new TypeError("invalid suite type");
        }
        function c(e2, t3, r2) {
          if (e2 = e2.toLowerCase(), s[e2]) return i.createDecipheriv(e2, t3, r2);
          if (o[e2]) return new n({ key: t3, iv: r2, mode: e2, decrypt: true });
          throw new TypeError("invalid suite type");
        }
        r.createCipher = r.Cipher = function(e2, t3) {
          var r2, n2;
          if (e2 = e2.toLowerCase(), s[e2]) r2 = s[e2].key, n2 = s[e2].iv;
          else {
            if (!o[e2]) throw new TypeError("invalid suite type");
            r2 = 8 * o[e2].key, n2 = o[e2].iv;
          }
          var i2 = a(t3, false, r2, n2);
          return l(e2, i2.key, i2.iv);
        }, r.createCipheriv = r.Cipheriv = l, r.createDecipher = r.Decipher = function(e2, t3) {
          var r2, n2;
          if (e2 = e2.toLowerCase(), s[e2]) r2 = s[e2].key, n2 = s[e2].iv;
          else {
            if (!o[e2]) throw new TypeError("invalid suite type");
            r2 = 8 * o[e2].key, n2 = o[e2].iv;
          }
          var i2 = a(t3, false, r2, n2);
          return c(e2, i2.key, i2.iv);
        }, r.createDecipheriv = r.Decipheriv = c, r.listCiphers = r.getCiphers = function() {
          return Object.keys(o).concat(i.getCiphers());
        };
      }, { "browserify-aes/browser": 191, "browserify-aes/modes": 202, "browserify-des": 207, "browserify-des/modes": 208, evp_bytestokey: 423 }], 207: [function(e, t2, r) {
        var n = e("cipher-base"), i = e("des.js"), s = e("inherits"), o = e("safe-buffer").Buffer, a = { "des-ede3-cbc": i.CBC.instantiate(i.EDE), "des-ede3": i.EDE, "des-ede-cbc": i.CBC.instantiate(i.EDE), "des-ede": i.EDE, "des-cbc": i.CBC.instantiate(i.DES), "des-ecb": i.DES };
        function l(e2) {
          n.call(this);
          var t3, r2 = e2.mode.toLowerCase(), i2 = a[r2];
          t3 = e2.decrypt ? "decrypt" : "encrypt";
          var s2 = e2.key;
          o.isBuffer(s2) || (s2 = o.from(s2)), "des-ede" !== r2 && "des-ede-cbc" !== r2 || (s2 = o.concat([s2, s2.slice(0, 8)]));
          var l2 = e2.iv;
          o.isBuffer(l2) || (l2 = o.from(l2)), this._des = i2.create({ key: s2, iv: l2, type: t3 });
        }
        a.des = a["des-cbc"], a.des3 = a["des-ede3-cbc"], t2.exports = l, s(l, n), l.prototype._update = function(e2) {
          return o.from(this._des.update(e2));
        }, l.prototype._final = function() {
          return o.from(this._des.final());
        };
      }, { "cipher-base": 221, "des.js": 394, inherits: 440, "safe-buffer": 494 }], 208: [function(e, t2, r) {
        r["des-ecb"] = { key: 8, iv: 0 }, r["des-cbc"] = r.des = { key: 8, iv: 8 }, r["des-ede3-cbc"] = r.des3 = { key: 24, iv: 8 }, r["des-ede3"] = { key: 24, iv: 0 }, r["des-ede-cbc"] = { key: 16, iv: 8 }, r["des-ede"] = { key: 16, iv: 0 };
      }, {}], 209: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n = e("bn.js"), i = e("randombytes");
            function s(e2) {
              var t3, r3 = e2.modulus.byteLength();
              do {
                t3 = new n(i(r3));
              } while (t3.cmp(e2.modulus) >= 0 || !t3.umod(e2.prime1) || !t3.umod(e2.prime2));
              return t3;
            }
            function o(e2, t3) {
              var i2 = (function(e3) {
                var t4 = s(e3);
                return { blinder: t4.toRed(n.mont(e3.modulus)).redPow(new n(e3.publicExponent)).fromRed(), unblinder: t4.invm(e3.modulus) };
              })(t3), o2 = t3.modulus.byteLength(), a = new n(e2).mul(i2.blinder).umod(t3.modulus), l = a.toRed(n.mont(t3.prime1)), c = a.toRed(n.mont(t3.prime2)), u = t3.coefficient, h = t3.prime1, f = t3.prime2, d = l.redPow(t3.exponent1).fromRed(), p = c.redPow(t3.exponent2).fromRed(), m = d.isub(p).imul(u).umod(h).imul(f);
              return p.iadd(m).imul(i2.unblinder).umod(t3.modulus).toArrayLike(r2, "be", o2);
            }
            o.getr = s, t2.exports = o;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "bn.js": 186, buffer: 220, randombytes: 475 }], 210: [function(e, t2, r) {
        t2.exports = e("./browser/algorithms.json");
      }, { "./browser/algorithms.json": 211 }], 211: [function(e, t2, r) {
        t2.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
      }, {}], 212: [function(e, t2, r) {
        t2.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
      }, {}], 213: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("create-hash"), s = e("readable-stream"), o = e("inherits"), a = e("./sign"), l = e("./verify"), c = e("./algorithms.json");
        function u(e2) {
          s.Writable.call(this);
          var t3 = c[e2];
          if (!t3) throw new Error("Unknown message digest");
          this._hashType = t3.hash, this._hash = i(t3.hash), this._tag = t3.id, this._signType = t3.sign;
        }
        function h(e2) {
          s.Writable.call(this);
          var t3 = c[e2];
          if (!t3) throw new Error("Unknown message digest");
          this._hash = i(t3.hash), this._tag = t3.id, this._signType = t3.sign;
        }
        function f(e2) {
          return new u(e2);
        }
        function d(e2) {
          return new h(e2);
        }
        Object.keys(c).forEach((function(e2) {
          c[e2].id = n.from(c[e2].id, "hex"), c[e2.toLowerCase()] = c[e2];
        })), o(u, s.Writable), u.prototype._write = function(e2, t3, r2) {
          this._hash.update(e2), r2();
        }, u.prototype.update = function(e2, t3) {
          return "string" == typeof e2 && (e2 = n.from(e2, t3)), this._hash.update(e2), this;
        }, u.prototype.sign = function(e2, t3) {
          this.end();
          var r2 = this._hash.digest(), n2 = a(r2, e2, this._hashType, this._signType, this._tag);
          return t3 ? n2.toString(t3) : n2;
        }, o(h, s.Writable), h.prototype._write = function(e2, t3, r2) {
          this._hash.update(e2), r2();
        }, h.prototype.update = function(e2, t3) {
          return "string" == typeof e2 && (e2 = n.from(e2, t3)), this._hash.update(e2), this;
        }, h.prototype.verify = function(e2, t3, r2) {
          "string" == typeof t3 && (t3 = n.from(t3, r2)), this.end();
          var i2 = this._hash.digest();
          return l(t3, i2, e2, this._signType, this._tag);
        }, t2.exports = { Sign: f, Verify: d, createSign: f, createVerify: d };
      }, { "./algorithms.json": 211, "./sign": 214, "./verify": 215, "create-hash": 386, inherits: 440, "readable-stream": 491, "safe-buffer": 494 }], 214: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("create-hmac"), s = e("browserify-rsa"), o = e("elliptic").ec, a = e("bn.js"), l = e("parse-asn1"), c = e("./curves.json");
        function u(e2, t3, r2, s2) {
          if ((e2 = n.from(e2.toArray())).length < t3.byteLength()) {
            var o2 = n.alloc(t3.byteLength() - e2.length);
            e2 = n.concat([o2, e2]);
          }
          var a2 = r2.length, l2 = (function(e3, t4) {
            e3 = (e3 = h(e3, t4)).mod(t4);
            var r3 = n.from(e3.toArray());
            if (r3.length < t4.byteLength()) {
              var i2 = n.alloc(t4.byteLength() - r3.length);
              r3 = n.concat([i2, r3]);
            }
            return r3;
          })(r2, t3), c2 = n.alloc(a2);
          c2.fill(1);
          var u2 = n.alloc(a2);
          return u2 = i(s2, u2).update(c2).update(n.from([0])).update(e2).update(l2).digest(), c2 = i(s2, u2).update(c2).digest(), { k: u2 = i(s2, u2).update(c2).update(n.from([1])).update(e2).update(l2).digest(), v: c2 = i(s2, u2).update(c2).digest() };
        }
        function h(e2, t3) {
          var r2 = new a(e2), n2 = (e2.length << 3) - t3.bitLength();
          return n2 > 0 && r2.ishrn(n2), r2;
        }
        function f(e2, t3, r2) {
          var s2, o2;
          do {
            for (s2 = n.alloc(0); 8 * s2.length < e2.bitLength(); ) t3.v = i(r2, t3.k).update(t3.v).digest(), s2 = n.concat([s2, t3.v]);
            o2 = h(s2, e2), t3.k = i(r2, t3.k).update(t3.v).update(n.from([0])).digest(), t3.v = i(r2, t3.k).update(t3.v).digest();
          } while (-1 !== o2.cmp(e2));
          return o2;
        }
        function d(e2, t3, r2, n2) {
          return e2.toRed(a.mont(r2)).redPow(t3).fromRed().mod(n2);
        }
        t2.exports = function(e2, t3, r2, i2, p) {
          var m = l(t3);
          if (m.curve) {
            if ("ecdsa" !== i2 && "ecdsa/rsa" !== i2) throw new Error("wrong private key type");
            return (function(e3, t4) {
              var r3 = c[t4.curve.join(".")];
              if (!r3) throw new Error("unknown curve " + t4.curve.join("."));
              var i3 = new o(r3).keyFromPrivate(t4.privateKey).sign(e3);
              return n.from(i3.toDER());
            })(e2, m);
          }
          if ("dsa" === m.type) {
            if ("dsa" !== i2) throw new Error("wrong private key type");
            return (function(e3, t4, r3) {
              var i3, s2 = t4.params.priv_key, o2 = t4.params.p, l2 = t4.params.q, c2 = t4.params.g, p2 = new a(0), m2 = h(e3, l2).mod(l2), b2 = false, g2 = u(s2, l2, e3, r3);
              for (; false === b2; ) i3 = f(l2, g2, r3), p2 = d(c2, i3, o2, l2), 0 === (b2 = i3.invm(l2).imul(m2.add(s2.mul(p2))).mod(l2)).cmpn(0) && (b2 = false, p2 = new a(0));
              return (function(e4, t5) {
                e4 = e4.toArray(), t5 = t5.toArray(), 128 & e4[0] && (e4 = [0].concat(e4));
                128 & t5[0] && (t5 = [0].concat(t5));
                var r4 = [48, e4.length + t5.length + 4, 2, e4.length];
                return r4 = r4.concat(e4, [2, t5.length], t5), n.from(r4);
              })(p2, b2);
            })(e2, m, r2);
          }
          if ("rsa" !== i2 && "ecdsa/rsa" !== i2) throw new Error("wrong private key type");
          e2 = n.concat([p, e2]);
          for (var b = m.modulus.byteLength(), g = [0, 1]; e2.length + g.length + 1 < b; ) g.push(255);
          g.push(0);
          for (var y = -1; ++y < e2.length; ) g.push(e2[y]);
          return s(g, m);
        }, t2.exports.getKey = u, t2.exports.makeKey = f;
      }, { "./curves.json": 212, "bn.js": 186, "browserify-rsa": 209, "create-hmac": 388, elliptic: 405, "parse-asn1": 459, "safe-buffer": 494 }], 215: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("bn.js"), s = e("elliptic").ec, o = e("parse-asn1"), a = e("./curves.json");
        function l(e2, t3) {
          if (e2.cmpn(0) <= 0) throw new Error("invalid sig");
          if (e2.cmp(t3) >= t3) throw new Error("invalid sig");
        }
        t2.exports = function(e2, t3, r2, c, u) {
          var h = o(r2);
          if ("ec" === h.type) {
            if ("ecdsa" !== c && "ecdsa/rsa" !== c) throw new Error("wrong public key type");
            return (function(e3, t4, r3) {
              var n2 = a[r3.data.algorithm.curve.join(".")];
              if (!n2) throw new Error("unknown curve " + r3.data.algorithm.curve.join("."));
              var i2 = new s(n2), o2 = r3.data.subjectPrivateKey.data;
              return i2.verify(t4, e3, o2);
            })(e2, t3, h);
          }
          if ("dsa" === h.type) {
            if ("dsa" !== c) throw new Error("wrong public key type");
            return (function(e3, t4, r3) {
              var n2 = r3.data.p, s2 = r3.data.q, a2 = r3.data.g, c2 = r3.data.pub_key, u2 = o.signature.decode(e3, "der"), h2 = u2.s, f2 = u2.r;
              l(h2, s2), l(f2, s2);
              var d2 = i.mont(n2), p2 = h2.invm(s2);
              return 0 === a2.toRed(d2).redPow(new i(t4).mul(p2).mod(s2)).fromRed().mul(c2.toRed(d2).redPow(f2.mul(p2).mod(s2)).fromRed()).mod(n2).mod(s2).cmp(f2);
            })(e2, t3, h);
          }
          if ("rsa" !== c && "ecdsa/rsa" !== c) throw new Error("wrong public key type");
          t3 = n.concat([u, t3]);
          for (var f = h.modulus.byteLength(), d = [1], p = 0; t3.length + d.length + 2 < f; ) d.push(255), p++;
          d.push(0);
          for (var m = -1; ++m < t3.length; ) d.push(t3[m]);
          d = n.from(d);
          var b = i.mont(h.modulus);
          e2 = (e2 = new i(e2).toRed(b)).redPow(new i(h.publicExponent)), e2 = n.from(e2.fromRed().toArray());
          var g = p < 8 ? 1 : 0;
          for (f = Math.min(e2.length, d.length), e2.length !== d.length && (g = 1), m = -1; ++m < f; ) g |= e2[m] ^ d[m];
          return 0 === g;
        };
      }, { "./curves.json": 212, "bn.js": 186, elliptic: 405, "parse-asn1": 459, "safe-buffer": 494 }], 216: [function(e, t2, r) {
      }, {}], 217: [function(e, t2, r) {
        var n = e("buffer"), i = n.Buffer;
        function s(e2, t3) {
          for (var r2 in e2) t3[r2] = e2[r2];
        }
        function o(e2, t3, r2) {
          return i(e2, t3, r2);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t2.exports = n : (s(n, r), r.Buffer = o), s(i, o), o.from = function(e2, t3, r2) {
          if ("number" == typeof e2) throw new TypeError("Argument must not be a number");
          return i(e2, t3, r2);
        }, o.alloc = function(e2, t3, r2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          var n2 = i(e2);
          return void 0 !== t3 ? "string" == typeof r2 ? n2.fill(t3, r2) : n2.fill(t3) : n2.fill(0), n2;
        }, o.allocUnsafe = function(e2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          return i(e2);
        }, o.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e2);
        };
      }, { buffer: 220 }], 218: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = n.isEncoding || function(e2) {
          switch ((e2 = "" + e2) && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function s(e2) {
          var t3;
          switch (this.encoding = (function(e3) {
            var t4 = (function(e4) {
              if (!e4) return "utf8";
              for (var t5; ; ) switch (e4) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return e4;
                default:
                  if (t5) return;
                  e4 = ("" + e4).toLowerCase(), t5 = true;
              }
            })(e3);
            if ("string" != typeof t4 && (n.isEncoding === i || !i(e3))) throw new Error("Unknown encoding: " + e3);
            return t4 || e3;
          })(e2), this.encoding) {
            case "utf16le":
              this.text = l, this.end = c, t3 = 4;
              break;
            case "utf8":
              this.fillLast = a, t3 = 4;
              break;
            case "base64":
              this.text = u, this.end = h, t3 = 3;
              break;
            default:
              return this.write = f, void (this.end = d);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t3);
        }
        function o(e2) {
          return e2 <= 127 ? 0 : e2 >> 5 == 6 ? 2 : e2 >> 4 == 14 ? 3 : e2 >> 3 == 30 ? 4 : e2 >> 6 == 2 ? -1 : -2;
        }
        function a(e2) {
          var t3 = this.lastTotal - this.lastNeed, r2 = (function(e3, t4, r3) {
            if (128 != (192 & t4[0])) return e3.lastNeed = 0, "�";
            if (e3.lastNeed > 1 && t4.length > 1) {
              if (128 != (192 & t4[1])) return e3.lastNeed = 1, "�";
              if (e3.lastNeed > 2 && t4.length > 2 && 128 != (192 & t4[2])) return e3.lastNeed = 2, "�";
            }
          })(this, e2);
          return void 0 !== r2 ? r2 : this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e2.copy(this.lastChar, t3, 0, e2.length), void (this.lastNeed -= e2.length));
        }
        function l(e2, t3) {
          if ((e2.length - t3) % 2 == 0) {
            var r2 = e2.toString("utf16le", t3);
            if (r2) {
              var n2 = r2.charCodeAt(r2.length - 1);
              if (n2 >= 55296 && n2 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], r2.slice(0, -1);
            }
            return r2;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t3, e2.length - 1);
        }
        function c(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var r2 = this.lastTotal - this.lastNeed;
            return t3 + this.lastChar.toString("utf16le", 0, r2);
          }
          return t3;
        }
        function u(e2, t3) {
          var r2 = (e2.length - t3) % 3;
          return 0 === r2 ? e2.toString("base64", t3) : (this.lastNeed = 3 - r2, this.lastTotal = 3, 1 === r2 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t3, e2.length - r2));
        }
        function h(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
        }
        function f(e2) {
          return e2.toString(this.encoding);
        }
        function d(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        r.StringDecoder = s, s.prototype.write = function(e2) {
          if (0 === e2.length) return "";
          var t3, r2;
          if (this.lastNeed) {
            if (void 0 === (t3 = this.fillLast(e2))) return "";
            r2 = this.lastNeed, this.lastNeed = 0;
          } else r2 = 0;
          return r2 < e2.length ? t3 ? t3 + this.text(e2, r2) : this.text(e2, r2) : t3 || "";
        }, s.prototype.end = function(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + "�" : t3;
        }, s.prototype.text = function(e2, t3) {
          var r2 = (function(e3, t4, r3) {
            var n3 = t4.length - 1;
            if (n3 < r3) return 0;
            var i2 = o(t4[n3]);
            if (i2 >= 0) return i2 > 0 && (e3.lastNeed = i2 - 1), i2;
            if (--n3 < r3 || -2 === i2) return 0;
            if ((i2 = o(t4[n3])) >= 0) return i2 > 0 && (e3.lastNeed = i2 - 2), i2;
            if (--n3 < r3 || -2 === i2) return 0;
            if ((i2 = o(t4[n3])) >= 0) return i2 > 0 && (2 === i2 ? i2 = 0 : e3.lastNeed = i2 - 3), i2;
            return 0;
          })(this, e2, t3);
          if (!this.lastNeed) return e2.toString("utf8", t3);
          this.lastTotal = r2;
          var n2 = e2.length - (r2 - this.lastNeed);
          return e2.copy(this.lastChar, 0, n2), e2.toString("utf8", t3, n2);
        }, s.prototype.fillLast = function(e2) {
          if (this.lastNeed <= e2.length) return e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length;
        };
      }, { "safe-buffer": 217 }], 219: [function(e, t2, r) {
        (function(e2) {
          (function() {
            t2.exports = function(t3, r2) {
              for (var n = Math.min(t3.length, r2.length), i = new e2(n), s = 0; s < n; ++s) i[s] = t3[s] ^ r2[s];
              return i;
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { buffer: 220 }], 220: [function(e, t2, r) {
        (function(t3) {
          (function() {
            var t4 = e("base64-js"), n = e("ieee754");
            r.Buffer = s, r.SlowBuffer = function(e2) {
              +e2 != e2 && (e2 = 0);
              return s.alloc(+e2);
            }, r.INSPECT_MAX_BYTES = 50;
            function i(e2) {
              if (e2 > 2147483647) throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t5 = new Uint8Array(e2);
              return t5.__proto__ = s.prototype, t5;
            }
            function s(e2, t5, r2) {
              if ("number" == typeof e2) {
                if ("string" == typeof t5) throw new TypeError('The "string" argument must be of type string. Received type number');
                return l(e2);
              }
              return o(e2, t5, r2);
            }
            function o(e2, t5, r2) {
              if ("string" == typeof e2) return (function(e3, t6) {
                "string" == typeof t6 && "" !== t6 || (t6 = "utf8");
                if (!s.isEncoding(t6)) throw new TypeError("Unknown encoding: " + t6);
                var r3 = 0 | h(e3, t6), n3 = i(r3), o3 = n3.write(e3, t6);
                o3 !== r3 && (n3 = n3.slice(0, o3));
                return n3;
              })(e2, t5);
              if (ArrayBuffer.isView(e2)) return c(e2);
              if (null == e2) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (F(e2, ArrayBuffer) || e2 && F(e2.buffer, ArrayBuffer)) return (function(e3, t6, r3) {
                if (t6 < 0 || e3.byteLength < t6) throw new RangeError('"offset" is outside of buffer bounds');
                if (e3.byteLength < t6 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
                var n3;
                n3 = void 0 === t6 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t6) : new Uint8Array(e3, t6, r3);
                return n3.__proto__ = s.prototype, n3;
              })(e2, t5, r2);
              if ("number" == typeof e2) throw new TypeError('The "value" argument must not be of type number. Received type number');
              var n2 = e2.valueOf && e2.valueOf();
              if (null != n2 && n2 !== e2) return s.from(n2, t5, r2);
              var o2 = (function(e3) {
                if (s.isBuffer(e3)) {
                  var t6 = 0 | u(e3.length), r3 = i(t6);
                  return 0 === r3.length || e3.copy(r3, 0, 0, t6), r3;
                }
                if (void 0 !== e3.length) return "number" != typeof e3.length || L(e3.length) ? i(0) : c(e3);
                if ("Buffer" === e3.type && Array.isArray(e3.data)) return c(e3.data);
              })(e2);
              if (o2) return o2;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive]) return s.from(e2[Symbol.toPrimitive]("string"), t5, r2);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function a(e2) {
              if ("number" != typeof e2) throw new TypeError('"size" argument must be of type number');
              if (e2 < 0) throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function l(e2) {
              return a(e2), i(e2 < 0 ? 0 : 0 | u(e2));
            }
            function c(e2) {
              for (var t5 = e2.length < 0 ? 0 : 0 | u(e2.length), r2 = i(t5), n2 = 0; n2 < t5; n2 += 1) r2[n2] = 255 & e2[n2];
              return r2;
            }
            function u(e2) {
              if (e2 >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
              return 0 | e2;
            }
            function h(e2, t5) {
              if (s.isBuffer(e2)) return e2.length;
              if (ArrayBuffer.isView(e2) || F(e2, ArrayBuffer)) return e2.byteLength;
              if ("string" != typeof e2) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var r2 = e2.length, n2 = arguments.length > 2 && true === arguments[2];
              if (!n2 && 0 === r2) return 0;
              for (var i2 = false; ; ) switch (t5) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r2;
                case "utf8":
                case "utf-8":
                  return P(e2).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r2;
                case "hex":
                  return r2 >>> 1;
                case "base64":
                  return B(e2).length;
                default:
                  if (i2) return n2 ? -1 : P(e2).length;
                  t5 = ("" + t5).toLowerCase(), i2 = true;
              }
            }
            function f(e2, t5, r2) {
              var n2 = false;
              if ((void 0 === t5 || t5 < 0) && (t5 = 0), t5 > this.length) return "";
              if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0) return "";
              if ((r2 >>>= 0) <= (t5 >>>= 0)) return "";
              for (e2 || (e2 = "utf8"); ; ) switch (e2) {
                case "hex":
                  return C2(this, t5, r2);
                case "utf8":
                case "utf-8":
                  return k(this, t5, r2);
                case "ascii":
                  return S(this, t5, r2);
                case "latin1":
                case "binary":
                  return M(this, t5, r2);
                case "base64":
                  return x(this, t5, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return T(this, t5, r2);
                default:
                  if (n2) throw new TypeError("Unknown encoding: " + e2);
                  e2 = (e2 + "").toLowerCase(), n2 = true;
              }
            }
            function d(e2, t5, r2) {
              var n2 = e2[t5];
              e2[t5] = e2[r2], e2[r2] = n2;
            }
            function p(e2, t5, r2, n2, i2) {
              if (0 === e2.length) return -1;
              if ("string" == typeof r2 ? (n2 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), L(r2 = +r2) && (r2 = i2 ? 0 : e2.length - 1), r2 < 0 && (r2 = e2.length + r2), r2 >= e2.length) {
                if (i2) return -1;
                r2 = e2.length - 1;
              } else if (r2 < 0) {
                if (!i2) return -1;
                r2 = 0;
              }
              if ("string" == typeof t5 && (t5 = s.from(t5, n2)), s.isBuffer(t5)) return 0 === t5.length ? -1 : m(e2, t5, r2, n2, i2);
              if ("number" == typeof t5) return t5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e2, t5, r2) : Uint8Array.prototype.lastIndexOf.call(e2, t5, r2) : m(e2, [t5], r2, n2, i2);
              throw new TypeError("val must be string, number or Buffer");
            }
            function m(e2, t5, r2, n2, i2) {
              var s2, o2 = 1, a2 = e2.length, l2 = t5.length;
              if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
                if (e2.length < 2 || t5.length < 2) return -1;
                o2 = 2, a2 /= 2, l2 /= 2, r2 /= 2;
              }
              function c2(e3, t6) {
                return 1 === o2 ? e3[t6] : e3.readUInt16BE(t6 * o2);
              }
              if (i2) {
                var u2 = -1;
                for (s2 = r2; s2 < a2; s2++) if (c2(e2, s2) === c2(t5, -1 === u2 ? 0 : s2 - u2)) {
                  if (-1 === u2 && (u2 = s2), s2 - u2 + 1 === l2) return u2 * o2;
                } else -1 !== u2 && (s2 -= s2 - u2), u2 = -1;
              } else for (r2 + l2 > a2 && (r2 = a2 - l2), s2 = r2; s2 >= 0; s2--) {
                for (var h2 = true, f2 = 0; f2 < l2; f2++) if (c2(e2, s2 + f2) !== c2(t5, f2)) {
                  h2 = false;
                  break;
                }
                if (h2) return s2;
              }
              return -1;
            }
            function b(e2, t5, r2, n2) {
              r2 = Number(r2) || 0;
              var i2 = e2.length - r2;
              n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
              var s2 = t5.length;
              n2 > s2 / 2 && (n2 = s2 / 2);
              for (var o2 = 0; o2 < n2; ++o2) {
                var a2 = parseInt(t5.substr(2 * o2, 2), 16);
                if (L(a2)) return o2;
                e2[r2 + o2] = a2;
              }
              return o2;
            }
            function g(e2, t5, r2, n2) {
              return D(P(t5, e2.length - r2), e2, r2, n2);
            }
            function y(e2, t5, r2, n2) {
              return D((function(e3) {
                for (var t6 = [], r3 = 0; r3 < e3.length; ++r3) t6.push(255 & e3.charCodeAt(r3));
                return t6;
              })(t5), e2, r2, n2);
            }
            function v(e2, t5, r2, n2) {
              return y(e2, t5, r2, n2);
            }
            function w(e2, t5, r2, n2) {
              return D(B(t5), e2, r2, n2);
            }
            function _(e2, t5, r2, n2) {
              return D((function(e3, t6) {
                for (var r3, n3, i2, s2 = [], o2 = 0; o2 < e3.length && !((t6 -= 2) < 0); ++o2) r3 = e3.charCodeAt(o2), n3 = r3 >> 8, i2 = r3 % 256, s2.push(i2), s2.push(n3);
                return s2;
              })(t5, e2.length - r2), e2, r2, n2);
            }
            function x(e2, r2, n2) {
              return 0 === r2 && n2 === e2.length ? t4.fromByteArray(e2) : t4.fromByteArray(e2.slice(r2, n2));
            }
            function k(e2, t5, r2) {
              r2 = Math.min(e2.length, r2);
              for (var n2 = [], i2 = t5; i2 < r2; ) {
                var s2, o2, a2, l2, c2 = e2[i2], u2 = null, h2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
                if (i2 + h2 <= r2) switch (h2) {
                  case 1:
                    c2 < 128 && (u2 = c2);
                    break;
                  case 2:
                    128 == (192 & (s2 = e2[i2 + 1])) && (l2 = (31 & c2) << 6 | 63 & s2) > 127 && (u2 = l2);
                    break;
                  case 3:
                    s2 = e2[i2 + 1], o2 = e2[i2 + 2], 128 == (192 & s2) && 128 == (192 & o2) && (l2 = (15 & c2) << 12 | (63 & s2) << 6 | 63 & o2) > 2047 && (l2 < 55296 || l2 > 57343) && (u2 = l2);
                    break;
                  case 4:
                    s2 = e2[i2 + 1], o2 = e2[i2 + 2], a2 = e2[i2 + 3], 128 == (192 & s2) && 128 == (192 & o2) && 128 == (192 & a2) && (l2 = (15 & c2) << 18 | (63 & s2) << 12 | (63 & o2) << 6 | 63 & a2) > 65535 && l2 < 1114112 && (u2 = l2);
                }
                null === u2 ? (u2 = 65533, h2 = 1) : u2 > 65535 && (u2 -= 65536, n2.push(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2.push(u2), i2 += h2;
              }
              return (function(e3) {
                var t6 = e3.length;
                if (t6 <= 4096) return String.fromCharCode.apply(String, e3);
                var r3 = "", n3 = 0;
                for (; n3 < t6; ) r3 += String.fromCharCode.apply(String, e3.slice(n3, n3 += 4096));
                return r3;
              })(n2);
            }
            r.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = (function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (e3) {
                return false;
              }
            })(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              if (s.isBuffer(this)) return this.buffer;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              if (s.isBuffer(this)) return this.byteOffset;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t5, r2) {
              return o(e2, t5, r2);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t5, r2) {
              return (function(e3, t6, r3) {
                return a(e3), e3 <= 0 ? i(e3) : void 0 !== t6 ? "string" == typeof r3 ? i(e3).fill(t6, r3) : i(e3).fill(t6) : i(e3);
              })(e2, t5, r2);
            }, s.allocUnsafe = function(e2) {
              return l(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return l(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t5) {
              if (F(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), F(t5, Uint8Array) && (t5 = s.from(t5, t5.offset, t5.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t5)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t5) return 0;
              for (var r2 = e2.length, n2 = t5.length, i2 = 0, o2 = Math.min(r2, n2); i2 < o2; ++i2) if (e2[i2] !== t5[i2]) {
                r2 = e2[i2], n2 = t5[i2];
                break;
              }
              return r2 < n2 ? -1 : n2 < r2 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch (String(e2).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t5) {
              if (!Array.isArray(e2)) throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length) return s.alloc(0);
              var r2;
              if (void 0 === t5) for (t5 = 0, r2 = 0; r2 < e2.length; ++r2) t5 += e2[r2].length;
              var n2 = s.allocUnsafe(t5), i2 = 0;
              for (r2 = 0; r2 < e2.length; ++r2) {
                var o2 = e2[r2];
                if (F(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2)) throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(n2, i2), i2 += o2.length;
              }
              return n2;
            }, s.byteLength = h, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (e2 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t5 = 0; t5 < e2; t5 += 2) d(this, t5, t5 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (e2 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t5 = 0; t5 < e2; t5 += 4) d(this, t5, t5 + 3), d(this, t5 + 1, t5 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (e2 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t5 = 0; t5 < e2; t5 += 8) d(this, t5, t5 + 7), d(this, t5 + 1, t5 + 6), d(this, t5 + 2, t5 + 5), d(this, t5 + 3, t5 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? k(this, 0, e2) : f.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2)) throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t5 = r.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t5).replace(/(.{2})/g, "$1 ").trim(), this.length > t5 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t5, r2, n2, i2) {
              if (F(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t5 && (t5 = 0), void 0 === r2 && (r2 = e2 ? e2.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), t5 < 0 || r2 > e2.length || n2 < 0 || i2 > this.length) throw new RangeError("out of range index");
              if (n2 >= i2 && t5 >= r2) return 0;
              if (n2 >= i2) return -1;
              if (t5 >= r2) return 1;
              if (this === e2) return 0;
              for (var o2 = (i2 >>>= 0) - (n2 >>>= 0), a2 = (r2 >>>= 0) - (t5 >>>= 0), l2 = Math.min(o2, a2), c2 = this.slice(n2, i2), u2 = e2.slice(t5, r2), h2 = 0; h2 < l2; ++h2) if (c2[h2] !== u2[h2]) {
                o2 = c2[h2], a2 = u2[h2];
                break;
              }
              return o2 < a2 ? -1 : a2 < o2 ? 1 : 0;
            }, s.prototype.includes = function(e2, t5, r2) {
              return -1 !== this.indexOf(e2, t5, r2);
            }, s.prototype.indexOf = function(e2, t5, r2) {
              return p(this, e2, t5, r2, true);
            }, s.prototype.lastIndexOf = function(e2, t5, r2) {
              return p(this, e2, t5, r2, false);
            }, s.prototype.write = function(e2, t5, r2, n2) {
              if (void 0 === t5) n2 = "utf8", r2 = this.length, t5 = 0;
              else if (void 0 === r2 && "string" == typeof t5) n2 = t5, r2 = this.length, t5 = 0;
              else {
                if (!isFinite(t5)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t5 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r2, r2 = void 0);
              }
              var i2 = this.length - t5;
              if ((void 0 === r2 || r2 > i2) && (r2 = i2), e2.length > 0 && (r2 < 0 || t5 < 0) || t5 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
              n2 || (n2 = "utf8");
              for (var s2 = false; ; ) switch (n2) {
                case "hex":
                  return b(this, e2, t5, r2);
                case "utf8":
                case "utf-8":
                  return g(this, e2, t5, r2);
                case "ascii":
                  return y(this, e2, t5, r2);
                case "latin1":
                case "binary":
                  return v(this, e2, t5, r2);
                case "base64":
                  return w(this, e2, t5, r2);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return _(this, e2, t5, r2);
                default:
                  if (s2) throw new TypeError("Unknown encoding: " + n2);
                  n2 = ("" + n2).toLowerCase(), s2 = true;
              }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            function S(e2, t5, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t5; i2 < r2; ++i2) n2 += String.fromCharCode(127 & e2[i2]);
              return n2;
            }
            function M(e2, t5, r2) {
              var n2 = "";
              r2 = Math.min(e2.length, r2);
              for (var i2 = t5; i2 < r2; ++i2) n2 += String.fromCharCode(e2[i2]);
              return n2;
            }
            function C2(e2, t5, r2) {
              var n2 = e2.length;
              (!t5 || t5 < 0) && (t5 = 0), (!r2 || r2 < 0 || r2 > n2) && (r2 = n2);
              for (var i2 = "", s2 = t5; s2 < r2; ++s2) i2 += N(e2[s2]);
              return i2;
            }
            function T(e2, t5, r2) {
              for (var n2 = e2.slice(t5, r2), i2 = "", s2 = 0; s2 < n2.length; s2 += 2) i2 += String.fromCharCode(n2[s2] + 256 * n2[s2 + 1]);
              return i2;
            }
            function E(e2, t5, r2) {
              if (e2 % 1 != 0 || e2 < 0) throw new RangeError("offset is not uint");
              if (e2 + t5 > r2) throw new RangeError("Trying to access beyond buffer length");
            }
            function A(e2, t5, r2, n2, i2, o2) {
              if (!s.isBuffer(e2)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t5 > i2 || t5 < o2) throw new RangeError('"value" argument is out of bounds');
              if (r2 + n2 > e2.length) throw new RangeError("Index out of range");
            }
            function R(e2, t5, r2, n2, i2, s2) {
              if (r2 + n2 > e2.length) throw new RangeError("Index out of range");
              if (r2 < 0) throw new RangeError("Index out of range");
            }
            function O(e2, t5, r2, i2, s2) {
              return t5 = +t5, r2 >>>= 0, s2 || R(e2, 0, r2, 4), n.write(e2, t5, r2, i2, 23, 4), r2 + 4;
            }
            function j(e2, t5, r2, i2, s2) {
              return t5 = +t5, r2 >>>= 0, s2 || R(e2, 0, r2, 8), n.write(e2, t5, r2, i2, 52, 8), r2 + 8;
            }
            s.prototype.slice = function(e2, t5) {
              var r2 = this.length;
              (e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t5 = void 0 === t5 ? r2 : ~~t5) < 0 ? (t5 += r2) < 0 && (t5 = 0) : t5 > r2 && (t5 = r2), t5 < e2 && (t5 = e2);
              var n2 = this.subarray(e2, t5);
              return n2.__proto__ = s.prototype, n2;
            }, s.prototype.readUIntLE = function(e2, t5, r2) {
              e2 >>>= 0, t5 >>>= 0, r2 || E(e2, t5, this.length);
              for (var n2 = this[e2], i2 = 1, s2 = 0; ++s2 < t5 && (i2 *= 256); ) n2 += this[e2 + s2] * i2;
              return n2;
            }, s.prototype.readUIntBE = function(e2, t5, r2) {
              e2 >>>= 0, t5 >>>= 0, r2 || E(e2, t5, this.length);
              for (var n2 = this[e2 + --t5], i2 = 1; t5 > 0 && (i2 *= 256); ) n2 += this[e2 + --t5] * i2;
              return n2;
            }, s.prototype.readUInt8 = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t5, r2) {
              e2 >>>= 0, t5 >>>= 0, r2 || E(e2, t5, this.length);
              for (var n2 = this[e2], i2 = 1, s2 = 0; ++s2 < t5 && (i2 *= 256); ) n2 += this[e2 + s2] * i2;
              return n2 >= (i2 *= 128) && (n2 -= Math.pow(2, 8 * t5)), n2;
            }, s.prototype.readIntBE = function(e2, t5, r2) {
              e2 >>>= 0, t5 >>>= 0, r2 || E(e2, t5, this.length);
              for (var n2 = t5, i2 = 1, s2 = this[e2 + --n2]; n2 > 0 && (i2 *= 256); ) s2 += this[e2 + --n2] * i2;
              return s2 >= (i2 *= 128) && (s2 -= Math.pow(2, 8 * t5)), s2;
            }, s.prototype.readInt8 = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t5) {
              e2 >>>= 0, t5 || E(e2, 2, this.length);
              var r2 = this[e2] | this[e2 + 1] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, s.prototype.readInt16BE = function(e2, t5) {
              e2 >>>= 0, t5 || E(e2, 2, this.length);
              var r2 = this[e2 + 1] | this[e2] << 8;
              return 32768 & r2 ? 4294901760 | r2 : r2;
            }, s.prototype.readInt32LE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), n.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 4, this.length), n.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 8, this.length), n.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t5) {
              return e2 >>>= 0, t5 || E(e2, 8, this.length), n.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t5, r2, n2) {
              (e2 = +e2, t5 >>>= 0, r2 >>>= 0, n2) || A(this, e2, t5, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = 1, s2 = 0;
              for (this[t5] = 255 & e2; ++s2 < r2 && (i2 *= 256); ) this[t5 + s2] = e2 / i2 & 255;
              return t5 + r2;
            }, s.prototype.writeUIntBE = function(e2, t5, r2, n2) {
              (e2 = +e2, t5 >>>= 0, r2 >>>= 0, n2) || A(this, e2, t5, r2, Math.pow(2, 8 * r2) - 1, 0);
              var i2 = r2 - 1, s2 = 1;
              for (this[t5 + i2] = 255 & e2; --i2 >= 0 && (s2 *= 256); ) this[t5 + i2] = e2 / s2 & 255;
              return t5 + r2;
            }, s.prototype.writeUInt8 = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 1, 255, 0), this[t5] = 255 & e2, t5 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 2, 65535, 0), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 2, 65535, 0), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 4, 4294967295, 0), this[t5 + 3] = e2 >>> 24, this[t5 + 2] = e2 >>> 16, this[t5 + 1] = e2 >>> 8, this[t5] = 255 & e2, t5 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 4, 4294967295, 0), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
            }, s.prototype.writeIntLE = function(e2, t5, r2, n2) {
              if (e2 = +e2, t5 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                A(this, e2, t5, r2, i2 - 1, -i2);
              }
              var s2 = 0, o2 = 1, a2 = 0;
              for (this[t5] = 255 & e2; ++s2 < r2 && (o2 *= 256); ) e2 < 0 && 0 === a2 && 0 !== this[t5 + s2 - 1] && (a2 = 1), this[t5 + s2] = (e2 / o2 >> 0) - a2 & 255;
              return t5 + r2;
            }, s.prototype.writeIntBE = function(e2, t5, r2, n2) {
              if (e2 = +e2, t5 >>>= 0, !n2) {
                var i2 = Math.pow(2, 8 * r2 - 1);
                A(this, e2, t5, r2, i2 - 1, -i2);
              }
              var s2 = r2 - 1, o2 = 1, a2 = 0;
              for (this[t5 + s2] = 255 & e2; --s2 >= 0 && (o2 *= 256); ) e2 < 0 && 0 === a2 && 0 !== this[t5 + s2 + 1] && (a2 = 1), this[t5 + s2] = (e2 / o2 >> 0) - a2 & 255;
              return t5 + r2;
            }, s.prototype.writeInt8 = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 1, 127, -128), e2 < 0 && (e2 = 255 + e2 + 1), this[t5] = 255 & e2, t5 + 1;
            }, s.prototype.writeInt16LE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 2, 32767, -32768), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, t5 + 2;
            }, s.prototype.writeInt16BE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 2, 32767, -32768), this[t5] = e2 >>> 8, this[t5 + 1] = 255 & e2, t5 + 2;
            }, s.prototype.writeInt32LE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 4, 2147483647, -2147483648), this[t5] = 255 & e2, this[t5 + 1] = e2 >>> 8, this[t5 + 2] = e2 >>> 16, this[t5 + 3] = e2 >>> 24, t5 + 4;
            }, s.prototype.writeInt32BE = function(e2, t5, r2) {
              return e2 = +e2, t5 >>>= 0, r2 || A(this, e2, t5, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), this[t5] = e2 >>> 24, this[t5 + 1] = e2 >>> 16, this[t5 + 2] = e2 >>> 8, this[t5 + 3] = 255 & e2, t5 + 4;
            }, s.prototype.writeFloatLE = function(e2, t5, r2) {
              return O(this, e2, t5, true, r2);
            }, s.prototype.writeFloatBE = function(e2, t5, r2) {
              return O(this, e2, t5, false, r2);
            }, s.prototype.writeDoubleLE = function(e2, t5, r2) {
              return j(this, e2, t5, true, r2);
            }, s.prototype.writeDoubleBE = function(e2, t5, r2) {
              return j(this, e2, t5, false, r2);
            }, s.prototype.copy = function(e2, t5, r2, n2) {
              if (!s.isBuffer(e2)) throw new TypeError("argument should be a Buffer");
              if (r2 || (r2 = 0), n2 || 0 === n2 || (n2 = this.length), t5 >= e2.length && (t5 = e2.length), t5 || (t5 = 0), n2 > 0 && n2 < r2 && (n2 = r2), n2 === r2) return 0;
              if (0 === e2.length || 0 === this.length) return 0;
              if (t5 < 0) throw new RangeError("targetStart out of bounds");
              if (r2 < 0 || r2 >= this.length) throw new RangeError("Index out of range");
              if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
              n2 > this.length && (n2 = this.length), e2.length - t5 < n2 - r2 && (n2 = e2.length - t5 + r2);
              var i2 = n2 - r2;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t5, r2, n2);
              else if (this === e2 && r2 < t5 && t5 < n2) for (var o2 = i2 - 1; o2 >= 0; --o2) e2[o2 + t5] = this[o2 + r2];
              else Uint8Array.prototype.set.call(e2, this.subarray(r2, n2), t5);
              return i2;
            }, s.prototype.fill = function(e2, t5, r2, n2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t5 ? (n2 = t5, t5 = 0, r2 = this.length) : "string" == typeof r2 && (n2 = r2, r2 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
                if ("string" == typeof n2 && !s.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
                if (1 === e2.length) {
                  var i2 = e2.charCodeAt(0);
                  ("utf8" === n2 && i2 < 128 || "latin1" === n2) && (e2 = i2);
                }
              } else "number" == typeof e2 && (e2 &= 255);
              if (t5 < 0 || this.length < t5 || this.length < r2) throw new RangeError("Out of range index");
              if (r2 <= t5) return this;
              var o2;
              if (t5 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e2 || (e2 = 0), "number" == typeof e2) for (o2 = t5; o2 < r2; ++o2) this[o2] = e2;
              else {
                var a2 = s.isBuffer(e2) ? e2 : s.from(e2, n2), l2 = a2.length;
                if (0 === l2) throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < r2 - t5; ++o2) this[o2 + t5] = a2[o2 % l2];
              }
              return this;
            };
            var I = /[^+/0-9A-Za-z-_]/g;
            function N(e2) {
              return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function P(e2, t5) {
              var r2;
              t5 = t5 || 1 / 0;
              for (var n2 = e2.length, i2 = null, s2 = [], o2 = 0; o2 < n2; ++o2) {
                if ((r2 = e2.charCodeAt(o2)) > 55295 && r2 < 57344) {
                  if (!i2) {
                    if (r2 > 56319) {
                      (t5 -= 3) > -1 && s2.push(239, 191, 189);
                      continue;
                    }
                    if (o2 + 1 === n2) {
                      (t5 -= 3) > -1 && s2.push(239, 191, 189);
                      continue;
                    }
                    i2 = r2;
                    continue;
                  }
                  if (r2 < 56320) {
                    (t5 -= 3) > -1 && s2.push(239, 191, 189), i2 = r2;
                    continue;
                  }
                  r2 = 65536 + (i2 - 55296 << 10 | r2 - 56320);
                } else i2 && (t5 -= 3) > -1 && s2.push(239, 191, 189);
                if (i2 = null, r2 < 128) {
                  if ((t5 -= 1) < 0) break;
                  s2.push(r2);
                } else if (r2 < 2048) {
                  if ((t5 -= 2) < 0) break;
                  s2.push(r2 >> 6 | 192, 63 & r2 | 128);
                } else if (r2 < 65536) {
                  if ((t5 -= 3) < 0) break;
                  s2.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                } else {
                  if (!(r2 < 1114112)) throw new Error("Invalid code point");
                  if ((t5 -= 4) < 0) break;
                  s2.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
                }
              }
              return s2;
            }
            function B(e2) {
              return t4.toByteArray((function(e3) {
                if ((e3 = (e3 = e3.split("=")[0]).trim().replace(I, "")).length < 2) return "";
                for (; e3.length % 4 != 0; ) e3 += "=";
                return e3;
              })(e2));
            }
            function D(e2, t5, r2, n2) {
              for (var i2 = 0; i2 < n2 && !(i2 + r2 >= t5.length || i2 >= e2.length); ++i2) t5[i2 + r2] = e2[i2];
              return i2;
            }
            function F(e2, t5) {
              return e2 instanceof t5 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t5.name;
            }
            function L(e2) {
              return e2 != e2;
            }
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 185, buffer: 220, ieee754: 439 }], 221: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("stream").Transform, s = e("string_decoder").StringDecoder;
        function o(e2) {
          i.call(this), this.hashMode = "string" == typeof e2, this.hashMode ? this[e2] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
        }
        e("inherits")(o, i), o.prototype.update = function(e2, t3, r2) {
          "string" == typeof e2 && (e2 = n.from(e2, t3));
          var i2 = this._update(e2);
          return this.hashMode ? this : (r2 && (i2 = this._toString(i2, r2)), i2);
        }, o.prototype.setAutoPadding = function() {
        }, o.prototype.getAuthTag = function() {
          throw new Error("trying to get auth tag in unsupported state");
        }, o.prototype.setAuthTag = function() {
          throw new Error("trying to set auth tag in unsupported state");
        }, o.prototype.setAAD = function() {
          throw new Error("trying to set aad in unsupported state");
        }, o.prototype._transform = function(e2, t3, r2) {
          var n2;
          try {
            this.hashMode ? this._update(e2) : this.push(this._update(e2));
          } catch (e3) {
            n2 = e3;
          } finally {
            r2(n2);
          }
        }, o.prototype._flush = function(e2) {
          var t3;
          try {
            this.push(this.__final());
          } catch (e3) {
            t3 = e3;
          }
          e2(t3);
        }, o.prototype._finalOrDigest = function(e2) {
          var t3 = this.__final() || n.alloc(0);
          return e2 && (t3 = this._toString(t3, e2, true)), t3;
        }, o.prototype._toString = function(e2, t3, r2) {
          if (this._decoder || (this._decoder = new s(t3), this._encoding = t3), this._encoding !== t3) throw new Error("can't switch encodings");
          var n2 = this._decoder.write(e2);
          return r2 && (n2 += this._decoder.end()), n2;
        }, t2.exports = o;
      }, { inherits: 440, "safe-buffer": 494, stream: 505, string_decoder: 218 }], 222: [function(e, t2, r) {
        var n = e("../internals/is-callable"), i = e("../internals/try-to-string"), s = TypeError;
        t2.exports = function(e2) {
          if (n(e2)) return e2;
          throw new s(i(e2) + " is not a function");
        };
      }, { "../internals/is-callable": 285, "../internals/try-to-string": 349 }], 223: [function(e, t2, r) {
        var n = e("../internals/is-constructor"), i = e("../internals/try-to-string"), s = TypeError;
        t2.exports = function(e2) {
          if (n(e2)) return e2;
          throw new s(i(e2) + " is not a constructor");
        };
      }, { "../internals/is-constructor": 286, "../internals/try-to-string": 349 }], 224: [function(e, t2, r) {
        var n = e("../internals/is-callable"), i = String, s = TypeError;
        t2.exports = function(e2) {
          if ("object" == typeof e2 || n(e2)) return e2;
          throw new s("Can't set " + i(e2) + " as a prototype");
        };
      }, { "../internals/is-callable": 285 }], 225: [function(e, t2, r) {
        var n = e("../internals/well-known-symbol"), i = e("../internals/object-create"), s = e("../internals/object-define-property").f, o = n("unscopables"), a = Array.prototype;
        void 0 === a[o] && s(a, o, { configurable: true, value: i(null) }), t2.exports = function(e2) {
          a[o][e2] = true;
        };
      }, { "../internals/object-create": 306, "../internals/object-define-property": 308, "../internals/well-known-symbol": 357 }], 226: [function(e, t2, r) {
        var n = e("../internals/object-is-prototype-of"), i = TypeError;
        t2.exports = function(e2, t3) {
          if (n(t3, e2)) return e2;
          throw new i("Incorrect invocation");
        };
      }, { "../internals/object-is-prototype-of": 314 }], 227: [function(e, t2, r) {
        var n = e("../internals/is-object"), i = String, s = TypeError;
        t2.exports = function(e2) {
          if (n(e2)) return e2;
          throw new s(i(e2) + " is not an object");
        };
      }, { "../internals/is-object": 289 }], 228: [function(e, t2, r) {
        var n = e("../internals/to-indexed-object"), i = e("../internals/to-absolute-index"), s = e("../internals/length-of-array-like"), o = function(e2) {
          return function(t3, r2, o2) {
            var a, l = n(t3), c = s(l), u = i(o2, c);
            if (e2 && r2 != r2) {
              for (; c > u; ) if ((a = l[u++]) != a) return true;
            } else for (; c > u; u++) if ((e2 || u in l) && l[u] === r2) return e2 || u || 0;
            return !e2 && -1;
          };
        };
        t2.exports = { includes: o(true), indexOf: o(false) };
      }, { "../internals/length-of-array-like": 299, "../internals/to-absolute-index": 340, "../internals/to-indexed-object": 341 }], 229: [function(e, t2, r) {
        var n = e("../internals/function-bind-context"), i = e("../internals/function-uncurry-this"), s = e("../internals/indexed-object"), o = e("../internals/to-object"), a = e("../internals/length-of-array-like"), l = e("../internals/array-species-create"), c = i([].push), u = function(e2) {
          var t3 = 1 === e2, r2 = 2 === e2, i2 = 3 === e2, u2 = 4 === e2, h = 6 === e2, f = 7 === e2, d = 5 === e2 || h;
          return function(p, m, b, g) {
            for (var y, v, w = o(p), _ = s(w), x = n(m, b), k = a(_), S = 0, M = g || l, C2 = t3 ? M(p, k) : r2 || f ? M(p, 0) : void 0; k > S; S++) if ((d || S in _) && (v = x(y = _[S], S, w), e2)) if (t3) C2[S] = v;
            else if (v) switch (e2) {
              case 3:
                return true;
              case 5:
                return y;
              case 6:
                return S;
              case 2:
                c(C2, y);
            }
            else switch (e2) {
              case 4:
                return false;
              case 7:
                c(C2, y);
            }
            return h ? -1 : i2 || u2 ? u2 : C2;
          };
        };
        t2.exports = { forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6), filterReject: u(7) };
      }, { "../internals/array-species-create": 233, "../internals/function-bind-context": 262, "../internals/function-uncurry-this": 268, "../internals/indexed-object": 280, "../internals/length-of-array-like": 299, "../internals/to-object": 344 }], 230: [function(e, t2, r) {
        var n = e("../internals/to-absolute-index"), i = e("../internals/length-of-array-like"), s = e("../internals/create-property"), o = Array, a = Math.max;
        t2.exports = function(e2, t3, r2) {
          for (var l = i(e2), c = n(t3, l), u = n(void 0 === r2 ? l : r2, l), h = o(a(u - c, 0)), f = 0; c < u; c++, f++) s(h, f, e2[c]);
          return h.length = f, h;
        };
      }, { "../internals/create-property": 243, "../internals/length-of-array-like": 299, "../internals/to-absolute-index": 340 }], 231: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this");
        t2.exports = n([].slice);
      }, { "../internals/function-uncurry-this": 268 }], 232: [function(e, t2, r) {
        var n = e("../internals/is-array"), i = e("../internals/is-constructor"), s = e("../internals/is-object"), o = e("../internals/well-known-symbol")("species"), a = Array;
        t2.exports = function(e2) {
          var t3;
          return n(e2) && (t3 = e2.constructor, (i(t3) && (t3 === a || n(t3.prototype)) || s(t3) && null === (t3 = t3[o])) && (t3 = void 0)), void 0 === t3 ? a : t3;
        };
      }, { "../internals/is-array": 284, "../internals/is-constructor": 286, "../internals/is-object": 289, "../internals/well-known-symbol": 357 }], 233: [function(e, t2, r) {
        var n = e("../internals/array-species-constructor");
        t2.exports = function(e2, t3) {
          return new (n(e2))(0 === t3 ? 0 : t3);
        };
      }, { "../internals/array-species-constructor": 232 }], 234: [function(e, t2, r) {
        var n = e("../internals/well-known-symbol")("iterator"), i = false;
        try {
          var s = 0, o = { next: function() {
            return { done: !!s++ };
          }, return: function() {
            i = true;
          } };
          o[n] = function() {
            return this;
          }, Array.from(o, (function() {
            throw 2;
          }));
        } catch (e2) {
        }
        t2.exports = function(e2, t3) {
          try {
            if (!t3 && !i) return false;
          } catch (e3) {
            return false;
          }
          var r2 = false;
          try {
            var s2 = {};
            s2[n] = function() {
              return { next: function() {
                return { done: r2 = true };
              } };
            }, e2(s2);
          } catch (e3) {
          }
          return r2;
        };
      }, { "../internals/well-known-symbol": 357 }], 235: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = n({}.toString), s = n("".slice);
        t2.exports = function(e2) {
          return s(i(e2), 8, -1);
        };
      }, { "../internals/function-uncurry-this": 268 }], 236: [function(e, t2, r) {
        var n = e("../internals/to-string-tag-support"), i = e("../internals/is-callable"), s = e("../internals/classof-raw"), o = e("../internals/well-known-symbol")("toStringTag"), a = Object, l = "Arguments" === s(/* @__PURE__ */ (function() {
          return arguments;
        })());
        t2.exports = n ? s : function(e2) {
          var t3, r2, n2;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (r2 = (function(e3, t4) {
            try {
              return e3[t4];
            } catch (e4) {
            }
          })(t3 = a(e2), o)) ? r2 : l ? s(t3) : "Object" === (n2 = s(t3)) && i(t3.callee) ? "Arguments" : n2;
        };
      }, { "../internals/classof-raw": 235, "../internals/is-callable": 285, "../internals/to-string-tag-support": 347, "../internals/well-known-symbol": 357 }], 237: [function(e, t2, r) {
        var n = e("../internals/has-own-property"), i = e("../internals/own-keys"), s = e("../internals/object-get-own-property-descriptor"), o = e("../internals/object-define-property");
        t2.exports = function(e2, t3, r2) {
          for (var a = i(t3), l = o.f, c = s.f, u = 0; u < a.length; u++) {
            var h = a[u];
            n(e2, h) || r2 && n(r2, h) || l(e2, h, c(t3, h));
          }
        };
      }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/object-get-own-property-descriptor": 309, "../internals/own-keys": 321 }], 238: [function(e, t2, r) {
        var n = e("../internals/well-known-symbol")("match");
        t2.exports = function(e2) {
          var t3 = /./;
          try {
            "/./"[e2](t3);
          } catch (r2) {
            try {
              return t3[n] = false, "/./"[e2](t3);
            } catch (e3) {
            }
          }
          return false;
        };
      }, { "../internals/well-known-symbol": 357 }], 239: [function(e, t2, r) {
        var n = e("../internals/fails");
        t2.exports = !n((function() {
          function e2() {
          }
          return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
        }));
      }, { "../internals/fails": 260 }], 240: [function(e, t2, r) {
        t2.exports = function(e2, t3) {
          return { value: e2, done: t3 };
        };
      }, {}], 241: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/object-define-property"), s = e("../internals/create-property-descriptor");
        t2.exports = n ? function(e2, t3, r2) {
          return i.f(e2, t3, s(1, r2));
        } : function(e2, t3, r2) {
          return e2[t3] = r2, e2;
        };
      }, { "../internals/create-property-descriptor": 242, "../internals/descriptors": 247, "../internals/object-define-property": 308 }], 242: [function(e, t2, r) {
        t2.exports = function(e2, t3) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t3 };
        };
      }, {}], 243: [function(e, t2, r) {
        var n = e("../internals/to-property-key"), i = e("../internals/object-define-property"), s = e("../internals/create-property-descriptor");
        t2.exports = function(e2, t3, r2) {
          var o = n(t3);
          o in e2 ? i.f(e2, o, s(0, r2)) : e2[o] = r2;
        };
      }, { "../internals/create-property-descriptor": 242, "../internals/object-define-property": 308, "../internals/to-property-key": 346 }], 244: [function(e, t2, r) {
        var n = e("../internals/make-built-in"), i = e("../internals/object-define-property");
        t2.exports = function(e2, t3, r2) {
          return r2.get && n(r2.get, t3, { getter: true }), r2.set && n(r2.set, t3, { setter: true }), i.f(e2, t3, r2);
        };
      }, { "../internals/make-built-in": 300, "../internals/object-define-property": 308 }], 245: [function(e, t2, r) {
        var n = e("../internals/is-callable"), i = e("../internals/object-define-property"), s = e("../internals/make-built-in"), o = e("../internals/define-global-property");
        t2.exports = function(e2, t3, r2, a) {
          a || (a = {});
          var l = a.enumerable, c = void 0 !== a.name ? a.name : t3;
          if (n(r2) && s(r2, c, a), a.global) l ? e2[t3] = r2 : o(t3, r2);
          else {
            try {
              a.unsafe ? e2[t3] && (l = true) : delete e2[t3];
            } catch (e3) {
            }
            l ? e2[t3] = r2 : i.f(e2, t3, { value: r2, enumerable: false, configurable: !a.nonConfigurable, writable: !a.nonWritable });
          }
          return e2;
        };
      }, { "../internals/define-global-property": 246, "../internals/is-callable": 285, "../internals/make-built-in": 300, "../internals/object-define-property": 308 }], 246: [function(e, t2, r) {
        var n = e("../internals/global"), i = Object.defineProperty;
        t2.exports = function(e2, t3) {
          try {
            i(n, e2, { value: t3, configurable: true, writable: true });
          } catch (r2) {
            n[e2] = t3;
          }
          return t3;
        };
      }, { "../internals/global": 274 }], 247: [function(e, t2, r) {
        var n = e("../internals/fails");
        t2.exports = !n((function() {
          return 7 !== Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1];
        }));
      }, { "../internals/fails": 260 }], 248: [function(e, t2, r) {
        var n = "object" == typeof document && document.all, i = void 0 === n && void 0 !== n;
        t2.exports = { all: n, IS_HTMLDDA: i };
      }, {}], 249: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/is-object"), s = n.document, o = i(s) && i(s.createElement);
        t2.exports = function(e2) {
          return o ? s.createElement(e2) : {};
        };
      }, { "../internals/global": 274, "../internals/is-object": 289 }], 250: [function(e, t2, r) {
        var n = e("../internals/engine-is-deno"), i = e("../internals/engine-is-node");
        t2.exports = !n && !i && "object" == typeof window && "object" == typeof document;
      }, { "../internals/engine-is-deno": 251, "../internals/engine-is-node": 254 }], 251: [function(e, t2, r) {
        t2.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version;
      }, {}], 252: [function(e, t2, r) {
        var n = e("../internals/engine-user-agent");
        t2.exports = /ipad|iphone|ipod/i.test(n) && "undefined" != typeof Pebble;
      }, { "../internals/engine-user-agent": 256 }], 253: [function(e, t2, r) {
        var n = e("../internals/engine-user-agent");
        t2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(n);
      }, { "../internals/engine-user-agent": 256 }], 254: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/classof-raw");
        t2.exports = "process" === i(n.process);
      }, { "../internals/classof-raw": 235, "../internals/global": 274 }], 255: [function(e, t2, r) {
        var n = e("../internals/engine-user-agent");
        t2.exports = /web0s(?!.*chrome)/i.test(n);
      }, { "../internals/engine-user-agent": 256 }], 256: [function(e, t2, r) {
        t2.exports = "undefined" != typeof navigator && String(navigator.userAgent) || "";
      }, {}], 257: [function(e, t2, r) {
        var n, i, s = e("../internals/global"), o = e("../internals/engine-user-agent"), a = s.process, l = s.Deno, c = a && a.versions || l && l.version, u = c && c.v8;
        u && (i = (n = u.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])), !i && o && (!(n = o.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = o.match(/Chrome\/(\d+)/)) && (i = +n[1]), t2.exports = i;
      }, { "../internals/engine-user-agent": 256, "../internals/global": 274 }], 258: [function(e, t2, r) {
        t2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      }, {}], 259: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/object-get-own-property-descriptor").f, s = e("../internals/create-non-enumerable-property"), o = e("../internals/define-built-in"), a = e("../internals/define-global-property"), l = e("../internals/copy-constructor-properties"), c = e("../internals/is-forced");
        t2.exports = function(e2, t3) {
          var r2, u, h, f, d, p = e2.target, m = e2.global, b = e2.stat;
          if (r2 = m ? n : b ? n[p] || a(p, {}) : (n[p] || {}).prototype) for (u in t3) {
            if (f = t3[u], h = e2.dontCallGetSet ? (d = i(r2, u)) && d.value : r2[u], !c(m ? u : p + (b ? "." : "#") + u, e2.forced) && void 0 !== h) {
              if (typeof f == typeof h) continue;
              l(f, h);
            }
            (e2.sham || h && h.sham) && s(f, "sham", true), o(r2, u, f, e2);
          }
        };
      }, { "../internals/copy-constructor-properties": 237, "../internals/create-non-enumerable-property": 241, "../internals/define-built-in": 245, "../internals/define-global-property": 246, "../internals/global": 274, "../internals/is-forced": 287, "../internals/object-get-own-property-descriptor": 309 }], 260: [function(e, t2, r) {
        t2.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      }, {}], 261: [function(e, t2, r) {
        var n = e("../internals/function-bind-native"), i = Function.prototype, s = i.apply, o = i.call;
        t2.exports = "object" == typeof Reflect && Reflect.apply || (n ? o.bind(s) : function() {
          return o.apply(s, arguments);
        });
      }, { "../internals/function-bind-native": 263 }], 262: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this-clause"), i = e("../internals/a-callable"), s = e("../internals/function-bind-native"), o = n(n.bind);
        t2.exports = function(e2, t3) {
          return i(e2), void 0 === t3 ? e2 : s ? o(e2, t3) : function() {
            return e2.apply(t3, arguments);
          };
        };
      }, { "../internals/a-callable": 222, "../internals/function-bind-native": 263, "../internals/function-uncurry-this-clause": 267 }], 263: [function(e, t2, r) {
        var n = e("../internals/fails");
        t2.exports = !n((function() {
          var e2 = (function() {
          }).bind();
          return "function" != typeof e2 || e2.hasOwnProperty("prototype");
        }));
      }, { "../internals/fails": 260 }], 264: [function(e, t2, r) {
        var n = e("../internals/function-bind-native"), i = Function.prototype.call;
        t2.exports = n ? i.bind(i) : function() {
          return i.apply(i, arguments);
        };
      }, { "../internals/function-bind-native": 263 }], 265: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/has-own-property"), s = Function.prototype, o = n && Object.getOwnPropertyDescriptor, a = i(s, "name"), l = a && "something" === (function() {
        }).name, c = a && (!n || n && o(s, "name").configurable);
        t2.exports = { EXISTS: a, PROPER: l, CONFIGURABLE: c };
      }, { "../internals/descriptors": 247, "../internals/has-own-property": 275 }], 266: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/a-callable");
        t2.exports = function(e2, t3, r2) {
          try {
            return n(i(Object.getOwnPropertyDescriptor(e2, t3)[r2]));
          } catch (e3) {
          }
        };
      }, { "../internals/a-callable": 222, "../internals/function-uncurry-this": 268 }], 267: [function(e, t2, r) {
        var n = e("../internals/classof-raw"), i = e("../internals/function-uncurry-this");
        t2.exports = function(e2) {
          if ("Function" === n(e2)) return i(e2);
        };
      }, { "../internals/classof-raw": 235, "../internals/function-uncurry-this": 268 }], 268: [function(e, t2, r) {
        var n = e("../internals/function-bind-native"), i = Function.prototype, s = i.call, o = n && i.bind.bind(s, s);
        t2.exports = n ? o : function(e2) {
          return function() {
            return s.apply(e2, arguments);
          };
        };
      }, { "../internals/function-bind-native": 263 }], 269: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/is-callable"), s = function(e2) {
          return i(e2) ? e2 : void 0;
        };
        t2.exports = function(e2, t3) {
          return arguments.length < 2 ? s(n[e2]) : n[e2] && n[e2][t3];
        };
      }, { "../internals/global": 274, "../internals/is-callable": 285 }], 270: [function(e, t2, r) {
        var n = e("../internals/classof"), i = e("../internals/get-method"), s = e("../internals/is-null-or-undefined"), o = e("../internals/iterators"), a = e("../internals/well-known-symbol")("iterator");
        t2.exports = function(e2) {
          if (!s(e2)) return i(e2, a) || i(e2, "@@iterator") || o[n(e2)];
        };
      }, { "../internals/classof": 236, "../internals/get-method": 273, "../internals/is-null-or-undefined": 288, "../internals/iterators": 298, "../internals/well-known-symbol": 357 }], 271: [function(e, t2, r) {
        var n = e("../internals/function-call"), i = e("../internals/a-callable"), s = e("../internals/an-object"), o = e("../internals/try-to-string"), a = e("../internals/get-iterator-method"), l = TypeError;
        t2.exports = function(e2, t3) {
          var r2 = arguments.length < 2 ? a(e2) : t3;
          if (i(r2)) return s(n(r2, e2));
          throw new l(o(e2) + " is not iterable");
        };
      }, { "../internals/a-callable": 222, "../internals/an-object": 227, "../internals/function-call": 264, "../internals/get-iterator-method": 270, "../internals/try-to-string": 349 }], 272: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/is-array"), s = e("../internals/is-callable"), o = e("../internals/classof-raw"), a = e("../internals/to-string"), l = n([].push);
        t2.exports = function(e2) {
          if (s(e2)) return e2;
          if (i(e2)) {
            for (var t3 = e2.length, r2 = [], n2 = 0; n2 < t3; n2++) {
              var c = e2[n2];
              "string" == typeof c ? l(r2, c) : "number" != typeof c && "Number" !== o(c) && "String" !== o(c) || l(r2, a(c));
            }
            var u = r2.length, h = true;
            return function(e3, t4) {
              if (h) return h = false, t4;
              if (i(this)) return t4;
              for (var n3 = 0; n3 < u; n3++) if (r2[n3] === e3) return t4;
            };
          }
        };
      }, { "../internals/classof-raw": 235, "../internals/function-uncurry-this": 268, "../internals/is-array": 284, "../internals/is-callable": 285, "../internals/to-string": 348 }], 273: [function(e, t2, r) {
        var n = e("../internals/a-callable"), i = e("../internals/is-null-or-undefined");
        t2.exports = function(e2, t3) {
          var r2 = e2[t3];
          return i(r2) ? void 0 : n(r2);
        };
      }, { "../internals/a-callable": 222, "../internals/is-null-or-undefined": 288 }], 274: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var r2 = function(e3) {
              return e3 && e3.Math === Math && e3;
            };
            t2.exports = r2("object" == typeof globalThis && globalThis) || r2("object" == typeof window && window) || r2("object" == typeof self && self) || r2("object" == typeof e2 && e2) || /* @__PURE__ */ (function() {
              return this;
            })() || this || Function("return this")();
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 275: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/to-object"), s = n({}.hasOwnProperty);
        t2.exports = Object.hasOwn || function(e2, t3) {
          return s(i(e2), t3);
        };
      }, { "../internals/function-uncurry-this": 268, "../internals/to-object": 344 }], 276: [function(e, t2, r) {
        t2.exports = {};
      }, {}], 277: [function(e, t2, r) {
        t2.exports = function(e2, t3) {
          try {
            1 === arguments.length ? console.error(e2) : console.error(e2, t3);
          } catch (e3) {
          }
        };
      }, {}], 278: [function(e, t2, r) {
        var n = e("../internals/get-built-in");
        t2.exports = n("document", "documentElement");
      }, { "../internals/get-built-in": 269 }], 279: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/fails"), s = e("../internals/document-create-element");
        t2.exports = !n && !i((function() {
          return 7 !== Object.defineProperty(s("div"), "a", { get: function() {
            return 7;
          } }).a;
        }));
      }, { "../internals/descriptors": 247, "../internals/document-create-element": 249, "../internals/fails": 260 }], 280: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/fails"), s = e("../internals/classof-raw"), o = Object, a = n("".split);
        t2.exports = i((function() {
          return !o("z").propertyIsEnumerable(0);
        })) ? function(e2) {
          return "String" === s(e2) ? a(e2, "") : o(e2);
        } : o;
      }, { "../internals/classof-raw": 235, "../internals/fails": 260, "../internals/function-uncurry-this": 268 }], 281: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/is-callable"), s = e("../internals/shared-store"), o = n(Function.toString);
        i(s.inspectSource) || (s.inspectSource = function(e2) {
          return o(e2);
        }), t2.exports = s.inspectSource;
      }, { "../internals/function-uncurry-this": 268, "../internals/is-callable": 285, "../internals/shared-store": 333 }], 282: [function(e, t2, r) {
        var n, i, s, o = e("../internals/weak-map-basic-detection"), a = e("../internals/global"), l = e("../internals/is-object"), c = e("../internals/create-non-enumerable-property"), u = e("../internals/has-own-property"), h = e("../internals/shared-store"), f = e("../internals/shared-key"), d = e("../internals/hidden-keys"), p = a.TypeError, m = a.WeakMap;
        if (o || h.state) {
          var b = h.state || (h.state = new m());
          b.get = b.get, b.has = b.has, b.set = b.set, n = function(e2, t3) {
            if (b.has(e2)) throw new p("Object already initialized");
            return t3.facade = e2, b.set(e2, t3), t3;
          }, i = function(e2) {
            return b.get(e2) || {};
          }, s = function(e2) {
            return b.has(e2);
          };
        } else {
          var g = f("state");
          d[g] = true, n = function(e2, t3) {
            if (u(e2, g)) throw new p("Object already initialized");
            return t3.facade = e2, c(e2, g, t3), t3;
          }, i = function(e2) {
            return u(e2, g) ? e2[g] : {};
          }, s = function(e2) {
            return u(e2, g);
          };
        }
        t2.exports = { set: n, get: i, has: s, enforce: function(e2) {
          return s(e2) ? i(e2) : n(e2, {});
        }, getterFor: function(e2) {
          return function(t3) {
            var r2;
            if (!l(t3) || (r2 = i(t3)).type !== e2) throw new p("Incompatible receiver, " + e2 + " required");
            return r2;
          };
        } };
      }, { "../internals/create-non-enumerable-property": 241, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/is-object": 289, "../internals/shared-key": 332, "../internals/shared-store": 333, "../internals/weak-map-basic-detection": 354 }], 283: [function(e, t2, r) {
        var n = e("../internals/well-known-symbol"), i = e("../internals/iterators"), s = n("iterator"), o = Array.prototype;
        t2.exports = function(e2) {
          return void 0 !== e2 && (i.Array === e2 || o[s] === e2);
        };
      }, { "../internals/iterators": 298, "../internals/well-known-symbol": 357 }], 284: [function(e, t2, r) {
        var n = e("../internals/classof-raw");
        t2.exports = Array.isArray || function(e2) {
          return "Array" === n(e2);
        };
      }, { "../internals/classof-raw": 235 }], 285: [function(e, t2, r) {
        var n = e("../internals/document-all"), i = n.all;
        t2.exports = n.IS_HTMLDDA ? function(e2) {
          return "function" == typeof e2 || e2 === i;
        } : function(e2) {
          return "function" == typeof e2;
        };
      }, { "../internals/document-all": 248 }], 286: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/fails"), s = e("../internals/is-callable"), o = e("../internals/classof"), a = e("../internals/get-built-in"), l = e("../internals/inspect-source"), c = function() {
        }, u = [], h = a("Reflect", "construct"), f = /^\s*(?:class|function)\b/, d = n(f.exec), p = !f.test(c), m = function(e2) {
          if (!s(e2)) return false;
          try {
            return h(c, u, e2), true;
          } catch (e3) {
            return false;
          }
        }, b = function(e2) {
          if (!s(e2)) return false;
          switch (o(e2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return p || !!d(f, l(e2));
          } catch (e3) {
            return true;
          }
        };
        b.sham = true, t2.exports = !h || i((function() {
          var e2;
          return m(m.call) || !m(Object) || !m((function() {
            e2 = true;
          })) || e2;
        })) ? b : m;
      }, { "../internals/classof": 236, "../internals/fails": 260, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/inspect-source": 281, "../internals/is-callable": 285 }], 287: [function(e, t2, r) {
        var n = e("../internals/fails"), i = e("../internals/is-callable"), s = /#|\.prototype\./, o = function(e2, t3) {
          var r2 = l[a(e2)];
          return r2 === u || r2 !== c && (i(t3) ? n(t3) : !!t3);
        }, a = o.normalize = function(e2) {
          return String(e2).replace(s, ".").toLowerCase();
        }, l = o.data = {}, c = o.NATIVE = "N", u = o.POLYFILL = "P";
        t2.exports = o;
      }, { "../internals/fails": 260, "../internals/is-callable": 285 }], 288: [function(e, t2, r) {
        t2.exports = function(e2) {
          return null == e2;
        };
      }, {}], 289: [function(e, t2, r) {
        var n = e("../internals/is-callable"), i = e("../internals/document-all"), s = i.all;
        t2.exports = i.IS_HTMLDDA ? function(e2) {
          return "object" == typeof e2 ? null !== e2 : n(e2) || e2 === s;
        } : function(e2) {
          return "object" == typeof e2 ? null !== e2 : n(e2);
        };
      }, { "../internals/document-all": 248, "../internals/is-callable": 285 }], 290: [function(e, t2, r) {
        t2.exports = false;
      }, {}], 291: [function(e, t2, r) {
        var n = e("../internals/is-object"), i = e("../internals/classof-raw"), s = e("../internals/well-known-symbol")("match");
        t2.exports = function(e2) {
          var t3;
          return n(e2) && (void 0 !== (t3 = e2[s]) ? !!t3 : "RegExp" === i(e2));
        };
      }, { "../internals/classof-raw": 235, "../internals/is-object": 289, "../internals/well-known-symbol": 357 }], 292: [function(e, t2, r) {
        var n = e("../internals/get-built-in"), i = e("../internals/is-callable"), s = e("../internals/object-is-prototype-of"), o = e("../internals/use-symbol-as-uid"), a = Object;
        t2.exports = o ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          var t3 = n("Symbol");
          return i(t3) && s(t3.prototype, a(e2));
        };
      }, { "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/object-is-prototype-of": 314, "../internals/use-symbol-as-uid": 351 }], 293: [function(e, t2, r) {
        var n = e("../internals/function-bind-context"), i = e("../internals/function-call"), s = e("../internals/an-object"), o = e("../internals/try-to-string"), a = e("../internals/is-array-iterator-method"), l = e("../internals/length-of-array-like"), c = e("../internals/object-is-prototype-of"), u = e("../internals/get-iterator"), h = e("../internals/get-iterator-method"), f = e("../internals/iterator-close"), d = TypeError, p = function(e2, t3) {
          this.stopped = e2, this.result = t3;
        }, m = p.prototype;
        t2.exports = function(e2, t3, r2) {
          var b, g, y, v, w, _, x, k = r2 && r2.that, S = !(!r2 || !r2.AS_ENTRIES), M = !(!r2 || !r2.IS_RECORD), C2 = !(!r2 || !r2.IS_ITERATOR), T = !(!r2 || !r2.INTERRUPTED), E = n(t3, k), A = function(e3) {
            return b && f(b, "normal", e3), new p(true, e3);
          }, R = function(e3) {
            return S ? (s(e3), T ? E(e3[0], e3[1], A) : E(e3[0], e3[1])) : T ? E(e3, A) : E(e3);
          };
          if (M) b = e2.iterator;
          else if (C2) b = e2;
          else {
            if (!(g = h(e2))) throw new d(o(e2) + " is not iterable");
            if (a(g)) {
              for (y = 0, v = l(e2); v > y; y++) if ((w = R(e2[y])) && c(m, w)) return w;
              return new p(false);
            }
            b = u(e2, g);
          }
          for (_ = M ? e2.next : b.next; !(x = i(_, b)).done; ) {
            try {
              w = R(x.value);
            } catch (e3) {
              f(b, "throw", e3);
            }
            if ("object" == typeof w && w && c(m, w)) return w;
          }
          return new p(false);
        };
      }, { "../internals/an-object": 227, "../internals/function-bind-context": 262, "../internals/function-call": 264, "../internals/get-iterator": 271, "../internals/get-iterator-method": 270, "../internals/is-array-iterator-method": 283, "../internals/iterator-close": 294, "../internals/length-of-array-like": 299, "../internals/object-is-prototype-of": 314, "../internals/try-to-string": 349 }], 294: [function(e, t2, r) {
        var n = e("../internals/function-call"), i = e("../internals/an-object"), s = e("../internals/get-method");
        t2.exports = function(e2, t3, r2) {
          var o, a;
          i(e2);
          try {
            if (!(o = s(e2, "return"))) {
              if ("throw" === t3) throw r2;
              return r2;
            }
            o = n(o, e2);
          } catch (e3) {
            a = true, o = e3;
          }
          if ("throw" === t3) throw r2;
          if (a) throw o;
          return i(o), r2;
        };
      }, { "../internals/an-object": 227, "../internals/function-call": 264, "../internals/get-method": 273 }], 295: [function(e, t2, r) {
        var n = e("../internals/iterators-core").IteratorPrototype, i = e("../internals/object-create"), s = e("../internals/create-property-descriptor"), o = e("../internals/set-to-string-tag"), a = e("../internals/iterators"), l = function() {
          return this;
        };
        t2.exports = function(e2, t3, r2, c) {
          var u = t3 + " Iterator";
          return e2.prototype = i(n, { next: s(+!c, r2) }), o(e2, u, false, true), a[u] = l, e2;
        };
      }, { "../internals/create-property-descriptor": 242, "../internals/iterators": 298, "../internals/iterators-core": 297, "../internals/object-create": 306, "../internals/set-to-string-tag": 331 }], 296: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-call"), s = e("../internals/is-pure"), o = e("../internals/function-name"), a = e("../internals/is-callable"), l = e("../internals/iterator-create-constructor"), c = e("../internals/object-get-prototype-of"), u = e("../internals/object-set-prototype-of"), h = e("../internals/set-to-string-tag"), f = e("../internals/create-non-enumerable-property"), d = e("../internals/define-built-in"), p = e("../internals/well-known-symbol"), m = e("../internals/iterators"), b = e("../internals/iterators-core"), g = o.PROPER, y = o.CONFIGURABLE, v = b.IteratorPrototype, w = b.BUGGY_SAFARI_ITERATORS, _ = p("iterator"), x = function() {
          return this;
        };
        t2.exports = function(e2, t3, r2, o2, p2, b2, k) {
          l(r2, t3, o2);
          var S, M, C2, T = function(e3) {
            if (e3 === p2 && j) return j;
            if (!w && e3 && e3 in R) return R[e3];
            switch (e3) {
              case "keys":
              case "values":
              case "entries":
                return function() {
                  return new r2(this, e3);
                };
            }
            return function() {
              return new r2(this);
            };
          }, E = t3 + " Iterator", A = false, R = e2.prototype, O = R[_] || R["@@iterator"] || p2 && R[p2], j = !w && O || T(p2), I = "Array" === t3 && R.entries || O;
          if (I && (S = c(I.call(new e2()))) !== Object.prototype && S.next && (s || c(S) === v || (u ? u(S, v) : a(S[_]) || d(S, _, x)), h(S, E, true, true), s && (m[E] = x)), g && "values" === p2 && O && "values" !== O.name && (!s && y ? f(R, "name", "values") : (A = true, j = function() {
            return i(O, this);
          })), p2) if (M = { values: T("values"), keys: b2 ? j : T("keys"), entries: T("entries") }, k) for (C2 in M) (w || A || !(C2 in R)) && d(R, C2, M[C2]);
          else n({ target: t3, proto: true, forced: w || A }, M);
          return s && !k || R[_] === j || d(R, _, j, { name: p2 }), m[t3] = j, M;
        };
      }, { "../internals/create-non-enumerable-property": 241, "../internals/define-built-in": 245, "../internals/export": 259, "../internals/function-call": 264, "../internals/function-name": 265, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/iterator-create-constructor": 295, "../internals/iterators": 298, "../internals/iterators-core": 297, "../internals/object-get-prototype-of": 313, "../internals/object-set-prototype-of": 318, "../internals/set-to-string-tag": 331, "../internals/well-known-symbol": 357 }], 297: [function(e, t2, r) {
        var n, i, s, o = e("../internals/fails"), a = e("../internals/is-callable"), l = e("../internals/is-object"), c = e("../internals/object-create"), u = e("../internals/object-get-prototype-of"), h = e("../internals/define-built-in"), f = e("../internals/well-known-symbol"), d = e("../internals/is-pure"), p = f("iterator"), m = false;
        [].keys && ("next" in (s = [].keys()) ? (i = u(u(s))) !== Object.prototype && (n = i) : m = true), !l(n) || o((function() {
          var e2 = {};
          return n[p].call(e2) !== e2;
        })) ? n = {} : d && (n = c(n)), a(n[p]) || h(n, p, (function() {
          return this;
        })), t2.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: m };
      }, { "../internals/define-built-in": 245, "../internals/fails": 260, "../internals/is-callable": 285, "../internals/is-object": 289, "../internals/is-pure": 290, "../internals/object-create": 306, "../internals/object-get-prototype-of": 313, "../internals/well-known-symbol": 357 }], 298: [function(e, t2, r) {
        arguments[4][276][0].apply(r, arguments);
      }, { dup: 276 }], 299: [function(e, t2, r) {
        var n = e("../internals/to-length");
        t2.exports = function(e2) {
          return n(e2.length);
        };
      }, { "../internals/to-length": 343 }], 300: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/fails"), s = e("../internals/is-callable"), o = e("../internals/has-own-property"), a = e("../internals/descriptors"), l = e("../internals/function-name").CONFIGURABLE, c = e("../internals/inspect-source"), u = e("../internals/internal-state"), h = u.enforce, f = u.get, d = String, p = Object.defineProperty, m = n("".slice), b = n("".replace), g = n([].join), y = a && !i((function() {
          return 8 !== p((function() {
          }), "length", { value: 8 }).length;
        })), v = String(String).split("String"), w = t2.exports = function(e2, t3, r2) {
          "Symbol(" === m(d(t3), 0, 7) && (t3 = "[" + b(d(t3), /^Symbol\(([^)]*)\)/, "$1") + "]"), r2 && r2.getter && (t3 = "get " + t3), r2 && r2.setter && (t3 = "set " + t3), (!o(e2, "name") || l && e2.name !== t3) && (a ? p(e2, "name", { value: t3, configurable: true }) : e2.name = t3), y && r2 && o(r2, "arity") && e2.length !== r2.arity && p(e2, "length", { value: r2.arity });
          try {
            r2 && o(r2, "constructor") && r2.constructor ? a && p(e2, "prototype", { writable: false }) : e2.prototype && (e2.prototype = void 0);
          } catch (e3) {
          }
          var n2 = h(e2);
          return o(n2, "source") || (n2.source = g(v, "string" == typeof t3 ? t3 : "")), e2;
        };
        Function.prototype.toString = w((function() {
          return s(this) && f(this).source || c(this);
        }), "toString");
      }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-name": 265, "../internals/function-uncurry-this": 268, "../internals/has-own-property": 275, "../internals/inspect-source": 281, "../internals/internal-state": 282, "../internals/is-callable": 285 }], 301: [function(e, t2, r) {
        var n = Math.ceil, i = Math.floor;
        t2.exports = Math.trunc || function(e2) {
          var t3 = +e2;
          return (t3 > 0 ? i : n)(t3);
        };
      }, {}], 302: [function(e, t2, r) {
        var n, i, s, o, a, l = e("../internals/global"), c = e("../internals/function-bind-context"), u = e("../internals/object-get-own-property-descriptor").f, h = e("../internals/task").set, f = e("../internals/queue"), d = e("../internals/engine-is-ios"), p = e("../internals/engine-is-ios-pebble"), m = e("../internals/engine-is-webos-webkit"), b = e("../internals/engine-is-node"), g = l.MutationObserver || l.WebKitMutationObserver, y = l.document, v = l.process, w = l.Promise, _ = u(l, "queueMicrotask"), x = _ && _.value;
        if (!x) {
          var k = new f(), S = function() {
            var e2, t3;
            for (b && (e2 = v.domain) && e2.exit(); t3 = k.get(); ) try {
              t3();
            } catch (e3) {
              throw k.head && n(), e3;
            }
            e2 && e2.enter();
          };
          d || b || m || !g || !y ? !p && w && w.resolve ? ((o = w.resolve(void 0)).constructor = w, a = c(o.then, o), n = function() {
            a(S);
          }) : b ? n = function() {
            v.nextTick(S);
          } : (h = c(h, l), n = function() {
            h(S);
          }) : (i = true, s = y.createTextNode(""), new g(S).observe(s, { characterData: true }), n = function() {
            s.data = i = !i;
          }), x = function(e2) {
            k.head || n(), k.add(e2);
          };
        }
        t2.exports = x;
      }, { "../internals/engine-is-ios": 253, "../internals/engine-is-ios-pebble": 252, "../internals/engine-is-node": 254, "../internals/engine-is-webos-webkit": 255, "../internals/function-bind-context": 262, "../internals/global": 274, "../internals/object-get-own-property-descriptor": 309, "../internals/queue": 328, "../internals/task": 339 }], 303: [function(e, t2, r) {
        var n = e("../internals/a-callable"), i = TypeError, s = function(e2) {
          var t3, r2;
          this.promise = new e2((function(e3, n2) {
            if (void 0 !== t3 || void 0 !== r2) throw new i("Bad Promise constructor");
            t3 = e3, r2 = n2;
          })), this.resolve = n(t3), this.reject = n(r2);
        };
        t2.exports.f = function(e2) {
          return new s(e2);
        };
      }, { "../internals/a-callable": 222 }], 304: [function(e, t2, r) {
        var n = e("../internals/is-regexp"), i = TypeError;
        t2.exports = function(e2) {
          if (n(e2)) throw new i("The method doesn't accept regular expressions");
          return e2;
        };
      }, { "../internals/is-regexp": 291 }], 305: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/function-uncurry-this"), s = e("../internals/function-call"), o = e("../internals/fails"), a = e("../internals/object-keys"), l = e("../internals/object-get-own-property-symbols"), c = e("../internals/object-property-is-enumerable"), u = e("../internals/to-object"), h = e("../internals/indexed-object"), f = Object.assign, d = Object.defineProperty, p = i([].concat);
        t2.exports = !f || o((function() {
          if (n && 1 !== f({ b: 1 }, f(d({}, "a", { enumerable: true, get: function() {
            d(this, "b", { value: 3, enumerable: false });
          } }), { b: 2 })).b) return true;
          var e2 = {}, t3 = {}, r2 = /* @__PURE__ */ Symbol("assign detection");
          return e2[r2] = 7, "abcdefghijklmnopqrst".split("").forEach((function(e3) {
            t3[e3] = e3;
          })), 7 !== f({}, e2)[r2] || "abcdefghijklmnopqrst" !== a(f({}, t3)).join("");
        })) ? function(e2, t3) {
          for (var r2 = u(e2), i2 = arguments.length, o2 = 1, f2 = l.f, d2 = c.f; i2 > o2; ) for (var m, b = h(arguments[o2++]), g = f2 ? p(a(b), f2(b)) : a(b), y = g.length, v = 0; y > v; ) m = g[v++], n && !s(d2, b, m) || (r2[m] = b[m]);
          return r2;
        } : f;
      }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/indexed-object": 280, "../internals/object-get-own-property-symbols": 312, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/to-object": 344 }], 306: [function(e, t2, r) {
        var n, i = e("../internals/an-object"), s = e("../internals/object-define-properties"), o = e("../internals/enum-bug-keys"), a = e("../internals/hidden-keys"), l = e("../internals/html"), c = e("../internals/document-create-element"), u = e("../internals/shared-key"), h = u("IE_PROTO"), f = function() {
        }, d = function(e2) {
          return "<script>" + e2 + "<\/script>";
        }, p = function(e2) {
          e2.write(d("")), e2.close();
          var t3 = e2.parentWindow.Object;
          return e2 = null, t3;
        }, m = function() {
          try {
            n = new ActiveXObject("htmlfile");
          } catch (e3) {
          }
          var e2, t3;
          m = "undefined" != typeof document ? document.domain && n ? p(n) : ((t3 = c("iframe")).style.display = "none", l.appendChild(t3), t3.src = String("javascript:"), (e2 = t3.contentWindow.document).open(), e2.write(d("document.F=Object")), e2.close(), e2.F) : p(n);
          for (var r2 = o.length; r2--; ) delete m.prototype[o[r2]];
          return m();
        };
        a[h] = true, t2.exports = Object.create || function(e2, t3) {
          var r2;
          return null !== e2 ? (f.prototype = i(e2), r2 = new f(), f.prototype = null, r2[h] = e2) : r2 = m(), void 0 === t3 ? r2 : s.f(r2, t3);
        };
      }, { "../internals/an-object": 227, "../internals/document-create-element": 249, "../internals/enum-bug-keys": 258, "../internals/hidden-keys": 276, "../internals/html": 278, "../internals/object-define-properties": 307, "../internals/shared-key": 332 }], 307: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/v8-prototype-define-bug"), s = e("../internals/object-define-property"), o = e("../internals/an-object"), a = e("../internals/to-indexed-object"), l = e("../internals/object-keys");
        r.f = n && !i ? Object.defineProperties : function(e2, t3) {
          o(e2);
          for (var r2, n2 = a(t3), i2 = l(t3), c = i2.length, u = 0; c > u; ) s.f(e2, r2 = i2[u++], n2[r2]);
          return e2;
        };
      }, { "../internals/an-object": 227, "../internals/descriptors": 247, "../internals/object-define-property": 308, "../internals/object-keys": 316, "../internals/to-indexed-object": 341, "../internals/v8-prototype-define-bug": 352 }], 308: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/ie8-dom-define"), s = e("../internals/v8-prototype-define-bug"), o = e("../internals/an-object"), a = e("../internals/to-property-key"), l = TypeError, c = Object.defineProperty, u = Object.getOwnPropertyDescriptor;
        r.f = n ? s ? function(e2, t3, r2) {
          if (o(e2), t3 = a(t3), o(r2), "function" == typeof e2 && "prototype" === t3 && "value" in r2 && "writable" in r2 && !r2.writable) {
            var n2 = u(e2, t3);
            n2 && n2.writable && (e2[t3] = r2.value, r2 = { configurable: "configurable" in r2 ? r2.configurable : n2.configurable, enumerable: "enumerable" in r2 ? r2.enumerable : n2.enumerable, writable: false });
          }
          return c(e2, t3, r2);
        } : c : function(e2, t3, r2) {
          if (o(e2), t3 = a(t3), o(r2), i) try {
            return c(e2, t3, r2);
          } catch (e3) {
          }
          if ("get" in r2 || "set" in r2) throw new l("Accessors not supported");
          return "value" in r2 && (e2[t3] = r2.value), e2;
        };
      }, { "../internals/an-object": 227, "../internals/descriptors": 247, "../internals/ie8-dom-define": 279, "../internals/to-property-key": 346, "../internals/v8-prototype-define-bug": 352 }], 309: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/function-call"), s = e("../internals/object-property-is-enumerable"), o = e("../internals/create-property-descriptor"), a = e("../internals/to-indexed-object"), l = e("../internals/to-property-key"), c = e("../internals/has-own-property"), u = e("../internals/ie8-dom-define"), h = Object.getOwnPropertyDescriptor;
        r.f = n ? h : function(e2, t3) {
          if (e2 = a(e2), t3 = l(t3), u) try {
            return h(e2, t3);
          } catch (e3) {
          }
          if (c(e2, t3)) return o(!i(s.f, e2, t3), e2[t3]);
        };
      }, { "../internals/create-property-descriptor": 242, "../internals/descriptors": 247, "../internals/function-call": 264, "../internals/has-own-property": 275, "../internals/ie8-dom-define": 279, "../internals/object-property-is-enumerable": 317, "../internals/to-indexed-object": 341, "../internals/to-property-key": 346 }], 310: [function(e, t2, r) {
        var n = e("../internals/classof-raw"), i = e("../internals/to-indexed-object"), s = e("../internals/object-get-own-property-names").f, o = e("../internals/array-slice-simple"), a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        t2.exports.f = function(e2) {
          return a && "Window" === n(e2) ? (function(e3) {
            try {
              return s(e3);
            } catch (e4) {
              return o(a);
            }
          })(e2) : s(i(e2));
        };
      }, { "../internals/array-slice-simple": 230, "../internals/classof-raw": 235, "../internals/object-get-own-property-names": 311, "../internals/to-indexed-object": 341 }], 311: [function(e, t2, r) {
        var n = e("../internals/object-keys-internal"), i = e("../internals/enum-bug-keys").concat("length", "prototype");
        r.f = Object.getOwnPropertyNames || function(e2) {
          return n(e2, i);
        };
      }, { "../internals/enum-bug-keys": 258, "../internals/object-keys-internal": 315 }], 312: [function(e, t2, r) {
        r.f = Object.getOwnPropertySymbols;
      }, {}], 313: [function(e, t2, r) {
        var n = e("../internals/has-own-property"), i = e("../internals/is-callable"), s = e("../internals/to-object"), o = e("../internals/shared-key"), a = e("../internals/correct-prototype-getter"), l = o("IE_PROTO"), c = Object, u = c.prototype;
        t2.exports = a ? c.getPrototypeOf : function(e2) {
          var t3 = s(e2);
          if (n(t3, l)) return t3[l];
          var r2 = t3.constructor;
          return i(r2) && t3 instanceof r2 ? r2.prototype : t3 instanceof c ? u : null;
        };
      }, { "../internals/correct-prototype-getter": 239, "../internals/has-own-property": 275, "../internals/is-callable": 285, "../internals/shared-key": 332, "../internals/to-object": 344 }], 314: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this");
        t2.exports = n({}.isPrototypeOf);
      }, { "../internals/function-uncurry-this": 268 }], 315: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = e("../internals/has-own-property"), s = e("../internals/to-indexed-object"), o = e("../internals/array-includes").indexOf, a = e("../internals/hidden-keys"), l = n([].push);
        t2.exports = function(e2, t3) {
          var r2, n2 = s(e2), c = 0, u = [];
          for (r2 in n2) !i(a, r2) && i(n2, r2) && l(u, r2);
          for (; t3.length > c; ) i(n2, r2 = t3[c++]) && (~o(u, r2) || l(u, r2));
          return u;
        };
      }, { "../internals/array-includes": 228, "../internals/function-uncurry-this": 268, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/to-indexed-object": 341 }], 316: [function(e, t2, r) {
        var n = e("../internals/object-keys-internal"), i = e("../internals/enum-bug-keys");
        t2.exports = Object.keys || function(e2) {
          return n(e2, i);
        };
      }, { "../internals/enum-bug-keys": 258, "../internals/object-keys-internal": 315 }], 317: [function(e, t2, r) {
        var n = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, s = i && !n.call({ 1: 2 }, 1);
        r.f = s ? function(e2) {
          var t3 = i(this, e2);
          return !!t3 && t3.enumerable;
        } : n;
      }, {}], 318: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this-accessor"), i = e("../internals/an-object"), s = e("../internals/a-possible-prototype");
        t2.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
          var e2, t3 = false, r2 = {};
          try {
            (e2 = n(Object.prototype, "__proto__", "set"))(r2, []), t3 = r2 instanceof Array;
          } catch (e3) {
          }
          return function(r3, n2) {
            return i(r3), s(n2), t3 ? e2(r3, n2) : r3.__proto__ = n2, r3;
          };
        })() : void 0);
      }, { "../internals/a-possible-prototype": 224, "../internals/an-object": 227, "../internals/function-uncurry-this-accessor": 266 }], 319: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/fails"), s = e("../internals/function-uncurry-this"), o = e("../internals/object-get-prototype-of"), a = e("../internals/object-keys"), l = e("../internals/to-indexed-object"), c = s(e("../internals/object-property-is-enumerable").f), u = s([].push), h = n && i((function() {
          var e2 = /* @__PURE__ */ Object.create(null);
          return e2[2] = 2, !c(e2, 2);
        })), f = function(e2) {
          return function(t3) {
            for (var r2, i2 = l(t3), s2 = a(i2), f2 = h && null === o(i2), d = s2.length, p = 0, m = []; d > p; ) r2 = s2[p++], n && !(f2 ? r2 in i2 : c(i2, r2)) || u(m, e2 ? [r2, i2[r2]] : i2[r2]);
            return m;
          };
        };
        t2.exports = { entries: f(true), values: f(false) };
      }, { "../internals/descriptors": 247, "../internals/fails": 260, "../internals/function-uncurry-this": 268, "../internals/object-get-prototype-of": 313, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/to-indexed-object": 341 }], 320: [function(e, t2, r) {
        var n = e("../internals/function-call"), i = e("../internals/is-callable"), s = e("../internals/is-object"), o = TypeError;
        t2.exports = function(e2, t3) {
          var r2, a;
          if ("string" === t3 && i(r2 = e2.toString) && !s(a = n(r2, e2))) return a;
          if (i(r2 = e2.valueOf) && !s(a = n(r2, e2))) return a;
          if ("string" !== t3 && i(r2 = e2.toString) && !s(a = n(r2, e2))) return a;
          throw new o("Can't convert object to primitive value");
        };
      }, { "../internals/function-call": 264, "../internals/is-callable": 285, "../internals/is-object": 289 }], 321: [function(e, t2, r) {
        var n = e("../internals/get-built-in"), i = e("../internals/function-uncurry-this"), s = e("../internals/object-get-own-property-names"), o = e("../internals/object-get-own-property-symbols"), a = e("../internals/an-object"), l = i([].concat);
        t2.exports = n("Reflect", "ownKeys") || function(e2) {
          var t3 = s.f(a(e2)), r2 = o.f;
          return r2 ? l(t3, r2(e2)) : t3;
        };
      }, { "../internals/an-object": 227, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/object-get-own-property-names": 311, "../internals/object-get-own-property-symbols": 312 }], 322: [function(e, t2, r) {
        var n = e("../internals/global");
        t2.exports = n;
      }, { "../internals/global": 274 }], 323: [function(e, t2, r) {
        t2.exports = function(e2) {
          try {
            return { error: false, value: e2() };
          } catch (e3) {
            return { error: true, value: e3 };
          }
        };
      }, {}], 324: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/promise-native-constructor"), s = e("../internals/is-callable"), o = e("../internals/is-forced"), a = e("../internals/inspect-source"), l = e("../internals/well-known-symbol"), c = e("../internals/engine-is-browser"), u = e("../internals/engine-is-deno"), h = e("../internals/is-pure"), f = e("../internals/engine-v8-version"), d = i && i.prototype, p = l("species"), m = false, b = s(n.PromiseRejectionEvent), g = o("Promise", (function() {
          var e2 = a(i), t3 = e2 !== String(i);
          if (!t3 && 66 === f) return true;
          if (h && (!d.catch || !d.finally)) return true;
          if (!f || f < 51 || !/native code/.test(e2)) {
            var r2 = new i((function(e3) {
              e3(1);
            })), n2 = function(e3) {
              e3((function() {
              }), (function() {
              }));
            };
            if ((r2.constructor = {})[p] = n2, !(m = r2.then((function() {
            })) instanceof n2)) return true;
          }
          return !t3 && (c || u) && !b;
        }));
        t2.exports = { CONSTRUCTOR: g, REJECTION_EVENT: b, SUBCLASSING: m };
      }, { "../internals/engine-is-browser": 250, "../internals/engine-is-deno": 251, "../internals/engine-v8-version": 257, "../internals/global": 274, "../internals/inspect-source": 281, "../internals/is-callable": 285, "../internals/is-forced": 287, "../internals/is-pure": 290, "../internals/promise-native-constructor": 325, "../internals/well-known-symbol": 357 }], 325: [function(e, t2, r) {
        var n = e("../internals/global");
        t2.exports = n.Promise;
      }, { "../internals/global": 274 }], 326: [function(e, t2, r) {
        var n = e("../internals/an-object"), i = e("../internals/is-object"), s = e("../internals/new-promise-capability");
        t2.exports = function(e2, t3) {
          if (n(e2), i(t3) && t3.constructor === e2) return t3;
          var r2 = s.f(e2);
          return (0, r2.resolve)(t3), r2.promise;
        };
      }, { "../internals/an-object": 227, "../internals/is-object": 289, "../internals/new-promise-capability": 303 }], 327: [function(e, t2, r) {
        var n = e("../internals/promise-native-constructor"), i = e("../internals/check-correctness-of-iteration"), s = e("../internals/promise-constructor-detection").CONSTRUCTOR;
        t2.exports = s || !i((function(e2) {
          n.all(e2).then(void 0, (function() {
          }));
        }));
      }, { "../internals/check-correctness-of-iteration": 234, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325 }], 328: [function(e, t2, r) {
        var n = function() {
          this.head = null, this.tail = null;
        };
        n.prototype = { add: function(e2) {
          var t3 = { item: e2, next: null }, r2 = this.tail;
          r2 ? r2.next = t3 : this.head = t3, this.tail = t3;
        }, get: function() {
          var e2 = this.head;
          if (e2) return null === (this.head = e2.next) && (this.tail = null), e2.item;
        } }, t2.exports = n;
      }, {}], 329: [function(e, t2, r) {
        var n = e("../internals/is-null-or-undefined"), i = TypeError;
        t2.exports = function(e2) {
          if (n(e2)) throw new i("Can't call method on " + e2);
          return e2;
        };
      }, { "../internals/is-null-or-undefined": 288 }], 330: [function(e, t2, r) {
        var n = e("../internals/get-built-in"), i = e("../internals/define-built-in-accessor"), s = e("../internals/well-known-symbol"), o = e("../internals/descriptors"), a = s("species");
        t2.exports = function(e2) {
          var t3 = n(e2);
          o && t3 && !t3[a] && i(t3, a, { configurable: true, get: function() {
            return this;
          } });
        };
      }, { "../internals/define-built-in-accessor": 244, "../internals/descriptors": 247, "../internals/get-built-in": 269, "../internals/well-known-symbol": 357 }], 331: [function(e, t2, r) {
        var n = e("../internals/object-define-property").f, i = e("../internals/has-own-property"), s = e("../internals/well-known-symbol")("toStringTag");
        t2.exports = function(e2, t3, r2) {
          e2 && !r2 && (e2 = e2.prototype), e2 && !i(e2, s) && n(e2, s, { configurable: true, value: t3 });
        };
      }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/well-known-symbol": 357 }], 332: [function(e, t2, r) {
        var n = e("../internals/shared"), i = e("../internals/uid"), s = n("keys");
        t2.exports = function(e2) {
          return s[e2] || (s[e2] = i(e2));
        };
      }, { "../internals/shared": 334, "../internals/uid": 350 }], 333: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/define-global-property"), s = n["__core-js_shared__"] || i("__core-js_shared__", {});
        t2.exports = s;
      }, { "../internals/define-global-property": 246, "../internals/global": 274 }], 334: [function(e, t2, r) {
        var n = e("../internals/is-pure"), i = e("../internals/shared-store");
        (t2.exports = function(e2, t3) {
          return i[e2] || (i[e2] = void 0 !== t3 ? t3 : {});
        })("versions", []).push({ version: "3.33.0", mode: n ? "pure" : "global", copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE", source: "https://github.com/zloirock/core-js" });
      }, { "../internals/is-pure": 290, "../internals/shared-store": 333 }], 335: [function(e, t2, r) {
        var n = e("../internals/an-object"), i = e("../internals/a-constructor"), s = e("../internals/is-null-or-undefined"), o = e("../internals/well-known-symbol")("species");
        t2.exports = function(e2, t3) {
          var r2, a = n(e2).constructor;
          return void 0 === a || s(r2 = n(a)[o]) ? t3 : i(r2);
        };
      }, { "../internals/a-constructor": 223, "../internals/an-object": 227, "../internals/is-null-or-undefined": 288, "../internals/well-known-symbol": 357 }], 336: [function(e, t2, r) {
        var n = e("../internals/engine-v8-version"), i = e("../internals/fails"), s = e("../internals/global").String;
        t2.exports = !!Object.getOwnPropertySymbols && !i((function() {
          var e2 = /* @__PURE__ */ Symbol("symbol detection");
          return !s(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && n && n < 41;
        }));
      }, { "../internals/engine-v8-version": 257, "../internals/fails": 260, "../internals/global": 274 }], 337: [function(e, t2, r) {
        var n = e("../internals/function-call"), i = e("../internals/get-built-in"), s = e("../internals/well-known-symbol"), o = e("../internals/define-built-in");
        t2.exports = function() {
          var e2 = i("Symbol"), t3 = e2 && e2.prototype, r2 = t3 && t3.valueOf, a = s("toPrimitive");
          t3 && !t3[a] && o(t3, a, (function(e3) {
            return n(r2, this);
          }), { arity: 1 });
        };
      }, { "../internals/define-built-in": 245, "../internals/function-call": 264, "../internals/get-built-in": 269, "../internals/well-known-symbol": 357 }], 338: [function(e, t2, r) {
        var n = e("../internals/symbol-constructor-detection");
        t2.exports = n && !!Symbol.for && !!Symbol.keyFor;
      }, { "../internals/symbol-constructor-detection": 336 }], 339: [function(e, t2, r) {
        var n, i, s, o, a = e("../internals/global"), l = e("../internals/function-apply"), c = e("../internals/function-bind-context"), u = e("../internals/is-callable"), h = e("../internals/has-own-property"), f = e("../internals/fails"), d = e("../internals/html"), p = e("../internals/array-slice"), m = e("../internals/document-create-element"), b = e("../internals/validate-arguments-length"), g = e("../internals/engine-is-ios"), y = e("../internals/engine-is-node"), v = a.setImmediate, w = a.clearImmediate, _ = a.process, x = a.Dispatch, k = a.Function, S = a.MessageChannel, M = a.String, C2 = 0, T = {};
        f((function() {
          n = a.location;
        }));
        var E = function(e2) {
          if (h(T, e2)) {
            var t3 = T[e2];
            delete T[e2], t3();
          }
        }, A = function(e2) {
          return function() {
            E(e2);
          };
        }, R = function(e2) {
          E(e2.data);
        }, O = function(e2) {
          a.postMessage(M(e2), n.protocol + "//" + n.host);
        };
        v && w || (v = function(e2) {
          b(arguments.length, 1);
          var t3 = u(e2) ? e2 : k(e2), r2 = p(arguments, 1);
          return T[++C2] = function() {
            l(t3, void 0, r2);
          }, i(C2), C2;
        }, w = function(e2) {
          delete T[e2];
        }, y ? i = function(e2) {
          _.nextTick(A(e2));
        } : x && x.now ? i = function(e2) {
          x.now(A(e2));
        } : S && !g ? (o = (s = new S()).port2, s.port1.onmessage = R, i = c(o.postMessage, o)) : a.addEventListener && u(a.postMessage) && !a.importScripts && n && "file:" !== n.protocol && !f(O) ? (i = O, a.addEventListener("message", R, false)) : i = "onreadystatechange" in m("script") ? function(e2) {
          d.appendChild(m("script")).onreadystatechange = function() {
            d.removeChild(this), E(e2);
          };
        } : function(e2) {
          setTimeout(A(e2), 0);
        }), t2.exports = { set: v, clear: w };
      }, { "../internals/array-slice": 231, "../internals/document-create-element": 249, "../internals/engine-is-ios": 253, "../internals/engine-is-node": 254, "../internals/fails": 260, "../internals/function-apply": 261, "../internals/function-bind-context": 262, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/html": 278, "../internals/is-callable": 285, "../internals/validate-arguments-length": 353 }], 340: [function(e, t2, r) {
        var n = e("../internals/to-integer-or-infinity"), i = Math.max, s = Math.min;
        t2.exports = function(e2, t3) {
          var r2 = n(e2);
          return r2 < 0 ? i(r2 + t3, 0) : s(r2, t3);
        };
      }, { "../internals/to-integer-or-infinity": 342 }], 341: [function(e, t2, r) {
        var n = e("../internals/indexed-object"), i = e("../internals/require-object-coercible");
        t2.exports = function(e2) {
          return n(i(e2));
        };
      }, { "../internals/indexed-object": 280, "../internals/require-object-coercible": 329 }], 342: [function(e, t2, r) {
        var n = e("../internals/math-trunc");
        t2.exports = function(e2) {
          var t3 = +e2;
          return t3 != t3 || 0 === t3 ? 0 : n(t3);
        };
      }, { "../internals/math-trunc": 301 }], 343: [function(e, t2, r) {
        var n = e("../internals/to-integer-or-infinity"), i = Math.min;
        t2.exports = function(e2) {
          return e2 > 0 ? i(n(e2), 9007199254740991) : 0;
        };
      }, { "../internals/to-integer-or-infinity": 342 }], 344: [function(e, t2, r) {
        var n = e("../internals/require-object-coercible"), i = Object;
        t2.exports = function(e2) {
          return i(n(e2));
        };
      }, { "../internals/require-object-coercible": 329 }], 345: [function(e, t2, r) {
        var n = e("../internals/function-call"), i = e("../internals/is-object"), s = e("../internals/is-symbol"), o = e("../internals/get-method"), a = e("../internals/ordinary-to-primitive"), l = e("../internals/well-known-symbol"), c = TypeError, u = l("toPrimitive");
        t2.exports = function(e2, t3) {
          if (!i(e2) || s(e2)) return e2;
          var r2, l2 = o(e2, u);
          if (l2) {
            if (void 0 === t3 && (t3 = "default"), r2 = n(l2, e2, t3), !i(r2) || s(r2)) return r2;
            throw new c("Can't convert object to primitive value");
          }
          return void 0 === t3 && (t3 = "number"), a(e2, t3);
        };
      }, { "../internals/function-call": 264, "../internals/get-method": 273, "../internals/is-object": 289, "../internals/is-symbol": 292, "../internals/ordinary-to-primitive": 320, "../internals/well-known-symbol": 357 }], 346: [function(e, t2, r) {
        var n = e("../internals/to-primitive"), i = e("../internals/is-symbol");
        t2.exports = function(e2) {
          var t3 = n(e2, "string");
          return i(t3) ? t3 : t3 + "";
        };
      }, { "../internals/is-symbol": 292, "../internals/to-primitive": 345 }], 347: [function(e, t2, r) {
        var n = {};
        n[e("../internals/well-known-symbol")("toStringTag")] = "z", t2.exports = "[object z]" === String(n);
      }, { "../internals/well-known-symbol": 357 }], 348: [function(e, t2, r) {
        var n = e("../internals/classof"), i = String;
        t2.exports = function(e2) {
          if ("Symbol" === n(e2)) throw new TypeError("Cannot convert a Symbol value to a string");
          return i(e2);
        };
      }, { "../internals/classof": 236 }], 349: [function(e, t2, r) {
        var n = String;
        t2.exports = function(e2) {
          try {
            return n(e2);
          } catch (e3) {
            return "Object";
          }
        };
      }, {}], 350: [function(e, t2, r) {
        var n = e("../internals/function-uncurry-this"), i = 0, s = Math.random(), o = n(1 .toString);
        t2.exports = function(e2) {
          return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + o(++i + s, 36);
        };
      }, { "../internals/function-uncurry-this": 268 }], 351: [function(e, t2, r) {
        var n = e("../internals/symbol-constructor-detection");
        t2.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator;
      }, { "../internals/symbol-constructor-detection": 336 }], 352: [function(e, t2, r) {
        var n = e("../internals/descriptors"), i = e("../internals/fails");
        t2.exports = n && i((function() {
          return 42 !== Object.defineProperty((function() {
          }), "prototype", { value: 42, writable: false }).prototype;
        }));
      }, { "../internals/descriptors": 247, "../internals/fails": 260 }], 353: [function(e, t2, r) {
        var n = TypeError;
        t2.exports = function(e2, t3) {
          if (e2 < t3) throw new n("Not enough arguments");
          return e2;
        };
      }, {}], 354: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/is-callable"), s = n.WeakMap;
        t2.exports = i(s) && /native code/.test(String(s));
      }, { "../internals/global": 274, "../internals/is-callable": 285 }], 355: [function(e, t2, r) {
        var n = e("../internals/path"), i = e("../internals/has-own-property"), s = e("../internals/well-known-symbol-wrapped"), o = e("../internals/object-define-property").f;
        t2.exports = function(e2) {
          var t3 = n.Symbol || (n.Symbol = {});
          i(t3, e2) || o(t3, e2, { value: s.f(e2) });
        };
      }, { "../internals/has-own-property": 275, "../internals/object-define-property": 308, "../internals/path": 322, "../internals/well-known-symbol-wrapped": 356 }], 356: [function(e, t2, r) {
        var n = e("../internals/well-known-symbol");
        r.f = n;
      }, { "../internals/well-known-symbol": 357 }], 357: [function(e, t2, r) {
        var n = e("../internals/global"), i = e("../internals/shared"), s = e("../internals/has-own-property"), o = e("../internals/uid"), a = e("../internals/symbol-constructor-detection"), l = e("../internals/use-symbol-as-uid"), c = n.Symbol, u = i("wks"), h = l ? c.for || c : c && c.withoutSetter || o;
        t2.exports = function(e2) {
          return s(u, e2) || (u[e2] = a && s(c, e2) ? c[e2] : h("Symbol." + e2)), u[e2];
        };
      }, { "../internals/global": 274, "../internals/has-own-property": 275, "../internals/shared": 334, "../internals/symbol-constructor-detection": 336, "../internals/uid": 350, "../internals/use-symbol-as-uid": 351 }], 358: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/array-iteration").findIndex, s = e("../internals/add-to-unscopables"), o = true;
        "findIndex" in [] && Array(1).findIndex((function() {
          o = false;
        })), n({ target: "Array", proto: true, forced: o }, { findIndex: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } }), s("findIndex");
      }, { "../internals/add-to-unscopables": 225, "../internals/array-iteration": 229, "../internals/export": 259 }], 359: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/array-iteration").find, s = e("../internals/add-to-unscopables"), o = true;
        "find" in [] && Array(1).find((function() {
          o = false;
        })), n({ target: "Array", proto: true, forced: o }, { find: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } }), s("find");
      }, { "../internals/add-to-unscopables": 225, "../internals/array-iteration": 229, "../internals/export": 259 }], 360: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/array-includes").includes, s = e("../internals/fails"), o = e("../internals/add-to-unscopables");
        n({ target: "Array", proto: true, forced: s((function() {
          return !Array(1).includes();
        })) }, { includes: function(e2) {
          return i(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } }), o("includes");
      }, { "../internals/add-to-unscopables": 225, "../internals/array-includes": 228, "../internals/export": 259, "../internals/fails": 260 }], 361: [function(e, t2, r) {
        var n = e("../internals/to-indexed-object"), i = e("../internals/add-to-unscopables"), s = e("../internals/iterators"), o = e("../internals/internal-state"), a = e("../internals/object-define-property").f, l = e("../internals/iterator-define"), c = e("../internals/create-iter-result-object"), u = e("../internals/is-pure"), h = e("../internals/descriptors"), f = o.set, d = o.getterFor("Array Iterator");
        t2.exports = l(Array, "Array", (function(e2, t3) {
          f(this, { type: "Array Iterator", target: n(e2), index: 0, kind: t3 });
        }), (function() {
          var e2 = d(this), t3 = e2.target, r2 = e2.kind, n2 = e2.index++;
          if (!t3 || n2 >= t3.length) return e2.target = void 0, c(void 0, true);
          switch (r2) {
            case "keys":
              return c(n2, false);
            case "values":
              return c(t3[n2], false);
          }
          return c([n2, t3[n2]], false);
        }), "values");
        var p = s.Arguments = s.Array;
        if (i("keys"), i("values"), i("entries"), !u && h && "values" !== p.name) try {
          a(p, "name", { value: "values" });
        } catch (e2) {
        }
      }, { "../internals/add-to-unscopables": 225, "../internals/create-iter-result-object": 240, "../internals/descriptors": 247, "../internals/internal-state": 282, "../internals/is-pure": 290, "../internals/iterator-define": 296, "../internals/iterators": 298, "../internals/object-define-property": 308, "../internals/to-indexed-object": 341 }], 362: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/get-built-in"), s = e("../internals/function-apply"), o = e("../internals/function-call"), a = e("../internals/function-uncurry-this"), l = e("../internals/fails"), c = e("../internals/is-callable"), u = e("../internals/is-symbol"), h = e("../internals/array-slice"), f = e("../internals/get-json-replacer-function"), d = e("../internals/symbol-constructor-detection"), p = String, m = i("JSON", "stringify"), b = a(/./.exec), g = a("".charAt), y = a("".charCodeAt), v = a("".replace), w = a(1 .toString), _ = /[\uD800-\uDFFF]/g, x = /^[\uD800-\uDBFF]$/, k = /^[\uDC00-\uDFFF]$/, S = !d || l((function() {
          var e2 = i("Symbol")("stringify detection");
          return "[null]" !== m([e2]) || "{}" !== m({ a: e2 }) || "{}" !== m(Object(e2));
        })), M = l((function() {
          return '"\\udf06\\ud834"' !== m("\uDF06\uD834") || '"\\udead"' !== m("\uDEAD");
        })), C2 = function(e2, t3) {
          var r2 = h(arguments), n2 = f(t3);
          if (c(n2) || void 0 !== e2 && !u(e2)) return r2[1] = function(e3, t4) {
            if (c(n2) && (t4 = o(n2, this, p(e3), t4)), !u(t4)) return t4;
          }, s(m, null, r2);
        }, T = function(e2, t3, r2) {
          var n2 = g(r2, t3 - 1), i2 = g(r2, t3 + 1);
          return b(x, e2) && !b(k, i2) || b(k, e2) && !b(x, n2) ? "\\u" + w(y(e2, 0), 16) : e2;
        };
        m && n({ target: "JSON", stat: true, arity: 3, forced: S || M }, { stringify: function(e2, t3, r2) {
          var n2 = h(arguments), i2 = s(S ? C2 : m, null, n2);
          return M && "string" == typeof i2 ? v(i2, _, T) : i2;
        } });
      }, { "../internals/array-slice": 231, "../internals/export": 259, "../internals/fails": 260, "../internals/function-apply": 261, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/get-built-in": 269, "../internals/get-json-replacer-function": 272, "../internals/is-callable": 285, "../internals/is-symbol": 292, "../internals/symbol-constructor-detection": 336 }], 363: [function(e, t2, r) {
        e("../internals/export")({ target: "Number", stat: true }, { isNaN: function(e2) {
          return e2 != e2;
        } });
      }, { "../internals/export": 259 }], 364: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/object-assign");
        n({ target: "Object", stat: true, arity: 2, forced: Object.assign !== i }, { assign: i });
      }, { "../internals/export": 259, "../internals/object-assign": 305 }], 365: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/symbol-constructor-detection"), s = e("../internals/fails"), o = e("../internals/object-get-own-property-symbols"), a = e("../internals/to-object");
        n({ target: "Object", stat: true, forced: !i || s((function() {
          o.f(1);
        })) }, { getOwnPropertySymbols: function(e2) {
          var t3 = o.f;
          return t3 ? t3(a(e2)) : [];
        } });
      }, { "../internals/export": 259, "../internals/fails": 260, "../internals/object-get-own-property-symbols": 312, "../internals/symbol-constructor-detection": 336, "../internals/to-object": 344 }], 366: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/to-object"), s = e("../internals/object-keys");
        n({ target: "Object", stat: true, forced: e("../internals/fails")((function() {
          s(1);
        })) }, { keys: function(e2) {
          return s(i(e2));
        } });
      }, { "../internals/export": 259, "../internals/fails": 260, "../internals/object-keys": 316, "../internals/to-object": 344 }], 367: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/object-to-array").values;
        n({ target: "Object", stat: true }, { values: function(e2) {
          return i(e2);
        } });
      }, { "../internals/export": 259, "../internals/object-to-array": 319 }], 368: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-call"), s = e("../internals/a-callable"), o = e("../internals/new-promise-capability"), a = e("../internals/perform"), l = e("../internals/iterate");
        n({ target: "Promise", stat: true, forced: e("../internals/promise-statics-incorrect-iteration") }, { all: function(e2) {
          var t3 = this, r2 = o.f(t3), n2 = r2.resolve, c = r2.reject, u = a((function() {
            var r3 = s(t3.resolve), o2 = [], a2 = 0, u2 = 1;
            l(e2, (function(e3) {
              var s2 = a2++, l2 = false;
              u2++, i(r3, t3, e3).then((function(e4) {
                l2 || (l2 = true, o2[s2] = e4, --u2 || n2(o2));
              }), c);
            })), --u2 || n2(o2);
          }));
          return u.error && c(u.value), r2.promise;
        } });
      }, { "../internals/a-callable": 222, "../internals/export": 259, "../internals/function-call": 264, "../internals/iterate": 293, "../internals/new-promise-capability": 303, "../internals/perform": 323, "../internals/promise-statics-incorrect-iteration": 327 }], 369: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/is-pure"), s = e("../internals/promise-constructor-detection").CONSTRUCTOR, o = e("../internals/promise-native-constructor"), a = e("../internals/get-built-in"), l = e("../internals/is-callable"), c = e("../internals/define-built-in"), u = o && o.prototype;
        if (n({ target: "Promise", proto: true, forced: s, real: true }, { catch: function(e2) {
          return this.then(void 0, e2);
        } }), !i && l(o)) {
          var h = a("Promise").prototype.catch;
          u.catch !== h && c(u, "catch", h, { unsafe: true });
        }
      }, { "../internals/define-built-in": 245, "../internals/export": 259, "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325 }], 370: [function(e, t2, r) {
        var n, i, s, o = e("../internals/export"), a = e("../internals/is-pure"), l = e("../internals/engine-is-node"), c = e("../internals/global"), u = e("../internals/function-call"), h = e("../internals/define-built-in"), f = e("../internals/object-set-prototype-of"), d = e("../internals/set-to-string-tag"), p = e("../internals/set-species"), m = e("../internals/a-callable"), b = e("../internals/is-callable"), g = e("../internals/is-object"), y = e("../internals/an-instance"), v = e("../internals/species-constructor"), w = e("../internals/task").set, _ = e("../internals/microtask"), x = e("../internals/host-report-errors"), k = e("../internals/perform"), S = e("../internals/queue"), M = e("../internals/internal-state"), C2 = e("../internals/promise-native-constructor"), T = e("../internals/promise-constructor-detection"), E = e("../internals/new-promise-capability"), A = T.CONSTRUCTOR, R = T.REJECTION_EVENT, O = T.SUBCLASSING, j = M.getterFor("Promise"), I = M.set, N = C2 && C2.prototype, P = C2, B = N, D = c.TypeError, F = c.document, L = c.process, z = E.f, U = z, $ = !!(F && F.createEvent && c.dispatchEvent), H = function(e2) {
          var t3;
          return !(!g(e2) || !b(t3 = e2.then)) && t3;
        }, V = function(e2, t3) {
          var r2, n2, i2, s2 = t3.value, o2 = 1 === t3.state, a2 = o2 ? e2.ok : e2.fail, l2 = e2.resolve, c2 = e2.reject, h2 = e2.domain;
          try {
            a2 ? (o2 || (2 === t3.rejection && Y(t3), t3.rejection = 1), true === a2 ? r2 = s2 : (h2 && h2.enter(), r2 = a2(s2), h2 && (h2.exit(), i2 = true)), r2 === e2.promise ? c2(new D("Promise-chain cycle")) : (n2 = H(r2)) ? u(n2, r2, l2, c2) : l2(r2)) : c2(s2);
          } catch (e3) {
            h2 && !i2 && h2.exit(), c2(e3);
          }
        }, q = function(e2, t3) {
          e2.notified || (e2.notified = true, _((function() {
            for (var r2, n2 = e2.reactions; r2 = n2.get(); ) V(r2, e2);
            e2.notified = false, t3 && !e2.rejection && X(e2);
          })));
        }, W = function(e2, t3, r2) {
          var n2, i2;
          $ ? ((n2 = F.createEvent("Event")).promise = t3, n2.reason = r2, n2.initEvent(e2, false, true), c.dispatchEvent(n2)) : n2 = { promise: t3, reason: r2 }, !R && (i2 = c["on" + e2]) ? i2(n2) : "unhandledrejection" === e2 && x("Unhandled promise rejection", r2);
        }, X = function(e2) {
          u(w, c, (function() {
            var t3, r2 = e2.facade, n2 = e2.value;
            if (K(e2) && (t3 = k((function() {
              l ? L.emit("unhandledRejection", n2, r2) : W("unhandledrejection", r2, n2);
            })), e2.rejection = l || K(e2) ? 2 : 1, t3.error)) throw t3.value;
          }));
        }, K = function(e2) {
          return 1 !== e2.rejection && !e2.parent;
        }, Y = function(e2) {
          u(w, c, (function() {
            var t3 = e2.facade;
            l ? L.emit("rejectionHandled", t3) : W("rejectionhandled", t3, e2.value);
          }));
        }, Z = function(e2, t3, r2) {
          return function(n2) {
            e2(t3, n2, r2);
          };
        }, G = function(e2, t3, r2) {
          e2.done || (e2.done = true, r2 && (e2 = r2), e2.value = t3, e2.state = 2, q(e2, true));
        }, J = function(e2, t3, r2) {
          if (!e2.done) {
            e2.done = true, r2 && (e2 = r2);
            try {
              if (e2.facade === t3) throw new D("Promise can't be resolved itself");
              var n2 = H(t3);
              n2 ? _((function() {
                var r3 = { done: false };
                try {
                  u(n2, t3, Z(J, r3, e2), Z(G, r3, e2));
                } catch (t4) {
                  G(r3, t4, e2);
                }
              })) : (e2.value = t3, e2.state = 1, q(e2, false));
            } catch (t4) {
              G({ done: false }, t4, e2);
            }
          }
        };
        if (A && (B = (P = function(e2) {
          y(this, B), m(e2), u(n, this);
          var t3 = j(this);
          try {
            e2(Z(J, t3), Z(G, t3));
          } catch (e3) {
            G(t3, e3);
          }
        }).prototype, (n = function(e2) {
          I(this, { type: "Promise", done: false, notified: false, parent: false, reactions: new S(), rejection: false, state: 0, value: void 0 });
        }).prototype = h(B, "then", (function(e2, t3) {
          var r2 = j(this), n2 = z(v(this, P));
          return r2.parent = true, n2.ok = !b(e2) || e2, n2.fail = b(t3) && t3, n2.domain = l ? L.domain : void 0, 0 === r2.state ? r2.reactions.add(n2) : _((function() {
            V(n2, r2);
          })), n2.promise;
        })), i = function() {
          var e2 = new n(), t3 = j(e2);
          this.promise = e2, this.resolve = Z(J, t3), this.reject = Z(G, t3);
        }, E.f = z = function(e2) {
          return e2 === P || void 0 === e2 ? new i(e2) : U(e2);
        }, !a && b(C2) && N !== Object.prototype)) {
          s = N.then, O || h(N, "then", (function(e2, t3) {
            var r2 = this;
            return new P((function(e3, t4) {
              u(s, r2, e3, t4);
            })).then(e2, t3);
          }), { unsafe: true });
          try {
            delete N.constructor;
          } catch (e2) {
          }
          f && f(N, B);
        }
        o({ global: true, constructor: true, wrap: true, forced: A }, { Promise: P }), d(P, "Promise", false, true), p("Promise");
      }, { "../internals/a-callable": 222, "../internals/an-instance": 226, "../internals/define-built-in": 245, "../internals/engine-is-node": 254, "../internals/export": 259, "../internals/function-call": 264, "../internals/global": 274, "../internals/host-report-errors": 277, "../internals/internal-state": 282, "../internals/is-callable": 285, "../internals/is-object": 289, "../internals/is-pure": 290, "../internals/microtask": 302, "../internals/new-promise-capability": 303, "../internals/object-set-prototype-of": 318, "../internals/perform": 323, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325, "../internals/queue": 328, "../internals/set-species": 330, "../internals/set-to-string-tag": 331, "../internals/species-constructor": 335, "../internals/task": 339 }], 371: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/is-pure"), s = e("../internals/promise-native-constructor"), o = e("../internals/fails"), a = e("../internals/get-built-in"), l = e("../internals/is-callable"), c = e("../internals/species-constructor"), u = e("../internals/promise-resolve"), h = e("../internals/define-built-in"), f = s && s.prototype;
        if (n({ target: "Promise", proto: true, real: true, forced: !!s && o((function() {
          f.finally.call({ then: function() {
          } }, (function() {
          }));
        })) }, { finally: function(e2) {
          var t3 = c(this, a("Promise")), r2 = l(e2);
          return this.then(r2 ? function(r3) {
            return u(t3, e2()).then((function() {
              return r3;
            }));
          } : e2, r2 ? function(r3) {
            return u(t3, e2()).then((function() {
              throw r3;
            }));
          } : e2);
        } }), !i && l(s)) {
          var d = a("Promise").prototype.finally;
          f.finally !== d && h(f, "finally", d, { unsafe: true });
        }
      }, { "../internals/define-built-in": 245, "../internals/export": 259, "../internals/fails": 260, "../internals/get-built-in": 269, "../internals/is-callable": 285, "../internals/is-pure": 290, "../internals/promise-native-constructor": 325, "../internals/promise-resolve": 326, "../internals/species-constructor": 335 }], 372: [function(e, t2, r) {
        e("../modules/es.promise.constructor"), e("../modules/es.promise.all"), e("../modules/es.promise.catch"), e("../modules/es.promise.race"), e("../modules/es.promise.reject"), e("../modules/es.promise.resolve");
      }, { "../modules/es.promise.all": 368, "../modules/es.promise.catch": 369, "../modules/es.promise.constructor": 370, "../modules/es.promise.race": 373, "../modules/es.promise.reject": 374, "../modules/es.promise.resolve": 375 }], 373: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-call"), s = e("../internals/a-callable"), o = e("../internals/new-promise-capability"), a = e("../internals/perform"), l = e("../internals/iterate");
        n({ target: "Promise", stat: true, forced: e("../internals/promise-statics-incorrect-iteration") }, { race: function(e2) {
          var t3 = this, r2 = o.f(t3), n2 = r2.reject, c = a((function() {
            var o2 = s(t3.resolve);
            l(e2, (function(e3) {
              i(o2, t3, e3).then(r2.resolve, n2);
            }));
          }));
          return c.error && n2(c.value), r2.promise;
        } });
      }, { "../internals/a-callable": 222, "../internals/export": 259, "../internals/function-call": 264, "../internals/iterate": 293, "../internals/new-promise-capability": 303, "../internals/perform": 323, "../internals/promise-statics-incorrect-iteration": 327 }], 374: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-call"), s = e("../internals/new-promise-capability");
        n({ target: "Promise", stat: true, forced: e("../internals/promise-constructor-detection").CONSTRUCTOR }, { reject: function(e2) {
          var t3 = s.f(this);
          return i(t3.reject, void 0, e2), t3.promise;
        } });
      }, { "../internals/export": 259, "../internals/function-call": 264, "../internals/new-promise-capability": 303, "../internals/promise-constructor-detection": 324 }], 375: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/get-built-in"), s = e("../internals/is-pure"), o = e("../internals/promise-native-constructor"), a = e("../internals/promise-constructor-detection").CONSTRUCTOR, l = e("../internals/promise-resolve"), c = i("Promise"), u = s && !a;
        n({ target: "Promise", stat: true, forced: s || a }, { resolve: function(e2) {
          return l(u && this === c ? o : this, e2);
        } });
      }, { "../internals/export": 259, "../internals/get-built-in": 269, "../internals/is-pure": 290, "../internals/promise-constructor-detection": 324, "../internals/promise-native-constructor": 325, "../internals/promise-resolve": 326 }], 376: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-uncurry-this"), s = e("../internals/to-absolute-index"), o = RangeError, a = String.fromCharCode, l = String.fromCodePoint, c = i([].join);
        n({ target: "String", stat: true, arity: 1, forced: !!l && 1 !== l.length }, { fromCodePoint: function(e2) {
          for (var t3, r2 = [], n2 = arguments.length, i2 = 0; n2 > i2; ) {
            if (t3 = +arguments[i2++], s(t3, 1114111) !== t3) throw new o(t3 + " is not a valid code point");
            r2[i2] = t3 < 65536 ? a(t3) : a(55296 + ((t3 -= 65536) >> 10), t3 % 1024 + 56320);
          }
          return c(r2, "");
        } });
      }, { "../internals/export": 259, "../internals/function-uncurry-this": 268, "../internals/to-absolute-index": 340 }], 377: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/function-uncurry-this"), s = e("../internals/not-a-regexp"), o = e("../internals/require-object-coercible"), a = e("../internals/to-string"), l = e("../internals/correct-is-regexp-logic"), c = i("".indexOf);
        n({ target: "String", proto: true, forced: !l("includes") }, { includes: function(e2) {
          return !!~c(a(o(this)), a(s(e2)), arguments.length > 1 ? arguments[1] : void 0);
        } });
      }, { "../internals/correct-is-regexp-logic": 238, "../internals/export": 259, "../internals/function-uncurry-this": 268, "../internals/not-a-regexp": 304, "../internals/require-object-coercible": 329, "../internals/to-string": 348 }], 378: [function(e, t2, r) {
        e("../internals/well-known-symbol-define")("asyncIterator");
      }, { "../internals/well-known-symbol-define": 355 }], 379: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/global"), s = e("../internals/function-call"), o = e("../internals/function-uncurry-this"), a = e("../internals/is-pure"), l = e("../internals/descriptors"), c = e("../internals/symbol-constructor-detection"), u = e("../internals/fails"), h = e("../internals/has-own-property"), f = e("../internals/object-is-prototype-of"), d = e("../internals/an-object"), p = e("../internals/to-indexed-object"), m = e("../internals/to-property-key"), b = e("../internals/to-string"), g = e("../internals/create-property-descriptor"), y = e("../internals/object-create"), v = e("../internals/object-keys"), w = e("../internals/object-get-own-property-names"), _ = e("../internals/object-get-own-property-names-external"), x = e("../internals/object-get-own-property-symbols"), k = e("../internals/object-get-own-property-descriptor"), S = e("../internals/object-define-property"), M = e("../internals/object-define-properties"), C2 = e("../internals/object-property-is-enumerable"), T = e("../internals/define-built-in"), E = e("../internals/define-built-in-accessor"), A = e("../internals/shared"), R = e("../internals/shared-key"), O = e("../internals/hidden-keys"), j = e("../internals/uid"), I = e("../internals/well-known-symbol"), N = e("../internals/well-known-symbol-wrapped"), P = e("../internals/well-known-symbol-define"), B = e("../internals/symbol-define-to-primitive"), D = e("../internals/set-to-string-tag"), F = e("../internals/internal-state"), L = e("../internals/array-iteration").forEach, z = R("hidden"), U = F.set, $ = F.getterFor("Symbol"), H = Object.prototype, V = i.Symbol, q = V && V.prototype, W = i.RangeError, X = i.TypeError, K = i.QObject, Y = k.f, Z = S.f, G = _.f, J = C2.f, Q = o([].push), ee = A("symbols"), te = A("op-symbols"), re = A("wks"), ne = !K || !K.prototype || !K.prototype.findChild, ie2 = function(e2, t3, r2) {
          var n2 = Y(H, t3);
          n2 && delete H[t3], Z(e2, t3, r2), n2 && e2 !== H && Z(H, t3, n2);
        }, se = l && u((function() {
          return 7 !== y(Z({}, "a", { get: function() {
            return Z(this, "a", { value: 7 }).a;
          } })).a;
        })) ? ie2 : Z, oe = function(e2, t3) {
          var r2 = ee[e2] = y(q);
          return U(r2, { type: "Symbol", tag: e2, description: t3 }), l || (r2.description = t3), r2;
        }, ae = function(e2, t3, r2) {
          e2 === H && ae(te, t3, r2), d(e2);
          var n2 = m(t3);
          return d(r2), h(ee, n2) ? (r2.enumerable ? (h(e2, z) && e2[z][n2] && (e2[z][n2] = false), r2 = y(r2, { enumerable: g(0, false) })) : (h(e2, z) || Z(e2, z, g(1, {})), e2[z][n2] = true), se(e2, n2, r2)) : Z(e2, n2, r2);
        }, le = function(e2, t3) {
          d(e2);
          var r2 = p(t3), n2 = v(r2).concat(fe(r2));
          return L(n2, (function(t4) {
            l && !s(ce, r2, t4) || ae(e2, t4, r2[t4]);
          })), e2;
        }, ce = function(e2) {
          var t3 = m(e2), r2 = s(J, this, t3);
          return !(this === H && h(ee, t3) && !h(te, t3)) && (!(r2 || !h(this, t3) || !h(ee, t3) || h(this, z) && this[z][t3]) || r2);
        }, ue = function(e2, t3) {
          var r2 = p(e2), n2 = m(t3);
          if (r2 !== H || !h(ee, n2) || h(te, n2)) {
            var i2 = Y(r2, n2);
            return !i2 || !h(ee, n2) || h(r2, z) && r2[z][n2] || (i2.enumerable = true), i2;
          }
        }, he = function(e2) {
          var t3 = G(p(e2)), r2 = [];
          return L(t3, (function(e3) {
            h(ee, e3) || h(O, e3) || Q(r2, e3);
          })), r2;
        }, fe = function(e2) {
          var t3 = e2 === H, r2 = G(t3 ? te : p(e2)), n2 = [];
          return L(r2, (function(e3) {
            !h(ee, e3) || t3 && !h(H, e3) || Q(n2, ee[e3]);
          })), n2;
        };
        c || (T(q = (V = function() {
          if (f(q, this)) throw new X("Symbol is not a constructor");
          var e2 = arguments.length && void 0 !== arguments[0] ? b(arguments[0]) : void 0, t3 = j(e2), r2 = function(e3) {
            this === H && s(r2, te, e3), h(this, z) && h(this[z], t3) && (this[z][t3] = false);
            var n2 = g(1, e3);
            try {
              se(this, t3, n2);
            } catch (e4) {
              if (!(e4 instanceof W)) throw e4;
              ie2(this, t3, n2);
            }
          };
          return l && ne && se(H, t3, { configurable: true, set: r2 }), oe(t3, e2);
        }).prototype, "toString", (function() {
          return $(this).tag;
        })), T(V, "withoutSetter", (function(e2) {
          return oe(j(e2), e2);
        })), C2.f = ce, S.f = ae, M.f = le, k.f = ue, w.f = _.f = he, x.f = fe, N.f = function(e2) {
          return oe(I(e2), e2);
        }, l && (E(q, "description", { configurable: true, get: function() {
          return $(this).description;
        } }), a || T(H, "propertyIsEnumerable", ce, { unsafe: true }))), n({ global: true, constructor: true, wrap: true, forced: !c, sham: !c }, { Symbol: V }), L(v(re), (function(e2) {
          P(e2);
        })), n({ target: "Symbol", stat: true, forced: !c }, { useSetter: function() {
          ne = true;
        }, useSimple: function() {
          ne = false;
        } }), n({ target: "Object", stat: true, forced: !c, sham: !l }, { create: function(e2, t3) {
          return void 0 === t3 ? y(e2) : le(y(e2), t3);
        }, defineProperty: ae, defineProperties: le, getOwnPropertyDescriptor: ue }), n({ target: "Object", stat: true, forced: !c }, { getOwnPropertyNames: he }), B(), D(V, "Symbol"), O[z] = true;
      }, { "../internals/an-object": 227, "../internals/array-iteration": 229, "../internals/create-property-descriptor": 242, "../internals/define-built-in": 245, "../internals/define-built-in-accessor": 244, "../internals/descriptors": 247, "../internals/export": 259, "../internals/fails": 260, "../internals/function-call": 264, "../internals/function-uncurry-this": 268, "../internals/global": 274, "../internals/has-own-property": 275, "../internals/hidden-keys": 276, "../internals/internal-state": 282, "../internals/is-pure": 290, "../internals/object-create": 306, "../internals/object-define-properties": 307, "../internals/object-define-property": 308, "../internals/object-get-own-property-descriptor": 309, "../internals/object-get-own-property-names": 311, "../internals/object-get-own-property-names-external": 310, "../internals/object-get-own-property-symbols": 312, "../internals/object-is-prototype-of": 314, "../internals/object-keys": 316, "../internals/object-property-is-enumerable": 317, "../internals/set-to-string-tag": 331, "../internals/shared": 334, "../internals/shared-key": 332, "../internals/symbol-constructor-detection": 336, "../internals/symbol-define-to-primitive": 337, "../internals/to-indexed-object": 341, "../internals/to-property-key": 346, "../internals/to-string": 348, "../internals/uid": 350, "../internals/well-known-symbol": 357, "../internals/well-known-symbol-define": 355, "../internals/well-known-symbol-wrapped": 356 }], 380: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/get-built-in"), s = e("../internals/has-own-property"), o = e("../internals/to-string"), a = e("../internals/shared"), l = e("../internals/symbol-registry-detection"), c = a("string-to-symbol-registry"), u = a("symbol-to-string-registry");
        n({ target: "Symbol", stat: true, forced: !l }, { for: function(e2) {
          var t3 = o(e2);
          if (s(c, t3)) return c[t3];
          var r2 = i("Symbol")(t3);
          return c[t3] = r2, u[r2] = t3, r2;
        } });
      }, { "../internals/export": 259, "../internals/get-built-in": 269, "../internals/has-own-property": 275, "../internals/shared": 334, "../internals/symbol-registry-detection": 338, "../internals/to-string": 348 }], 381: [function(e, t2, r) {
        e("../modules/es.symbol.constructor"), e("../modules/es.symbol.for"), e("../modules/es.symbol.key-for"), e("../modules/es.json.stringify"), e("../modules/es.object.get-own-property-symbols");
      }, { "../modules/es.json.stringify": 362, "../modules/es.object.get-own-property-symbols": 365, "../modules/es.symbol.constructor": 379, "../modules/es.symbol.for": 380, "../modules/es.symbol.key-for": 382 }], 382: [function(e, t2, r) {
        var n = e("../internals/export"), i = e("../internals/has-own-property"), s = e("../internals/is-symbol"), o = e("../internals/try-to-string"), a = e("../internals/shared"), l = e("../internals/symbol-registry-detection"), c = a("symbol-to-string-registry");
        n({ target: "Symbol", stat: true, forced: !l }, { keyFor: function(e2) {
          if (!s(e2)) throw new TypeError(o(e2) + " is not a symbol");
          if (i(c, e2)) return c[e2];
        } });
      }, { "../internals/export": 259, "../internals/has-own-property": 275, "../internals/is-symbol": 292, "../internals/shared": 334, "../internals/symbol-registry-detection": 338, "../internals/try-to-string": 349 }], 383: [function(e, t2, r) {
        function n(e2) {
          return Object.prototype.toString.call(e2);
        }
        r.isArray = function(e2) {
          return Array.isArray ? Array.isArray(e2) : "[object Array]" === n(e2);
        }, r.isBoolean = function(e2) {
          return "boolean" == typeof e2;
        }, r.isNull = function(e2) {
          return null === e2;
        }, r.isNullOrUndefined = function(e2) {
          return null == e2;
        }, r.isNumber = function(e2) {
          return "number" == typeof e2;
        }, r.isString = function(e2) {
          return "string" == typeof e2;
        }, r.isSymbol = function(e2) {
          return "symbol" == typeof e2;
        }, r.isUndefined = function(e2) {
          return void 0 === e2;
        }, r.isRegExp = function(e2) {
          return "[object RegExp]" === n(e2);
        }, r.isObject = function(e2) {
          return "object" == typeof e2 && null !== e2;
        }, r.isDate = function(e2) {
          return "[object Date]" === n(e2);
        }, r.isError = function(e2) {
          return "[object Error]" === n(e2) || e2 instanceof Error;
        }, r.isFunction = function(e2) {
          return "function" == typeof e2;
        }, r.isPrimitive = function(e2) {
          return null === e2 || "boolean" == typeof e2 || "number" == typeof e2 || "string" == typeof e2 || "symbol" == typeof e2 || void 0 === e2;
        }, r.isBuffer = e("buffer").Buffer.isBuffer;
      }, { buffer: 220 }], 384: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n = e("elliptic"), i = e("bn.js");
            t2.exports = function(e2) {
              return new o(e2);
            };
            var s = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
            function o(e2) {
              this.curveType = s[e2], this.curveType || (this.curveType = { name: e2 }), this.curve = new n.ec(this.curveType.name), this.keys = void 0;
            }
            function a(e2, t3, n2) {
              Array.isArray(e2) || (e2 = e2.toArray());
              var i2 = new r2(e2);
              if (n2 && i2.length < n2) {
                var s2 = new r2(n2 - i2.length);
                s2.fill(0), i2 = r2.concat([s2, i2]);
              }
              return t3 ? i2.toString(t3) : i2;
            }
            s.p224 = s.secp224r1, s.p256 = s.secp256r1 = s.prime256v1, s.p192 = s.secp192r1 = s.prime192v1, s.p384 = s.secp384r1, s.p521 = s.secp521r1, o.prototype.generateKeys = function(e2, t3) {
              return this.keys = this.curve.genKeyPair(), this.getPublicKey(e2, t3);
            }, o.prototype.computeSecret = function(e2, t3, n2) {
              return t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3)), a(this.curve.keyFromPublic(e2).getPublic().mul(this.keys.getPrivate()).getX(), n2, this.curveType.byteLength);
            }, o.prototype.getPublicKey = function(e2, t3) {
              var r3 = this.keys.getPublic("compressed" === t3, true);
              return "hybrid" === t3 && (r3[r3.length - 1] % 2 ? r3[0] = 7 : r3[0] = 6), a(r3, e2);
            }, o.prototype.getPrivateKey = function(e2) {
              return a(this.keys.getPrivate(), e2);
            }, o.prototype.setPublicKey = function(e2, t3) {
              return t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3)), this.keys._importPublic(e2), this;
            }, o.prototype.setPrivateKey = function(e2, t3) {
              t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3));
              var n2 = new i(e2);
              return n2 = n2.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(n2), this;
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "bn.js": 385, buffer: 220, elliptic: 405 }], 385: [function(e, t2, r) {
        arguments[4][184][0].apply(r, arguments);
      }, { buffer: 188, dup: 184 }], 386: [function(e, t2, r) {
        var n = e("inherits"), i = e("md5.js"), s = e("ripemd160"), o = e("sha.js"), a = e("cipher-base");
        function l(e2) {
          a.call(this, "digest"), this._hash = e2;
        }
        n(l, a), l.prototype._update = function(e2) {
          this._hash.update(e2);
        }, l.prototype._final = function() {
          return this._hash.digest();
        }, t2.exports = function(e2) {
          return "md5" === (e2 = e2.toLowerCase()) ? new i() : "rmd160" === e2 || "ripemd160" === e2 ? new s() : new l(o(e2));
        };
      }, { "cipher-base": 221, inherits: 440, "md5.js": 450, ripemd160: 493, "sha.js": 498 }], 387: [function(e, t2, r) {
        var n = e("md5.js");
        t2.exports = function(e2) {
          return new n().update(e2).digest();
        };
      }, { "md5.js": 450 }], 388: [function(e, t2, r) {
        var n = e("inherits"), i = e("./legacy"), s = e("cipher-base"), o = e("safe-buffer").Buffer, a = e("create-hash/md5"), l = e("ripemd160"), c = e("sha.js"), u = o.alloc(128);
        function h(e2, t3) {
          s.call(this, "digest"), "string" == typeof t3 && (t3 = o.from(t3));
          var r2 = "sha512" === e2 || "sha384" === e2 ? 128 : 64;
          (this._alg = e2, this._key = t3, t3.length > r2) ? t3 = ("rmd160" === e2 ? new l() : c(e2)).update(t3).digest() : t3.length < r2 && (t3 = o.concat([t3, u], r2));
          for (var n2 = this._ipad = o.allocUnsafe(r2), i2 = this._opad = o.allocUnsafe(r2), a2 = 0; a2 < r2; a2++) n2[a2] = 54 ^ t3[a2], i2[a2] = 92 ^ t3[a2];
          this._hash = "rmd160" === e2 ? new l() : c(e2), this._hash.update(n2);
        }
        n(h, s), h.prototype._update = function(e2) {
          this._hash.update(e2);
        }, h.prototype._final = function() {
          var e2 = this._hash.digest();
          return ("rmd160" === this._alg ? new l() : c(this._alg)).update(this._opad).update(e2).digest();
        }, t2.exports = function(e2, t3) {
          return "rmd160" === (e2 = e2.toLowerCase()) || "ripemd160" === e2 ? new h("rmd160", t3) : "md5" === e2 ? new i(a, t3) : new h(e2, t3);
        };
      }, { "./legacy": 389, "cipher-base": 221, "create-hash/md5": 387, inherits: 440, ripemd160: 493, "safe-buffer": 494, "sha.js": 498 }], 389: [function(e, t2, r) {
        var n = e("inherits"), i = e("safe-buffer").Buffer, s = e("cipher-base"), o = i.alloc(128);
        function a(e2, t3) {
          s.call(this, "digest"), "string" == typeof t3 && (t3 = i.from(t3)), this._alg = e2, this._key = t3, t3.length > 64 ? t3 = e2(t3) : t3.length < 64 && (t3 = i.concat([t3, o], 64));
          for (var r2 = this._ipad = i.allocUnsafe(64), n2 = this._opad = i.allocUnsafe(64), a2 = 0; a2 < 64; a2++) r2[a2] = 54 ^ t3[a2], n2[a2] = 92 ^ t3[a2];
          this._hash = [r2];
        }
        n(a, s), a.prototype._update = function(e2) {
          this._hash.push(e2);
        }, a.prototype._final = function() {
          var e2 = this._alg(i.concat(this._hash));
          return this._alg(i.concat([this._opad, e2]));
        }, t2.exports = a;
      }, { "cipher-base": 221, inherits: 440, "safe-buffer": 494 }], 390: [function(e, t2, r) {
        r.randomBytes = r.rng = r.pseudoRandomBytes = r.prng = e("randombytes"), r.createHash = r.Hash = e("create-hash"), r.createHmac = r.Hmac = e("create-hmac");
        var n = e("browserify-sign/algos"), i = Object.keys(n), s = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(i);
        r.getHashes = function() {
          return s;
        };
        var o = e("pbkdf2");
        r.pbkdf2 = o.pbkdf2, r.pbkdf2Sync = o.pbkdf2Sync;
        var a = e("browserify-cipher");
        r.Cipher = a.Cipher, r.createCipher = a.createCipher, r.Cipheriv = a.Cipheriv, r.createCipheriv = a.createCipheriv, r.Decipher = a.Decipher, r.createDecipher = a.createDecipher, r.Decipheriv = a.Decipheriv, r.createDecipheriv = a.createDecipheriv, r.getCiphers = a.getCiphers, r.listCiphers = a.listCiphers;
        var l = e("diffie-hellman");
        r.DiffieHellmanGroup = l.DiffieHellmanGroup, r.createDiffieHellmanGroup = l.createDiffieHellmanGroup, r.getDiffieHellman = l.getDiffieHellman, r.createDiffieHellman = l.createDiffieHellman, r.DiffieHellman = l.DiffieHellman;
        var c = e("browserify-sign");
        r.createSign = c.createSign, r.Sign = c.Sign, r.createVerify = c.createVerify, r.Verify = c.Verify, r.createECDH = e("create-ecdh");
        var u = e("public-encrypt");
        r.publicEncrypt = u.publicEncrypt, r.privateEncrypt = u.privateEncrypt, r.publicDecrypt = u.publicDecrypt, r.privateDecrypt = u.privateDecrypt;
        var h = e("randomfill");
        r.randomFill = h.randomFill, r.randomFillSync = h.randomFillSync, r.createCredentials = function() {
          throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
        }, r.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
      }, { "browserify-cipher": 206, "browserify-sign": 213, "browserify-sign/algos": 210, "create-ecdh": 384, "create-hash": 386, "create-hmac": 388, "diffie-hellman": 400, pbkdf2: 460, "public-encrypt": 468, randombytes: 475, randomfill: 476 }], 391: [function(e, t2, r) {
        !(function(e2, n) {
          "object" == typeof r && void 0 !== t2 ? t2.exports = n() : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs = n();
        })(void 0, (function() {
          var e2 = 6e4, t3 = 36e5, r2 = "millisecond", n = "second", i = "minute", s = "hour", o = "day", a = "week", l = "month", c = "quarter", u = "year", h = "date", f = "Invalid Date", d = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, p = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, m = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e3) {
            var t4 = ["th", "st", "nd", "rd"], r3 = e3 % 100;
            return "[" + e3 + (t4[(r3 - 20) % 10] || t4[r3] || t4[0]) + "]";
          } }, b = function(e3, t4, r3) {
            var n2 = String(e3);
            return !n2 || n2.length >= t4 ? e3 : "" + Array(t4 + 1 - n2.length).join(r3) + e3;
          }, g = { s: b, z: function(e3) {
            var t4 = -e3.utcOffset(), r3 = Math.abs(t4), n2 = Math.floor(r3 / 60), i2 = r3 % 60;
            return (t4 <= 0 ? "+" : "-") + b(n2, 2, "0") + ":" + b(i2, 2, "0");
          }, m: function e3(t4, r3) {
            if (t4.date() < r3.date()) return -e3(r3, t4);
            var n2 = 12 * (r3.year() - t4.year()) + (r3.month() - t4.month()), i2 = t4.clone().add(n2, l), s2 = r3 - i2 < 0, o2 = t4.clone().add(n2 + (s2 ? -1 : 1), l);
            return +(-(n2 + (r3 - i2) / (s2 ? i2 - o2 : o2 - i2)) || 0);
          }, a: function(e3) {
            return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
          }, p: function(e3) {
            return { M: l, y: u, w: a, d: o, D: h, h: s, m: i, s: n, ms: r2, Q: c }[e3] || String(e3 || "").toLowerCase().replace(/s$/, "");
          }, u: function(e3) {
            return void 0 === e3;
          } }, y = "en", v = {};
          v[y] = m;
          var w = "$isDayjsObject", _ = function(e3) {
            return e3 instanceof M || !(!e3 || !e3[w]);
          }, x = function e3(t4, r3, n2) {
            var i2;
            if (!t4) return y;
            if ("string" == typeof t4) {
              var s2 = t4.toLowerCase();
              v[s2] && (i2 = s2), r3 && (v[s2] = r3, i2 = s2);
              var o2 = t4.split("-");
              if (!i2 && o2.length > 1) return e3(o2[0]);
            } else {
              var a2 = t4.name;
              v[a2] = t4, i2 = a2;
            }
            return !n2 && i2 && (y = i2), i2 || !n2 && y;
          }, k = function(e3, t4) {
            if (_(e3)) return e3.clone();
            var r3 = "object" == typeof t4 ? t4 : {};
            return r3.date = e3, r3.args = arguments, new M(r3);
          }, S = g;
          S.l = x, S.i = _, S.w = function(e3, t4) {
            return k(e3, { locale: t4.$L, utc: t4.$u, x: t4.$x, $offset: t4.$offset });
          };
          var M = (function() {
            function m2(e3) {
              this.$L = x(e3.locale, null, true), this.parse(e3), this.$x = this.$x || e3.x || {}, this[w] = true;
            }
            var b2 = m2.prototype;
            return b2.parse = function(e3) {
              this.$d = (function(e4) {
                var t4 = e4.date, r3 = e4.utc;
                if (null === t4) return /* @__PURE__ */ new Date(NaN);
                if (S.u(t4)) return /* @__PURE__ */ new Date();
                if (t4 instanceof Date) return new Date(t4);
                if ("string" == typeof t4 && !/Z$/i.test(t4)) {
                  var n2 = t4.match(d);
                  if (n2) {
                    var i2 = n2[2] - 1 || 0, s2 = (n2[7] || "0").substring(0, 3);
                    return r3 ? new Date(Date.UTC(n2[1], i2, n2[3] || 1, n2[4] || 0, n2[5] || 0, n2[6] || 0, s2)) : new Date(n2[1], i2, n2[3] || 1, n2[4] || 0, n2[5] || 0, n2[6] || 0, s2);
                  }
                }
                return new Date(t4);
              })(e3), this.init();
            }, b2.init = function() {
              var e3 = this.$d;
              this.$y = e3.getFullYear(), this.$M = e3.getMonth(), this.$D = e3.getDate(), this.$W = e3.getDay(), this.$H = e3.getHours(), this.$m = e3.getMinutes(), this.$s = e3.getSeconds(), this.$ms = e3.getMilliseconds();
            }, b2.$utils = function() {
              return S;
            }, b2.isValid = function() {
              return !(this.$d.toString() === f);
            }, b2.isSame = function(e3, t4) {
              var r3 = k(e3);
              return this.startOf(t4) <= r3 && r3 <= this.endOf(t4);
            }, b2.isAfter = function(e3, t4) {
              return k(e3) < this.startOf(t4);
            }, b2.isBefore = function(e3, t4) {
              return this.endOf(t4) < k(e3);
            }, b2.$g = function(e3, t4, r3) {
              return S.u(e3) ? this[t4] : this.set(r3, e3);
            }, b2.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, b2.valueOf = function() {
              return this.$d.getTime();
            }, b2.startOf = function(e3, t4) {
              var r3 = this, c2 = !!S.u(t4) || t4, f2 = S.p(e3), d2 = function(e4, t5) {
                var n2 = S.w(r3.$u ? Date.UTC(r3.$y, t5, e4) : new Date(r3.$y, t5, e4), r3);
                return c2 ? n2 : n2.endOf(o);
              }, p2 = function(e4, t5) {
                return S.w(r3.toDate()[e4].apply(r3.toDate("s"), (c2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t5)), r3);
              }, m3 = this.$W, b3 = this.$M, g2 = this.$D, y2 = "set" + (this.$u ? "UTC" : "");
              switch (f2) {
                case u:
                  return c2 ? d2(1, 0) : d2(31, 11);
                case l:
                  return c2 ? d2(1, b3) : d2(0, b3 + 1);
                case a:
                  var v2 = this.$locale().weekStart || 0, w2 = (m3 < v2 ? m3 + 7 : m3) - v2;
                  return d2(c2 ? g2 - w2 : g2 + (6 - w2), b3);
                case o:
                case h:
                  return p2(y2 + "Hours", 0);
                case s:
                  return p2(y2 + "Minutes", 1);
                case i:
                  return p2(y2 + "Seconds", 2);
                case n:
                  return p2(y2 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, b2.endOf = function(e3) {
              return this.startOf(e3, false);
            }, b2.$set = function(e3, t4) {
              var a2, c2 = S.p(e3), f2 = "set" + (this.$u ? "UTC" : ""), d2 = (a2 = {}, a2[o] = f2 + "Date", a2[h] = f2 + "Date", a2[l] = f2 + "Month", a2[u] = f2 + "FullYear", a2[s] = f2 + "Hours", a2[i] = f2 + "Minutes", a2[n] = f2 + "Seconds", a2[r2] = f2 + "Milliseconds", a2)[c2], p2 = c2 === o ? this.$D + (t4 - this.$W) : t4;
              if (c2 === l || c2 === u) {
                var m3 = this.clone().set(h, 1);
                m3.$d[d2](p2), m3.init(), this.$d = m3.set(h, Math.min(this.$D, m3.daysInMonth())).$d;
              } else d2 && this.$d[d2](p2);
              return this.init(), this;
            }, b2.set = function(e3, t4) {
              return this.clone().$set(e3, t4);
            }, b2.get = function(e3) {
              return this[S.p(e3)]();
            }, b2.add = function(r3, c2) {
              var h2, f2 = this;
              r3 = Number(r3);
              var d2 = S.p(c2), p2 = function(e3) {
                var t4 = k(f2);
                return S.w(t4.date(t4.date() + Math.round(e3 * r3)), f2);
              };
              if (d2 === l) return this.set(l, this.$M + r3);
              if (d2 === u) return this.set(u, this.$y + r3);
              if (d2 === o) return p2(1);
              if (d2 === a) return p2(7);
              var m3 = (h2 = {}, h2[i] = e2, h2[s] = t3, h2[n] = 1e3, h2)[d2] || 1, b3 = this.$d.getTime() + r3 * m3;
              return S.w(b3, this);
            }, b2.subtract = function(e3, t4) {
              return this.add(-1 * e3, t4);
            }, b2.format = function(e3) {
              var t4 = this, r3 = this.$locale();
              if (!this.isValid()) return r3.invalidDate || f;
              var n2 = e3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = S.z(this), s2 = this.$H, o2 = this.$m, a2 = this.$M, l2 = r3.weekdays, c2 = r3.months, u2 = r3.meridiem, h2 = function(e4, r4, i3, s3) {
                return e4 && (e4[r4] || e4(t4, n2)) || i3[r4].slice(0, s3);
              }, d2 = function(e4) {
                return S.s(s2 % 12 || 12, e4, "0");
              }, m3 = u2 || function(e4, t5, r4) {
                var n3 = e4 < 12 ? "AM" : "PM";
                return r4 ? n3.toLowerCase() : n3;
              };
              return n2.replace(p, (function(e4, n3) {
                return n3 || (function(e5) {
                  switch (e5) {
                    case "YY":
                      return String(t4.$y).slice(-2);
                    case "YYYY":
                      return S.s(t4.$y, 4, "0");
                    case "M":
                      return a2 + 1;
                    case "MM":
                      return S.s(a2 + 1, 2, "0");
                    case "MMM":
                      return h2(r3.monthsShort, a2, c2, 3);
                    case "MMMM":
                      return h2(c2, a2);
                    case "D":
                      return t4.$D;
                    case "DD":
                      return S.s(t4.$D, 2, "0");
                    case "d":
                      return String(t4.$W);
                    case "dd":
                      return h2(r3.weekdaysMin, t4.$W, l2, 2);
                    case "ddd":
                      return h2(r3.weekdaysShort, t4.$W, l2, 3);
                    case "dddd":
                      return l2[t4.$W];
                    case "H":
                      return String(s2);
                    case "HH":
                      return S.s(s2, 2, "0");
                    case "h":
                      return d2(1);
                    case "hh":
                      return d2(2);
                    case "a":
                      return m3(s2, o2, true);
                    case "A":
                      return m3(s2, o2, false);
                    case "m":
                      return String(o2);
                    case "mm":
                      return S.s(o2, 2, "0");
                    case "s":
                      return String(t4.$s);
                    case "ss":
                      return S.s(t4.$s, 2, "0");
                    case "SSS":
                      return S.s(t4.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                })(e4) || i2.replace(":", "");
              }));
            }, b2.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, b2.diff = function(r3, h2, f2) {
              var d2, p2 = this, m3 = S.p(h2), b3 = k(r3), g2 = (b3.utcOffset() - this.utcOffset()) * e2, y2 = this - b3, v2 = function() {
                return S.m(p2, b3);
              };
              switch (m3) {
                case u:
                  d2 = v2() / 12;
                  break;
                case l:
                  d2 = v2();
                  break;
                case c:
                  d2 = v2() / 3;
                  break;
                case a:
                  d2 = (y2 - g2) / 6048e5;
                  break;
                case o:
                  d2 = (y2 - g2) / 864e5;
                  break;
                case s:
                  d2 = y2 / t3;
                  break;
                case i:
                  d2 = y2 / e2;
                  break;
                case n:
                  d2 = y2 / 1e3;
                  break;
                default:
                  d2 = y2;
              }
              return f2 ? d2 : S.a(d2);
            }, b2.daysInMonth = function() {
              return this.endOf(l).$D;
            }, b2.$locale = function() {
              return v[this.$L];
            }, b2.locale = function(e3, t4) {
              if (!e3) return this.$L;
              var r3 = this.clone(), n2 = x(e3, t4, true);
              return n2 && (r3.$L = n2), r3;
            }, b2.clone = function() {
              return S.w(this.$d, this);
            }, b2.toDate = function() {
              return new Date(this.valueOf());
            }, b2.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, b2.toISOString = function() {
              return this.$d.toISOString();
            }, b2.toString = function() {
              return this.$d.toUTCString();
            }, m2;
          })(), C2 = M.prototype;
          return k.prototype = C2, [["$ms", r2], ["$s", n], ["$m", i], ["$H", s], ["$W", o], ["$M", l], ["$y", u], ["$D", h]].forEach((function(e3) {
            C2[e3[1]] = function(t4) {
              return this.$g(t4, e3[0], e3[1]);
            };
          })), k.extend = function(e3, t4) {
            return e3.$i || (e3(t4, M, k), e3.$i = true), k;
          }, k.locale = x, k.isDayjs = _, k.unix = function(e3) {
            return k(1e3 * e3);
          }, k.en = v[y], k.Ls = v, k.p = {}, k;
        }));
      }, {}], 392: [function(e, t2, r) {
        !(function(e2, n) {
          "object" == typeof r && void 0 !== t2 ? t2.exports = n() : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_customParseFormat = n();
        })(void 0, (function() {
          var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t3 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r2 = /\d\d/, n = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, s = {}, o = function(e3) {
            return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
          }, a = function(e3) {
            return function(t4) {
              this[e3] = +t4;
            };
          }, l = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
            (this.zone || (this.zone = {})).offset = (function(e4) {
              if (!e4) return 0;
              if ("Z" === e4) return 0;
              var t4 = e4.match(/([+-]|\d\d)/g), r3 = 60 * t4[1] + (+t4[2] || 0);
              return 0 === r3 ? 0 : "+" === t4[0] ? -r3 : r3;
            })(e3);
          }], c = function(e3) {
            var t4 = s[e3];
            return t4 && (t4.indexOf ? t4 : t4.s.concat(t4.f));
          }, u = function(e3, t4) {
            var r3, n2 = s.meridiem;
            if (n2) {
              for (var i2 = 1; i2 <= 24; i2 += 1) if (e3.indexOf(n2(i2, 0, t4)) > -1) {
                r3 = i2 > 12;
                break;
              }
            } else r3 = e3 === (t4 ? "pm" : "PM");
            return r3;
          }, h = { A: [i, function(e3) {
            this.afternoon = u(e3, false);
          }], a: [i, function(e3) {
            this.afternoon = u(e3, true);
          }], S: [/\d/, function(e3) {
            this.milliseconds = 100 * +e3;
          }], SS: [r2, function(e3) {
            this.milliseconds = 10 * +e3;
          }], SSS: [/\d{3}/, function(e3) {
            this.milliseconds = +e3;
          }], s: [n, a("seconds")], ss: [n, a("seconds")], m: [n, a("minutes")], mm: [n, a("minutes")], H: [n, a("hours")], h: [n, a("hours")], HH: [n, a("hours")], hh: [n, a("hours")], D: [n, a("day")], DD: [r2, a("day")], Do: [i, function(e3) {
            var t4 = s.ordinal, r3 = e3.match(/\d+/);
            if (this.day = r3[0], t4) for (var n2 = 1; n2 <= 31; n2 += 1) t4(n2).replace(/\[|\]/g, "") === e3 && (this.day = n2);
          }], M: [n, a("month")], MM: [r2, a("month")], MMM: [i, function(e3) {
            var t4 = c("months"), r3 = (c("monthsShort") || t4.map((function(e4) {
              return e4.slice(0, 3);
            }))).indexOf(e3) + 1;
            if (r3 < 1) throw new Error();
            this.month = r3 % 12 || r3;
          }], MMMM: [i, function(e3) {
            var t4 = c("months").indexOf(e3) + 1;
            if (t4 < 1) throw new Error();
            this.month = t4 % 12 || t4;
          }], Y: [/[+-]?\d+/, a("year")], YY: [r2, function(e3) {
            this.year = o(e3);
          }], YYYY: [/\d{4}/, a("year")], Z: l, ZZ: l };
          function f(r3) {
            var n2, i2;
            n2 = r3, i2 = s && s.formats;
            for (var o2 = (r3 = n2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t4, r4, n3) {
              var s2 = n3 && n3.toUpperCase();
              return r4 || i2[n3] || e2[n3] || i2[s2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e3, t5, r5) {
                return t5 || r5.slice(1);
              }));
            }))).match(t3), a2 = o2.length, l2 = 0; l2 < a2; l2 += 1) {
              var c2 = o2[l2], u2 = h[c2], f2 = u2 && u2[0], d = u2 && u2[1];
              o2[l2] = d ? { regex: f2, parser: d } : c2.replace(/^\[|\]$/g, "");
            }
            return function(e3) {
              for (var t4 = {}, r4 = 0, n3 = 0; r4 < a2; r4 += 1) {
                var i3 = o2[r4];
                if ("string" == typeof i3) n3 += i3.length;
                else {
                  var s2 = i3.regex, l3 = i3.parser, c3 = e3.slice(n3), u3 = s2.exec(c3)[0];
                  l3.call(t4, u3), e3 = e3.replace(u3, "");
                }
              }
              return (function(e4) {
                var t5 = e4.afternoon;
                if (void 0 !== t5) {
                  var r5 = e4.hours;
                  t5 ? r5 < 12 && (e4.hours += 12) : 12 === r5 && (e4.hours = 0), delete e4.afternoon;
                }
              })(t4), t4;
            };
          }
          return function(e3, t4, r3) {
            r3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (o = e3.parseTwoDigitYear);
            var n2 = t4.prototype, i2 = n2.parse;
            n2.parse = function(e4) {
              var t5 = e4.date, n3 = e4.utc, o2 = e4.args;
              this.$u = n3;
              var a2 = o2[1];
              if ("string" == typeof a2) {
                var l2 = true === o2[2], c2 = true === o2[3], u2 = l2 || c2, h2 = o2[2];
                c2 && (h2 = o2[2]), s = this.$locale(), !l2 && h2 && (s = r3.Ls[h2]), this.$d = (function(e5, t6, r4) {
                  try {
                    if (["x", "X"].indexOf(t6) > -1) return new Date(("X" === t6 ? 1e3 : 1) * e5);
                    var n4 = f(t6)(e5), i3 = n4.year, s2 = n4.month, o3 = n4.day, a3 = n4.hours, l3 = n4.minutes, c3 = n4.seconds, u3 = n4.milliseconds, h3 = n4.zone, d2 = /* @__PURE__ */ new Date(), p2 = o3 || (i3 || s2 ? 1 : d2.getDate()), m2 = i3 || d2.getFullYear(), b = 0;
                    i3 && !s2 || (b = s2 > 0 ? s2 - 1 : d2.getMonth());
                    var g = a3 || 0, y = l3 || 0, v = c3 || 0, w = u3 || 0;
                    return h3 ? new Date(Date.UTC(m2, b, p2, g, y, v, w + 60 * h3.offset * 1e3)) : r4 ? new Date(Date.UTC(m2, b, p2, g, y, v, w)) : new Date(m2, b, p2, g, y, v, w);
                  } catch (e6) {
                    return /* @__PURE__ */ new Date("");
                  }
                })(t5, a2, n3), this.init(), h2 && true !== h2 && (this.$L = this.locale(h2).$L), u2 && t5 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
              } else if (a2 instanceof Array) for (var d = a2.length, p = 1; p <= d; p += 1) {
                o2[1] = a2[p - 1];
                var m = r3.apply(this, o2);
                if (m.isValid()) {
                  this.$d = m.$d, this.$L = m.$L, this.init();
                  break;
                }
                p === d && (this.$d = /* @__PURE__ */ new Date(""));
              }
              else i2.call(this, e4);
            };
          };
        }));
      }, {}], 393: [function(e, t2, r) {
        !(function(e2, n) {
          "object" == typeof r && void 0 !== t2 ? t2.exports = n() : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_utc = n();
        })(void 0, (function() {
          var e2 = "minute", t3 = /[+-]\d\d(?::?\d\d)?/g, r2 = /([+-]|\d\d)/g;
          return function(n, i, s) {
            var o = i.prototype;
            s.utc = function(e3) {
              var t4 = { date: e3, utc: true, args: arguments };
              return new i(t4);
            }, o.utc = function(t4) {
              var r3 = s(this.toDate(), { locale: this.$L, utc: true });
              return t4 ? r3.add(this.utcOffset(), e2) : r3;
            }, o.local = function() {
              return s(this.toDate(), { locale: this.$L, utc: false });
            };
            var a = o.parse;
            o.parse = function(e3) {
              e3.utc && (this.$u = true), this.$utils().u(e3.$offset) || (this.$offset = e3.$offset), a.call(this, e3);
            };
            var l = o.init;
            o.init = function() {
              if (this.$u) {
                var e3 = this.$d;
                this.$y = e3.getUTCFullYear(), this.$M = e3.getUTCMonth(), this.$D = e3.getUTCDate(), this.$W = e3.getUTCDay(), this.$H = e3.getUTCHours(), this.$m = e3.getUTCMinutes(), this.$s = e3.getUTCSeconds(), this.$ms = e3.getUTCMilliseconds();
              } else l.call(this);
            };
            var c = o.utcOffset;
            o.utcOffset = function(n2, i2) {
              var s2 = this.$utils().u;
              if (s2(n2)) return this.$u ? 0 : s2(this.$offset) ? c.call(this) : this.$offset;
              if ("string" == typeof n2 && null === (n2 = (function(e3) {
                void 0 === e3 && (e3 = "");
                var n3 = e3.match(t3);
                if (!n3) return null;
                var i3 = ("" + n3[0]).match(r2) || ["-", 0, 0], s3 = i3[0], o3 = 60 * +i3[1] + +i3[2];
                return 0 === o3 ? 0 : "+" === s3 ? o3 : -o3;
              })(n2))) return this;
              var o2 = Math.abs(n2) <= 16 ? 60 * n2 : n2, a2 = this;
              if (i2) return a2.$offset = o2, a2.$u = 0 === n2, a2;
              if (0 !== n2) {
                var l2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                (a2 = this.local().add(o2 + l2, e2)).$offset = o2, a2.$x.$localOffset = l2;
              } else a2 = this.utc();
              return a2;
            };
            var u = o.format;
            o.format = function(e3) {
              var t4 = e3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
              return u.call(this, t4);
            }, o.valueOf = function() {
              var e3 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
              return this.$d.valueOf() - 6e4 * e3;
            }, o.isUTC = function() {
              return !!this.$u;
            }, o.toISOString = function() {
              return this.toDate().toISOString();
            }, o.toString = function() {
              return this.toDate().toUTCString();
            };
            var h = o.toDate;
            o.toDate = function(e3) {
              return "s" === e3 && this.$offset ? s(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : h.call(this);
            };
            var f = o.diff;
            o.diff = function(e3, t4, r3) {
              if (e3 && this.$u === e3.$u) return f.call(this, e3, t4, r3);
              var n2 = this.local(), i2 = s(e3).local();
              return f.call(n2, i2, t4, r3);
            };
          };
        }));
      }, {}], 394: [function(e, t2, r) {
        r.utils = e("./des/utils"), r.Cipher = e("./des/cipher"), r.DES = e("./des/des"), r.CBC = e("./des/cbc"), r.EDE = e("./des/ede");
      }, { "./des/cbc": 395, "./des/cipher": 396, "./des/des": 397, "./des/ede": 398, "./des/utils": 399 }], 395: [function(e, t2, r) {
        var n = e("minimalistic-assert"), i = e("inherits"), s = {};
        function o(e2) {
          n.equal(e2.length, 8, "Invalid IV length"), this.iv = new Array(8);
          for (var t3 = 0; t3 < this.iv.length; t3++) this.iv[t3] = e2[t3];
        }
        r.instantiate = function(e2) {
          function t3(t4) {
            e2.call(this, t4), this._cbcInit();
          }
          i(t3, e2);
          for (var r2 = Object.keys(s), n2 = 0; n2 < r2.length; n2++) {
            var o2 = r2[n2];
            t3.prototype[o2] = s[o2];
          }
          return t3.create = function(e3) {
            return new t3(e3);
          }, t3;
        }, s._cbcInit = function() {
          var e2 = new o(this.options.iv);
          this._cbcState = e2;
        }, s._update = function(e2, t3, r2, n2) {
          var i2 = this._cbcState, s2 = this.constructor.super_.prototype, o2 = i2.iv;
          if ("encrypt" === this.type) {
            for (var a = 0; a < this.blockSize; a++) o2[a] ^= e2[t3 + a];
            s2._update.call(this, o2, 0, r2, n2);
            for (a = 0; a < this.blockSize; a++) o2[a] = r2[n2 + a];
          } else {
            s2._update.call(this, e2, t3, r2, n2);
            for (a = 0; a < this.blockSize; a++) r2[n2 + a] ^= o2[a];
            for (a = 0; a < this.blockSize; a++) o2[a] = e2[t3 + a];
          }
        };
      }, { inherits: 440, "minimalistic-assert": 453 }], 396: [function(e, t2, r) {
        var n = e("minimalistic-assert");
        function i(e2) {
          this.options = e2, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = false !== e2.padding;
        }
        t2.exports = i, i.prototype._init = function() {
        }, i.prototype.update = function(e2) {
          return 0 === e2.length ? [] : "decrypt" === this.type ? this._updateDecrypt(e2) : this._updateEncrypt(e2);
        }, i.prototype._buffer = function(e2, t3) {
          for (var r2 = Math.min(this.buffer.length - this.bufferOff, e2.length - t3), n2 = 0; n2 < r2; n2++) this.buffer[this.bufferOff + n2] = e2[t3 + n2];
          return this.bufferOff += r2, r2;
        }, i.prototype._flushBuffer = function(e2, t3) {
          return this._update(this.buffer, 0, e2, t3), this.bufferOff = 0, this.blockSize;
        }, i.prototype._updateEncrypt = function(e2) {
          var t3 = 0, r2 = 0, n2 = (this.bufferOff + e2.length) / this.blockSize | 0, i2 = new Array(n2 * this.blockSize);
          0 !== this.bufferOff && (t3 += this._buffer(e2, t3), this.bufferOff === this.buffer.length && (r2 += this._flushBuffer(i2, r2)));
          for (var s = e2.length - (e2.length - t3) % this.blockSize; t3 < s; t3 += this.blockSize) this._update(e2, t3, i2, r2), r2 += this.blockSize;
          for (; t3 < e2.length; t3++, this.bufferOff++) this.buffer[this.bufferOff] = e2[t3];
          return i2;
        }, i.prototype._updateDecrypt = function(e2) {
          for (var t3 = 0, r2 = 0, n2 = Math.ceil((this.bufferOff + e2.length) / this.blockSize) - 1, i2 = new Array(n2 * this.blockSize); n2 > 0; n2--) t3 += this._buffer(e2, t3), r2 += this._flushBuffer(i2, r2);
          return t3 += this._buffer(e2, t3), i2;
        }, i.prototype.final = function(e2) {
          var t3, r2;
          return e2 && (t3 = this.update(e2)), r2 = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), t3 ? t3.concat(r2) : r2;
        }, i.prototype._pad = function(e2, t3) {
          if (0 === t3) return false;
          for (; t3 < e2.length; ) e2[t3++] = 0;
          return true;
        }, i.prototype._finalEncrypt = function() {
          if (!this._pad(this.buffer, this.bufferOff)) return [];
          var e2 = new Array(this.blockSize);
          return this._update(this.buffer, 0, e2, 0), e2;
        }, i.prototype._unpad = function(e2) {
          return e2;
        }, i.prototype._finalDecrypt = function() {
          n.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
          var e2 = new Array(this.blockSize);
          return this._flushBuffer(e2, 0), this._unpad(e2);
        };
      }, { "minimalistic-assert": 453 }], 397: [function(e, t2, r) {
        var n = e("minimalistic-assert"), i = e("inherits"), s = e("./utils"), o = e("./cipher");
        function a() {
          this.tmp = new Array(2), this.keys = null;
        }
        function l(e2) {
          o.call(this, e2);
          var t3 = new a();
          this._desState = t3, this.deriveKeys(t3, e2.key);
        }
        i(l, o), t2.exports = l, l.create = function(e2) {
          return new l(e2);
        };
        var c = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
        l.prototype.deriveKeys = function(e2, t3) {
          e2.keys = new Array(32), n.equal(t3.length, this.blockSize, "Invalid key length");
          var r2 = s.readUInt32BE(t3, 0), i2 = s.readUInt32BE(t3, 4);
          s.pc1(r2, i2, e2.tmp, 0), r2 = e2.tmp[0], i2 = e2.tmp[1];
          for (var o2 = 0; o2 < e2.keys.length; o2 += 2) {
            var a2 = c[o2 >>> 1];
            r2 = s.r28shl(r2, a2), i2 = s.r28shl(i2, a2), s.pc2(r2, i2, e2.keys, o2);
          }
        }, l.prototype._update = function(e2, t3, r2, n2) {
          var i2 = this._desState, o2 = s.readUInt32BE(e2, t3), a2 = s.readUInt32BE(e2, t3 + 4);
          s.ip(o2, a2, i2.tmp, 0), o2 = i2.tmp[0], a2 = i2.tmp[1], "encrypt" === this.type ? this._encrypt(i2, o2, a2, i2.tmp, 0) : this._decrypt(i2, o2, a2, i2.tmp, 0), o2 = i2.tmp[0], a2 = i2.tmp[1], s.writeUInt32BE(r2, o2, n2), s.writeUInt32BE(r2, a2, n2 + 4);
        }, l.prototype._pad = function(e2, t3) {
          if (false === this.padding) return false;
          for (var r2 = e2.length - t3, n2 = t3; n2 < e2.length; n2++) e2[n2] = r2;
          return true;
        }, l.prototype._unpad = function(e2) {
          if (false === this.padding) return e2;
          for (var t3 = e2[e2.length - 1], r2 = e2.length - t3; r2 < e2.length; r2++) n.equal(e2[r2], t3);
          return e2.slice(0, e2.length - t3);
        }, l.prototype._encrypt = function(e2, t3, r2, n2, i2) {
          for (var o2 = t3, a2 = r2, l2 = 0; l2 < e2.keys.length; l2 += 2) {
            var c2 = e2.keys[l2], u = e2.keys[l2 + 1];
            s.expand(a2, e2.tmp, 0), c2 ^= e2.tmp[0], u ^= e2.tmp[1];
            var h = s.substitute(c2, u), f = a2;
            a2 = (o2 ^ s.permute(h)) >>> 0, o2 = f;
          }
          s.rip(a2, o2, n2, i2);
        }, l.prototype._decrypt = function(e2, t3, r2, n2, i2) {
          for (var o2 = r2, a2 = t3, l2 = e2.keys.length - 2; l2 >= 0; l2 -= 2) {
            var c2 = e2.keys[l2], u = e2.keys[l2 + 1];
            s.expand(o2, e2.tmp, 0), c2 ^= e2.tmp[0], u ^= e2.tmp[1];
            var h = s.substitute(c2, u), f = o2;
            o2 = (a2 ^ s.permute(h)) >>> 0, a2 = f;
          }
          s.rip(o2, a2, n2, i2);
        };
      }, { "./cipher": 396, "./utils": 399, inherits: 440, "minimalistic-assert": 453 }], 398: [function(e, t2, r) {
        var n = e("minimalistic-assert"), i = e("inherits"), s = e("./cipher"), o = e("./des");
        function a(e2, t3) {
          n.equal(t3.length, 24, "Invalid key length");
          var r2 = t3.slice(0, 8), i2 = t3.slice(8, 16), s2 = t3.slice(16, 24);
          this.ciphers = "encrypt" === e2 ? [o.create({ type: "encrypt", key: r2 }), o.create({ type: "decrypt", key: i2 }), o.create({ type: "encrypt", key: s2 })] : [o.create({ type: "decrypt", key: s2 }), o.create({ type: "encrypt", key: i2 }), o.create({ type: "decrypt", key: r2 })];
        }
        function l(e2) {
          s.call(this, e2);
          var t3 = new a(this.type, this.options.key);
          this._edeState = t3;
        }
        i(l, s), t2.exports = l, l.create = function(e2) {
          return new l(e2);
        }, l.prototype._update = function(e2, t3, r2, n2) {
          var i2 = this._edeState;
          i2.ciphers[0]._update(e2, t3, r2, n2), i2.ciphers[1]._update(r2, n2, r2, n2), i2.ciphers[2]._update(r2, n2, r2, n2);
        }, l.prototype._pad = o.prototype._pad, l.prototype._unpad = o.prototype._unpad;
      }, { "./cipher": 396, "./des": 397, inherits: 440, "minimalistic-assert": 453 }], 399: [function(e, t2, r) {
        r.readUInt32BE = function(e2, t3) {
          return (e2[0 + t3] << 24 | e2[1 + t3] << 16 | e2[2 + t3] << 8 | e2[3 + t3]) >>> 0;
        }, r.writeUInt32BE = function(e2, t3, r2) {
          e2[0 + r2] = t3 >>> 24, e2[1 + r2] = t3 >>> 16 & 255, e2[2 + r2] = t3 >>> 8 & 255, e2[3 + r2] = 255 & t3;
        }, r.ip = function(e2, t3, r2, n2) {
          for (var i2 = 0, s2 = 0, o = 6; o >= 0; o -= 2) {
            for (var a = 0; a <= 24; a += 8) i2 <<= 1, i2 |= t3 >>> a + o & 1;
            for (a = 0; a <= 24; a += 8) i2 <<= 1, i2 |= e2 >>> a + o & 1;
          }
          for (o = 6; o >= 0; o -= 2) {
            for (a = 1; a <= 25; a += 8) s2 <<= 1, s2 |= t3 >>> a + o & 1;
            for (a = 1; a <= 25; a += 8) s2 <<= 1, s2 |= e2 >>> a + o & 1;
          }
          r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = s2 >>> 0;
        }, r.rip = function(e2, t3, r2, n2) {
          for (var i2 = 0, s2 = 0, o = 0; o < 4; o++) for (var a = 24; a >= 0; a -= 8) i2 <<= 1, i2 |= t3 >>> a + o & 1, i2 <<= 1, i2 |= e2 >>> a + o & 1;
          for (o = 4; o < 8; o++) for (a = 24; a >= 0; a -= 8) s2 <<= 1, s2 |= t3 >>> a + o & 1, s2 <<= 1, s2 |= e2 >>> a + o & 1;
          r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = s2 >>> 0;
        }, r.pc1 = function(e2, t3, r2, n2) {
          for (var i2 = 0, s2 = 0, o = 7; o >= 5; o--) {
            for (var a = 0; a <= 24; a += 8) i2 <<= 1, i2 |= t3 >> a + o & 1;
            for (a = 0; a <= 24; a += 8) i2 <<= 1, i2 |= e2 >> a + o & 1;
          }
          for (a = 0; a <= 24; a += 8) i2 <<= 1, i2 |= t3 >> a + o & 1;
          for (o = 1; o <= 3; o++) {
            for (a = 0; a <= 24; a += 8) s2 <<= 1, s2 |= t3 >> a + o & 1;
            for (a = 0; a <= 24; a += 8) s2 <<= 1, s2 |= e2 >> a + o & 1;
          }
          for (a = 0; a <= 24; a += 8) s2 <<= 1, s2 |= e2 >> a + o & 1;
          r2[n2 + 0] = i2 >>> 0, r2[n2 + 1] = s2 >>> 0;
        }, r.r28shl = function(e2, t3) {
          return e2 << t3 & 268435455 | e2 >>> 28 - t3;
        };
        var n = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
        r.pc2 = function(e2, t3, r2, i2) {
          for (var s2 = 0, o = 0, a = n.length >>> 1, l = 0; l < a; l++) s2 <<= 1, s2 |= e2 >>> n[l] & 1;
          for (l = a; l < n.length; l++) o <<= 1, o |= t3 >>> n[l] & 1;
          r2[i2 + 0] = s2 >>> 0, r2[i2 + 1] = o >>> 0;
        }, r.expand = function(e2, t3, r2) {
          var n2 = 0, i2 = 0;
          n2 = (1 & e2) << 5 | e2 >>> 27;
          for (var s2 = 23; s2 >= 15; s2 -= 4) n2 <<= 6, n2 |= e2 >>> s2 & 63;
          for (s2 = 11; s2 >= 3; s2 -= 4) i2 |= e2 >>> s2 & 63, i2 <<= 6;
          i2 |= (31 & e2) << 1 | e2 >>> 31, t3[r2 + 0] = n2 >>> 0, t3[r2 + 1] = i2 >>> 0;
        };
        var i = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
        r.substitute = function(e2, t3) {
          for (var r2 = 0, n2 = 0; n2 < 4; n2++) {
            r2 <<= 4, r2 |= i[64 * n2 + (e2 >>> 18 - 6 * n2 & 63)];
          }
          for (n2 = 0; n2 < 4; n2++) {
            r2 <<= 4, r2 |= i[256 + 64 * n2 + (t3 >>> 18 - 6 * n2 & 63)];
          }
          return r2 >>> 0;
        };
        var s = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
        r.permute = function(e2) {
          for (var t3 = 0, r2 = 0; r2 < s.length; r2++) t3 <<= 1, t3 |= e2 >>> s[r2] & 1;
          return t3 >>> 0;
        }, r.padSplit = function(e2, t3, r2) {
          for (var n2 = e2.toString(2); n2.length < t3; ) n2 = "0" + n2;
          for (var i2 = [], s2 = 0; s2 < t3; s2 += r2) i2.push(n2.slice(s2, s2 + r2));
          return i2.join(" ");
        };
      }, {}], 400: [function(e, t2, r) {
        (function(t3) {
          (function() {
            var n = e("./lib/generatePrime"), i = e("./lib/primes.json"), s = e("./lib/dh");
            var o = { binary: true, hex: true, base64: true };
            r.DiffieHellmanGroup = r.createDiffieHellmanGroup = r.getDiffieHellman = function(e2) {
              var r2 = new t3(i[e2].prime, "hex"), n2 = new t3(i[e2].gen, "hex");
              return new s(r2, n2);
            }, r.createDiffieHellman = r.DiffieHellman = function e2(r2, i2, a, l) {
              return t3.isBuffer(i2) || void 0 === o[i2] ? e2(r2, "binary", i2, a) : (i2 = i2 || "binary", l = l || "binary", a = a || new t3([2]), t3.isBuffer(a) || (a = new t3(a, l)), "number" == typeof r2 ? new s(n(r2, a), a, true) : (t3.isBuffer(r2) || (r2 = new t3(r2, i2)), new s(r2, a, true)));
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./lib/dh": 401, "./lib/generatePrime": 402, "./lib/primes.json": 403, buffer: 220 }], 401: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n = e("bn.js"), i = new (e("miller-rabin"))(), s = new n(24), o = new n(11), a = new n(10), l = new n(3), c = new n(7), u = e("./generatePrime"), h = e("randombytes");
            function f(e2, t3) {
              return t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3)), this._pub = new n(e2), this;
            }
            function d(e2, t3) {
              return t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3)), this._priv = new n(e2), this;
            }
            t2.exports = m;
            var p = {};
            function m(e2, t3, r3) {
              this.setGenerator(t3), this.__prime = new n(e2), this._prime = n.mont(this.__prime), this._primeLen = e2.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r3 ? (this.setPublicKey = f, this.setPrivateKey = d) : this._primeCode = 8;
            }
            function b(e2, t3) {
              var n2 = new r2(e2.toArray());
              return t3 ? n2.toString(t3) : n2;
            }
            Object.defineProperty(m.prototype, "verifyError", { enumerable: true, get: function() {
              return "number" != typeof this._primeCode && (this._primeCode = (function(e2, t3) {
                var r3 = t3.toString("hex"), n2 = [r3, e2.toString(16)].join("_");
                if (n2 in p) return p[n2];
                var h2, f2 = 0;
                if (e2.isEven() || !u.simpleSieve || !u.fermatTest(e2) || !i.test(e2)) return f2 += 1, f2 += "02" === r3 || "05" === r3 ? 8 : 4, p[n2] = f2, f2;
                switch (i.test(e2.shrn(1)) || (f2 += 2), r3) {
                  case "02":
                    e2.mod(s).cmp(o) && (f2 += 8);
                    break;
                  case "05":
                    (h2 = e2.mod(a)).cmp(l) && h2.cmp(c) && (f2 += 8);
                    break;
                  default:
                    f2 += 4;
                }
                return p[n2] = f2, f2;
              })(this.__prime, this.__gen)), this._primeCode;
            } }), m.prototype.generateKeys = function() {
              return this._priv || (this._priv = new n(h(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
            }, m.prototype.computeSecret = function(e2) {
              var t3 = (e2 = (e2 = new n(e2)).toRed(this._prime)).redPow(this._priv).fromRed(), i2 = new r2(t3.toArray()), s2 = this.getPrime();
              if (i2.length < s2.length) {
                var o2 = new r2(s2.length - i2.length);
                o2.fill(0), i2 = r2.concat([o2, i2]);
              }
              return i2;
            }, m.prototype.getPublicKey = function(e2) {
              return b(this._pub, e2);
            }, m.prototype.getPrivateKey = function(e2) {
              return b(this._priv, e2);
            }, m.prototype.getPrime = function(e2) {
              return b(this.__prime, e2);
            }, m.prototype.getGenerator = function(e2) {
              return b(this._gen, e2);
            }, m.prototype.setGenerator = function(e2, t3) {
              return t3 = t3 || "utf8", r2.isBuffer(e2) || (e2 = new r2(e2, t3)), this.__gen = e2, this._gen = new n(e2), this;
            };
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "./generatePrime": 402, "bn.js": 404, buffer: 220, "miller-rabin": 451, randombytes: 475 }], 402: [function(e, t2, r) {
        var n = e("randombytes");
        t2.exports = y, y.simpleSieve = b, y.fermatTest = g;
        var i = e("bn.js"), s = new i(24), o = new (e("miller-rabin"))(), a = new i(1), l = new i(2), c = new i(5), u = (new i(16), new i(8), new i(10)), h = new i(3), f = (new i(7), new i(11)), d = new i(4), p = (new i(12), null);
        function m() {
          if (null !== p) return p;
          var e2 = [];
          e2[0] = 2;
          for (var t3 = 1, r2 = 3; r2 < 1048576; r2 += 2) {
            for (var n2 = Math.ceil(Math.sqrt(r2)), i2 = 0; i2 < t3 && e2[i2] <= n2 && r2 % e2[i2] != 0; i2++) ;
            t3 !== i2 && e2[i2] <= n2 || (e2[t3++] = r2);
          }
          return p = e2, e2;
        }
        function b(e2) {
          for (var t3 = m(), r2 = 0; r2 < t3.length; r2++) if (0 === e2.modn(t3[r2])) return 0 === e2.cmpn(t3[r2]);
          return true;
        }
        function g(e2) {
          var t3 = i.mont(e2);
          return 0 === l.toRed(t3).redPow(e2.subn(1)).fromRed().cmpn(1);
        }
        function y(e2, t3) {
          if (e2 < 16) return new i(2 === t3 || 5 === t3 ? [140, 123] : [140, 39]);
          var r2, p2;
          for (t3 = new i(t3); ; ) {
            for (r2 = new i(n(Math.ceil(e2 / 8))); r2.bitLength() > e2; ) r2.ishrn(1);
            if (r2.isEven() && r2.iadd(a), r2.testn(1) || r2.iadd(l), t3.cmp(l)) {
              if (!t3.cmp(c)) for (; r2.mod(u).cmp(h); ) r2.iadd(d);
            } else for (; r2.mod(s).cmp(f); ) r2.iadd(d);
            if (b(p2 = r2.shrn(1)) && b(r2) && g(p2) && g(r2) && o.test(p2) && o.test(r2)) return r2;
          }
        }
      }, { "bn.js": 404, "miller-rabin": 451, randombytes: 475 }], 403: [function(e, t2, r) {
        t2.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
      }, {}], 404: [function(e, t2, r) {
        arguments[4][184][0].apply(r, arguments);
      }, { buffer: 188, dup: 184 }], 405: [function(e, t2, r) {
        var n = r;
        n.version = e("../package.json").version, n.utils = e("./elliptic/utils"), n.rand = e("brorand"), n.curve = e("./elliptic/curve"), n.curves = e("./elliptic/curves"), n.ec = e("./elliptic/ec"), n.eddsa = e("./elliptic/eddsa");
      }, { "../package.json": 421, "./elliptic/curve": 408, "./elliptic/curves": 411, "./elliptic/ec": 412, "./elliptic/eddsa": 415, "./elliptic/utils": 419, brorand: 187 }], 406: [function(e, t2, r) {
        var n = e("bn.js"), i = e("../utils"), s = i.getNAF, o = i.getJSF, a = i.assert;
        function l(e2, t3) {
          this.type = e2, this.p = new n(t3.p, 16), this.red = t3.prime ? n.red(t3.prime) : n.mont(this.p), this.zero = new n(0).toRed(this.red), this.one = new n(1).toRed(this.red), this.two = new n(2).toRed(this.red), this.n = t3.n && new n(t3.n, 16), this.g = t3.g && this.pointFromJSON(t3.g, t3.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
          var r2 = this.n && this.p.div(this.n);
          !r2 || r2.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
        }
        function c(e2, t3) {
          this.curve = e2, this.type = t3, this.precomputed = null;
        }
        t2.exports = l, l.prototype.point = function() {
          throw new Error("Not implemented");
        }, l.prototype.validate = function() {
          throw new Error("Not implemented");
        }, l.prototype._fixedNafMul = function(e2, t3) {
          a(e2.precomputed);
          var r2 = e2._getDoubles(), n2 = s(t3, 1, this._bitLength), i2 = (1 << r2.step + 1) - (r2.step % 2 == 0 ? 2 : 1);
          i2 /= 3;
          var o2, l2, c2 = [];
          for (o2 = 0; o2 < n2.length; o2 += r2.step) {
            l2 = 0;
            for (var u = o2 + r2.step - 1; u >= o2; u--) l2 = (l2 << 1) + n2[u];
            c2.push(l2);
          }
          for (var h = this.jpoint(null, null, null), f = this.jpoint(null, null, null), d = i2; d > 0; d--) {
            for (o2 = 0; o2 < c2.length; o2++) (l2 = c2[o2]) === d ? f = f.mixedAdd(r2.points[o2]) : l2 === -d && (f = f.mixedAdd(r2.points[o2].neg()));
            h = h.add(f);
          }
          return h.toP();
        }, l.prototype._wnafMul = function(e2, t3) {
          var r2 = 4, n2 = e2._getNAFPoints(r2);
          r2 = n2.wnd;
          for (var i2 = n2.points, o2 = s(t3, r2, this._bitLength), l2 = this.jpoint(null, null, null), c2 = o2.length - 1; c2 >= 0; c2--) {
            for (var u = 0; c2 >= 0 && 0 === o2[c2]; c2--) u++;
            if (c2 >= 0 && u++, l2 = l2.dblp(u), c2 < 0) break;
            var h = o2[c2];
            a(0 !== h), l2 = "affine" === e2.type ? h > 0 ? l2.mixedAdd(i2[h - 1 >> 1]) : l2.mixedAdd(i2[-h - 1 >> 1].neg()) : h > 0 ? l2.add(i2[h - 1 >> 1]) : l2.add(i2[-h - 1 >> 1].neg());
          }
          return "affine" === e2.type ? l2.toP() : l2;
        }, l.prototype._wnafMulAdd = function(e2, t3, r2, n2, i2) {
          var a2, l2, c2, u = this._wnafT1, h = this._wnafT2, f = this._wnafT3, d = 0;
          for (a2 = 0; a2 < n2; a2++) {
            var p = (c2 = t3[a2])._getNAFPoints(e2);
            u[a2] = p.wnd, h[a2] = p.points;
          }
          for (a2 = n2 - 1; a2 >= 1; a2 -= 2) {
            var m = a2 - 1, b = a2;
            if (1 === u[m] && 1 === u[b]) {
              var g = [t3[m], null, null, t3[b]];
              0 === t3[m].y.cmp(t3[b].y) ? (g[1] = t3[m].add(t3[b]), g[2] = t3[m].toJ().mixedAdd(t3[b].neg())) : 0 === t3[m].y.cmp(t3[b].y.redNeg()) ? (g[1] = t3[m].toJ().mixedAdd(t3[b]), g[2] = t3[m].add(t3[b].neg())) : (g[1] = t3[m].toJ().mixedAdd(t3[b]), g[2] = t3[m].toJ().mixedAdd(t3[b].neg()));
              var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3], v = o(r2[m], r2[b]);
              for (d = Math.max(v[0].length, d), f[m] = new Array(d), f[b] = new Array(d), l2 = 0; l2 < d; l2++) {
                var w = 0 | v[0][l2], _ = 0 | v[1][l2];
                f[m][l2] = y[3 * (w + 1) + (_ + 1)], f[b][l2] = 0, h[m] = g;
              }
            } else f[m] = s(r2[m], u[m], this._bitLength), f[b] = s(r2[b], u[b], this._bitLength), d = Math.max(f[m].length, d), d = Math.max(f[b].length, d);
          }
          var x = this.jpoint(null, null, null), k = this._wnafT4;
          for (a2 = d; a2 >= 0; a2--) {
            for (var S = 0; a2 >= 0; ) {
              var M = true;
              for (l2 = 0; l2 < n2; l2++) k[l2] = 0 | f[l2][a2], 0 !== k[l2] && (M = false);
              if (!M) break;
              S++, a2--;
            }
            if (a2 >= 0 && S++, x = x.dblp(S), a2 < 0) break;
            for (l2 = 0; l2 < n2; l2++) {
              var C2 = k[l2];
              0 !== C2 && (C2 > 0 ? c2 = h[l2][C2 - 1 >> 1] : C2 < 0 && (c2 = h[l2][-C2 - 1 >> 1].neg()), x = "affine" === c2.type ? x.mixedAdd(c2) : x.add(c2));
            }
          }
          for (a2 = 0; a2 < n2; a2++) h[a2] = null;
          return i2 ? x : x.toP();
        }, l.BasePoint = c, c.prototype.eq = function() {
          throw new Error("Not implemented");
        }, c.prototype.validate = function() {
          return this.curve.validate(this);
        }, l.prototype.decodePoint = function(e2, t3) {
          e2 = i.toArray(e2, t3);
          var r2 = this.p.byteLength();
          if ((4 === e2[0] || 6 === e2[0] || 7 === e2[0]) && e2.length - 1 == 2 * r2) return 6 === e2[0] ? a(e2[e2.length - 1] % 2 == 0) : 7 === e2[0] && a(e2[e2.length - 1] % 2 == 1), this.point(e2.slice(1, 1 + r2), e2.slice(1 + r2, 1 + 2 * r2));
          if ((2 === e2[0] || 3 === e2[0]) && e2.length - 1 === r2) return this.pointFromX(e2.slice(1, 1 + r2), 3 === e2[0]);
          throw new Error("Unknown point format");
        }, c.prototype.encodeCompressed = function(e2) {
          return this.encode(e2, true);
        }, c.prototype._encode = function(e2) {
          var t3 = this.curve.p.byteLength(), r2 = this.getX().toArray("be", t3);
          return e2 ? [this.getY().isEven() ? 2 : 3].concat(r2) : [4].concat(r2, this.getY().toArray("be", t3));
        }, c.prototype.encode = function(e2, t3) {
          return i.encode(this._encode(t3), e2);
        }, c.prototype.precompute = function(e2) {
          if (this.precomputed) return this;
          var t3 = { doubles: null, naf: null, beta: null };
          return t3.naf = this._getNAFPoints(8), t3.doubles = this._getDoubles(4, e2), t3.beta = this._getBeta(), this.precomputed = t3, this;
        }, c.prototype._hasDoubles = function(e2) {
          if (!this.precomputed) return false;
          var t3 = this.precomputed.doubles;
          return !!t3 && t3.points.length >= Math.ceil((e2.bitLength() + 1) / t3.step);
        }, c.prototype._getDoubles = function(e2, t3) {
          if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
          for (var r2 = [this], n2 = this, i2 = 0; i2 < t3; i2 += e2) {
            for (var s2 = 0; s2 < e2; s2++) n2 = n2.dbl();
            r2.push(n2);
          }
          return { step: e2, points: r2 };
        }, c.prototype._getNAFPoints = function(e2) {
          if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
          for (var t3 = [this], r2 = (1 << e2) - 1, n2 = 1 === r2 ? null : this.dbl(), i2 = 1; i2 < r2; i2++) t3[i2] = t3[i2 - 1].add(n2);
          return { wnd: e2, points: t3 };
        }, c.prototype._getBeta = function() {
          return null;
        }, c.prototype.dblp = function(e2) {
          for (var t3 = this, r2 = 0; r2 < e2; r2++) t3 = t3.dbl();
          return t3;
        };
      }, { "../utils": 419, "bn.js": 420 }], 407: [function(e, t2, r) {
        var n = e("../utils"), i = e("bn.js"), s = e("inherits"), o = e("./base"), a = n.assert;
        function l(e2) {
          this.twisted = 1 != (0 | e2.a), this.mOneA = this.twisted && -1 == (0 | e2.a), this.extended = this.mOneA, o.call(this, "edwards", e2), this.a = new i(e2.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i(e2.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i(e2.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), a(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | e2.c);
        }
        function c(e2, t3, r2, n2, s2) {
          o.BasePoint.call(this, e2, "projective"), null === t3 && null === r2 && null === n2 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new i(t3, 16), this.y = new i(r2, 16), this.z = n2 ? new i(n2, 16) : this.curve.one, this.t = s2 && new i(s2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
        }
        s(l, o), t2.exports = l, l.prototype._mulA = function(e2) {
          return this.mOneA ? e2.redNeg() : this.a.redMul(e2);
        }, l.prototype._mulC = function(e2) {
          return this.oneC ? e2 : this.c.redMul(e2);
        }, l.prototype.jpoint = function(e2, t3, r2, n2) {
          return this.point(e2, t3, r2, n2);
        }, l.prototype.pointFromX = function(e2, t3) {
          (e2 = new i(e2, 16)).red || (e2 = e2.toRed(this.red));
          var r2 = e2.redSqr(), n2 = this.c2.redSub(this.a.redMul(r2)), s2 = this.one.redSub(this.c2.redMul(this.d).redMul(r2)), o2 = n2.redMul(s2.redInvm()), a2 = o2.redSqrt();
          if (0 !== a2.redSqr().redSub(o2).cmp(this.zero)) throw new Error("invalid point");
          var l2 = a2.fromRed().isOdd();
          return (t3 && !l2 || !t3 && l2) && (a2 = a2.redNeg()), this.point(e2, a2);
        }, l.prototype.pointFromY = function(e2, t3) {
          (e2 = new i(e2, 16)).red || (e2 = e2.toRed(this.red));
          var r2 = e2.redSqr(), n2 = r2.redSub(this.c2), s2 = r2.redMul(this.d).redMul(this.c2).redSub(this.a), o2 = n2.redMul(s2.redInvm());
          if (0 === o2.cmp(this.zero)) {
            if (t3) throw new Error("invalid point");
            return this.point(this.zero, e2);
          }
          var a2 = o2.redSqrt();
          if (0 !== a2.redSqr().redSub(o2).cmp(this.zero)) throw new Error("invalid point");
          return a2.fromRed().isOdd() !== t3 && (a2 = a2.redNeg()), this.point(a2, e2);
        }, l.prototype.validate = function(e2) {
          if (e2.isInfinity()) return true;
          e2.normalize();
          var t3 = e2.x.redSqr(), r2 = e2.y.redSqr(), n2 = t3.redMul(this.a).redAdd(r2), i2 = this.c2.redMul(this.one.redAdd(this.d.redMul(t3).redMul(r2)));
          return 0 === n2.cmp(i2);
        }, s(c, o.BasePoint), l.prototype.pointFromJSON = function(e2) {
          return c.fromJSON(this, e2);
        }, l.prototype.point = function(e2, t3, r2, n2) {
          return new c(this, e2, t3, r2, n2);
        }, c.fromJSON = function(e2, t3) {
          return new c(e2, t3[0], t3[1], t3[2]);
        }, c.prototype.inspect = function() {
          return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
        }, c.prototype.isInfinity = function() {
          return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
        }, c.prototype._extDbl = function() {
          var e2 = this.x.redSqr(), t3 = this.y.redSqr(), r2 = this.z.redSqr();
          r2 = r2.redIAdd(r2);
          var n2 = this.curve._mulA(e2), i2 = this.x.redAdd(this.y).redSqr().redISub(e2).redISub(t3), s2 = n2.redAdd(t3), o2 = s2.redSub(r2), a2 = n2.redSub(t3), l2 = i2.redMul(o2), c2 = s2.redMul(a2), u = i2.redMul(a2), h = o2.redMul(s2);
          return this.curve.point(l2, c2, h, u);
        }, c.prototype._projDbl = function() {
          var e2, t3, r2, n2, i2, s2, o2 = this.x.redAdd(this.y).redSqr(), a2 = this.x.redSqr(), l2 = this.y.redSqr();
          if (this.curve.twisted) {
            var c2 = (n2 = this.curve._mulA(a2)).redAdd(l2);
            this.zOne ? (e2 = o2.redSub(a2).redSub(l2).redMul(c2.redSub(this.curve.two)), t3 = c2.redMul(n2.redSub(l2)), r2 = c2.redSqr().redSub(c2).redSub(c2)) : (i2 = this.z.redSqr(), s2 = c2.redSub(i2).redISub(i2), e2 = o2.redSub(a2).redISub(l2).redMul(s2), t3 = c2.redMul(n2.redSub(l2)), r2 = c2.redMul(s2));
          } else n2 = a2.redAdd(l2), i2 = this.curve._mulC(this.z).redSqr(), s2 = n2.redSub(i2).redSub(i2), e2 = this.curve._mulC(o2.redISub(n2)).redMul(s2), t3 = this.curve._mulC(n2).redMul(a2.redISub(l2)), r2 = n2.redMul(s2);
          return this.curve.point(e2, t3, r2);
        }, c.prototype.dbl = function() {
          return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
        }, c.prototype._extAdd = function(e2) {
          var t3 = this.y.redSub(this.x).redMul(e2.y.redSub(e2.x)), r2 = this.y.redAdd(this.x).redMul(e2.y.redAdd(e2.x)), n2 = this.t.redMul(this.curve.dd).redMul(e2.t), i2 = this.z.redMul(e2.z.redAdd(e2.z)), s2 = r2.redSub(t3), o2 = i2.redSub(n2), a2 = i2.redAdd(n2), l2 = r2.redAdd(t3), c2 = s2.redMul(o2), u = a2.redMul(l2), h = s2.redMul(l2), f = o2.redMul(a2);
          return this.curve.point(c2, u, f, h);
        }, c.prototype._projAdd = function(e2) {
          var t3, r2, n2 = this.z.redMul(e2.z), i2 = n2.redSqr(), s2 = this.x.redMul(e2.x), o2 = this.y.redMul(e2.y), a2 = this.curve.d.redMul(s2).redMul(o2), l2 = i2.redSub(a2), c2 = i2.redAdd(a2), u = this.x.redAdd(this.y).redMul(e2.x.redAdd(e2.y)).redISub(s2).redISub(o2), h = n2.redMul(l2).redMul(u);
          return this.curve.twisted ? (t3 = n2.redMul(c2).redMul(o2.redSub(this.curve._mulA(s2))), r2 = l2.redMul(c2)) : (t3 = n2.redMul(c2).redMul(o2.redSub(s2)), r2 = this.curve._mulC(l2).redMul(c2)), this.curve.point(h, t3, r2);
        }, c.prototype.add = function(e2) {
          return this.isInfinity() ? e2 : e2.isInfinity() ? this : this.curve.extended ? this._extAdd(e2) : this._projAdd(e2);
        }, c.prototype.mul = function(e2) {
          return this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve._wnafMul(this, e2);
        }, c.prototype.mulAdd = function(e2, t3, r2) {
          return this.curve._wnafMulAdd(1, [this, t3], [e2, r2], 2, false);
        }, c.prototype.jmulAdd = function(e2, t3, r2) {
          return this.curve._wnafMulAdd(1, [this, t3], [e2, r2], 2, true);
        }, c.prototype.normalize = function() {
          if (this.zOne) return this;
          var e2 = this.z.redInvm();
          return this.x = this.x.redMul(e2), this.y = this.y.redMul(e2), this.t && (this.t = this.t.redMul(e2)), this.z = this.curve.one, this.zOne = true, this;
        }, c.prototype.neg = function() {
          return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
        }, c.prototype.getX = function() {
          return this.normalize(), this.x.fromRed();
        }, c.prototype.getY = function() {
          return this.normalize(), this.y.fromRed();
        }, c.prototype.eq = function(e2) {
          return this === e2 || 0 === this.getX().cmp(e2.getX()) && 0 === this.getY().cmp(e2.getY());
        }, c.prototype.eqXToP = function(e2) {
          var t3 = e2.toRed(this.curve.red).redMul(this.z);
          if (0 === this.x.cmp(t3)) return true;
          for (var r2 = e2.clone(), n2 = this.curve.redN.redMul(this.z); ; ) {
            if (r2.iadd(this.curve.n), r2.cmp(this.curve.p) >= 0) return false;
            if (t3.redIAdd(n2), 0 === this.x.cmp(t3)) return true;
          }
        }, c.prototype.toP = c.prototype.normalize, c.prototype.mixedAdd = c.prototype.add;
      }, { "../utils": 419, "./base": 406, "bn.js": 420, inherits: 440 }], 408: [function(e, t2, r) {
        var n = r;
        n.base = e("./base"), n.short = e("./short"), n.mont = e("./mont"), n.edwards = e("./edwards");
      }, { "./base": 406, "./edwards": 407, "./mont": 409, "./short": 410 }], 409: [function(e, t2, r) {
        var n = e("bn.js"), i = e("inherits"), s = e("./base"), o = e("../utils");
        function a(e2) {
          s.call(this, "mont", e2), this.a = new n(e2.a, 16).toRed(this.red), this.b = new n(e2.b, 16).toRed(this.red), this.i4 = new n(4).toRed(this.red).redInvm(), this.two = new n(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
        }
        function l(e2, t3, r2) {
          s.BasePoint.call(this, e2, "projective"), null === t3 && null === r2 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new n(t3, 16), this.z = new n(r2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
        }
        i(a, s), t2.exports = a, a.prototype.validate = function(e2) {
          var t3 = e2.normalize().x, r2 = t3.redSqr(), n2 = r2.redMul(t3).redAdd(r2.redMul(this.a)).redAdd(t3);
          return 0 === n2.redSqrt().redSqr().cmp(n2);
        }, i(l, s.BasePoint), a.prototype.decodePoint = function(e2, t3) {
          return this.point(o.toArray(e2, t3), 1);
        }, a.prototype.point = function(e2, t3) {
          return new l(this, e2, t3);
        }, a.prototype.pointFromJSON = function(e2) {
          return l.fromJSON(this, e2);
        }, l.prototype.precompute = function() {
        }, l.prototype._encode = function() {
          return this.getX().toArray("be", this.curve.p.byteLength());
        }, l.fromJSON = function(e2, t3) {
          return new l(e2, t3[0], t3[1] || e2.one);
        }, l.prototype.inspect = function() {
          return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
        }, l.prototype.isInfinity = function() {
          return 0 === this.z.cmpn(0);
        }, l.prototype.dbl = function() {
          var e2 = this.x.redAdd(this.z).redSqr(), t3 = this.x.redSub(this.z).redSqr(), r2 = e2.redSub(t3), n2 = e2.redMul(t3), i2 = r2.redMul(t3.redAdd(this.curve.a24.redMul(r2)));
          return this.curve.point(n2, i2);
        }, l.prototype.add = function() {
          throw new Error("Not supported on Montgomery curve");
        }, l.prototype.diffAdd = function(e2, t3) {
          var r2 = this.x.redAdd(this.z), n2 = this.x.redSub(this.z), i2 = e2.x.redAdd(e2.z), s2 = e2.x.redSub(e2.z).redMul(r2), o2 = i2.redMul(n2), a2 = t3.z.redMul(s2.redAdd(o2).redSqr()), l2 = t3.x.redMul(s2.redISub(o2).redSqr());
          return this.curve.point(a2, l2);
        }, l.prototype.mul = function(e2) {
          for (var t3 = e2.clone(), r2 = this, n2 = this.curve.point(null, null), i2 = []; 0 !== t3.cmpn(0); t3.iushrn(1)) i2.push(t3.andln(1));
          for (var s2 = i2.length - 1; s2 >= 0; s2--) 0 === i2[s2] ? (r2 = r2.diffAdd(n2, this), n2 = n2.dbl()) : (n2 = r2.diffAdd(n2, this), r2 = r2.dbl());
          return n2;
        }, l.prototype.mulAdd = function() {
          throw new Error("Not supported on Montgomery curve");
        }, l.prototype.jumlAdd = function() {
          throw new Error("Not supported on Montgomery curve");
        }, l.prototype.eq = function(e2) {
          return 0 === this.getX().cmp(e2.getX());
        }, l.prototype.normalize = function() {
          return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
        }, l.prototype.getX = function() {
          return this.normalize(), this.x.fromRed();
        };
      }, { "../utils": 419, "./base": 406, "bn.js": 420, inherits: 440 }], 410: [function(e, t2, r) {
        var n = e("../utils"), i = e("bn.js"), s = e("inherits"), o = e("./base"), a = n.assert;
        function l(e2) {
          o.call(this, "short", e2), this.a = new i(e2.a, 16).toRed(this.red), this.b = new i(e2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e2), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
        }
        function c(e2, t3, r2, n2) {
          o.BasePoint.call(this, e2, "affine"), null === t3 && null === r2 ? (this.x = null, this.y = null, this.inf = true) : (this.x = new i(t3, 16), this.y = new i(r2, 16), n2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
        }
        function u(e2, t3, r2, n2) {
          o.BasePoint.call(this, e2, "jacobian"), null === t3 && null === r2 && null === n2 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i(0)) : (this.x = new i(t3, 16), this.y = new i(r2, 16), this.z = new i(n2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
        }
        s(l, o), t2.exports = l, l.prototype._getEndomorphism = function(e2) {
          if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
            var t3, r2;
            if (e2.beta) t3 = new i(e2.beta, 16).toRed(this.red);
            else {
              var n2 = this._getEndoRoots(this.p);
              t3 = (t3 = n2[0].cmp(n2[1]) < 0 ? n2[0] : n2[1]).toRed(this.red);
            }
            if (e2.lambda) r2 = new i(e2.lambda, 16);
            else {
              var s2 = this._getEndoRoots(this.n);
              0 === this.g.mul(s2[0]).x.cmp(this.g.x.redMul(t3)) ? r2 = s2[0] : (r2 = s2[1], a(0 === this.g.mul(r2).x.cmp(this.g.x.redMul(t3))));
            }
            return { beta: t3, lambda: r2, basis: e2.basis ? e2.basis.map((function(e3) {
              return { a: new i(e3.a, 16), b: new i(e3.b, 16) };
            })) : this._getEndoBasis(r2) };
          }
        }, l.prototype._getEndoRoots = function(e2) {
          var t3 = e2 === this.p ? this.red : i.mont(e2), r2 = new i(2).toRed(t3).redInvm(), n2 = r2.redNeg(), s2 = new i(3).toRed(t3).redNeg().redSqrt().redMul(r2);
          return [n2.redAdd(s2).fromRed(), n2.redSub(s2).fromRed()];
        }, l.prototype._getEndoBasis = function(e2) {
          for (var t3, r2, n2, s2, o2, a2, l2, c2, u2, h = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), f = e2, d = this.n.clone(), p = new i(1), m = new i(0), b = new i(0), g = new i(1), y = 0; 0 !== f.cmpn(0); ) {
            var v = d.div(f);
            c2 = d.sub(v.mul(f)), u2 = b.sub(v.mul(p));
            var w = g.sub(v.mul(m));
            if (!n2 && c2.cmp(h) < 0) t3 = l2.neg(), r2 = p, n2 = c2.neg(), s2 = u2;
            else if (n2 && 2 == ++y) break;
            l2 = c2, d = f, f = c2, b = p, p = u2, g = m, m = w;
          }
          o2 = c2.neg(), a2 = u2;
          var _ = n2.sqr().add(s2.sqr());
          return o2.sqr().add(a2.sqr()).cmp(_) >= 0 && (o2 = t3, a2 = r2), n2.negative && (n2 = n2.neg(), s2 = s2.neg()), o2.negative && (o2 = o2.neg(), a2 = a2.neg()), [{ a: n2, b: s2 }, { a: o2, b: a2 }];
        }, l.prototype._endoSplit = function(e2) {
          var t3 = this.endo.basis, r2 = t3[0], n2 = t3[1], i2 = n2.b.mul(e2).divRound(this.n), s2 = r2.b.neg().mul(e2).divRound(this.n), o2 = i2.mul(r2.a), a2 = s2.mul(n2.a), l2 = i2.mul(r2.b), c2 = s2.mul(n2.b);
          return { k1: e2.sub(o2).sub(a2), k2: l2.add(c2).neg() };
        }, l.prototype.pointFromX = function(e2, t3) {
          (e2 = new i(e2, 16)).red || (e2 = e2.toRed(this.red));
          var r2 = e2.redSqr().redMul(e2).redIAdd(e2.redMul(this.a)).redIAdd(this.b), n2 = r2.redSqrt();
          if (0 !== n2.redSqr().redSub(r2).cmp(this.zero)) throw new Error("invalid point");
          var s2 = n2.fromRed().isOdd();
          return (t3 && !s2 || !t3 && s2) && (n2 = n2.redNeg()), this.point(e2, n2);
        }, l.prototype.validate = function(e2) {
          if (e2.inf) return true;
          var t3 = e2.x, r2 = e2.y, n2 = this.a.redMul(t3), i2 = t3.redSqr().redMul(t3).redIAdd(n2).redIAdd(this.b);
          return 0 === r2.redSqr().redISub(i2).cmpn(0);
        }, l.prototype._endoWnafMulAdd = function(e2, t3, r2) {
          for (var n2 = this._endoWnafT1, i2 = this._endoWnafT2, s2 = 0; s2 < e2.length; s2++) {
            var o2 = this._endoSplit(t3[s2]), a2 = e2[s2], l2 = a2._getBeta();
            o2.k1.negative && (o2.k1.ineg(), a2 = a2.neg(true)), o2.k2.negative && (o2.k2.ineg(), l2 = l2.neg(true)), n2[2 * s2] = a2, n2[2 * s2 + 1] = l2, i2[2 * s2] = o2.k1, i2[2 * s2 + 1] = o2.k2;
          }
          for (var c2 = this._wnafMulAdd(1, n2, i2, 2 * s2, r2), u2 = 0; u2 < 2 * s2; u2++) n2[u2] = null, i2[u2] = null;
          return c2;
        }, s(c, o.BasePoint), l.prototype.point = function(e2, t3, r2) {
          return new c(this, e2, t3, r2);
        }, l.prototype.pointFromJSON = function(e2, t3) {
          return c.fromJSON(this, e2, t3);
        }, c.prototype._getBeta = function() {
          if (this.curve.endo) {
            var e2 = this.precomputed;
            if (e2 && e2.beta) return e2.beta;
            var t3 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (e2) {
              var r2 = this.curve, n2 = function(e3) {
                return r2.point(e3.x.redMul(r2.endo.beta), e3.y);
              };
              e2.beta = t3, t3.precomputed = { beta: null, naf: e2.naf && { wnd: e2.naf.wnd, points: e2.naf.points.map(n2) }, doubles: e2.doubles && { step: e2.doubles.step, points: e2.doubles.points.map(n2) } };
            }
            return t3;
          }
        }, c.prototype.toJSON = function() {
          return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
        }, c.fromJSON = function(e2, t3, r2) {
          "string" == typeof t3 && (t3 = JSON.parse(t3));
          var n2 = e2.point(t3[0], t3[1], r2);
          if (!t3[2]) return n2;
          function i2(t4) {
            return e2.point(t4[0], t4[1], r2);
          }
          var s2 = t3[2];
          return n2.precomputed = { beta: null, doubles: s2.doubles && { step: s2.doubles.step, points: [n2].concat(s2.doubles.points.map(i2)) }, naf: s2.naf && { wnd: s2.naf.wnd, points: [n2].concat(s2.naf.points.map(i2)) } }, n2;
        }, c.prototype.inspect = function() {
          return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
        }, c.prototype.isInfinity = function() {
          return this.inf;
        }, c.prototype.add = function(e2) {
          if (this.inf) return e2;
          if (e2.inf) return this;
          if (this.eq(e2)) return this.dbl();
          if (this.neg().eq(e2)) return this.curve.point(null, null);
          if (0 === this.x.cmp(e2.x)) return this.curve.point(null, null);
          var t3 = this.y.redSub(e2.y);
          0 !== t3.cmpn(0) && (t3 = t3.redMul(this.x.redSub(e2.x).redInvm()));
          var r2 = t3.redSqr().redISub(this.x).redISub(e2.x), n2 = t3.redMul(this.x.redSub(r2)).redISub(this.y);
          return this.curve.point(r2, n2);
        }, c.prototype.dbl = function() {
          if (this.inf) return this;
          var e2 = this.y.redAdd(this.y);
          if (0 === e2.cmpn(0)) return this.curve.point(null, null);
          var t3 = this.curve.a, r2 = this.x.redSqr(), n2 = e2.redInvm(), i2 = r2.redAdd(r2).redIAdd(r2).redIAdd(t3).redMul(n2), s2 = i2.redSqr().redISub(this.x.redAdd(this.x)), o2 = i2.redMul(this.x.redSub(s2)).redISub(this.y);
          return this.curve.point(s2, o2);
        }, c.prototype.getX = function() {
          return this.x.fromRed();
        }, c.prototype.getY = function() {
          return this.y.fromRed();
        }, c.prototype.mul = function(e2) {
          return e2 = new i(e2, 16), this.isInfinity() ? this : this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e2]) : this.curve._wnafMul(this, e2);
        }, c.prototype.mulAdd = function(e2, t3, r2) {
          var n2 = [this, t3], i2 = [e2, r2];
          return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i2) : this.curve._wnafMulAdd(1, n2, i2, 2);
        }, c.prototype.jmulAdd = function(e2, t3, r2) {
          var n2 = [this, t3], i2 = [e2, r2];
          return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i2, true) : this.curve._wnafMulAdd(1, n2, i2, 2, true);
        }, c.prototype.eq = function(e2) {
          return this === e2 || this.inf === e2.inf && (this.inf || 0 === this.x.cmp(e2.x) && 0 === this.y.cmp(e2.y));
        }, c.prototype.neg = function(e2) {
          if (this.inf) return this;
          var t3 = this.curve.point(this.x, this.y.redNeg());
          if (e2 && this.precomputed) {
            var r2 = this.precomputed, n2 = function(e3) {
              return e3.neg();
            };
            t3.precomputed = { naf: r2.naf && { wnd: r2.naf.wnd, points: r2.naf.points.map(n2) }, doubles: r2.doubles && { step: r2.doubles.step, points: r2.doubles.points.map(n2) } };
          }
          return t3;
        }, c.prototype.toJ = function() {
          return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
        }, s(u, o.BasePoint), l.prototype.jpoint = function(e2, t3, r2) {
          return new u(this, e2, t3, r2);
        }, u.prototype.toP = function() {
          if (this.isInfinity()) return this.curve.point(null, null);
          var e2 = this.z.redInvm(), t3 = e2.redSqr(), r2 = this.x.redMul(t3), n2 = this.y.redMul(t3).redMul(e2);
          return this.curve.point(r2, n2);
        }, u.prototype.neg = function() {
          return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
        }, u.prototype.add = function(e2) {
          if (this.isInfinity()) return e2;
          if (e2.isInfinity()) return this;
          var t3 = e2.z.redSqr(), r2 = this.z.redSqr(), n2 = this.x.redMul(t3), i2 = e2.x.redMul(r2), s2 = this.y.redMul(t3.redMul(e2.z)), o2 = e2.y.redMul(r2.redMul(this.z)), a2 = n2.redSub(i2), l2 = s2.redSub(o2);
          if (0 === a2.cmpn(0)) return 0 !== l2.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
          var c2 = a2.redSqr(), u2 = c2.redMul(a2), h = n2.redMul(c2), f = l2.redSqr().redIAdd(u2).redISub(h).redISub(h), d = l2.redMul(h.redISub(f)).redISub(s2.redMul(u2)), p = this.z.redMul(e2.z).redMul(a2);
          return this.curve.jpoint(f, d, p);
        }, u.prototype.mixedAdd = function(e2) {
          if (this.isInfinity()) return e2.toJ();
          if (e2.isInfinity()) return this;
          var t3 = this.z.redSqr(), r2 = this.x, n2 = e2.x.redMul(t3), i2 = this.y, s2 = e2.y.redMul(t3).redMul(this.z), o2 = r2.redSub(n2), a2 = i2.redSub(s2);
          if (0 === o2.cmpn(0)) return 0 !== a2.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
          var l2 = o2.redSqr(), c2 = l2.redMul(o2), u2 = r2.redMul(l2), h = a2.redSqr().redIAdd(c2).redISub(u2).redISub(u2), f = a2.redMul(u2.redISub(h)).redISub(i2.redMul(c2)), d = this.z.redMul(o2);
          return this.curve.jpoint(h, f, d);
        }, u.prototype.dblp = function(e2) {
          if (0 === e2) return this;
          if (this.isInfinity()) return this;
          if (!e2) return this.dbl();
          var t3;
          if (this.curve.zeroA || this.curve.threeA) {
            var r2 = this;
            for (t3 = 0; t3 < e2; t3++) r2 = r2.dbl();
            return r2;
          }
          var n2 = this.curve.a, i2 = this.curve.tinv, s2 = this.x, o2 = this.y, a2 = this.z, l2 = a2.redSqr().redSqr(), c2 = o2.redAdd(o2);
          for (t3 = 0; t3 < e2; t3++) {
            var u2 = s2.redSqr(), h = c2.redSqr(), f = h.redSqr(), d = u2.redAdd(u2).redIAdd(u2).redIAdd(n2.redMul(l2)), p = s2.redMul(h), m = d.redSqr().redISub(p.redAdd(p)), b = p.redISub(m), g = d.redMul(b);
            g = g.redIAdd(g).redISub(f);
            var y = c2.redMul(a2);
            t3 + 1 < e2 && (l2 = l2.redMul(f)), s2 = m, a2 = y, c2 = g;
          }
          return this.curve.jpoint(s2, c2.redMul(i2), a2);
        }, u.prototype.dbl = function() {
          return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
        }, u.prototype._zeroDbl = function() {
          var e2, t3, r2;
          if (this.zOne) {
            var n2 = this.x.redSqr(), i2 = this.y.redSqr(), s2 = i2.redSqr(), o2 = this.x.redAdd(i2).redSqr().redISub(n2).redISub(s2);
            o2 = o2.redIAdd(o2);
            var a2 = n2.redAdd(n2).redIAdd(n2), l2 = a2.redSqr().redISub(o2).redISub(o2), c2 = s2.redIAdd(s2);
            c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2), e2 = l2, t3 = a2.redMul(o2.redISub(l2)).redISub(c2), r2 = this.y.redAdd(this.y);
          } else {
            var u2 = this.x.redSqr(), h = this.y.redSqr(), f = h.redSqr(), d = this.x.redAdd(h).redSqr().redISub(u2).redISub(f);
            d = d.redIAdd(d);
            var p = u2.redAdd(u2).redIAdd(u2), m = p.redSqr(), b = f.redIAdd(f);
            b = (b = b.redIAdd(b)).redIAdd(b), e2 = m.redISub(d).redISub(d), t3 = p.redMul(d.redISub(e2)).redISub(b), r2 = (r2 = this.y.redMul(this.z)).redIAdd(r2);
          }
          return this.curve.jpoint(e2, t3, r2);
        }, u.prototype._threeDbl = function() {
          var e2, t3, r2;
          if (this.zOne) {
            var n2 = this.x.redSqr(), i2 = this.y.redSqr(), s2 = i2.redSqr(), o2 = this.x.redAdd(i2).redSqr().redISub(n2).redISub(s2);
            o2 = o2.redIAdd(o2);
            var a2 = n2.redAdd(n2).redIAdd(n2).redIAdd(this.curve.a), l2 = a2.redSqr().redISub(o2).redISub(o2);
            e2 = l2;
            var c2 = s2.redIAdd(s2);
            c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2), t3 = a2.redMul(o2.redISub(l2)).redISub(c2), r2 = this.y.redAdd(this.y);
          } else {
            var u2 = this.z.redSqr(), h = this.y.redSqr(), f = this.x.redMul(h), d = this.x.redSub(u2).redMul(this.x.redAdd(u2));
            d = d.redAdd(d).redIAdd(d);
            var p = f.redIAdd(f), m = (p = p.redIAdd(p)).redAdd(p);
            e2 = d.redSqr().redISub(m), r2 = this.y.redAdd(this.z).redSqr().redISub(h).redISub(u2);
            var b = h.redSqr();
            b = (b = (b = b.redIAdd(b)).redIAdd(b)).redIAdd(b), t3 = d.redMul(p.redISub(e2)).redISub(b);
          }
          return this.curve.jpoint(e2, t3, r2);
        }, u.prototype._dbl = function() {
          var e2 = this.curve.a, t3 = this.x, r2 = this.y, n2 = this.z, i2 = n2.redSqr().redSqr(), s2 = t3.redSqr(), o2 = r2.redSqr(), a2 = s2.redAdd(s2).redIAdd(s2).redIAdd(e2.redMul(i2)), l2 = t3.redAdd(t3), c2 = (l2 = l2.redIAdd(l2)).redMul(o2), u2 = a2.redSqr().redISub(c2.redAdd(c2)), h = c2.redISub(u2), f = o2.redSqr();
          f = (f = (f = f.redIAdd(f)).redIAdd(f)).redIAdd(f);
          var d = a2.redMul(h).redISub(f), p = r2.redAdd(r2).redMul(n2);
          return this.curve.jpoint(u2, d, p);
        }, u.prototype.trpl = function() {
          if (!this.curve.zeroA) return this.dbl().add(this);
          var e2 = this.x.redSqr(), t3 = this.y.redSqr(), r2 = this.z.redSqr(), n2 = t3.redSqr(), i2 = e2.redAdd(e2).redIAdd(e2), s2 = i2.redSqr(), o2 = this.x.redAdd(t3).redSqr().redISub(e2).redISub(n2), a2 = (o2 = (o2 = (o2 = o2.redIAdd(o2)).redAdd(o2).redIAdd(o2)).redISub(s2)).redSqr(), l2 = n2.redIAdd(n2);
          l2 = (l2 = (l2 = l2.redIAdd(l2)).redIAdd(l2)).redIAdd(l2);
          var c2 = i2.redIAdd(o2).redSqr().redISub(s2).redISub(a2).redISub(l2), u2 = t3.redMul(c2);
          u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2);
          var h = this.x.redMul(a2).redISub(u2);
          h = (h = h.redIAdd(h)).redIAdd(h);
          var f = this.y.redMul(c2.redMul(l2.redISub(c2)).redISub(o2.redMul(a2)));
          f = (f = (f = f.redIAdd(f)).redIAdd(f)).redIAdd(f);
          var d = this.z.redAdd(o2).redSqr().redISub(r2).redISub(a2);
          return this.curve.jpoint(h, f, d);
        }, u.prototype.mul = function(e2, t3) {
          return e2 = new i(e2, t3), this.curve._wnafMul(this, e2);
        }, u.prototype.eq = function(e2) {
          if ("affine" === e2.type) return this.eq(e2.toJ());
          if (this === e2) return true;
          var t3 = this.z.redSqr(), r2 = e2.z.redSqr();
          if (0 !== this.x.redMul(r2).redISub(e2.x.redMul(t3)).cmpn(0)) return false;
          var n2 = t3.redMul(this.z), i2 = r2.redMul(e2.z);
          return 0 === this.y.redMul(i2).redISub(e2.y.redMul(n2)).cmpn(0);
        }, u.prototype.eqXToP = function(e2) {
          var t3 = this.z.redSqr(), r2 = e2.toRed(this.curve.red).redMul(t3);
          if (0 === this.x.cmp(r2)) return true;
          for (var n2 = e2.clone(), i2 = this.curve.redN.redMul(t3); ; ) {
            if (n2.iadd(this.curve.n), n2.cmp(this.curve.p) >= 0) return false;
            if (r2.redIAdd(i2), 0 === this.x.cmp(r2)) return true;
          }
        }, u.prototype.inspect = function() {
          return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
        }, u.prototype.isInfinity = function() {
          return 0 === this.z.cmpn(0);
        };
      }, { "../utils": 419, "./base": 406, "bn.js": 420, inherits: 440 }], 411: [function(e, t2, r) {
        var n, i = r, s = e("hash.js"), o = e("./curve"), a = e("./utils").assert;
        function l(e2) {
          "short" === e2.type ? this.curve = new o.short(e2) : "edwards" === e2.type ? this.curve = new o.edwards(e2) : this.curve = new o.mont(e2), this.g = this.curve.g, this.n = this.curve.n, this.hash = e2.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }
        function c(e2, t3) {
          Object.defineProperty(i, e2, { configurable: true, enumerable: true, get: function() {
            var r2 = new l(t3);
            return Object.defineProperty(i, e2, { configurable: true, enumerable: true, value: r2 }), r2;
          } });
        }
        i.PresetCurve = l, c("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: s.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), c("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: s.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), c("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: s.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), c("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: s.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), c("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: s.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), c("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: s.sha256, gRed: false, g: ["9"] }), c("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: s.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
        try {
          n = e("./precomputed/secp256k1");
        } catch (e2) {
          n = void 0;
        }
        c("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: s.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] });
      }, { "./curve": 408, "./precomputed/secp256k1": 418, "./utils": 419, "hash.js": 426 }], 412: [function(e, t2, r) {
        var n = e("bn.js"), i = e("hmac-drbg"), s = e("../utils"), o = e("../curves"), a = e("brorand"), l = s.assert, c = e("./key"), u = e("./signature");
        function h(e2) {
          if (!(this instanceof h)) return new h(e2);
          "string" == typeof e2 && (l(Object.prototype.hasOwnProperty.call(o, e2), "Unknown curve " + e2), e2 = o[e2]), e2 instanceof o.PresetCurve && (e2 = { curve: e2 }), this.curve = e2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e2.curve.g, this.g.precompute(e2.curve.n.bitLength() + 1), this.hash = e2.hash || e2.curve.hash;
        }
        t2.exports = h, h.prototype.keyPair = function(e2) {
          return new c(this, e2);
        }, h.prototype.keyFromPrivate = function(e2, t3) {
          return c.fromPrivate(this, e2, t3);
        }, h.prototype.keyFromPublic = function(e2, t3) {
          return c.fromPublic(this, e2, t3);
        }, h.prototype.genKeyPair = function(e2) {
          e2 || (e2 = {});
          for (var t3 = new i({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || a(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.n.toArray() }), r2 = this.n.byteLength(), s2 = this.n.sub(new n(2)); ; ) {
            var o2 = new n(t3.generate(r2));
            if (!(o2.cmp(s2) > 0)) return o2.iaddn(1), this.keyFromPrivate(o2);
          }
        }, h.prototype._truncateToN = function(e2, t3) {
          var r2 = 8 * e2.byteLength() - this.n.bitLength();
          return r2 > 0 && (e2 = e2.ushrn(r2)), !t3 && e2.cmp(this.n) >= 0 ? e2.sub(this.n) : e2;
        }, h.prototype.sign = function(e2, t3, r2, s2) {
          "object" == typeof r2 && (s2 = r2, r2 = null), s2 || (s2 = {}), t3 = this.keyFromPrivate(t3, r2), e2 = this._truncateToN(new n(e2, 16));
          for (var o2 = this.n.byteLength(), a2 = t3.getPrivate().toArray("be", o2), l2 = e2.toArray("be", o2), c2 = new i({ hash: this.hash, entropy: a2, nonce: l2, pers: s2.pers, persEnc: s2.persEnc || "utf8" }), h2 = this.n.sub(new n(1)), f = 0; ; f++) {
            var d = s2.k ? s2.k(f) : new n(c2.generate(this.n.byteLength()));
            if (!((d = this._truncateToN(d, true)).cmpn(1) <= 0 || d.cmp(h2) >= 0)) {
              var p = this.g.mul(d);
              if (!p.isInfinity()) {
                var m = p.getX(), b = m.umod(this.n);
                if (0 !== b.cmpn(0)) {
                  var g = d.invm(this.n).mul(b.mul(t3.getPrivate()).iadd(e2));
                  if (0 !== (g = g.umod(this.n)).cmpn(0)) {
                    var y = (p.getY().isOdd() ? 1 : 0) | (0 !== m.cmp(b) ? 2 : 0);
                    return s2.canonical && g.cmp(this.nh) > 0 && (g = this.n.sub(g), y ^= 1), new u({ r: b, s: g, recoveryParam: y });
                  }
                }
              }
            }
          }
        }, h.prototype.verify = function(e2, t3, r2, i2) {
          e2 = this._truncateToN(new n(e2, 16)), r2 = this.keyFromPublic(r2, i2);
          var s2 = (t3 = new u(t3, "hex")).r, o2 = t3.s;
          if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0) return false;
          if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0) return false;
          var a2, l2 = o2.invm(this.n), c2 = l2.mul(e2).umod(this.n), h2 = l2.mul(s2).umod(this.n);
          return this.curve._maxwellTrick ? !(a2 = this.g.jmulAdd(c2, r2.getPublic(), h2)).isInfinity() && a2.eqXToP(s2) : !(a2 = this.g.mulAdd(c2, r2.getPublic(), h2)).isInfinity() && 0 === a2.getX().umod(this.n).cmp(s2);
        }, h.prototype.recoverPubKey = function(e2, t3, r2, i2) {
          l((3 & r2) === r2, "The recovery param is more than two bits"), t3 = new u(t3, i2);
          var s2 = this.n, o2 = new n(e2), a2 = t3.r, c2 = t3.s, h2 = 1 & r2, f = r2 >> 1;
          if (a2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && f) throw new Error("Unable to find sencond key candinate");
          a2 = f ? this.curve.pointFromX(a2.add(this.curve.n), h2) : this.curve.pointFromX(a2, h2);
          var d = t3.r.invm(s2), p = s2.sub(o2).mul(d).umod(s2), m = c2.mul(d).umod(s2);
          return this.g.mulAdd(p, a2, m);
        }, h.prototype.getKeyRecoveryParam = function(e2, t3, r2, n2) {
          if (null !== (t3 = new u(t3, n2)).recoveryParam) return t3.recoveryParam;
          for (var i2 = 0; i2 < 4; i2++) {
            var s2;
            try {
              s2 = this.recoverPubKey(e2, t3, i2);
            } catch (e3) {
              continue;
            }
            if (s2.eq(r2)) return i2;
          }
          throw new Error("Unable to find valid recovery factor");
        };
      }, { "../curves": 411, "../utils": 419, "./key": 413, "./signature": 414, "bn.js": 420, brorand: 187, "hmac-drbg": 438 }], 413: [function(e, t2, r) {
        var n = e("bn.js"), i = e("../utils").assert;
        function s(e2, t3) {
          this.ec = e2, this.priv = null, this.pub = null, t3.priv && this._importPrivate(t3.priv, t3.privEnc), t3.pub && this._importPublic(t3.pub, t3.pubEnc);
        }
        t2.exports = s, s.fromPublic = function(e2, t3, r2) {
          return t3 instanceof s ? t3 : new s(e2, { pub: t3, pubEnc: r2 });
        }, s.fromPrivate = function(e2, t3, r2) {
          return t3 instanceof s ? t3 : new s(e2, { priv: t3, privEnc: r2 });
        }, s.prototype.validate = function() {
          var e2 = this.getPublic();
          return e2.isInfinity() ? { result: false, reason: "Invalid public key" } : e2.validate() ? e2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
        }, s.prototype.getPublic = function(e2, t3) {
          return "string" == typeof e2 && (t3 = e2, e2 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t3 ? this.pub.encode(t3, e2) : this.pub;
        }, s.prototype.getPrivate = function(e2) {
          return "hex" === e2 ? this.priv.toString(16, 2) : this.priv;
        }, s.prototype._importPrivate = function(e2, t3) {
          this.priv = new n(e2, t3 || 16), this.priv = this.priv.umod(this.ec.curve.n);
        }, s.prototype._importPublic = function(e2, t3) {
          if (e2.x || e2.y) return "mont" === this.ec.curve.type ? i(e2.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || i(e2.x && e2.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(e2.x, e2.y));
          this.pub = this.ec.curve.decodePoint(e2, t3);
        }, s.prototype.derive = function(e2) {
          return e2.validate() || i(e2.validate(), "public point not validated"), e2.mul(this.priv).getX();
        }, s.prototype.sign = function(e2, t3, r2) {
          return this.ec.sign(e2, this, t3, r2);
        }, s.prototype.verify = function(e2, t3) {
          return this.ec.verify(e2, t3, this);
        }, s.prototype.inspect = function() {
          return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
        };
      }, { "../utils": 419, "bn.js": 420 }], 414: [function(e, t2, r) {
        var n = e("bn.js"), i = e("../utils"), s = i.assert;
        function o(e2, t3) {
          if (e2 instanceof o) return e2;
          this._importDER(e2, t3) || (s(e2.r && e2.s, "Signature without r or s"), this.r = new n(e2.r, 16), this.s = new n(e2.s, 16), void 0 === e2.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e2.recoveryParam);
        }
        function a() {
          this.place = 0;
        }
        function l(e2, t3) {
          var r2 = e2[t3.place++];
          if (!(128 & r2)) return r2;
          var n2 = 15 & r2;
          if (0 === n2 || n2 > 4) return false;
          for (var i2 = 0, s2 = 0, o2 = t3.place; s2 < n2; s2++, o2++) i2 <<= 8, i2 |= e2[o2], i2 >>>= 0;
          return !(i2 <= 127) && (t3.place = o2, i2);
        }
        function c(e2) {
          for (var t3 = 0, r2 = e2.length - 1; !e2[t3] && !(128 & e2[t3 + 1]) && t3 < r2; ) t3++;
          return 0 === t3 ? e2 : e2.slice(t3);
        }
        function u(e2, t3) {
          if (t3 < 128) e2.push(t3);
          else {
            var r2 = 1 + (Math.log(t3) / Math.LN2 >>> 3);
            for (e2.push(128 | r2); --r2; ) e2.push(t3 >>> (r2 << 3) & 255);
            e2.push(t3);
          }
        }
        t2.exports = o, o.prototype._importDER = function(e2, t3) {
          e2 = i.toArray(e2, t3);
          var r2 = new a();
          if (48 !== e2[r2.place++]) return false;
          var s2 = l(e2, r2);
          if (false === s2) return false;
          if (s2 + r2.place !== e2.length) return false;
          if (2 !== e2[r2.place++]) return false;
          var o2 = l(e2, r2);
          if (false === o2) return false;
          var c2 = e2.slice(r2.place, o2 + r2.place);
          if (r2.place += o2, 2 !== e2[r2.place++]) return false;
          var u2 = l(e2, r2);
          if (false === u2) return false;
          if (e2.length !== u2 + r2.place) return false;
          var h = e2.slice(r2.place, u2 + r2.place);
          if (0 === c2[0]) {
            if (!(128 & c2[1])) return false;
            c2 = c2.slice(1);
          }
          if (0 === h[0]) {
            if (!(128 & h[1])) return false;
            h = h.slice(1);
          }
          return this.r = new n(c2), this.s = new n(h), this.recoveryParam = null, true;
        }, o.prototype.toDER = function(e2) {
          var t3 = this.r.toArray(), r2 = this.s.toArray();
          for (128 & t3[0] && (t3 = [0].concat(t3)), 128 & r2[0] && (r2 = [0].concat(r2)), t3 = c(t3), r2 = c(r2); !(r2[0] || 128 & r2[1]); ) r2 = r2.slice(1);
          var n2 = [2];
          u(n2, t3.length), (n2 = n2.concat(t3)).push(2), u(n2, r2.length);
          var s2 = n2.concat(r2), o2 = [48];
          return u(o2, s2.length), o2 = o2.concat(s2), i.encode(o2, e2);
        };
      }, { "../utils": 419, "bn.js": 420 }], 415: [function(e, t2, r) {
        var n = e("hash.js"), i = e("../curves"), s = e("../utils"), o = s.assert, a = s.parseBytes, l = e("./key"), c = e("./signature");
        function u(e2) {
          if (o("ed25519" === e2, "only tested with ed25519 so far"), !(this instanceof u)) return new u(e2);
          e2 = i[e2].curve, this.curve = e2, this.g = e2.g, this.g.precompute(e2.n.bitLength() + 1), this.pointClass = e2.point().constructor, this.encodingLength = Math.ceil(e2.n.bitLength() / 8), this.hash = n.sha512;
        }
        t2.exports = u, u.prototype.sign = function(e2, t3) {
          e2 = a(e2);
          var r2 = this.keyFromSecret(t3), n2 = this.hashInt(r2.messagePrefix(), e2), i2 = this.g.mul(n2), s2 = this.encodePoint(i2), o2 = this.hashInt(s2, r2.pubBytes(), e2).mul(r2.priv()), l2 = n2.add(o2).umod(this.curve.n);
          return this.makeSignature({ R: i2, S: l2, Rencoded: s2 });
        }, u.prototype.verify = function(e2, t3, r2) {
          e2 = a(e2), t3 = this.makeSignature(t3);
          var n2 = this.keyFromPublic(r2), i2 = this.hashInt(t3.Rencoded(), n2.pubBytes(), e2), s2 = this.g.mul(t3.S());
          return t3.R().add(n2.pub().mul(i2)).eq(s2);
        }, u.prototype.hashInt = function() {
          for (var e2 = this.hash(), t3 = 0; t3 < arguments.length; t3++) e2.update(arguments[t3]);
          return s.intFromLE(e2.digest()).umod(this.curve.n);
        }, u.prototype.keyFromPublic = function(e2) {
          return l.fromPublic(this, e2);
        }, u.prototype.keyFromSecret = function(e2) {
          return l.fromSecret(this, e2);
        }, u.prototype.makeSignature = function(e2) {
          return e2 instanceof c ? e2 : new c(this, e2);
        }, u.prototype.encodePoint = function(e2) {
          var t3 = e2.getY().toArray("le", this.encodingLength);
          return t3[this.encodingLength - 1] |= e2.getX().isOdd() ? 128 : 0, t3;
        }, u.prototype.decodePoint = function(e2) {
          var t3 = (e2 = s.parseBytes(e2)).length - 1, r2 = e2.slice(0, t3).concat(-129 & e2[t3]), n2 = 0 != (128 & e2[t3]), i2 = s.intFromLE(r2);
          return this.curve.pointFromY(i2, n2);
        }, u.prototype.encodeInt = function(e2) {
          return e2.toArray("le", this.encodingLength);
        }, u.prototype.decodeInt = function(e2) {
          return s.intFromLE(e2);
        }, u.prototype.isPoint = function(e2) {
          return e2 instanceof this.pointClass;
        };
      }, { "../curves": 411, "../utils": 419, "./key": 416, "./signature": 417, "hash.js": 426 }], 416: [function(e, t2, r) {
        var n = e("../utils"), i = n.assert, s = n.parseBytes, o = n.cachedProperty;
        function a(e2, t3) {
          this.eddsa = e2, this._secret = s(t3.secret), e2.isPoint(t3.pub) ? this._pub = t3.pub : this._pubBytes = s(t3.pub);
        }
        a.fromPublic = function(e2, t3) {
          return t3 instanceof a ? t3 : new a(e2, { pub: t3 });
        }, a.fromSecret = function(e2, t3) {
          return t3 instanceof a ? t3 : new a(e2, { secret: t3 });
        }, a.prototype.secret = function() {
          return this._secret;
        }, o(a, "pubBytes", (function() {
          return this.eddsa.encodePoint(this.pub());
        })), o(a, "pub", (function() {
          return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
        })), o(a, "privBytes", (function() {
          var e2 = this.eddsa, t3 = this.hash(), r2 = e2.encodingLength - 1, n2 = t3.slice(0, e2.encodingLength);
          return n2[0] &= 248, n2[r2] &= 127, n2[r2] |= 64, n2;
        })), o(a, "priv", (function() {
          return this.eddsa.decodeInt(this.privBytes());
        })), o(a, "hash", (function() {
          return this.eddsa.hash().update(this.secret()).digest();
        })), o(a, "messagePrefix", (function() {
          return this.hash().slice(this.eddsa.encodingLength);
        })), a.prototype.sign = function(e2) {
          return i(this._secret, "KeyPair can only verify"), this.eddsa.sign(e2, this);
        }, a.prototype.verify = function(e2, t3) {
          return this.eddsa.verify(e2, t3, this);
        }, a.prototype.getSecret = function(e2) {
          return i(this._secret, "KeyPair is public only"), n.encode(this.secret(), e2);
        }, a.prototype.getPublic = function(e2) {
          return n.encode(this.pubBytes(), e2);
        }, t2.exports = a;
      }, { "../utils": 419 }], 417: [function(e, t2, r) {
        var n = e("bn.js"), i = e("../utils"), s = i.assert, o = i.cachedProperty, a = i.parseBytes;
        function l(e2, t3) {
          this.eddsa = e2, "object" != typeof t3 && (t3 = a(t3)), Array.isArray(t3) && (t3 = { R: t3.slice(0, e2.encodingLength), S: t3.slice(e2.encodingLength) }), s(t3.R && t3.S, "Signature without R or S"), e2.isPoint(t3.R) && (this._R = t3.R), t3.S instanceof n && (this._S = t3.S), this._Rencoded = Array.isArray(t3.R) ? t3.R : t3.Rencoded, this._Sencoded = Array.isArray(t3.S) ? t3.S : t3.Sencoded;
        }
        o(l, "S", (function() {
          return this.eddsa.decodeInt(this.Sencoded());
        })), o(l, "R", (function() {
          return this.eddsa.decodePoint(this.Rencoded());
        })), o(l, "Rencoded", (function() {
          return this.eddsa.encodePoint(this.R());
        })), o(l, "Sencoded", (function() {
          return this.eddsa.encodeInt(this.S());
        })), l.prototype.toBytes = function() {
          return this.Rencoded().concat(this.Sencoded());
        }, l.prototype.toHex = function() {
          return i.encode(this.toBytes(), "hex").toUpperCase();
        }, t2.exports = l;
      }, { "../utils": 419, "bn.js": 420 }], 418: [function(e, t2, r) {
        t2.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
      }, {}], 419: [function(e, t2, r) {
        var n = r, i = e("bn.js"), s = e("minimalistic-assert"), o = e("minimalistic-crypto-utils");
        n.assert = s, n.toArray = o.toArray, n.zero2 = o.zero2, n.toHex = o.toHex, n.encode = o.encode, n.getNAF = function(e2, t3, r2) {
          var n2 = new Array(Math.max(e2.bitLength(), r2) + 1);
          n2.fill(0);
          for (var i2 = 1 << t3 + 1, s2 = e2.clone(), o2 = 0; o2 < n2.length; o2++) {
            var a, l = s2.andln(i2 - 1);
            s2.isOdd() ? (a = l > (i2 >> 1) - 1 ? (i2 >> 1) - l : l, s2.isubn(a)) : a = 0, n2[o2] = a, s2.iushrn(1);
          }
          return n2;
        }, n.getJSF = function(e2, t3) {
          var r2 = [[], []];
          e2 = e2.clone(), t3 = t3.clone();
          for (var n2, i2 = 0, s2 = 0; e2.cmpn(-i2) > 0 || t3.cmpn(-s2) > 0; ) {
            var o2, a, l = e2.andln(3) + i2 & 3, c = t3.andln(3) + s2 & 3;
            3 === l && (l = -1), 3 === c && (c = -1), o2 = 0 == (1 & l) ? 0 : 3 !== (n2 = e2.andln(7) + i2 & 7) && 5 !== n2 || 2 !== c ? l : -l, r2[0].push(o2), a = 0 == (1 & c) ? 0 : 3 !== (n2 = t3.andln(7) + s2 & 7) && 5 !== n2 || 2 !== l ? c : -c, r2[1].push(a), 2 * i2 === o2 + 1 && (i2 = 1 - i2), 2 * s2 === a + 1 && (s2 = 1 - s2), e2.iushrn(1), t3.iushrn(1);
          }
          return r2;
        }, n.cachedProperty = function(e2, t3, r2) {
          var n2 = "_" + t3;
          e2.prototype[t3] = function() {
            return void 0 !== this[n2] ? this[n2] : this[n2] = r2.call(this);
          };
        }, n.parseBytes = function(e2) {
          return "string" == typeof e2 ? n.toArray(e2, "hex") : e2;
        }, n.intFromLE = function(e2) {
          return new i(e2, "hex", "le");
        };
      }, { "bn.js": 420, "minimalistic-assert": 453, "minimalistic-crypto-utils": 454 }], 420: [function(e, t2, r) {
        arguments[4][184][0].apply(r, arguments);
      }, { buffer: 188, dup: 184 }], 421: [function(e, t2, r) {
        t2.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
      }, {}], 422: [function(e, t2, r) {
        var n = Object.create || function(e2) {
          var t3 = function() {
          };
          return t3.prototype = e2, new t3();
        }, i = Object.keys || function(e2) {
          var t3 = [];
          for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && t3.push(r2);
          return r2;
        }, s = Function.prototype.bind || function(e2) {
          var t3 = this;
          return function() {
            return t3.apply(e2, arguments);
          };
        };
        function o() {
          this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = n(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        t2.exports = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._maxListeners = void 0;
        var a, l = 10;
        try {
          var c = {};
          Object.defineProperty && Object.defineProperty(c, "x", { value: 0 }), a = 0 === c.x;
        } catch (e2) {
          a = false;
        }
        function u(e2) {
          return void 0 === e2._maxListeners ? o.defaultMaxListeners : e2._maxListeners;
        }
        function h(e2, t3, r2) {
          if (t3) e2.call(r2);
          else for (var n2 = e2.length, i2 = _(e2, n2), s2 = 0; s2 < n2; ++s2) i2[s2].call(r2);
        }
        function f(e2, t3, r2, n2) {
          if (t3) e2.call(r2, n2);
          else for (var i2 = e2.length, s2 = _(e2, i2), o2 = 0; o2 < i2; ++o2) s2[o2].call(r2, n2);
        }
        function d(e2, t3, r2, n2, i2) {
          if (t3) e2.call(r2, n2, i2);
          else for (var s2 = e2.length, o2 = _(e2, s2), a2 = 0; a2 < s2; ++a2) o2[a2].call(r2, n2, i2);
        }
        function p(e2, t3, r2, n2, i2, s2) {
          if (t3) e2.call(r2, n2, i2, s2);
          else for (var o2 = e2.length, a2 = _(e2, o2), l2 = 0; l2 < o2; ++l2) a2[l2].call(r2, n2, i2, s2);
        }
        function m(e2, t3, r2, n2) {
          if (t3) e2.apply(r2, n2);
          else for (var i2 = e2.length, s2 = _(e2, i2), o2 = 0; o2 < i2; ++o2) s2[o2].apply(r2, n2);
        }
        function b(e2, t3, r2, i2) {
          var s2, o2, a2;
          if ("function" != typeof r2) throw new TypeError('"listener" argument must be a function');
          if ((o2 = e2._events) ? (o2.newListener && (e2.emit("newListener", t3, r2.listener ? r2.listener : r2), o2 = e2._events), a2 = o2[t3]) : (o2 = e2._events = n(null), e2._eventsCount = 0), a2) {
            if ("function" == typeof a2 ? a2 = o2[t3] = i2 ? [r2, a2] : [a2, r2] : i2 ? a2.unshift(r2) : a2.push(r2), !a2.warned && (s2 = u(e2)) && s2 > 0 && a2.length > s2) {
              a2.warned = true;
              var l2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + ' "' + String(t3) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              l2.name = "MaxListenersExceededWarning", l2.emitter = e2, l2.type = t3, l2.count = a2.length, "object" == typeof console && console.warn && console.warn("%s: %s", l2.name, l2.message);
            }
          } else a2 = o2[t3] = r2, ++e2._eventsCount;
          return e2;
        }
        function g() {
          if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              for (var e2 = new Array(arguments.length), t3 = 0; t3 < e2.length; ++t3) e2[t3] = arguments[t3];
              this.listener.apply(this.target, e2);
          }
        }
        function y(e2, t3, r2) {
          var n2 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: r2 }, i2 = s.call(g, n2);
          return i2.listener = r2, n2.wrapFn = i2, i2;
        }
        function v(e2, t3, r2) {
          var n2 = e2._events;
          if (!n2) return [];
          var i2 = n2[t3];
          return i2 ? "function" == typeof i2 ? r2 ? [i2.listener || i2] : [i2] : r2 ? (function(e3) {
            for (var t4 = new Array(e3.length), r3 = 0; r3 < t4.length; ++r3) t4[r3] = e3[r3].listener || e3[r3];
            return t4;
          })(i2) : _(i2, i2.length) : [];
        }
        function w(e2) {
          var t3 = this._events;
          if (t3) {
            var r2 = t3[e2];
            if ("function" == typeof r2) return 1;
            if (r2) return r2.length;
          }
          return 0;
        }
        function _(e2, t3) {
          for (var r2 = new Array(t3), n2 = 0; n2 < t3; ++n2) r2[n2] = e2[n2];
          return r2;
        }
        a ? Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
          return l;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || e2 != e2) throw new TypeError('"defaultMaxListeners" must be a positive number');
          l = e2;
        } }) : o.defaultMaxListeners = l, o.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || isNaN(e2)) throw new TypeError('"n" argument must be a positive number');
          return this._maxListeners = e2, this;
        }, o.prototype.getMaxListeners = function() {
          return u(this);
        }, o.prototype.emit = function(e2) {
          var t3, r2, n2, i2, s2, o2, a2 = "error" === e2;
          if (o2 = this._events) a2 = a2 && null == o2.error;
          else if (!a2) return false;
          if (a2) {
            if (arguments.length > 1 && (t3 = arguments[1]), t3 instanceof Error) throw t3;
            var l2 = new Error('Unhandled "error" event. (' + t3 + ")");
            throw l2.context = t3, l2;
          }
          if (!(r2 = o2[e2])) return false;
          var c2 = "function" == typeof r2;
          switch (n2 = arguments.length) {
            case 1:
              h(r2, c2, this);
              break;
            case 2:
              f(r2, c2, this, arguments[1]);
              break;
            case 3:
              d(r2, c2, this, arguments[1], arguments[2]);
              break;
            case 4:
              p(r2, c2, this, arguments[1], arguments[2], arguments[3]);
              break;
            default:
              for (i2 = new Array(n2 - 1), s2 = 1; s2 < n2; s2++) i2[s2 - 1] = arguments[s2];
              m(r2, c2, this, i2);
          }
          return true;
        }, o.prototype.addListener = function(e2, t3) {
          return b(this, e2, t3, false);
        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e2, t3) {
          return b(this, e2, t3, true);
        }, o.prototype.once = function(e2, t3) {
          if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
          return this.on(e2, y(this, e2, t3)), this;
        }, o.prototype.prependOnceListener = function(e2, t3) {
          if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
          return this.prependListener(e2, y(this, e2, t3)), this;
        }, o.prototype.removeListener = function(e2, t3) {
          var r2, i2, s2, o2, a2;
          if ("function" != typeof t3) throw new TypeError('"listener" argument must be a function');
          if (!(i2 = this._events)) return this;
          if (!(r2 = i2[e2])) return this;
          if (r2 === t3 || r2.listener === t3) 0 == --this._eventsCount ? this._events = n(null) : (delete i2[e2], i2.removeListener && this.emit("removeListener", e2, r2.listener || t3));
          else if ("function" != typeof r2) {
            for (s2 = -1, o2 = r2.length - 1; o2 >= 0; o2--) if (r2[o2] === t3 || r2[o2].listener === t3) {
              a2 = r2[o2].listener, s2 = o2;
              break;
            }
            if (s2 < 0) return this;
            0 === s2 ? r2.shift() : (function(e3, t4) {
              for (var r3 = t4, n2 = r3 + 1, i3 = e3.length; n2 < i3; r3 += 1, n2 += 1) e3[r3] = e3[n2];
              e3.pop();
            })(r2, s2), 1 === r2.length && (i2[e2] = r2[0]), i2.removeListener && this.emit("removeListener", e2, a2 || t3);
          }
          return this;
        }, o.prototype.removeAllListeners = function(e2) {
          var t3, r2, s2;
          if (!(r2 = this._events)) return this;
          if (!r2.removeListener) return 0 === arguments.length ? (this._events = n(null), this._eventsCount = 0) : r2[e2] && (0 == --this._eventsCount ? this._events = n(null) : delete r2[e2]), this;
          if (0 === arguments.length) {
            var o2, a2 = i(r2);
            for (s2 = 0; s2 < a2.length; ++s2) "removeListener" !== (o2 = a2[s2]) && this.removeAllListeners(o2);
            return this.removeAllListeners("removeListener"), this._events = n(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t3 = r2[e2])) this.removeListener(e2, t3);
          else if (t3) for (s2 = t3.length - 1; s2 >= 0; s2--) this.removeListener(e2, t3[s2]);
          return this;
        }, o.prototype.listeners = function(e2) {
          return v(this, e2, true);
        }, o.prototype.rawListeners = function(e2) {
          return v(this, e2, false);
        }, o.listenerCount = function(e2, t3) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t3) : w.call(e2, t3);
        }, o.prototype.listenerCount = w, o.prototype.eventNames = function() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
      }, {}], 423: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("md5.js");
        t2.exports = function(e2, t3, r2, s) {
          if (n.isBuffer(e2) || (e2 = n.from(e2, "binary")), t3 && (n.isBuffer(t3) || (t3 = n.from(t3, "binary")), 8 !== t3.length)) throw new RangeError("salt should be Buffer with 8 byte length");
          for (var o = r2 / 8, a = n.alloc(o), l = n.alloc(s || 0), c = n.alloc(0); o > 0 || s > 0; ) {
            var u = new i();
            u.update(c), u.update(e2), t3 && u.update(t3), c = u.digest();
            var h = 0;
            if (o > 0) {
              var f = a.length - o;
              h = Math.min(o, c.length), c.copy(a, f, 0, h), o -= h;
            }
            if (h < c.length && s > 0) {
              var d = l.length - s, p = Math.min(s, c.length - h);
              c.copy(l, d, h, h + p), s -= p;
            }
          }
          return c.fill(0), { key: a, iv: l };
        };
      }, { "md5.js": 450, "safe-buffer": 494 }], 424: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.CsvParserStream = r.ParserOptions = r.parseFile = r.parseStream = r.parseString = r.parse = r.FormatterOptions = r.CsvFormatterStream = r.writeToPath = r.writeToString = r.writeToBuffer = r.writeToStream = r.write = r.format = void 0;
        var n = e("@fast-csv/format");
        Object.defineProperty(r, "format", { enumerable: true, get: function() {
          return n.format;
        } }), Object.defineProperty(r, "write", { enumerable: true, get: function() {
          return n.write;
        } }), Object.defineProperty(r, "writeToStream", { enumerable: true, get: function() {
          return n.writeToStream;
        } }), Object.defineProperty(r, "writeToBuffer", { enumerable: true, get: function() {
          return n.writeToBuffer;
        } }), Object.defineProperty(r, "writeToString", { enumerable: true, get: function() {
          return n.writeToString;
        } }), Object.defineProperty(r, "writeToPath", { enumerable: true, get: function() {
          return n.writeToPath;
        } }), Object.defineProperty(r, "CsvFormatterStream", { enumerable: true, get: function() {
          return n.CsvFormatterStream;
        } }), Object.defineProperty(r, "FormatterOptions", { enumerable: true, get: function() {
          return n.FormatterOptions;
        } });
        var i = e("@fast-csv/parse");
        Object.defineProperty(r, "parse", { enumerable: true, get: function() {
          return i.parse;
        } }), Object.defineProperty(r, "parseString", { enumerable: true, get: function() {
          return i.parseString;
        } }), Object.defineProperty(r, "parseStream", { enumerable: true, get: function() {
          return i.parseStream;
        } }), Object.defineProperty(r, "parseFile", { enumerable: true, get: function() {
          return i.parseFile;
        } }), Object.defineProperty(r, "ParserOptions", { enumerable: true, get: function() {
          return i.ParserOptions;
        } }), Object.defineProperty(r, "CsvParserStream", { enumerable: true, get: function() {
          return i.CsvParserStream;
        } });
      }, { "@fast-csv/format": 151, "@fast-csv/parse": 155 }], 425: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("readable-stream").Transform;
        function s(e2) {
          i.call(this), this._block = n.allocUnsafe(e2), this._blockSize = e2, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
        }
        e("inherits")(s, i), s.prototype._transform = function(e2, t3, r2) {
          var n2 = null;
          try {
            this.update(e2, t3);
          } catch (e3) {
            n2 = e3;
          }
          r2(n2);
        }, s.prototype._flush = function(e2) {
          var t3 = null;
          try {
            this.push(this.digest());
          } catch (e3) {
            t3 = e3;
          }
          e2(t3);
        }, s.prototype.update = function(e2, t3) {
          if ((function(e3, t4) {
            if (!n.isBuffer(e3) && "string" != typeof e3) throw new TypeError(t4 + " must be a string or a buffer");
          })(e2, "Data"), this._finalized) throw new Error("Digest already called");
          n.isBuffer(e2) || (e2 = n.from(e2, t3));
          for (var r2 = this._block, i2 = 0; this._blockOffset + e2.length - i2 >= this._blockSize; ) {
            for (var s2 = this._blockOffset; s2 < this._blockSize; ) r2[s2++] = e2[i2++];
            this._update(), this._blockOffset = 0;
          }
          for (; i2 < e2.length; ) r2[this._blockOffset++] = e2[i2++];
          for (var o = 0, a = 8 * e2.length; a > 0; ++o) this._length[o] += a, (a = this._length[o] / 4294967296 | 0) > 0 && (this._length[o] -= 4294967296 * a);
          return this;
        }, s.prototype._update = function() {
          throw new Error("_update is not implemented");
        }, s.prototype.digest = function(e2) {
          if (this._finalized) throw new Error("Digest already called");
          this._finalized = true;
          var t3 = this._digest();
          void 0 !== e2 && (t3 = t3.toString(e2)), this._block.fill(0), this._blockOffset = 0;
          for (var r2 = 0; r2 < 4; ++r2) this._length[r2] = 0;
          return t3;
        }, s.prototype._digest = function() {
          throw new Error("_digest is not implemented");
        }, t2.exports = s;
      }, { inherits: 440, "readable-stream": 491, "safe-buffer": 494 }], 426: [function(e, t2, r) {
        var n = r;
        n.utils = e("./hash/utils"), n.common = e("./hash/common"), n.sha = e("./hash/sha"), n.ripemd = e("./hash/ripemd"), n.hmac = e("./hash/hmac"), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160;
      }, { "./hash/common": 427, "./hash/hmac": 428, "./hash/ripemd": 429, "./hash/sha": 430, "./hash/utils": 437 }], 427: [function(e, t2, r) {
        var n = e("./utils"), i = e("minimalistic-assert");
        function s() {
          this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
        }
        r.BlockHash = s, s.prototype.update = function(e2, t3) {
          if (e2 = n.toArray(e2, t3), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
            var r2 = (e2 = this.pending).length % this._delta8;
            this.pending = e2.slice(e2.length - r2, e2.length), 0 === this.pending.length && (this.pending = null), e2 = n.join32(e2, 0, e2.length - r2, this.endian);
            for (var i2 = 0; i2 < e2.length; i2 += this._delta32) this._update(e2, i2, i2 + this._delta32);
          }
          return this;
        }, s.prototype.digest = function(e2) {
          return this.update(this._pad()), i(null === this.pending), this._digest(e2);
        }, s.prototype._pad = function() {
          var e2 = this.pendingTotal, t3 = this._delta8, r2 = t3 - (e2 + this.padLength) % t3, n2 = new Array(r2 + this.padLength);
          n2[0] = 128;
          for (var i2 = 1; i2 < r2; i2++) n2[i2] = 0;
          if (e2 <<= 3, "big" === this.endian) {
            for (var s2 = 8; s2 < this.padLength; s2++) n2[i2++] = 0;
            n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = e2 >>> 24 & 255, n2[i2++] = e2 >>> 16 & 255, n2[i2++] = e2 >>> 8 & 255, n2[i2++] = 255 & e2;
          } else for (n2[i2++] = 255 & e2, n2[i2++] = e2 >>> 8 & 255, n2[i2++] = e2 >>> 16 & 255, n2[i2++] = e2 >>> 24 & 255, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, s2 = 8; s2 < this.padLength; s2++) n2[i2++] = 0;
          return n2;
        };
      }, { "./utils": 437, "minimalistic-assert": 453 }], 428: [function(e, t2, r) {
        var n = e("./utils"), i = e("minimalistic-assert");
        function s(e2, t3, r2) {
          if (!(this instanceof s)) return new s(e2, t3, r2);
          this.Hash = e2, this.blockSize = e2.blockSize / 8, this.outSize = e2.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(t3, r2));
        }
        t2.exports = s, s.prototype._init = function(e2) {
          e2.length > this.blockSize && (e2 = new this.Hash().update(e2).digest()), i(e2.length <= this.blockSize);
          for (var t3 = e2.length; t3 < this.blockSize; t3++) e2.push(0);
          for (t3 = 0; t3 < e2.length; t3++) e2[t3] ^= 54;
          for (this.inner = new this.Hash().update(e2), t3 = 0; t3 < e2.length; t3++) e2[t3] ^= 106;
          this.outer = new this.Hash().update(e2);
        }, s.prototype.update = function(e2, t3) {
          return this.inner.update(e2, t3), this;
        }, s.prototype.digest = function(e2) {
          return this.outer.update(this.inner.digest()), this.outer.digest(e2);
        };
      }, { "./utils": 437, "minimalistic-assert": 453 }], 429: [function(e, t2, r) {
        var n = e("./utils"), i = e("./common"), s = n.rotl32, o = n.sum32, a = n.sum32_3, l = n.sum32_4, c = i.BlockHash;
        function u() {
          if (!(this instanceof u)) return new u();
          c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
        }
        function h(e2, t3, r2, n2) {
          return e2 <= 15 ? t3 ^ r2 ^ n2 : e2 <= 31 ? t3 & r2 | ~t3 & n2 : e2 <= 47 ? (t3 | ~r2) ^ n2 : e2 <= 63 ? t3 & n2 | r2 & ~n2 : t3 ^ (r2 | ~n2);
        }
        function f(e2) {
          return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
        }
        function d(e2) {
          return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
        }
        n.inherits(u, c), r.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function(e2, t3) {
          for (var r2 = this.h[0], n2 = this.h[1], i2 = this.h[2], c2 = this.h[3], u2 = this.h[4], y = r2, v = n2, w = i2, _ = c2, x = u2, k = 0; k < 80; k++) {
            var S = o(s(l(r2, h(k, n2, i2, c2), e2[p[k] + t3], f(k)), b[k]), u2);
            r2 = u2, u2 = c2, c2 = s(i2, 10), i2 = n2, n2 = S, S = o(s(l(y, h(79 - k, v, w, _), e2[m[k] + t3], d(k)), g[k]), x), y = x, x = _, _ = s(w, 10), w = v, v = S;
          }
          S = a(this.h[1], i2, _), this.h[1] = a(this.h[2], c2, x), this.h[2] = a(this.h[3], u2, y), this.h[3] = a(this.h[4], r2, v), this.h[4] = a(this.h[0], n2, w), this.h[0] = S;
        }, u.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h, "little") : n.split32(this.h, "little");
        };
        var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], b = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], g = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
      }, { "./common": 427, "./utils": 437 }], 430: [function(e, t2, r) {
        r.sha1 = e("./sha/1"), r.sha224 = e("./sha/224"), r.sha256 = e("./sha/256"), r.sha384 = e("./sha/384"), r.sha512 = e("./sha/512");
      }, { "./sha/1": 431, "./sha/224": 432, "./sha/256": 433, "./sha/384": 434, "./sha/512": 435 }], 431: [function(e, t2, r) {
        var n = e("../utils"), i = e("../common"), s = e("./common"), o = n.rotl32, a = n.sum32, l = n.sum32_5, c = s.ft_1, u = i.BlockHash, h = [1518500249, 1859775393, 2400959708, 3395469782];
        function f() {
          if (!(this instanceof f)) return new f();
          u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
        }
        n.inherits(f, u), t2.exports = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 80, f.padLength = 64, f.prototype._update = function(e2, t3) {
          for (var r2 = this.W, n2 = 0; n2 < 16; n2++) r2[n2] = e2[t3 + n2];
          for (; n2 < r2.length; n2++) r2[n2] = o(r2[n2 - 3] ^ r2[n2 - 8] ^ r2[n2 - 14] ^ r2[n2 - 16], 1);
          var i2 = this.h[0], s2 = this.h[1], u2 = this.h[2], f2 = this.h[3], d = this.h[4];
          for (n2 = 0; n2 < r2.length; n2++) {
            var p = ~~(n2 / 20), m = l(o(i2, 5), c(p, s2, u2, f2), d, r2[n2], h[p]);
            d = f2, f2 = u2, u2 = o(s2, 30), s2 = i2, i2 = m;
          }
          this.h[0] = a(this.h[0], i2), this.h[1] = a(this.h[1], s2), this.h[2] = a(this.h[2], u2), this.h[3] = a(this.h[3], f2), this.h[4] = a(this.h[4], d);
        }, f.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
        };
      }, { "../common": 427, "../utils": 437, "./common": 436 }], 432: [function(e, t2, r) {
        var n = e("../utils"), i = e("./256");
        function s() {
          if (!(this instanceof s)) return new s();
          i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
        }
        n.inherits(s, i), t2.exports = s, s.blockSize = 512, s.outSize = 224, s.hmacStrength = 192, s.padLength = 64, s.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big");
        };
      }, { "../utils": 437, "./256": 433 }], 433: [function(e, t2, r) {
        var n = e("../utils"), i = e("../common"), s = e("./common"), o = e("minimalistic-assert"), a = n.sum32, l = n.sum32_4, c = n.sum32_5, u = s.ch32, h = s.maj32, f = s.s0_256, d = s.s1_256, p = s.g0_256, m = s.g1_256, b = i.BlockHash, g = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
        function y() {
          if (!(this instanceof y)) return new y();
          b.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = g, this.W = new Array(64);
        }
        n.inherits(y, b), t2.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function(e2, t3) {
          for (var r2 = this.W, n2 = 0; n2 < 16; n2++) r2[n2] = e2[t3 + n2];
          for (; n2 < r2.length; n2++) r2[n2] = l(m(r2[n2 - 2]), r2[n2 - 7], p(r2[n2 - 15]), r2[n2 - 16]);
          var i2 = this.h[0], s2 = this.h[1], b2 = this.h[2], g2 = this.h[3], y2 = this.h[4], v = this.h[5], w = this.h[6], _ = this.h[7];
          for (o(this.k.length === r2.length), n2 = 0; n2 < r2.length; n2++) {
            var x = c(_, d(y2), u(y2, v, w), this.k[n2], r2[n2]), k = a(f(i2), h(i2, s2, b2));
            _ = w, w = v, v = y2, y2 = a(g2, x), g2 = b2, b2 = s2, s2 = i2, i2 = a(x, k);
          }
          this.h[0] = a(this.h[0], i2), this.h[1] = a(this.h[1], s2), this.h[2] = a(this.h[2], b2), this.h[3] = a(this.h[3], g2), this.h[4] = a(this.h[4], y2), this.h[5] = a(this.h[5], v), this.h[6] = a(this.h[6], w), this.h[7] = a(this.h[7], _);
        }, y.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
        };
      }, { "../common": 427, "../utils": 437, "./common": 436, "minimalistic-assert": 453 }], 434: [function(e, t2, r) {
        var n = e("../utils"), i = e("./512");
        function s() {
          if (!(this instanceof s)) return new s();
          i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
        }
        n.inherits(s, i), t2.exports = s, s.blockSize = 1024, s.outSize = 384, s.hmacStrength = 192, s.padLength = 128, s.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big");
        };
      }, { "../utils": 437, "./512": 435 }], 435: [function(e, t2, r) {
        var n = e("../utils"), i = e("../common"), s = e("minimalistic-assert"), o = n.rotr64_hi, a = n.rotr64_lo, l = n.shr64_hi, c = n.shr64_lo, u = n.sum64, h = n.sum64_hi, f = n.sum64_lo, d = n.sum64_4_hi, p = n.sum64_4_lo, m = n.sum64_5_hi, b = n.sum64_5_lo, g = i.BlockHash, y = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function v() {
          if (!(this instanceof v)) return new v();
          g.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = y, this.W = new Array(160);
        }
        function w(e2, t3, r2, n2, i2) {
          var s2 = e2 & r2 ^ ~e2 & i2;
          return s2 < 0 && (s2 += 4294967296), s2;
        }
        function _(e2, t3, r2, n2, i2, s2) {
          var o2 = t3 & n2 ^ ~t3 & s2;
          return o2 < 0 && (o2 += 4294967296), o2;
        }
        function x(e2, t3, r2, n2, i2) {
          var s2 = e2 & r2 ^ e2 & i2 ^ r2 & i2;
          return s2 < 0 && (s2 += 4294967296), s2;
        }
        function k(e2, t3, r2, n2, i2, s2) {
          var o2 = t3 & n2 ^ t3 & s2 ^ n2 & s2;
          return o2 < 0 && (o2 += 4294967296), o2;
        }
        function S(e2, t3) {
          var r2 = o(e2, t3, 28) ^ o(t3, e2, 2) ^ o(t3, e2, 7);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function M(e2, t3) {
          var r2 = a(e2, t3, 28) ^ a(t3, e2, 2) ^ a(t3, e2, 7);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function C2(e2, t3) {
          var r2 = o(e2, t3, 14) ^ o(e2, t3, 18) ^ o(t3, e2, 9);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function T(e2, t3) {
          var r2 = a(e2, t3, 14) ^ a(e2, t3, 18) ^ a(t3, e2, 9);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function E(e2, t3) {
          var r2 = o(e2, t3, 1) ^ o(e2, t3, 8) ^ l(e2, t3, 7);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function A(e2, t3) {
          var r2 = a(e2, t3, 1) ^ a(e2, t3, 8) ^ c(e2, t3, 7);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function R(e2, t3) {
          var r2 = o(e2, t3, 19) ^ o(t3, e2, 29) ^ l(e2, t3, 6);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        function O(e2, t3) {
          var r2 = a(e2, t3, 19) ^ a(t3, e2, 29) ^ c(e2, t3, 6);
          return r2 < 0 && (r2 += 4294967296), r2;
        }
        n.inherits(v, g), t2.exports = v, v.blockSize = 1024, v.outSize = 512, v.hmacStrength = 192, v.padLength = 128, v.prototype._prepareBlock = function(e2, t3) {
          for (var r2 = this.W, n2 = 0; n2 < 32; n2++) r2[n2] = e2[t3 + n2];
          for (; n2 < r2.length; n2 += 2) {
            var i2 = R(r2[n2 - 4], r2[n2 - 3]), s2 = O(r2[n2 - 4], r2[n2 - 3]), o2 = r2[n2 - 14], a2 = r2[n2 - 13], l2 = E(r2[n2 - 30], r2[n2 - 29]), c2 = A(r2[n2 - 30], r2[n2 - 29]), u2 = r2[n2 - 32], h2 = r2[n2 - 31];
            r2[n2] = d(i2, s2, o2, a2, l2, c2, u2, h2), r2[n2 + 1] = p(i2, s2, o2, a2, l2, c2, u2, h2);
          }
        }, v.prototype._update = function(e2, t3) {
          this._prepareBlock(e2, t3);
          var r2 = this.W, n2 = this.h[0], i2 = this.h[1], o2 = this.h[2], a2 = this.h[3], l2 = this.h[4], c2 = this.h[5], d2 = this.h[6], p2 = this.h[7], g2 = this.h[8], y2 = this.h[9], v2 = this.h[10], E2 = this.h[11], A2 = this.h[12], R2 = this.h[13], O2 = this.h[14], j = this.h[15];
          s(this.k.length === r2.length);
          for (var I = 0; I < r2.length; I += 2) {
            var N = O2, P = j, B = C2(g2, y2), D = T(g2, y2), F = w(g2, y2, v2, E2, A2), L = _(g2, y2, v2, E2, A2, R2), z = this.k[I], U = this.k[I + 1], $ = r2[I], H = r2[I + 1], V = m(N, P, B, D, F, L, z, U, $, H), q = b(N, P, B, D, F, L, z, U, $, H);
            N = S(n2, i2), P = M(n2, i2), B = x(n2, i2, o2, a2, l2), D = k(n2, i2, o2, a2, l2, c2);
            var W = h(N, P, B, D), X = f(N, P, B, D);
            O2 = A2, j = R2, A2 = v2, R2 = E2, v2 = g2, E2 = y2, g2 = h(d2, p2, V, q), y2 = f(p2, p2, V, q), d2 = l2, p2 = c2, l2 = o2, c2 = a2, o2 = n2, a2 = i2, n2 = h(V, q, W, X), i2 = f(V, q, W, X);
          }
          u(this.h, 0, n2, i2), u(this.h, 2, o2, a2), u(this.h, 4, l2, c2), u(this.h, 6, d2, p2), u(this.h, 8, g2, y2), u(this.h, 10, v2, E2), u(this.h, 12, A2, R2), u(this.h, 14, O2, j);
        }, v.prototype._digest = function(e2) {
          return "hex" === e2 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
        };
      }, { "../common": 427, "../utils": 437, "minimalistic-assert": 453 }], 436: [function(e, t2, r) {
        var n = e("../utils").rotr32;
        function i(e2, t3, r2) {
          return e2 & t3 ^ ~e2 & r2;
        }
        function s(e2, t3, r2) {
          return e2 & t3 ^ e2 & r2 ^ t3 & r2;
        }
        function o(e2, t3, r2) {
          return e2 ^ t3 ^ r2;
        }
        r.ft_1 = function(e2, t3, r2, n2) {
          return 0 === e2 ? i(t3, r2, n2) : 1 === e2 || 3 === e2 ? o(t3, r2, n2) : 2 === e2 ? s(t3, r2, n2) : void 0;
        }, r.ch32 = i, r.maj32 = s, r.p32 = o, r.s0_256 = function(e2) {
          return n(e2, 2) ^ n(e2, 13) ^ n(e2, 22);
        }, r.s1_256 = function(e2) {
          return n(e2, 6) ^ n(e2, 11) ^ n(e2, 25);
        }, r.g0_256 = function(e2) {
          return n(e2, 7) ^ n(e2, 18) ^ e2 >>> 3;
        }, r.g1_256 = function(e2) {
          return n(e2, 17) ^ n(e2, 19) ^ e2 >>> 10;
        };
      }, { "../utils": 437 }], 437: [function(e, t2, r) {
        var n = e("minimalistic-assert"), i = e("inherits");
        function s(e2, t3) {
          return 55296 == (64512 & e2.charCodeAt(t3)) && (!(t3 < 0 || t3 + 1 >= e2.length) && 56320 == (64512 & e2.charCodeAt(t3 + 1)));
        }
        function o(e2) {
          return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
        }
        function a(e2) {
          return 1 === e2.length ? "0" + e2 : e2;
        }
        function l(e2) {
          return 7 === e2.length ? "0" + e2 : 6 === e2.length ? "00" + e2 : 5 === e2.length ? "000" + e2 : 4 === e2.length ? "0000" + e2 : 3 === e2.length ? "00000" + e2 : 2 === e2.length ? "000000" + e2 : 1 === e2.length ? "0000000" + e2 : e2;
        }
        r.inherits = i, r.toArray = function(e2, t3) {
          if (Array.isArray(e2)) return e2.slice();
          if (!e2) return [];
          var r2 = [];
          if ("string" == typeof e2) if (t3) {
            if ("hex" === t3) for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), i2 = 0; i2 < e2.length; i2 += 2) r2.push(parseInt(e2[i2] + e2[i2 + 1], 16));
          } else for (var n2 = 0, i2 = 0; i2 < e2.length; i2++) {
            var o2 = e2.charCodeAt(i2);
            o2 < 128 ? r2[n2++] = o2 : o2 < 2048 ? (r2[n2++] = o2 >> 6 | 192, r2[n2++] = 63 & o2 | 128) : s(e2, i2) ? (o2 = 65536 + ((1023 & o2) << 10) + (1023 & e2.charCodeAt(++i2)), r2[n2++] = o2 >> 18 | 240, r2[n2++] = o2 >> 12 & 63 | 128, r2[n2++] = o2 >> 6 & 63 | 128, r2[n2++] = 63 & o2 | 128) : (r2[n2++] = o2 >> 12 | 224, r2[n2++] = o2 >> 6 & 63 | 128, r2[n2++] = 63 & o2 | 128);
          }
          else for (i2 = 0; i2 < e2.length; i2++) r2[i2] = 0 | e2[i2];
          return r2;
        }, r.toHex = function(e2) {
          for (var t3 = "", r2 = 0; r2 < e2.length; r2++) t3 += a(e2[r2].toString(16));
          return t3;
        }, r.htonl = o, r.toHex32 = function(e2, t3) {
          for (var r2 = "", n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2[n2];
            "little" === t3 && (i2 = o(i2)), r2 += l(i2.toString(16));
          }
          return r2;
        }, r.zero2 = a, r.zero8 = l, r.join32 = function(e2, t3, r2, i2) {
          var s2 = r2 - t3;
          n(s2 % 4 == 0);
          for (var o2 = new Array(s2 / 4), a2 = 0, l2 = t3; a2 < o2.length; a2++, l2 += 4) {
            var c;
            c = "big" === i2 ? e2[l2] << 24 | e2[l2 + 1] << 16 | e2[l2 + 2] << 8 | e2[l2 + 3] : e2[l2 + 3] << 24 | e2[l2 + 2] << 16 | e2[l2 + 1] << 8 | e2[l2], o2[a2] = c >>> 0;
          }
          return o2;
        }, r.split32 = function(e2, t3) {
          for (var r2 = new Array(4 * e2.length), n2 = 0, i2 = 0; n2 < e2.length; n2++, i2 += 4) {
            var s2 = e2[n2];
            "big" === t3 ? (r2[i2] = s2 >>> 24, r2[i2 + 1] = s2 >>> 16 & 255, r2[i2 + 2] = s2 >>> 8 & 255, r2[i2 + 3] = 255 & s2) : (r2[i2 + 3] = s2 >>> 24, r2[i2 + 2] = s2 >>> 16 & 255, r2[i2 + 1] = s2 >>> 8 & 255, r2[i2] = 255 & s2);
          }
          return r2;
        }, r.rotr32 = function(e2, t3) {
          return e2 >>> t3 | e2 << 32 - t3;
        }, r.rotl32 = function(e2, t3) {
          return e2 << t3 | e2 >>> 32 - t3;
        }, r.sum32 = function(e2, t3) {
          return e2 + t3 >>> 0;
        }, r.sum32_3 = function(e2, t3, r2) {
          return e2 + t3 + r2 >>> 0;
        }, r.sum32_4 = function(e2, t3, r2, n2) {
          return e2 + t3 + r2 + n2 >>> 0;
        }, r.sum32_5 = function(e2, t3, r2, n2, i2) {
          return e2 + t3 + r2 + n2 + i2 >>> 0;
        }, r.sum64 = function(e2, t3, r2, n2) {
          var i2 = e2[t3], s2 = n2 + e2[t3 + 1] >>> 0, o2 = (s2 < n2 ? 1 : 0) + r2 + i2;
          e2[t3] = o2 >>> 0, e2[t3 + 1] = s2;
        }, r.sum64_hi = function(e2, t3, r2, n2) {
          return (t3 + n2 >>> 0 < t3 ? 1 : 0) + e2 + r2 >>> 0;
        }, r.sum64_lo = function(e2, t3, r2, n2) {
          return t3 + n2 >>> 0;
        }, r.sum64_4_hi = function(e2, t3, r2, n2, i2, s2, o2, a2) {
          var l2 = 0, c = t3;
          return l2 += (c = c + n2 >>> 0) < t3 ? 1 : 0, l2 += (c = c + s2 >>> 0) < s2 ? 1 : 0, e2 + r2 + i2 + o2 + (l2 += (c = c + a2 >>> 0) < a2 ? 1 : 0) >>> 0;
        }, r.sum64_4_lo = function(e2, t3, r2, n2, i2, s2, o2, a2) {
          return t3 + n2 + s2 + a2 >>> 0;
        }, r.sum64_5_hi = function(e2, t3, r2, n2, i2, s2, o2, a2, l2, c) {
          var u = 0, h = t3;
          return u += (h = h + n2 >>> 0) < t3 ? 1 : 0, u += (h = h + s2 >>> 0) < s2 ? 1 : 0, u += (h = h + a2 >>> 0) < a2 ? 1 : 0, e2 + r2 + i2 + o2 + l2 + (u += (h = h + c >>> 0) < c ? 1 : 0) >>> 0;
        }, r.sum64_5_lo = function(e2, t3, r2, n2, i2, s2, o2, a2, l2, c) {
          return t3 + n2 + s2 + a2 + c >>> 0;
        }, r.rotr64_hi = function(e2, t3, r2) {
          return (t3 << 32 - r2 | e2 >>> r2) >>> 0;
        }, r.rotr64_lo = function(e2, t3, r2) {
          return (e2 << 32 - r2 | t3 >>> r2) >>> 0;
        }, r.shr64_hi = function(e2, t3, r2) {
          return e2 >>> r2;
        }, r.shr64_lo = function(e2, t3, r2) {
          return (e2 << 32 - r2 | t3 >>> r2) >>> 0;
        };
      }, { inherits: 440, "minimalistic-assert": 453 }], 438: [function(e, t2, r) {
        var n = e("hash.js"), i = e("minimalistic-crypto-utils"), s = e("minimalistic-assert");
        function o(e2) {
          if (!(this instanceof o)) return new o(e2);
          this.hash = e2.hash, this.predResist = !!e2.predResist, this.outLen = this.hash.outSize, this.minEntropy = e2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
          var t3 = i.toArray(e2.entropy, e2.entropyEnc || "hex"), r2 = i.toArray(e2.nonce, e2.nonceEnc || "hex"), n2 = i.toArray(e2.pers, e2.persEnc || "hex");
          s(t3.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t3, r2, n2);
        }
        t2.exports = o, o.prototype._init = function(e2, t3, r2) {
          var n2 = e2.concat(t3).concat(r2);
          this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
          for (var i2 = 0; i2 < this.V.length; i2++) this.K[i2] = 0, this.V[i2] = 1;
          this._update(n2), this._reseed = 1, this.reseedInterval = 281474976710656;
        }, o.prototype._hmac = function() {
          return new n.hmac(this.hash, this.K);
        }, o.prototype._update = function(e2) {
          var t3 = this._hmac().update(this.V).update([0]);
          e2 && (t3 = t3.update(e2)), this.K = t3.digest(), this.V = this._hmac().update(this.V).digest(), e2 && (this.K = this._hmac().update(this.V).update([1]).update(e2).digest(), this.V = this._hmac().update(this.V).digest());
        }, o.prototype.reseed = function(e2, t3, r2, n2) {
          "string" != typeof t3 && (n2 = r2, r2 = t3, t3 = null), e2 = i.toArray(e2, t3), r2 = i.toArray(r2, n2), s(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e2.concat(r2 || [])), this._reseed = 1;
        }, o.prototype.generate = function(e2, t3, r2, n2) {
          if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
          "string" != typeof t3 && (n2 = r2, r2 = t3, t3 = null), r2 && (r2 = i.toArray(r2, n2 || "hex"), this._update(r2));
          for (var s2 = []; s2.length < e2; ) this.V = this._hmac().update(this.V).digest(), s2 = s2.concat(this.V);
          var o2 = s2.slice(0, e2);
          return this._update(r2), this._reseed++, i.encode(o2, t3);
        };
      }, { "hash.js": 426, "minimalistic-assert": 453, "minimalistic-crypto-utils": 454 }], 439: [function(e, t2, r) {
        r.read = function(e2, t3, r2, n, i) {
          var s, o, a = 8 * i - n - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = r2 ? i - 1 : 0, f = r2 ? -1 : 1, d = e2[t3 + h];
          for (h += f, s = d & (1 << -u) - 1, d >>= -u, u += a; u > 0; s = 256 * s + e2[t3 + h], h += f, u -= 8) ;
          for (o = s & (1 << -u) - 1, s >>= -u, u += n; u > 0; o = 256 * o + e2[t3 + h], h += f, u -= 8) ;
          if (0 === s) s = 1 - c;
          else {
            if (s === l) return o ? NaN : 1 / 0 * (d ? -1 : 1);
            o += Math.pow(2, n), s -= c;
          }
          return (d ? -1 : 1) * o * Math.pow(2, s - n);
        }, r.write = function(e2, t3, r2, n, i, s) {
          var o, a, l, c = 8 * s - i - 1, u = (1 << c) - 1, h = u >> 1, f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : s - 1, p = n ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
          for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t3 += o + h >= 1 ? f / l : f * Math.pow(2, 1 - h)) * l >= 2 && (o++, l /= 2), o + h >= u ? (a = 0, o = u) : o + h >= 1 ? (a = (t3 * l - 1) * Math.pow(2, i), o += h) : (a = t3 * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); i >= 8; e2[r2 + d] = 255 & a, d += p, a /= 256, i -= 8) ;
          for (o = o << i | a, c += i; c > 0; e2[r2 + d] = 255 & o, d += p, o /= 256, c -= 8) ;
          e2[r2 + d - p] |= 128 * m;
        };
      }, {}], 440: [function(e, t2, r) {
        "function" == typeof Object.create ? t2.exports = function(e2, t3) {
          t3 && (e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : t2.exports = function(e2, t3) {
          if (t3) {
            e2.super_ = t3;
            var r2 = function() {
            };
            r2.prototype = t3.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 441: [function(e, t2, r) {
        (function(n, i, s, o, a, l, c, u) {
          (function() {
            !(function(e2) {
              "object" == typeof r && void 0 !== t2 ? t2.exports = e2() : ("undefined" != typeof window ? window : void 0 !== i ? i : "undefined" != typeof self ? self : this).JSZip = e2();
            })((function() {
              return (function t3(r2, n2, i2) {
                function s2(a3, l2) {
                  if (!n2[a3]) {
                    if (!r2[a3]) {
                      var c2 = "function" == typeof e && e;
                      if (!l2 && c2) return c2(a3, true);
                      if (o2) return o2(a3, true);
                      var u2 = new Error("Cannot find module '" + a3 + "'");
                      throw u2.code = "MODULE_NOT_FOUND", u2;
                    }
                    var h = n2[a3] = { exports: {} };
                    r2[a3][0].call(h.exports, (function(e2) {
                      return s2(r2[a3][1][e2] || e2);
                    }), h, h.exports, t3, r2, n2, i2);
                  }
                  return n2[a3].exports;
                }
                for (var o2 = "function" == typeof e && e, a2 = 0; a2 < i2.length; a2++) s2(i2[a2]);
                return s2;
              })({ 1: [function(e2, t3, r2) {
                var n2 = e2("./utils"), i2 = e2("./support"), s2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                r2.encode = function(e3) {
                  for (var t4, r3, i3, o2, a2, l2, c2, u2 = [], h = 0, f = e3.length, d = f, p = "string" !== n2.getTypeOf(e3); h < e3.length; ) d = f - h, i3 = p ? (t4 = e3[h++], r3 = h < f ? e3[h++] : 0, h < f ? e3[h++] : 0) : (t4 = e3.charCodeAt(h++), r3 = h < f ? e3.charCodeAt(h++) : 0, h < f ? e3.charCodeAt(h++) : 0), o2 = t4 >> 2, a2 = (3 & t4) << 4 | r3 >> 4, l2 = 1 < d ? (15 & r3) << 2 | i3 >> 6 : 64, c2 = 2 < d ? 63 & i3 : 64, u2.push(s2.charAt(o2) + s2.charAt(a2) + s2.charAt(l2) + s2.charAt(c2));
                  return u2.join("");
                }, r2.decode = function(e3) {
                  var t4, r3, n3, o2, a2, l2, c2 = 0, u2 = 0, h = "data:";
                  if (e3.substr(0, h.length) === h) throw new Error("Invalid base64 input, it looks like a data url.");
                  var f, d = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                  if (e3.charAt(e3.length - 1) === s2.charAt(64) && d--, e3.charAt(e3.length - 2) === s2.charAt(64) && d--, d % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                  for (f = i2.uint8array ? new Uint8Array(0 | d) : new Array(0 | d); c2 < e3.length; ) t4 = s2.indexOf(e3.charAt(c2++)) << 2 | (o2 = s2.indexOf(e3.charAt(c2++))) >> 4, r3 = (15 & o2) << 4 | (a2 = s2.indexOf(e3.charAt(c2++))) >> 2, n3 = (3 & a2) << 6 | (l2 = s2.indexOf(e3.charAt(c2++))), f[u2++] = t4, 64 !== a2 && (f[u2++] = r3), 64 !== l2 && (f[u2++] = n3);
                  return f;
                };
              }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t3, r2) {
                var n2 = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), o2 = e2("./stream/DataLengthProbe");
                function a2(e3, t4, r3, n3, i3) {
                  this.compressedSize = e3, this.uncompressedSize = t4, this.crc32 = r3, this.compression = n3, this.compressedContent = i3;
                }
                a2.prototype = { getContentWorker: function() {
                  var e3 = new i2(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new o2("data_length")), t4 = this;
                  return e3.on("end", (function() {
                    if (this.streamInfo.data_length !== t4.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                  })), e3;
                }, getCompressedWorker: function() {
                  return new i2(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                } }, a2.createWorkerFrom = function(e3, t4, r3) {
                  return e3.pipe(new s2()).pipe(new o2("uncompressedSize")).pipe(t4.compressWorker(r3)).pipe(new o2("compressedSize")).withStreamInfo("compression", t4);
                }, t3.exports = a2;
              }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t3, r2) {
                var n2 = e2("./stream/GenericWorker");
                r2.STORE = { magic: "\0\0", compressWorker: function() {
                  return new n2("STORE compression");
                }, uncompressWorker: function() {
                  return new n2("STORE decompression");
                } }, r2.DEFLATE = e2("./flate");
              }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t3, r2) {
                var n2 = e2("./utils"), i2 = (function() {
                  for (var e3, t4 = [], r3 = 0; r3 < 256; r3++) {
                    e3 = r3;
                    for (var n3 = 0; n3 < 8; n3++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
                    t4[r3] = e3;
                  }
                  return t4;
                })();
                t3.exports = function(e3, t4) {
                  return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? (function(e4, t5, r3, n3) {
                    var s2 = i2, o2 = 0 + r3;
                    e4 ^= -1;
                    for (var a2 = 0; a2 < o2; a2++) e4 = e4 >>> 8 ^ s2[255 & (e4 ^ t5[a2])];
                    return -1 ^ e4;
                  })(0 | t4, e3, e3.length) : (function(e4, t5, r3, n3) {
                    var s2 = i2, o2 = 0 + r3;
                    e4 ^= -1;
                    for (var a2 = 0; a2 < o2; a2++) e4 = e4 >>> 8 ^ s2[255 & (e4 ^ t5.charCodeAt(a2))];
                    return -1 ^ e4;
                  })(0 | t4, e3, e3.length) : 0;
                };
              }, { "./utils": 32 }], 5: [function(e2, t3, r2) {
                r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
              }, {}], 6: [function(e2, t3, r2) {
                var n2;
                n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t3.exports = { Promise: n2 };
              }, { lie: 37 }], 7: [function(e2, t3, r2) {
                var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), o2 = e2("./stream/GenericWorker"), a2 = n2 ? "uint8array" : "array";
                function l2(e3, t4) {
                  o2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t4, this.meta = {};
                }
                r2.magic = "\b\0", s2.inherits(l2, o2), l2.prototype.processChunk = function(e3) {
                  this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(a2, e3.data), false);
                }, l2.prototype.flush = function() {
                  o2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
                }, l2.prototype.cleanUp = function() {
                  o2.prototype.cleanUp.call(this), this._pako = null;
                }, l2.prototype._createPako = function() {
                  this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
                  var e3 = this;
                  this._pako.onData = function(t4) {
                    e3.push({ data: t4, meta: e3.meta });
                  };
                }, r2.compressWorker = function(e3) {
                  return new l2("Deflate", e3);
                }, r2.uncompressWorker = function() {
                  return new l2("Inflate", {});
                };
              }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t3, r2) {
                function n2(e3, t4) {
                  var r3, n3 = "";
                  for (r3 = 0; r3 < t4; r3++) n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
                  return n3;
                }
                function i2(e3, t4, r3, i3, o3, u3) {
                  var h, f, d = e3.file, p = e3.compression, m = u3 !== a2.utf8encode, b = s2.transformTo("string", u3(d.name)), g = s2.transformTo("string", a2.utf8encode(d.name)), y = d.comment, v = s2.transformTo("string", u3(y)), w = s2.transformTo("string", a2.utf8encode(y)), _ = g.length !== d.name.length, x = w.length !== y.length, k = "", S = "", M = "", C2 = d.dir, T = d.date, E = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                  t4 && !r3 || (E.crc32 = e3.crc32, E.compressedSize = e3.compressedSize, E.uncompressedSize = e3.uncompressedSize);
                  var A = 0;
                  t4 && (A |= 8), m || !_ && !x || (A |= 2048);
                  var R = 0, O = 0;
                  C2 && (R |= 16), "UNIX" === o3 ? (O = 798, R |= (function(e4, t5) {
                    var r4 = e4;
                    return e4 || (r4 = t5 ? 16893 : 33204), (65535 & r4) << 16;
                  })(d.unixPermissions, C2)) : (O = 20, R |= (function(e4) {
                    return 63 & (e4 || 0);
                  })(d.dosPermissions)), h = T.getUTCHours(), h <<= 6, h |= T.getUTCMinutes(), h <<= 5, h |= T.getUTCSeconds() / 2, f = T.getUTCFullYear() - 1980, f <<= 4, f |= T.getUTCMonth() + 1, f <<= 5, f |= T.getUTCDate(), _ && (S = n2(1, 1) + n2(l2(b), 4) + g, k += "up" + n2(S.length, 2) + S), x && (M = n2(1, 1) + n2(l2(v), 4) + w, k += "uc" + n2(M.length, 2) + M);
                  var j = "";
                  return j += "\n\0", j += n2(A, 2), j += p.magic, j += n2(h, 2), j += n2(f, 2), j += n2(E.crc32, 4), j += n2(E.compressedSize, 4), j += n2(E.uncompressedSize, 4), j += n2(b.length, 2), j += n2(k.length, 2), { fileRecord: c2.LOCAL_FILE_HEADER + j + b + k, dirRecord: c2.CENTRAL_FILE_HEADER + n2(O, 2) + j + n2(v.length, 2) + "\0\0\0\0" + n2(R, 4) + n2(i3, 4) + b + k + v };
                }
                var s2 = e2("../utils"), o2 = e2("../stream/GenericWorker"), a2 = e2("../utf8"), l2 = e2("../crc32"), c2 = e2("../signature");
                function u2(e3, t4, r3, n3) {
                  o2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t4, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                }
                s2.inherits(u2, o2), u2.prototype.push = function(e3) {
                  var t4 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
                  this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, o2.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t4 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
                }, u2.prototype.openedSource = function(e3) {
                  this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
                  var t4 = this.streamFiles && !e3.file.dir;
                  if (t4) {
                    var r3 = i2(e3, t4, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    this.push({ data: r3.fileRecord, meta: { percent: 0 } });
                  } else this.accumulate = true;
                }, u2.prototype.closedSource = function(e3) {
                  this.accumulate = false;
                  var t4 = this.streamFiles && !e3.file.dir, r3 = i2(e3, t4, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                  if (this.dirRecords.push(r3.dirRecord), t4) this.push({ data: (function(e4) {
                    return c2.DATA_DESCRIPTOR + n2(e4.crc32, 4) + n2(e4.compressedSize, 4) + n2(e4.uncompressedSize, 4);
                  })(e3), meta: { percent: 100 } });
                  else for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
                  this.currentFile = null;
                }, u2.prototype.flush = function() {
                  for (var e3 = this.bytesWritten, t4 = 0; t4 < this.dirRecords.length; t4++) this.push({ data: this.dirRecords[t4], meta: { percent: 100 } });
                  var r3 = this.bytesWritten - e3, i3 = (function(e4, t5, r4, i4, o3) {
                    var a3 = s2.transformTo("string", o3(i4));
                    return c2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n2(e4, 2) + n2(e4, 2) + n2(t5, 4) + n2(r4, 4) + n2(a3.length, 2) + a3;
                  })(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
                  this.push({ data: i3, meta: { percent: 100 } });
                }, u2.prototype.prepareNextSource = function() {
                  this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                }, u2.prototype.registerPrevious = function(e3) {
                  this._sources.push(e3);
                  var t4 = this;
                  return e3.on("data", (function(e4) {
                    t4.processChunk(e4);
                  })), e3.on("end", (function() {
                    t4.closedSource(t4.previous.streamInfo), t4._sources.length ? t4.prepareNextSource() : t4.end();
                  })), e3.on("error", (function(e4) {
                    t4.error(e4);
                  })), this;
                }, u2.prototype.resume = function() {
                  return !!o2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
                }, u2.prototype.error = function(e3) {
                  var t4 = this._sources;
                  if (!o2.prototype.error.call(this, e3)) return false;
                  for (var r3 = 0; r3 < t4.length; r3++) try {
                    t4[r3].error(e3);
                  } catch (e4) {
                  }
                  return true;
                }, u2.prototype.lock = function() {
                  o2.prototype.lock.call(this);
                  for (var e3 = this._sources, t4 = 0; t4 < e3.length; t4++) e3[t4].lock();
                }, t3.exports = u2;
              }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t3, r2) {
                var n2 = e2("../compressions"), i2 = e2("./ZipFileWorker");
                r2.generateWorker = function(e3, t4, r3) {
                  var s2 = new i2(t4.streamFiles, r3, t4.platform, t4.encodeFileName), o2 = 0;
                  try {
                    e3.forEach((function(e4, r4) {
                      o2++;
                      var i3 = (function(e5, t5) {
                        var r5 = e5 || t5, i4 = n2[r5];
                        if (!i4) throw new Error(r5 + " is not a valid compression method !");
                        return i4;
                      })(r4.options.compression, t4.compression), a2 = r4.options.compressionOptions || t4.compressionOptions || {}, l2 = r4.dir, c2 = r4.date;
                      r4._compressWorker(i3, a2).withStreamInfo("file", { name: e4, dir: l2, date: c2, comment: r4.comment || "", unixPermissions: r4.unixPermissions, dosPermissions: r4.dosPermissions }).pipe(s2);
                    })), s2.entriesCount = o2;
                  } catch (e4) {
                    s2.error(e4);
                  }
                  return s2;
                };
              }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t3, r2) {
                function n2() {
                  if (!(this instanceof n2)) return new n2();
                  if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                  this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                    var e3 = new n2();
                    for (var t4 in this) "function" != typeof this[t4] && (e3[t4] = this[t4]);
                    return e3;
                  };
                }
                (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t4) {
                  return new n2().loadAsync(e3, t4);
                }, n2.external = e2("./external"), t3.exports = n2;
              }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t3, r2) {
                var n2 = e2("./utils"), i2 = e2("./external"), s2 = e2("./utf8"), o2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
                function c2(e3) {
                  return new i2.Promise((function(t4, r3) {
                    var n3 = e3.decompressed.getContentWorker().pipe(new a2());
                    n3.on("error", (function(e4) {
                      r3(e4);
                    })).on("end", (function() {
                      n3.streamInfo.crc32 !== e3.decompressed.crc32 ? r3(new Error("Corrupted zip : CRC32 mismatch")) : t4();
                    })).resume();
                  }));
                }
                t3.exports = function(e3, t4) {
                  var r3 = this;
                  return t4 = n2.extend(t4 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: s2.utf8decode }), l2.isNode && l2.isStream(e3) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n2.prepareContent("the loaded zip file", e3, true, t4.optimizedBinaryString, t4.base64).then((function(e4) {
                    var r4 = new o2(t4);
                    return r4.load(e4), r4;
                  })).then((function(e4) {
                    var r4 = [i2.Promise.resolve(e4)], n3 = e4.files;
                    if (t4.checkCRC32) for (var s3 = 0; s3 < n3.length; s3++) r4.push(c2(n3[s3]));
                    return i2.Promise.all(r4);
                  })).then((function(e4) {
                    for (var i3 = e4.shift(), s3 = i3.files, o3 = 0; o3 < s3.length; o3++) {
                      var a3 = s3[o3], l3 = a3.fileNameStr, c3 = n2.resolve(a3.fileNameStr);
                      r3.file(c3, a3.decompressed, { binary: true, optimizedBinaryString: true, date: a3.date, dir: a3.dir, comment: a3.fileCommentStr.length ? a3.fileCommentStr : null, unixPermissions: a3.unixPermissions, dosPermissions: a3.dosPermissions, createFolders: t4.createFolders }), a3.dir || (r3.file(c3).unsafeOriginalName = l3);
                    }
                    return i3.zipComment.length && (r3.comment = i3.zipComment), r3;
                  }));
                };
              }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t3, r2) {
                var n2 = e2("../utils"), i2 = e2("../stream/GenericWorker");
                function s2(e3, t4) {
                  i2.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t4);
                }
                n2.inherits(s2, i2), s2.prototype._bindStream = function(e3) {
                  var t4 = this;
                  (this._stream = e3).pause(), e3.on("data", (function(e4) {
                    t4.push({ data: e4, meta: { percent: 0 } });
                  })).on("error", (function(e4) {
                    t4.isPaused ? this.generatedError = e4 : t4.error(e4);
                  })).on("end", (function() {
                    t4.isPaused ? t4._upstreamEnded = true : t4.end();
                  }));
                }, s2.prototype.pause = function() {
                  return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
                }, s2.prototype.resume = function() {
                  return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
                }, t3.exports = s2;
              }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t3, r2) {
                var n2 = e2("readable-stream").Readable;
                function i2(e3, t4, r3) {
                  n2.call(this, t4), this._helper = e3;
                  var i3 = this;
                  e3.on("data", (function(e4, t5) {
                    i3.push(e4) || i3._helper.pause(), r3 && r3(t5);
                  })).on("error", (function(e4) {
                    i3.emit("error", e4);
                  })).on("end", (function() {
                    i3.push(null);
                  }));
                }
                e2("../utils").inherits(i2, n2), i2.prototype._read = function() {
                  this._helper.resume();
                }, t3.exports = i2;
              }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t3, r2) {
                t3.exports = { isNode: void 0 !== s, newBufferFrom: function(e3, t4) {
                  if (s.from && s.from !== Uint8Array.from) return s.from(e3, t4);
                  if ("number" == typeof e3) throw new Error('The "data" argument must not be a number');
                  return new s(e3, t4);
                }, allocBuffer: function(e3) {
                  if (s.alloc) return s.alloc(e3);
                  var t4 = new s(e3);
                  return t4.fill(0), t4;
                }, isBuffer: function(e3) {
                  return s.isBuffer(e3);
                }, isStream: function(e3) {
                  return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
                } };
              }, {}], 15: [function(e2, t3, r2) {
                function n2(e3, t4, r3) {
                  var n3, i3 = s2.getTypeOf(t4), a3 = s2.extend(r3 || {}, l2);
                  a3.date = a3.date || /* @__PURE__ */ new Date(), null !== a3.compression && (a3.compression = a3.compression.toUpperCase()), "string" == typeof a3.unixPermissions && (a3.unixPermissions = parseInt(a3.unixPermissions, 8)), a3.unixPermissions && 16384 & a3.unixPermissions && (a3.dir = true), a3.dosPermissions && 16 & a3.dosPermissions && (a3.dir = true), a3.dir && (e3 = m(e3)), a3.createFolders && (n3 = p(e3)) && b.call(this, n3, true);
                  var h2 = "string" === i3 && false === a3.binary && false === a3.base64;
                  r3 && void 0 !== r3.binary || (a3.binary = !h2), (t4 instanceof c2 && 0 === t4.uncompressedSize || a3.dir || !t4 || 0 === t4.length) && (a3.base64 = false, a3.binary = true, t4 = "", a3.compression = "STORE", i3 = "string");
                  var g2;
                  g2 = t4 instanceof c2 || t4 instanceof o2 ? t4 : f.isNode && f.isStream(t4) ? new d(e3, t4) : s2.prepareContent(e3, t4, a3.binary, a3.optimizedBinaryString, a3.base64);
                  var y2 = new u2(e3, g2, a3);
                  this.files[e3] = y2;
                }
                var i2 = e2("./utf8"), s2 = e2("./utils"), o2 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), l2 = e2("./defaults"), c2 = e2("./compressedObject"), u2 = e2("./zipObject"), h = e2("./generate"), f = e2("./nodejsUtils"), d = e2("./nodejs/NodejsStreamInputAdapter"), p = function(e3) {
                  "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
                  var t4 = e3.lastIndexOf("/");
                  return 0 < t4 ? e3.substring(0, t4) : "";
                }, m = function(e3) {
                  return "/" !== e3.slice(-1) && (e3 += "/"), e3;
                }, b = function(e3, t4) {
                  return t4 = void 0 !== t4 ? t4 : l2.createFolders, e3 = m(e3), this.files[e3] || n2.call(this, e3, null, { dir: true, createFolders: t4 }), this.files[e3];
                };
                function g(e3) {
                  return "[object RegExp]" === Object.prototype.toString.call(e3);
                }
                var y = { load: function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, forEach: function(e3) {
                  var t4, r3, n3;
                  for (t4 in this.files) n3 = this.files[t4], (r3 = t4.slice(this.root.length, t4.length)) && t4.slice(0, this.root.length) === this.root && e3(r3, n3);
                }, filter: function(e3) {
                  var t4 = [];
                  return this.forEach((function(r3, n3) {
                    e3(r3, n3) && t4.push(n3);
                  })), t4;
                }, file: function(e3, t4, r3) {
                  if (1 !== arguments.length) return e3 = this.root + e3, n2.call(this, e3, t4, r3), this;
                  if (g(e3)) {
                    var i3 = e3;
                    return this.filter((function(e4, t5) {
                      return !t5.dir && i3.test(e4);
                    }));
                  }
                  var s3 = this.files[this.root + e3];
                  return s3 && !s3.dir ? s3 : null;
                }, folder: function(e3) {
                  if (!e3) return this;
                  if (g(e3)) return this.filter((function(t5, r4) {
                    return r4.dir && e3.test(t5);
                  }));
                  var t4 = this.root + e3, r3 = b.call(this, t4), n3 = this.clone();
                  return n3.root = r3.name, n3;
                }, remove: function(e3) {
                  e3 = this.root + e3;
                  var t4 = this.files[e3];
                  if (t4 || ("/" !== e3.slice(-1) && (e3 += "/"), t4 = this.files[e3]), t4 && !t4.dir) delete this.files[e3];
                  else for (var r3 = this.filter((function(t5, r4) {
                    return r4.name.slice(0, e3.length) === e3;
                  })), n3 = 0; n3 < r3.length; n3++) delete this.files[r3[n3].name];
                  return this;
                }, generate: function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, generateInternalStream: function(e3) {
                  var t4, r3 = {};
                  try {
                    if ((r3 = s2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type) throw new Error("No output type specified.");
                    s2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
                    var n3 = r3.comment || this.comment || "";
                    t4 = h.generateWorker(this, r3, n3);
                  } catch (e4) {
                    (t4 = new o2("error")).error(e4);
                  }
                  return new a2(t4, r3.type || "string", r3.mimeType);
                }, generateAsync: function(e3, t4) {
                  return this.generateInternalStream(e3).accumulate(t4);
                }, generateNodeStream: function(e3, t4) {
                  return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t4);
                } };
                t3.exports = y;
              }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t3, r2) {
                t3.exports = e2("stream");
              }, { stream: void 0 }], 17: [function(e2, t3, r2) {
                var n2 = e2("./DataReader");
                function i2(e3) {
                  n2.call(this, e3);
                  for (var t4 = 0; t4 < this.data.length; t4++) e3[t4] = 255 & e3[t4];
                }
                e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
                  return this.data[this.zero + e3];
                }, i2.prototype.lastIndexOfSignature = function(e3) {
                  for (var t4 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2) if (this.data[s2] === t4 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i3) return s2 - this.zero;
                  return -1;
                }, i2.prototype.readAndCheckSignature = function(e3) {
                  var t4 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.readData(4);
                  return t4 === s2[0] && r3 === s2[1] && n3 === s2[2] && i3 === s2[3];
                }, i2.prototype.readData = function(e3) {
                  if (this.checkOffset(e3), 0 === e3) return [];
                  var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
                  return this.index += e3, t4;
                }, t3.exports = i2;
              }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t3, r2) {
                var n2 = e2("../utils");
                function i2(e3) {
                  this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
                }
                i2.prototype = { checkOffset: function(e3) {
                  this.checkIndex(this.index + e3);
                }, checkIndex: function(e3) {
                  if (this.length < this.zero + e3 || e3 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
                }, setIndex: function(e3) {
                  this.checkIndex(e3), this.index = e3;
                }, skip: function(e3) {
                  this.setIndex(this.index + e3);
                }, byteAt: function() {
                }, readInt: function(e3) {
                  var t4, r3 = 0;
                  for (this.checkOffset(e3), t4 = this.index + e3 - 1; t4 >= this.index; t4--) r3 = (r3 << 8) + this.byteAt(t4);
                  return this.index += e3, r3;
                }, readString: function(e3) {
                  return n2.transformTo("string", this.readData(e3));
                }, readData: function() {
                }, lastIndexOfSignature: function() {
                }, readAndCheckSignature: function() {
                }, readDate: function() {
                  var e3 = this.readInt(4);
                  return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
                } }, t3.exports = i2;
              }, { "../utils": 32 }], 19: [function(e2, t3, r2) {
                var n2 = e2("./Uint8ArrayReader");
                function i2(e3) {
                  n2.call(this, e3);
                }
                e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
                  this.checkOffset(e3);
                  var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
                  return this.index += e3, t4;
                }, t3.exports = i2;
              }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t3, r2) {
                var n2 = e2("./DataReader");
                function i2(e3) {
                  n2.call(this, e3);
                }
                e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
                  return this.data.charCodeAt(this.zero + e3);
                }, i2.prototype.lastIndexOfSignature = function(e3) {
                  return this.data.lastIndexOf(e3) - this.zero;
                }, i2.prototype.readAndCheckSignature = function(e3) {
                  return e3 === this.readData(4);
                }, i2.prototype.readData = function(e3) {
                  this.checkOffset(e3);
                  var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
                  return this.index += e3, t4;
                }, t3.exports = i2;
              }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t3, r2) {
                var n2 = e2("./ArrayReader");
                function i2(e3) {
                  n2.call(this, e3);
                }
                e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
                  if (this.checkOffset(e3), 0 === e3) return new Uint8Array(0);
                  var t4 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
                  return this.index += e3, t4;
                }, t3.exports = i2;
              }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t3, r2) {
                var n2 = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), o2 = e2("./StringReader"), a2 = e2("./NodeBufferReader"), l2 = e2("./Uint8ArrayReader");
                t3.exports = function(e3) {
                  var t4 = n2.getTypeOf(e3);
                  return n2.checkSupport(t4), "string" !== t4 || i2.uint8array ? "nodebuffer" === t4 ? new a2(e3) : i2.uint8array ? new l2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new o2(e3);
                };
              }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t3, r2) {
                r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
              }, {}], 24: [function(e2, t3, r2) {
                var n2 = e2("./GenericWorker"), i2 = e2("../utils");
                function s2(e3) {
                  n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
                }
                i2.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
                  this.push({ data: i2.transformTo(this.destType, e3.data), meta: e3.meta });
                }, t3.exports = s2;
              }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t3, r2) {
                var n2 = e2("./GenericWorker"), i2 = e2("../crc32");
                function s2() {
                  n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                }
                e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
                  this.streamInfo.crc32 = i2(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
                }, t3.exports = s2;
              }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t3, r2) {
                var n2 = e2("../utils"), i2 = e2("./GenericWorker");
                function s2(e3) {
                  i2.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
                }
                n2.inherits(s2, i2), s2.prototype.processChunk = function(e3) {
                  if (e3) {
                    var t4 = this.streamInfo[this.propName] || 0;
                    this.streamInfo[this.propName] = t4 + e3.data.length;
                  }
                  i2.prototype.processChunk.call(this, e3);
                }, t3.exports = s2;
              }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t3, r2) {
                var n2 = e2("../utils"), i2 = e2("./GenericWorker");
                function s2(e3) {
                  i2.call(this, "DataWorker");
                  var t4 = this;
                  this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then((function(e4) {
                    t4.dataIsReady = true, t4.data = e4, t4.max = e4 && e4.length || 0, t4.type = n2.getTypeOf(e4), t4.isPaused || t4._tickAndRepeat();
                  }), (function(e4) {
                    t4.error(e4);
                  }));
                }
                n2.inherits(s2, i2), s2.prototype.cleanUp = function() {
                  i2.prototype.cleanUp.call(this), this.data = null;
                }, s2.prototype.resume = function() {
                  return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
                }, s2.prototype._tickAndRepeat = function() {
                  this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
                }, s2.prototype._tick = function() {
                  if (this.isPaused || this.isFinished) return false;
                  var e3 = null, t4 = Math.min(this.max, this.index + 16384);
                  if (this.index >= this.max) return this.end();
                  switch (this.type) {
                    case "string":
                      e3 = this.data.substring(this.index, t4);
                      break;
                    case "uint8array":
                      e3 = this.data.subarray(this.index, t4);
                      break;
                    case "array":
                    case "nodebuffer":
                      e3 = this.data.slice(this.index, t4);
                  }
                  return this.index = t4, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
                }, t3.exports = s2;
              }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t3, r2) {
                function n2(e3) {
                  this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
                }
                n2.prototype = { push: function(e3) {
                  this.emit("data", e3);
                }, end: function() {
                  if (this.isFinished) return false;
                  this.flush();
                  try {
                    this.emit("end"), this.cleanUp(), this.isFinished = true;
                  } catch (e3) {
                    this.emit("error", e3);
                  }
                  return true;
                }, error: function(e3) {
                  return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
                }, on: function(e3, t4) {
                  return this._listeners[e3].push(t4), this;
                }, cleanUp: function() {
                  this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                }, emit: function(e3, t4) {
                  if (this._listeners[e3]) for (var r3 = 0; r3 < this._listeners[e3].length; r3++) this._listeners[e3][r3].call(this, t4);
                }, pipe: function(e3) {
                  return e3.registerPrevious(this);
                }, registerPrevious: function(e3) {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                  this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
                  var t4 = this;
                  return e3.on("data", (function(e4) {
                    t4.processChunk(e4);
                  })), e3.on("end", (function() {
                    t4.end();
                  })), e3.on("error", (function(e4) {
                    t4.error(e4);
                  })), this;
                }, pause: function() {
                  return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
                }, resume: function() {
                  if (!this.isPaused || this.isFinished) return false;
                  var e3 = this.isPaused = false;
                  return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
                }, flush: function() {
                }, processChunk: function(e3) {
                  this.push(e3);
                }, withStreamInfo: function(e3, t4) {
                  return this.extraStreamInfo[e3] = t4, this.mergeStreamInfo(), this;
                }, mergeStreamInfo: function() {
                  for (var e3 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
                }, lock: function() {
                  if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                  this.isLocked = true, this.previous && this.previous.lock();
                }, toString: function() {
                  var e3 = "Worker " + this.name;
                  return this.previous ? this.previous + " -> " + e3 : e3;
                } }, t3.exports = n2;
              }, {}], 29: [function(e2, t3, r2) {
                var n2 = e2("../utils"), i2 = e2("./ConvertWorker"), o2 = e2("./GenericWorker"), a2 = e2("../base64"), l2 = e2("../support"), c2 = e2("../external"), u2 = null;
                if (l2.nodestream) try {
                  u2 = e2("../nodejs/NodejsStreamOutputAdapter");
                } catch (e3) {
                }
                function h(e3, t4, r3) {
                  var s2 = t4;
                  switch (t4) {
                    case "blob":
                    case "arraybuffer":
                      s2 = "uint8array";
                      break;
                    case "base64":
                      s2 = "string";
                  }
                  try {
                    this._internalType = s2, this._outputType = t4, this._mimeType = r3, n2.checkSupport(s2), this._worker = e3.pipe(new i2(s2)), e3.lock();
                  } catch (e4) {
                    this._worker = new o2("error"), this._worker.error(e4);
                  }
                }
                h.prototype = { accumulate: function(e3) {
                  return (function(e4, t4) {
                    return new c2.Promise((function(r3, i3) {
                      var o3 = [], l3 = e4._internalType, c3 = e4._outputType, u3 = e4._mimeType;
                      e4.on("data", (function(e5, r4) {
                        o3.push(e5), t4 && t4(r4);
                      })).on("error", (function(e5) {
                        o3 = [], i3(e5);
                      })).on("end", (function() {
                        try {
                          var e5 = (function(e6, t5, r4) {
                            switch (e6) {
                              case "blob":
                                return n2.newBlob(n2.transformTo("arraybuffer", t5), r4);
                              case "base64":
                                return a2.encode(t5);
                              default:
                                return n2.transformTo(e6, t5);
                            }
                          })(c3, (function(e6, t5) {
                            var r4, n3 = 0, i4 = null, o4 = 0;
                            for (r4 = 0; r4 < t5.length; r4++) o4 += t5[r4].length;
                            switch (e6) {
                              case "string":
                                return t5.join("");
                              case "array":
                                return Array.prototype.concat.apply([], t5);
                              case "uint8array":
                                for (i4 = new Uint8Array(o4), r4 = 0; r4 < t5.length; r4++) i4.set(t5[r4], n3), n3 += t5[r4].length;
                                return i4;
                              case "nodebuffer":
                                return s.concat(t5);
                              default:
                                throw new Error("concat : unsupported type '" + e6 + "'");
                            }
                          })(l3, o3), u3);
                          r3(e5);
                        } catch (e6) {
                          i3(e6);
                        }
                        o3 = [];
                      })).resume();
                    }));
                  })(this, e3);
                }, on: function(e3, t4) {
                  var r3 = this;
                  return "data" === e3 ? this._worker.on(e3, (function(e4) {
                    t4.call(r3, e4.data, e4.meta);
                  })) : this._worker.on(e3, (function() {
                    n2.delay(t4, arguments, r3);
                  })), this;
                }, resume: function() {
                  return n2.delay(this._worker.resume, [], this._worker), this;
                }, pause: function() {
                  return this._worker.pause(), this;
                }, toNodejsStream: function(e3) {
                  if (n2.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
                  return new u2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
                } }, t3.exports = h;
              }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t3, r2) {
                if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = void 0 !== s, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r2.blob = false;
                else {
                  var n2 = new ArrayBuffer(0);
                  try {
                    r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
                  } catch (e3) {
                    try {
                      var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                      i2.append(n2), r2.blob = 0 === i2.getBlob("application/zip").size;
                    } catch (e4) {
                      r2.blob = false;
                    }
                  }
                }
                try {
                  r2.nodestream = !!e2("readable-stream").Readable;
                } catch (e3) {
                  r2.nodestream = false;
                }
              }, { "readable-stream": 16 }], 31: [function(e2, t3, r2) {
                for (var n2 = e2("./utils"), i2 = e2("./support"), s2 = e2("./nodejsUtils"), o2 = e2("./stream/GenericWorker"), a2 = new Array(256), l2 = 0; l2 < 256; l2++) a2[l2] = 252 <= l2 ? 6 : 248 <= l2 ? 5 : 240 <= l2 ? 4 : 224 <= l2 ? 3 : 192 <= l2 ? 2 : 1;
                function c2() {
                  o2.call(this, "utf-8 decode"), this.leftOver = null;
                }
                function u2() {
                  o2.call(this, "utf-8 encode");
                }
                a2[254] = a2[254] = 1, r2.utf8encode = function(e3) {
                  return i2.nodebuffer ? s2.newBufferFrom(e3, "utf-8") : (function(e4) {
                    var t4, r3, n3, s3, o3, a3 = e4.length, l3 = 0;
                    for (s3 = 0; s3 < a3; s3++) 55296 == (64512 & (r3 = e4.charCodeAt(s3))) && s3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(s3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), s3++), l3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
                    for (t4 = i2.uint8array ? new Uint8Array(l3) : new Array(l3), s3 = o3 = 0; o3 < l3; s3++) 55296 == (64512 & (r3 = e4.charCodeAt(s3))) && s3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(s3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), s3++), r3 < 128 ? t4[o3++] = r3 : (r3 < 2048 ? t4[o3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t4[o3++] = 224 | r3 >>> 12 : (t4[o3++] = 240 | r3 >>> 18, t4[o3++] = 128 | r3 >>> 12 & 63), t4[o3++] = 128 | r3 >>> 6 & 63), t4[o3++] = 128 | 63 & r3);
                    return t4;
                  })(e3);
                }, r2.utf8decode = function(e3) {
                  return i2.nodebuffer ? n2.transformTo("nodebuffer", e3).toString("utf-8") : (function(e4) {
                    var t4, r3, i3, s3, o3 = e4.length, l3 = new Array(2 * o3);
                    for (t4 = r3 = 0; t4 < o3; ) if ((i3 = e4[t4++]) < 128) l3[r3++] = i3;
                    else if (4 < (s3 = a2[i3])) l3[r3++] = 65533, t4 += s3 - 1;
                    else {
                      for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && t4 < o3; ) i3 = i3 << 6 | 63 & e4[t4++], s3--;
                      1 < s3 ? l3[r3++] = 65533 : i3 < 65536 ? l3[r3++] = i3 : (i3 -= 65536, l3[r3++] = 55296 | i3 >> 10 & 1023, l3[r3++] = 56320 | 1023 & i3);
                    }
                    return l3.length !== r3 && (l3.subarray ? l3 = l3.subarray(0, r3) : l3.length = r3), n2.applyFromCharCode(l3);
                  })(e3 = n2.transformTo(i2.uint8array ? "uint8array" : "array", e3));
                }, n2.inherits(c2, o2), c2.prototype.processChunk = function(e3) {
                  var t4 = n2.transformTo(i2.uint8array ? "uint8array" : "array", e3.data);
                  if (this.leftOver && this.leftOver.length) {
                    if (i2.uint8array) {
                      var s3 = t4;
                      (t4 = new Uint8Array(s3.length + this.leftOver.length)).set(this.leftOver, 0), t4.set(s3, this.leftOver.length);
                    } else t4 = this.leftOver.concat(t4);
                    this.leftOver = null;
                  }
                  var o3 = (function(e4, t5) {
                    var r3;
                    for ((t5 = t5 || e4.length) > e4.length && (t5 = e4.length), r3 = t5 - 1; 0 <= r3 && 128 == (192 & e4[r3]); ) r3--;
                    return r3 < 0 || 0 === r3 ? t5 : r3 + a2[e4[r3]] > t5 ? r3 : t5;
                  })(t4), l3 = t4;
                  o3 !== t4.length && (i2.uint8array ? (l3 = t4.subarray(0, o3), this.leftOver = t4.subarray(o3, t4.length)) : (l3 = t4.slice(0, o3), this.leftOver = t4.slice(o3, t4.length))), this.push({ data: r2.utf8decode(l3), meta: e3.meta });
                }, c2.prototype.flush = function() {
                  this.leftOver && this.leftOver.length && (this.push({ data: r2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
                }, r2.Utf8DecodeWorker = c2, n2.inherits(u2, o2), u2.prototype.processChunk = function(e3) {
                  this.push({ data: r2.utf8encode(e3.data), meta: e3.meta });
                }, r2.Utf8EncodeWorker = u2;
              }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t3, r2) {
                var n2 = e2("./support"), i2 = e2("./base64"), s2 = e2("./nodejsUtils"), o2 = e2("./external");
                function a2(e3) {
                  return e3;
                }
                function l2(e3, t4) {
                  for (var r3 = 0; r3 < e3.length; ++r3) t4[r3] = 255 & e3.charCodeAt(r3);
                  return t4;
                }
                e2("setimmediate"), r2.newBlob = function(e3, t4) {
                  r2.checkSupport("blob");
                  try {
                    return new Blob([e3], { type: t4 });
                  } catch (r3) {
                    try {
                      var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                      return n3.append(e3), n3.getBlob(t4);
                    } catch (e4) {
                      throw new Error("Bug : can't construct the Blob.");
                    }
                  }
                };
                var c2 = { stringifyByChunk: function(e3, t4, r3) {
                  var n3 = [], i3 = 0, s3 = e3.length;
                  if (s3 <= r3) return String.fromCharCode.apply(null, e3);
                  for (; i3 < s3; ) "array" === t4 || "nodebuffer" === t4 ? n3.push(String.fromCharCode.apply(null, e3.slice(i3, Math.min(i3 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i3, Math.min(i3 + r3, s3)))), i3 += r3;
                  return n3.join("");
                }, stringifyByChar: function(e3) {
                  for (var t4 = "", r3 = 0; r3 < e3.length; r3++) t4 += String.fromCharCode(e3[r3]);
                  return t4;
                }, applyCanBeUsed: { uint8array: (function() {
                  try {
                    return n2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                  } catch (e3) {
                    return false;
                  }
                })(), nodebuffer: (function() {
                  try {
                    return n2.nodebuffer && 1 === String.fromCharCode.apply(null, s2.allocBuffer(1)).length;
                  } catch (e3) {
                    return false;
                  }
                })() } };
                function h(e3) {
                  var t4 = 65536, n3 = r2.getTypeOf(e3), i3 = true;
                  if ("uint8array" === n3 ? i3 = c2.applyCanBeUsed.uint8array : "nodebuffer" === n3 && (i3 = c2.applyCanBeUsed.nodebuffer), i3) for (; 1 < t4; ) try {
                    return c2.stringifyByChunk(e3, n3, t4);
                  } catch (e4) {
                    t4 = Math.floor(t4 / 2);
                  }
                  return c2.stringifyByChar(e3);
                }
                function f(e3, t4) {
                  for (var r3 = 0; r3 < e3.length; r3++) t4[r3] = e3[r3];
                  return t4;
                }
                r2.applyFromCharCode = h;
                var d = {};
                d.string = { string: a2, array: function(e3) {
                  return l2(e3, new Array(e3.length));
                }, arraybuffer: function(e3) {
                  return d.string.uint8array(e3).buffer;
                }, uint8array: function(e3) {
                  return l2(e3, new Uint8Array(e3.length));
                }, nodebuffer: function(e3) {
                  return l2(e3, s2.allocBuffer(e3.length));
                } }, d.array = { string: h, array: a2, arraybuffer: function(e3) {
                  return new Uint8Array(e3).buffer;
                }, uint8array: function(e3) {
                  return new Uint8Array(e3);
                }, nodebuffer: function(e3) {
                  return s2.newBufferFrom(e3);
                } }, d.arraybuffer = { string: function(e3) {
                  return h(new Uint8Array(e3));
                }, array: function(e3) {
                  return f(new Uint8Array(e3), new Array(e3.byteLength));
                }, arraybuffer: a2, uint8array: function(e3) {
                  return new Uint8Array(e3);
                }, nodebuffer: function(e3) {
                  return s2.newBufferFrom(new Uint8Array(e3));
                } }, d.uint8array = { string: h, array: function(e3) {
                  return f(e3, new Array(e3.length));
                }, arraybuffer: function(e3) {
                  return e3.buffer;
                }, uint8array: a2, nodebuffer: function(e3) {
                  return s2.newBufferFrom(e3);
                } }, d.nodebuffer = { string: h, array: function(e3) {
                  return f(e3, new Array(e3.length));
                }, arraybuffer: function(e3) {
                  return d.nodebuffer.uint8array(e3).buffer;
                }, uint8array: function(e3) {
                  return f(e3, new Uint8Array(e3.length));
                }, nodebuffer: a2 }, r2.transformTo = function(e3, t4) {
                  if (t4 = t4 || "", !e3) return t4;
                  r2.checkSupport(e3);
                  var n3 = r2.getTypeOf(t4);
                  return d[n3][e3](t4);
                }, r2.resolve = function(e3) {
                  for (var t4 = e3.split("/"), r3 = [], n3 = 0; n3 < t4.length; n3++) {
                    var i3 = t4[n3];
                    "." === i3 || "" === i3 && 0 !== n3 && n3 !== t4.length - 1 || (".." === i3 ? r3.pop() : r3.push(i3));
                  }
                  return r3.join("/");
                }, r2.getTypeOf = function(e3) {
                  return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : n2.nodebuffer && s2.isBuffer(e3) ? "nodebuffer" : n2.uint8array && e3 instanceof Uint8Array ? "uint8array" : n2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
                }, r2.checkSupport = function(e3) {
                  if (!n2[e3.toLowerCase()]) throw new Error(e3 + " is not supported by this platform");
                }, r2.MAX_VALUE_16BITS = 65535, r2.MAX_VALUE_32BITS = -1, r2.pretty = function(e3) {
                  var t4, r3, n3 = "";
                  for (r3 = 0; r3 < (e3 || "").length; r3++) n3 += "\\x" + ((t4 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t4.toString(16).toUpperCase();
                  return n3;
                }, r2.delay = function(e3, t4, r3) {
                  u((function() {
                    e3.apply(r3 || null, t4 || []);
                  }));
                }, r2.inherits = function(e3, t4) {
                  function r3() {
                  }
                  r3.prototype = t4.prototype, e3.prototype = new r3();
                }, r2.extend = function() {
                  var e3, t4, r3 = {};
                  for (e3 = 0; e3 < arguments.length; e3++) for (t4 in arguments[e3]) Object.prototype.hasOwnProperty.call(arguments[e3], t4) && void 0 === r3[t4] && (r3[t4] = arguments[e3][t4]);
                  return r3;
                }, r2.prepareContent = function(e3, t4, s3, a3, c3) {
                  return o2.Promise.resolve(t4).then((function(e4) {
                    return n2.blob && (e4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(e4))) && "undefined" != typeof FileReader ? new o2.Promise((function(t5, r3) {
                      var n3 = new FileReader();
                      n3.onload = function(e5) {
                        t5(e5.target.result);
                      }, n3.onerror = function(e5) {
                        r3(e5.target.error);
                      }, n3.readAsArrayBuffer(e4);
                    })) : e4;
                  })).then((function(t5) {
                    var u2 = r2.getTypeOf(t5);
                    return u2 ? ("arraybuffer" === u2 ? t5 = r2.transformTo("uint8array", t5) : "string" === u2 && (c3 ? t5 = i2.decode(t5) : s3 && true !== a3 && (t5 = (function(e4) {
                      return l2(e4, n2.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
                    })(t5))), t5) : o2.Promise.reject(new Error("Can't read the data of '" + e3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                  }));
                };
              }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t3, r2) {
                var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), o2 = e2("./zipEntry"), a2 = e2("./support");
                function l2(e3) {
                  this.files = [], this.loadOptions = e3;
                }
                l2.prototype = { checkSignature: function(e3) {
                  if (!this.reader.readAndCheckSignature(e3)) {
                    this.reader.index -= 4;
                    var t4 = this.reader.readString(4);
                    throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t4) + ", expected " + i2.pretty(e3) + ")");
                  }
                }, isSignature: function(e3, t4) {
                  var r3 = this.reader.index;
                  this.reader.setIndex(e3);
                  var n3 = this.reader.readString(4) === t4;
                  return this.reader.setIndex(r3), n3;
                }, readBlockEndOfCentral: function() {
                  this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                  var e3 = this.reader.readData(this.zipCommentLength), t4 = a2.uint8array ? "uint8array" : "array", r3 = i2.transformTo(t4, e3);
                  this.zipComment = this.loadOptions.decodeFileName(r3);
                }, readBlockZip64EndOfCentral: function() {
                  this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                  for (var e3, t4, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; ) e3 = this.reader.readInt(2), t4 = this.reader.readInt(4), r3 = this.reader.readData(t4), this.zip64ExtensibleData[e3] = { id: e3, length: t4, value: r3 };
                }, readBlockZip64EndOfCentralLocator: function() {
                  if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                }, readLocalFiles: function() {
                  var e3, t4;
                  for (e3 = 0; e3 < this.files.length; e3++) t4 = this.files[e3], this.reader.setIndex(t4.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t4.readLocalPart(this.reader), t4.handleUTF8(), t4.processAttributes();
                }, readCentralDir: function() {
                  var e3;
                  for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); ) (e3 = new o2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
                  if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                }, readEndOfCentral: function() {
                  var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
                  if (e3 < 0) throw this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                  this.reader.setIndex(e3);
                  var t4 = e3;
                  if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
                    if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                    if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                  }
                  var r3 = this.centralDirOffset + this.centralDirSize;
                  this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
                  var n3 = t4 - r3;
                  if (0 < n3) this.isSignature(t4, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
                  else if (n3 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
                }, prepareReader: function(e3) {
                  this.reader = n2(e3);
                }, load: function(e3) {
                  this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                } }, t3.exports = l2;
              }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t3, r2) {
                var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./compressedObject"), o2 = e2("./crc32"), a2 = e2("./utf8"), l2 = e2("./compressions"), c2 = e2("./support");
                function u2(e3, t4) {
                  this.options = e3, this.loadOptions = t4;
                }
                u2.prototype = { isEncrypted: function() {
                  return 1 == (1 & this.bitFlag);
                }, useUTF8: function() {
                  return 2048 == (2048 & this.bitFlag);
                }, readLocalPart: function(e3) {
                  var t4, r3;
                  if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                  if (null === (t4 = (function(e4) {
                    for (var t5 in l2) if (Object.prototype.hasOwnProperty.call(l2, t5) && l2[t5].magic === e4) return l2[t5];
                    return null;
                  })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + i2.pretty(this.compressionMethod) + " unknown (inner file : " + i2.transformTo("string", this.fileName) + ")");
                  this.decompressed = new s2(this.compressedSize, this.uncompressedSize, this.crc32, t4, e3.readData(this.compressedSize));
                }, readCentralPart: function(e3) {
                  this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
                  var t4 = e3.readInt(2);
                  if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                  e3.skip(t4), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
                }, processAttributes: function() {
                  this.unixPermissions = null, this.dosPermissions = null;
                  var e3 = this.versionMadeBy >> 8;
                  this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
                }, parseZIP64ExtraField: function() {
                  if (this.extraFields[1]) {
                    var e3 = n2(this.extraFields[1].value);
                    this.uncompressedSize === i2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === i2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === i2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === i2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
                  }
                }, readExtraFields: function(e3) {
                  var t4, r3, n3, i3 = e3.index + this.extraFieldsLength;
                  for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i3; ) t4 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t4] = { id: t4, length: r3, value: n3 };
                  e3.setIndex(i3);
                }, handleUTF8: function() {
                  var e3 = c2.uint8array ? "uint8array" : "array";
                  if (this.useUTF8()) this.fileNameStr = a2.utf8decode(this.fileName), this.fileCommentStr = a2.utf8decode(this.fileComment);
                  else {
                    var t4 = this.findExtraFieldUnicodePath();
                    if (null !== t4) this.fileNameStr = t4;
                    else {
                      var r3 = i2.transformTo(e3, this.fileName);
                      this.fileNameStr = this.loadOptions.decodeFileName(r3);
                    }
                    var n3 = this.findExtraFieldUnicodeComment();
                    if (null !== n3) this.fileCommentStr = n3;
                    else {
                      var s3 = i2.transformTo(e3, this.fileComment);
                      this.fileCommentStr = this.loadOptions.decodeFileName(s3);
                    }
                  }
                }, findExtraFieldUnicodePath: function() {
                  var e3 = this.extraFields[28789];
                  if (e3) {
                    var t4 = n2(e3.value);
                    return 1 !== t4.readInt(1) || o2(this.fileName) !== t4.readInt(4) ? null : a2.utf8decode(t4.readData(e3.length - 5));
                  }
                  return null;
                }, findExtraFieldUnicodeComment: function() {
                  var e3 = this.extraFields[25461];
                  if (e3) {
                    var t4 = n2(e3.value);
                    return 1 !== t4.readInt(1) || o2(this.fileComment) !== t4.readInt(4) ? null : a2.utf8decode(t4.readData(e3.length - 5));
                  }
                  return null;
                } }, t3.exports = u2;
              }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t3, r2) {
                function n2(e3, t4, r3) {
                  this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t4, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
                }
                var i2 = e2("./stream/StreamHelper"), s2 = e2("./stream/DataWorker"), o2 = e2("./utf8"), a2 = e2("./compressedObject"), l2 = e2("./stream/GenericWorker");
                n2.prototype = { internalStream: function(e3) {
                  var t4 = null, r3 = "string";
                  try {
                    if (!e3) throw new Error("No output type specified.");
                    var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
                    "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t4 = this._decompressWorker();
                    var s3 = !this._dataBinary;
                    s3 && !n3 && (t4 = t4.pipe(new o2.Utf8EncodeWorker())), !s3 && n3 && (t4 = t4.pipe(new o2.Utf8DecodeWorker()));
                  } catch (e4) {
                    (t4 = new l2("error")).error(e4);
                  }
                  return new i2(t4, r3, "");
                }, async: function(e3, t4) {
                  return this.internalStream(e3).accumulate(t4);
                }, nodeStream: function(e3, t4) {
                  return this.internalStream(e3 || "nodebuffer").toNodejsStream(t4);
                }, _compressWorker: function(e3, t4) {
                  if (this._data instanceof a2 && this._data.compression.magic === e3.magic) return this._data.getCompressedWorker();
                  var r3 = this._decompressWorker();
                  return this._dataBinary || (r3 = r3.pipe(new o2.Utf8EncodeWorker())), a2.createWorkerFrom(r3, e3, t4);
                }, _decompressWorker: function() {
                  return this._data instanceof a2 ? this._data.getContentWorker() : this._data instanceof l2 ? this._data : new s2(this._data);
                } };
                for (var c2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u2 = function() {
                  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, h = 0; h < c2.length; h++) n2.prototype[c2[h]] = u2;
                t3.exports = n2;
              }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, t3, r2) {
                (function(e3) {
                  var r3, n2, i2 = e3.MutationObserver || e3.WebKitMutationObserver;
                  if (i2) {
                    var s2 = 0, o2 = new i2(u2), a2 = e3.document.createTextNode("");
                    o2.observe(a2, { characterData: true }), r3 = function() {
                      a2.data = s2 = ++s2 % 2;
                    };
                  } else if (e3.setImmediate || void 0 === e3.MessageChannel) r3 = "document" in e3 && "onreadystatechange" in e3.document.createElement("script") ? function() {
                    var t4 = e3.document.createElement("script");
                    t4.onreadystatechange = function() {
                      u2(), t4.onreadystatechange = null, t4.parentNode.removeChild(t4), t4 = null;
                    }, e3.document.documentElement.appendChild(t4);
                  } : function() {
                    setTimeout(u2, 0);
                  };
                  else {
                    var l2 = new e3.MessageChannel();
                    l2.port1.onmessage = u2, r3 = function() {
                      l2.port2.postMessage(0);
                    };
                  }
                  var c2 = [];
                  function u2() {
                    var e4, t4;
                    n2 = true;
                    for (var r4 = c2.length; r4; ) {
                      for (t4 = c2, c2 = [], e4 = -1; ++e4 < r4; ) t4[e4]();
                      r4 = c2.length;
                    }
                    n2 = false;
                  }
                  t3.exports = function(e4) {
                    1 !== c2.push(e4) || n2 || r3();
                  };
                }).call(this, void 0 !== i ? i : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
              }, {}], 37: [function(e2, t3, r2) {
                var n2 = e2("immediate");
                function i2() {
                }
                var s2 = {}, o2 = ["REJECTED"], a2 = ["FULFILLED"], l2 = ["PENDING"];
                function c2(e3) {
                  if ("function" != typeof e3) throw new TypeError("resolver must be a function");
                  this.state = l2, this.queue = [], this.outcome = void 0, e3 !== i2 && d(this, e3);
                }
                function u2(e3, t4, r3) {
                  this.promise = e3, "function" == typeof t4 && (this.onFulfilled = t4, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
                }
                function h(e3, t4, r3) {
                  n2((function() {
                    var n3;
                    try {
                      n3 = t4(r3);
                    } catch (n4) {
                      return s2.reject(e3, n4);
                    }
                    n3 === e3 ? s2.reject(e3, new TypeError("Cannot resolve promise with itself")) : s2.resolve(e3, n3);
                  }));
                }
                function f(e3) {
                  var t4 = e3 && e3.then;
                  if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t4) return function() {
                    t4.apply(e3, arguments);
                  };
                }
                function d(e3, t4) {
                  var r3 = false;
                  function n3(t5) {
                    r3 || (r3 = true, s2.reject(e3, t5));
                  }
                  function i3(t5) {
                    r3 || (r3 = true, s2.resolve(e3, t5));
                  }
                  var o3 = p((function() {
                    t4(i3, n3);
                  }));
                  "error" === o3.status && n3(o3.value);
                }
                function p(e3, t4) {
                  var r3 = {};
                  try {
                    r3.value = e3(t4), r3.status = "success";
                  } catch (e4) {
                    r3.status = "error", r3.value = e4;
                  }
                  return r3;
                }
                (t3.exports = c2).prototype.finally = function(e3) {
                  if ("function" != typeof e3) return this;
                  var t4 = this.constructor;
                  return this.then((function(r3) {
                    return t4.resolve(e3()).then((function() {
                      return r3;
                    }));
                  }), (function(r3) {
                    return t4.resolve(e3()).then((function() {
                      throw r3;
                    }));
                  }));
                }, c2.prototype.catch = function(e3) {
                  return this.then(null, e3);
                }, c2.prototype.then = function(e3, t4) {
                  if ("function" != typeof e3 && this.state === a2 || "function" != typeof t4 && this.state === o2) return this;
                  var r3 = new this.constructor(i2);
                  return this.state !== l2 ? h(r3, this.state === a2 ? e3 : t4, this.outcome) : this.queue.push(new u2(r3, e3, t4)), r3;
                }, u2.prototype.callFulfilled = function(e3) {
                  s2.resolve(this.promise, e3);
                }, u2.prototype.otherCallFulfilled = function(e3) {
                  h(this.promise, this.onFulfilled, e3);
                }, u2.prototype.callRejected = function(e3) {
                  s2.reject(this.promise, e3);
                }, u2.prototype.otherCallRejected = function(e3) {
                  h(this.promise, this.onRejected, e3);
                }, s2.resolve = function(e3, t4) {
                  var r3 = p(f, t4);
                  if ("error" === r3.status) return s2.reject(e3, r3.value);
                  var n3 = r3.value;
                  if (n3) d(e3, n3);
                  else {
                    e3.state = a2, e3.outcome = t4;
                    for (var i3 = -1, o3 = e3.queue.length; ++i3 < o3; ) e3.queue[i3].callFulfilled(t4);
                  }
                  return e3;
                }, s2.reject = function(e3, t4) {
                  e3.state = o2, e3.outcome = t4;
                  for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; ) e3.queue[r3].callRejected(t4);
                  return e3;
                }, c2.resolve = function(e3) {
                  return e3 instanceof this ? e3 : s2.resolve(new this(i2), e3);
                }, c2.reject = function(e3) {
                  var t4 = new this(i2);
                  return s2.reject(t4, e3);
                }, c2.all = function(e3) {
                  var t4 = this;
                  if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
                  var r3 = e3.length, n3 = false;
                  if (!r3) return this.resolve([]);
                  for (var o3 = new Array(r3), a3 = 0, l3 = -1, c3 = new this(i2); ++l3 < r3; ) u3(e3[l3], l3);
                  return c3;
                  function u3(e4, i3) {
                    t4.resolve(e4).then((function(e5) {
                      o3[i3] = e5, ++a3 !== r3 || n3 || (n3 = true, s2.resolve(c3, o3));
                    }), (function(e5) {
                      n3 || (n3 = true, s2.reject(c3, e5));
                    }));
                  }
                }, c2.race = function(e3) {
                  if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
                  var t4 = e3.length, r3 = false;
                  if (!t4) return this.resolve([]);
                  for (var n3, o3 = -1, a3 = new this(i2); ++o3 < t4; ) n3 = e3[o3], this.resolve(n3).then((function(e4) {
                    r3 || (r3 = true, s2.resolve(a3, e4));
                  }), (function(e4) {
                    r3 || (r3 = true, s2.reject(a3, e4));
                  }));
                  return a3;
                };
              }, { immediate: 36 }], 38: [function(e2, t3, r2) {
                var n2 = {};
                (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t3.exports = n2;
              }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t3, r2) {
                var n2 = e2("./zlib/deflate"), i2 = e2("./utils/common"), s2 = e2("./utils/strings"), o2 = e2("./zlib/messages"), a2 = e2("./zlib/zstream"), l2 = Object.prototype.toString;
                function c2(e3) {
                  if (!(this instanceof c2)) return new c2(e3);
                  this.options = i2.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, e3 || {});
                  var t4 = this.options;
                  t4.raw && 0 < t4.windowBits ? t4.windowBits = -t4.windowBits : t4.gzip && 0 < t4.windowBits && t4.windowBits < 16 && (t4.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new a2(), this.strm.avail_out = 0;
                  var r3 = n2.deflateInit2(this.strm, t4.level, t4.method, t4.windowBits, t4.memLevel, t4.strategy);
                  if (0 !== r3) throw new Error(o2[r3]);
                  if (t4.header && n2.deflateSetHeader(this.strm, t4.header), t4.dictionary) {
                    var u3;
                    if (u3 = "string" == typeof t4.dictionary ? s2.string2buf(t4.dictionary) : "[object ArrayBuffer]" === l2.call(t4.dictionary) ? new Uint8Array(t4.dictionary) : t4.dictionary, 0 !== (r3 = n2.deflateSetDictionary(this.strm, u3))) throw new Error(o2[r3]);
                    this._dict_set = true;
                  }
                }
                function u2(e3, t4) {
                  var r3 = new c2(t4);
                  if (r3.push(e3, true), r3.err) throw r3.msg || o2[r3.err];
                  return r3.result;
                }
                c2.prototype.push = function(e3, t4) {
                  var r3, o3, a3 = this.strm, c3 = this.options.chunkSize;
                  if (this.ended) return false;
                  o3 = t4 === ~~t4 ? t4 : true === t4 ? 4 : 0, "string" == typeof e3 ? a3.input = s2.string2buf(e3) : "[object ArrayBuffer]" === l2.call(e3) ? a3.input = new Uint8Array(e3) : a3.input = e3, a3.next_in = 0, a3.avail_in = a3.input.length;
                  do {
                    if (0 === a3.avail_out && (a3.output = new i2.Buf8(c3), a3.next_out = 0, a3.avail_out = c3), 1 !== (r3 = n2.deflate(a3, o3)) && 0 !== r3) return this.onEnd(r3), !(this.ended = true);
                    0 !== a3.avail_out && (0 !== a3.avail_in || 4 !== o3 && 2 !== o3) || ("string" === this.options.to ? this.onData(s2.buf2binstring(i2.shrinkBuf(a3.output, a3.next_out))) : this.onData(i2.shrinkBuf(a3.output, a3.next_out)));
                  } while ((0 < a3.avail_in || 0 === a3.avail_out) && 1 !== r3);
                  return 4 === o3 ? (r3 = n2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, 0 === r3) : 2 !== o3 || (this.onEnd(0), !(a3.avail_out = 0));
                }, c2.prototype.onData = function(e3) {
                  this.chunks.push(e3);
                }, c2.prototype.onEnd = function(e3) {
                  0 === e3 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
                }, r2.Deflate = c2, r2.deflate = u2, r2.deflateRaw = function(e3, t4) {
                  return (t4 = t4 || {}).raw = true, u2(e3, t4);
                }, r2.gzip = function(e3, t4) {
                  return (t4 = t4 || {}).gzip = true, u2(e3, t4);
                };
              }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t3, r2) {
                var n2 = e2("./zlib/inflate"), i2 = e2("./utils/common"), s2 = e2("./utils/strings"), o2 = e2("./zlib/constants"), a2 = e2("./zlib/messages"), l2 = e2("./zlib/zstream"), c2 = e2("./zlib/gzheader"), u2 = Object.prototype.toString;
                function h(e3) {
                  if (!(this instanceof h)) return new h(e3);
                  this.options = i2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
                  var t4 = this.options;
                  t4.raw && 0 <= t4.windowBits && t4.windowBits < 16 && (t4.windowBits = -t4.windowBits, 0 === t4.windowBits && (t4.windowBits = -15)), !(0 <= t4.windowBits && t4.windowBits < 16) || e3 && e3.windowBits || (t4.windowBits += 32), 15 < t4.windowBits && t4.windowBits < 48 && 0 == (15 & t4.windowBits) && (t4.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new l2(), this.strm.avail_out = 0;
                  var r3 = n2.inflateInit2(this.strm, t4.windowBits);
                  if (r3 !== o2.Z_OK) throw new Error(a2[r3]);
                  this.header = new c2(), n2.inflateGetHeader(this.strm, this.header);
                }
                function f(e3, t4) {
                  var r3 = new h(t4);
                  if (r3.push(e3, true), r3.err) throw r3.msg || a2[r3.err];
                  return r3.result;
                }
                h.prototype.push = function(e3, t4) {
                  var r3, a3, l3, c3, h2, f2, d = this.strm, p = this.options.chunkSize, m = this.options.dictionary, b = false;
                  if (this.ended) return false;
                  a3 = t4 === ~~t4 ? t4 : true === t4 ? o2.Z_FINISH : o2.Z_NO_FLUSH, "string" == typeof e3 ? d.input = s2.binstring2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? d.input = new Uint8Array(e3) : d.input = e3, d.next_in = 0, d.avail_in = d.input.length;
                  do {
                    if (0 === d.avail_out && (d.output = new i2.Buf8(p), d.next_out = 0, d.avail_out = p), (r3 = n2.inflate(d, o2.Z_NO_FLUSH)) === o2.Z_NEED_DICT && m && (f2 = "string" == typeof m ? s2.string2buf(m) : "[object ArrayBuffer]" === u2.call(m) ? new Uint8Array(m) : m, r3 = n2.inflateSetDictionary(this.strm, f2)), r3 === o2.Z_BUF_ERROR && true === b && (r3 = o2.Z_OK, b = false), r3 !== o2.Z_STREAM_END && r3 !== o2.Z_OK) return this.onEnd(r3), !(this.ended = true);
                    d.next_out && (0 !== d.avail_out && r3 !== o2.Z_STREAM_END && (0 !== d.avail_in || a3 !== o2.Z_FINISH && a3 !== o2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (l3 = s2.utf8border(d.output, d.next_out), c3 = d.next_out - l3, h2 = s2.buf2string(d.output, l3), d.next_out = c3, d.avail_out = p - c3, c3 && i2.arraySet(d.output, d.output, l3, c3, 0), this.onData(h2)) : this.onData(i2.shrinkBuf(d.output, d.next_out)))), 0 === d.avail_in && 0 === d.avail_out && (b = true);
                  } while ((0 < d.avail_in || 0 === d.avail_out) && r3 !== o2.Z_STREAM_END);
                  return r3 === o2.Z_STREAM_END && (a3 = o2.Z_FINISH), a3 === o2.Z_FINISH ? (r3 = n2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === o2.Z_OK) : a3 !== o2.Z_SYNC_FLUSH || (this.onEnd(o2.Z_OK), !(d.avail_out = 0));
                }, h.prototype.onData = function(e3) {
                  this.chunks.push(e3);
                }, h.prototype.onEnd = function(e3) {
                  e3 === o2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
                }, r2.Inflate = h, r2.inflate = f, r2.inflateRaw = function(e3, t4) {
                  return (t4 = t4 || {}).raw = true, f(e3, t4);
                }, r2.ungzip = f;
              }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t3, r2) {
                var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                r2.assign = function(e3) {
                  for (var t4 = Array.prototype.slice.call(arguments, 1); t4.length; ) {
                    var r3 = t4.shift();
                    if (r3) {
                      if ("object" != typeof r3) throw new TypeError(r3 + "must be non-object");
                      for (var n3 in r3) r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
                    }
                  }
                  return e3;
                }, r2.shrinkBuf = function(e3, t4) {
                  return e3.length === t4 ? e3 : e3.subarray ? e3.subarray(0, t4) : (e3.length = t4, e3);
                };
                var i2 = { arraySet: function(e3, t4, r3, n3, i3) {
                  if (t4.subarray && e3.subarray) e3.set(t4.subarray(r3, r3 + n3), i3);
                  else for (var s3 = 0; s3 < n3; s3++) e3[i3 + s3] = t4[r3 + s3];
                }, flattenChunks: function(e3) {
                  var t4, r3, n3, i3, s3, o2;
                  for (t4 = n3 = 0, r3 = e3.length; t4 < r3; t4++) n3 += e3[t4].length;
                  for (o2 = new Uint8Array(n3), t4 = i3 = 0, r3 = e3.length; t4 < r3; t4++) s3 = e3[t4], o2.set(s3, i3), i3 += s3.length;
                  return o2;
                } }, s2 = { arraySet: function(e3, t4, r3, n3, i3) {
                  for (var s3 = 0; s3 < n3; s3++) e3[i3 + s3] = t4[r3 + s3];
                }, flattenChunks: function(e3) {
                  return [].concat.apply([], e3);
                } };
                r2.setTyped = function(e3) {
                  e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
                }, r2.setTyped(n2);
              }, {}], 42: [function(e2, t3, r2) {
                var n2 = e2("./common"), i2 = true, s2 = true;
                try {
                  String.fromCharCode.apply(null, [0]);
                } catch (e3) {
                  i2 = false;
                }
                try {
                  String.fromCharCode.apply(null, new Uint8Array(1));
                } catch (e3) {
                  s2 = false;
                }
                for (var o2 = new n2.Buf8(256), a2 = 0; a2 < 256; a2++) o2[a2] = 252 <= a2 ? 6 : 248 <= a2 ? 5 : 240 <= a2 ? 4 : 224 <= a2 ? 3 : 192 <= a2 ? 2 : 1;
                function l2(e3, t4) {
                  if (t4 < 65537 && (e3.subarray && s2 || !e3.subarray && i2)) return String.fromCharCode.apply(null, n2.shrinkBuf(e3, t4));
                  for (var r3 = "", o3 = 0; o3 < t4; o3++) r3 += String.fromCharCode(e3[o3]);
                  return r3;
                }
                o2[254] = o2[254] = 1, r2.string2buf = function(e3) {
                  var t4, r3, i3, s3, o3, a3 = e3.length, l3 = 0;
                  for (s3 = 0; s3 < a3; s3++) 55296 == (64512 & (r3 = e3.charCodeAt(s3))) && s3 + 1 < a3 && 56320 == (64512 & (i3 = e3.charCodeAt(s3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (i3 - 56320), s3++), l3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
                  for (t4 = new n2.Buf8(l3), s3 = o3 = 0; o3 < l3; s3++) 55296 == (64512 & (r3 = e3.charCodeAt(s3))) && s3 + 1 < a3 && 56320 == (64512 & (i3 = e3.charCodeAt(s3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (i3 - 56320), s3++), r3 < 128 ? t4[o3++] = r3 : (r3 < 2048 ? t4[o3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t4[o3++] = 224 | r3 >>> 12 : (t4[o3++] = 240 | r3 >>> 18, t4[o3++] = 128 | r3 >>> 12 & 63), t4[o3++] = 128 | r3 >>> 6 & 63), t4[o3++] = 128 | 63 & r3);
                  return t4;
                }, r2.buf2binstring = function(e3) {
                  return l2(e3, e3.length);
                }, r2.binstring2buf = function(e3) {
                  for (var t4 = new n2.Buf8(e3.length), r3 = 0, i3 = t4.length; r3 < i3; r3++) t4[r3] = e3.charCodeAt(r3);
                  return t4;
                }, r2.buf2string = function(e3, t4) {
                  var r3, n3, i3, s3, a3 = t4 || e3.length, c2 = new Array(2 * a3);
                  for (r3 = n3 = 0; r3 < a3; ) if ((i3 = e3[r3++]) < 128) c2[n3++] = i3;
                  else if (4 < (s3 = o2[i3])) c2[n3++] = 65533, r3 += s3 - 1;
                  else {
                    for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a3; ) i3 = i3 << 6 | 63 & e3[r3++], s3--;
                    1 < s3 ? c2[n3++] = 65533 : i3 < 65536 ? c2[n3++] = i3 : (i3 -= 65536, c2[n3++] = 55296 | i3 >> 10 & 1023, c2[n3++] = 56320 | 1023 & i3);
                  }
                  return l2(c2, n3);
                }, r2.utf8border = function(e3, t4) {
                  var r3;
                  for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
                  return r3 < 0 || 0 === r3 ? t4 : r3 + o2[e3[r3]] > t4 ? r3 : t4;
                };
              }, { "./common": 41 }], 43: [function(e2, t3, r2) {
                t3.exports = function(e3, t4, r3, n2) {
                  for (var i2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, o2 = 0; 0 !== r3; ) {
                    for (r3 -= o2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i2 = i2 + t4[n2++] | 0) | 0, --o2; ) ;
                    i2 %= 65521, s2 %= 65521;
                  }
                  return i2 | s2 << 16 | 0;
                };
              }, {}], 44: [function(e2, t3, r2) {
                t3.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
              }, {}], 45: [function(e2, t3, r2) {
                var n2 = (function() {
                  for (var e3, t4 = [], r3 = 0; r3 < 256; r3++) {
                    e3 = r3;
                    for (var n3 = 0; n3 < 8; n3++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
                    t4[r3] = e3;
                  }
                  return t4;
                })();
                t3.exports = function(e3, t4, r3, i2) {
                  var s2 = n2, o2 = i2 + r3;
                  e3 ^= -1;
                  for (var a2 = i2; a2 < o2; a2++) e3 = e3 >>> 8 ^ s2[255 & (e3 ^ t4[a2])];
                  return -1 ^ e3;
                };
              }, {}], 46: [function(e2, t3, r2) {
                var n2, i2 = e2("../utils/common"), s2 = e2("./trees"), o2 = e2("./adler32"), a2 = e2("./crc32"), l2 = e2("./messages"), c2 = -2, u2 = 258, h = 262, f = 113;
                function d(e3, t4) {
                  return e3.msg = l2[t4], t4;
                }
                function p(e3) {
                  return (e3 << 1) - (4 < e3 ? 9 : 0);
                }
                function m(e3) {
                  for (var t4 = e3.length; 0 <= --t4; ) e3[t4] = 0;
                }
                function b(e3) {
                  var t4 = e3.state, r3 = t4.pending;
                  r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (i2.arraySet(e3.output, t4.pending_buf, t4.pending_out, r3, e3.next_out), e3.next_out += r3, t4.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t4.pending -= r3, 0 === t4.pending && (t4.pending_out = 0));
                }
                function g(e3, t4) {
                  s2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t4), e3.block_start = e3.strstart, b(e3.strm);
                }
                function y(e3, t4) {
                  e3.pending_buf[e3.pending++] = t4;
                }
                function v(e3, t4) {
                  e3.pending_buf[e3.pending++] = t4 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t4;
                }
                function w(e3, t4) {
                  var r3, n3, i3 = e3.max_chain_length, s3 = e3.strstart, o3 = e3.prev_length, a3 = e3.nice_match, l3 = e3.strstart > e3.w_size - h ? e3.strstart - (e3.w_size - h) : 0, c3 = e3.window, f2 = e3.w_mask, d2 = e3.prev, p2 = e3.strstart + u2, m2 = c3[s3 + o3 - 1], b2 = c3[s3 + o3];
                  e3.prev_length >= e3.good_match && (i3 >>= 2), a3 > e3.lookahead && (a3 = e3.lookahead);
                  do {
                    if (c3[(r3 = t4) + o3] === b2 && c3[r3 + o3 - 1] === m2 && c3[r3] === c3[s3] && c3[++r3] === c3[s3 + 1]) {
                      s3 += 2, r3++;
                      do {
                      } while (c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && c3[++s3] === c3[++r3] && s3 < p2);
                      if (n3 = u2 - (p2 - s3), s3 = p2 - u2, o3 < n3) {
                        if (e3.match_start = t4, a3 <= (o3 = n3)) break;
                        m2 = c3[s3 + o3 - 1], b2 = c3[s3 + o3];
                      }
                    }
                  } while ((t4 = d2[t4 & f2]) > l3 && 0 != --i3);
                  return o3 <= e3.lookahead ? o3 : e3.lookahead;
                }
                function _(e3) {
                  var t4, r3, n3, s3, l3, c3, u3, f2, d2, p2, m2 = e3.w_size;
                  do {
                    if (s3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= m2 + (m2 - h)) {
                      for (i2.arraySet(e3.window, e3.window, m2, m2, 0), e3.match_start -= m2, e3.strstart -= m2, e3.block_start -= m2, t4 = r3 = e3.hash_size; n3 = e3.head[--t4], e3.head[t4] = m2 <= n3 ? n3 - m2 : 0, --r3; ) ;
                      for (t4 = r3 = m2; n3 = e3.prev[--t4], e3.prev[t4] = m2 <= n3 ? n3 - m2 : 0, --r3; ) ;
                      s3 += m2;
                    }
                    if (0 === e3.strm.avail_in) break;
                    if (c3 = e3.strm, u3 = e3.window, f2 = e3.strstart + e3.lookahead, p2 = void 0, (d2 = s3) < (p2 = c3.avail_in) && (p2 = d2), r3 = 0 === p2 ? 0 : (c3.avail_in -= p2, i2.arraySet(u3, c3.input, c3.next_in, p2, f2), 1 === c3.state.wrap ? c3.adler = o2(c3.adler, u3, p2, f2) : 2 === c3.state.wrap && (c3.adler = a2(c3.adler, u3, p2, f2)), c3.next_in += p2, c3.total_in += p2, p2), e3.lookahead += r3, e3.lookahead + e3.insert >= 3) for (l3 = e3.strstart - e3.insert, e3.ins_h = e3.window[l3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[l3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[l3 + 3 - 1]) & e3.hash_mask, e3.prev[l3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = l3, l3++, e3.insert--, !(e3.lookahead + e3.insert < 3)); ) ;
                  } while (e3.lookahead < h && 0 !== e3.strm.avail_in);
                }
                function x(e3, t4) {
                  for (var r3, n3; ; ) {
                    if (e3.lookahead < h) {
                      if (_(e3), e3.lookahead < h && 0 === t4) return 1;
                      if (0 === e3.lookahead) break;
                    }
                    if (r3 = 0, e3.lookahead >= 3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - h && (e3.match_length = w(e3, r3)), e3.match_length >= 3) if (n3 = s2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= 3) {
                      for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; ) ;
                      e3.strstart++;
                    } else e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
                    else n3 = s2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
                    if (n3 && (g(e3, false), 0 === e3.strm.avail_out)) return 1;
                  }
                  return e3.insert = e3.strstart < 2 ? e3.strstart : 2, 4 === t4 ? (g(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (g(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
                }
                function k(e3, t4) {
                  for (var r3, n3, i3; ; ) {
                    if (e3.lookahead < h) {
                      if (_(e3), e3.lookahead < h && 0 === t4) return 1;
                      if (0 === e3.lookahead) break;
                    }
                    if (r3 = 0, e3.lookahead >= 3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = 2, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - h && (e3.match_length = w(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || 3 === e3.match_length && 4096 < e3.strstart - e3.match_start) && (e3.match_length = 2)), e3.prev_length >= 3 && e3.match_length <= e3.prev_length) {
                      for (i3 = e3.strstart + e3.lookahead - 3, n3 = s2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - 3), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; ) ;
                      if (e3.match_available = 0, e3.match_length = 2, e3.strstart++, n3 && (g(e3, false), 0 === e3.strm.avail_out)) return 1;
                    } else if (e3.match_available) {
                      if ((n3 = s2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && g(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out) return 1;
                    } else e3.match_available = 1, e3.strstart++, e3.lookahead--;
                  }
                  return e3.match_available && (n3 = s2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < 2 ? e3.strstart : 2, 4 === t4 ? (g(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (g(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
                }
                function S(e3, t4, r3, n3, i3) {
                  this.good_length = e3, this.max_lazy = t4, this.nice_length = r3, this.max_chain = n3, this.func = i3;
                }
                function M() {
                  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i2.Buf16(1146), this.dyn_dtree = new i2.Buf16(122), this.bl_tree = new i2.Buf16(78), m(this.dyn_ltree), m(this.dyn_dtree), m(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i2.Buf16(16), this.heap = new i2.Buf16(573), m(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i2.Buf16(573), m(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                }
                function C2(e3) {
                  var t4;
                  return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = 2, (t4 = e3.state).pending = 0, t4.pending_out = 0, t4.wrap < 0 && (t4.wrap = -t4.wrap), t4.status = t4.wrap ? 42 : f, e3.adler = 2 === t4.wrap ? 0 : 1, t4.last_flush = 0, s2._tr_init(t4), 0) : d(e3, c2);
                }
                function T(e3) {
                  var t4 = C2(e3);
                  return 0 === t4 && (function(e4) {
                    e4.window_size = 2 * e4.w_size, m(e4.head), e4.max_lazy_match = n2[e4.level].max_lazy, e4.good_match = n2[e4.level].good_length, e4.nice_match = n2[e4.level].nice_length, e4.max_chain_length = n2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = 2, e4.match_available = 0, e4.ins_h = 0;
                  })(e3.state), t4;
                }
                function E(e3, t4, r3, n3, s3, o3) {
                  if (!e3) return c2;
                  var a3 = 1;
                  if (-1 === t4 && (t4 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), s3 < 1 || 9 < s3 || 8 !== r3 || n3 < 8 || 15 < n3 || t4 < 0 || 9 < t4 || o3 < 0 || 4 < o3) return d(e3, c2);
                  8 === n3 && (n3 = 9);
                  var l3 = new M();
                  return (e3.state = l3).strm = e3, l3.wrap = a3, l3.gzhead = null, l3.w_bits = n3, l3.w_size = 1 << l3.w_bits, l3.w_mask = l3.w_size - 1, l3.hash_bits = s3 + 7, l3.hash_size = 1 << l3.hash_bits, l3.hash_mask = l3.hash_size - 1, l3.hash_shift = ~~((l3.hash_bits + 3 - 1) / 3), l3.window = new i2.Buf8(2 * l3.w_size), l3.head = new i2.Buf16(l3.hash_size), l3.prev = new i2.Buf16(l3.w_size), l3.lit_bufsize = 1 << s3 + 6, l3.pending_buf_size = 4 * l3.lit_bufsize, l3.pending_buf = new i2.Buf8(l3.pending_buf_size), l3.d_buf = 1 * l3.lit_bufsize, l3.l_buf = 3 * l3.lit_bufsize, l3.level = t4, l3.strategy = o3, l3.method = r3, T(e3);
                }
                n2 = [new S(0, 0, 0, 0, (function(e3, t4) {
                  var r3 = 65535;
                  for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
                    if (e3.lookahead <= 1) {
                      if (_(e3), 0 === e3.lookahead && 0 === t4) return 1;
                      if (0 === e3.lookahead) break;
                    }
                    e3.strstart += e3.lookahead, e3.lookahead = 0;
                    var n3 = e3.block_start + r3;
                    if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, g(e3, false), 0 === e3.strm.avail_out)) return 1;
                    if (e3.strstart - e3.block_start >= e3.w_size - h && (g(e3, false), 0 === e3.strm.avail_out)) return 1;
                  }
                  return e3.insert = 0, 4 === t4 ? (g(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : (e3.strstart > e3.block_start && (g(e3, false), e3.strm.avail_out), 1);
                })), new S(4, 4, 8, 4, x), new S(4, 5, 16, 8, x), new S(4, 6, 32, 32, x), new S(4, 4, 16, 16, k), new S(8, 16, 32, 32, k), new S(8, 16, 128, 128, k), new S(8, 32, 128, 256, k), new S(32, 128, 258, 1024, k), new S(32, 258, 258, 4096, k)], r2.deflateInit = function(e3, t4) {
                  return E(e3, t4, 8, 15, 8, 0);
                }, r2.deflateInit2 = E, r2.deflateReset = T, r2.deflateResetKeep = C2, r2.deflateSetHeader = function(e3, t4) {
                  return e3 && e3.state ? 2 !== e3.state.wrap ? c2 : (e3.state.gzhead = t4, 0) : c2;
                }, r2.deflate = function(e3, t4) {
                  var r3, i3, o3, l3;
                  if (!e3 || !e3.state || 5 < t4 || t4 < 0) return e3 ? d(e3, c2) : c2;
                  if (i3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === i3.status && 4 !== t4) return d(e3, 0 === e3.avail_out ? -5 : c2);
                  if (i3.strm = e3, r3 = i3.last_flush, i3.last_flush = t4, 42 === i3.status) if (2 === i3.wrap) e3.adler = 0, y(i3, 31), y(i3, 139), y(i3, 8), i3.gzhead ? (y(i3, (i3.gzhead.text ? 1 : 0) + (i3.gzhead.hcrc ? 2 : 0) + (i3.gzhead.extra ? 4 : 0) + (i3.gzhead.name ? 8 : 0) + (i3.gzhead.comment ? 16 : 0)), y(i3, 255 & i3.gzhead.time), y(i3, i3.gzhead.time >> 8 & 255), y(i3, i3.gzhead.time >> 16 & 255), y(i3, i3.gzhead.time >> 24 & 255), y(i3, 9 === i3.level ? 2 : 2 <= i3.strategy || i3.level < 2 ? 4 : 0), y(i3, 255 & i3.gzhead.os), i3.gzhead.extra && i3.gzhead.extra.length && (y(i3, 255 & i3.gzhead.extra.length), y(i3, i3.gzhead.extra.length >> 8 & 255)), i3.gzhead.hcrc && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending, 0)), i3.gzindex = 0, i3.status = 69) : (y(i3, 0), y(i3, 0), y(i3, 0), y(i3, 0), y(i3, 0), y(i3, 9 === i3.level ? 2 : 2 <= i3.strategy || i3.level < 2 ? 4 : 0), y(i3, 3), i3.status = f);
                  else {
                    var h2 = 8 + (i3.w_bits - 8 << 4) << 8;
                    h2 |= (2 <= i3.strategy || i3.level < 2 ? 0 : i3.level < 6 ? 1 : 6 === i3.level ? 2 : 3) << 6, 0 !== i3.strstart && (h2 |= 32), h2 += 31 - h2 % 31, i3.status = f, v(i3, h2), 0 !== i3.strstart && (v(i3, e3.adler >>> 16), v(i3, 65535 & e3.adler)), e3.adler = 1;
                  }
                  if (69 === i3.status) if (i3.gzhead.extra) {
                    for (o3 = i3.pending; i3.gzindex < (65535 & i3.gzhead.extra.length) && (i3.pending !== i3.pending_buf_size || (i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), b(e3), o3 = i3.pending, i3.pending !== i3.pending_buf_size)); ) y(i3, 255 & i3.gzhead.extra[i3.gzindex]), i3.gzindex++;
                    i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), i3.gzindex === i3.gzhead.extra.length && (i3.gzindex = 0, i3.status = 73);
                  } else i3.status = 73;
                  if (73 === i3.status) if (i3.gzhead.name) {
                    o3 = i3.pending;
                    do {
                      if (i3.pending === i3.pending_buf_size && (i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), b(e3), o3 = i3.pending, i3.pending === i3.pending_buf_size)) {
                        l3 = 1;
                        break;
                      }
                      l3 = i3.gzindex < i3.gzhead.name.length ? 255 & i3.gzhead.name.charCodeAt(i3.gzindex++) : 0, y(i3, l3);
                    } while (0 !== l3);
                    i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), 0 === l3 && (i3.gzindex = 0, i3.status = 91);
                  } else i3.status = 91;
                  if (91 === i3.status) if (i3.gzhead.comment) {
                    o3 = i3.pending;
                    do {
                      if (i3.pending === i3.pending_buf_size && (i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), b(e3), o3 = i3.pending, i3.pending === i3.pending_buf_size)) {
                        l3 = 1;
                        break;
                      }
                      l3 = i3.gzindex < i3.gzhead.comment.length ? 255 & i3.gzhead.comment.charCodeAt(i3.gzindex++) : 0, y(i3, l3);
                    } while (0 !== l3);
                    i3.gzhead.hcrc && i3.pending > o3 && (e3.adler = a2(e3.adler, i3.pending_buf, i3.pending - o3, o3)), 0 === l3 && (i3.status = 103);
                  } else i3.status = 103;
                  if (103 === i3.status && (i3.gzhead.hcrc ? (i3.pending + 2 > i3.pending_buf_size && b(e3), i3.pending + 2 <= i3.pending_buf_size && (y(i3, 255 & e3.adler), y(i3, e3.adler >> 8 & 255), e3.adler = 0, i3.status = f)) : i3.status = f), 0 !== i3.pending) {
                    if (b(e3), 0 === e3.avail_out) return i3.last_flush = -1, 0;
                  } else if (0 === e3.avail_in && p(t4) <= p(r3) && 4 !== t4) return d(e3, -5);
                  if (666 === i3.status && 0 !== e3.avail_in) return d(e3, -5);
                  if (0 !== e3.avail_in || 0 !== i3.lookahead || 0 !== t4 && 666 !== i3.status) {
                    var w2 = 2 === i3.strategy ? (function(e4, t5) {
                      for (var r4; ; ) {
                        if (0 === e4.lookahead && (_(e4), 0 === e4.lookahead)) {
                          if (0 === t5) return 1;
                          break;
                        }
                        if (e4.match_length = 0, r4 = s2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (g(e4, false), 0 === e4.strm.avail_out)) return 1;
                      }
                      return e4.insert = 0, 4 === t5 ? (g(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (g(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
                    })(i3, t4) : 3 === i3.strategy ? (function(e4, t5) {
                      for (var r4, n3, i4, o4, a3 = e4.window; ; ) {
                        if (e4.lookahead <= u2) {
                          if (_(e4), e4.lookahead <= u2 && 0 === t5) return 1;
                          if (0 === e4.lookahead) break;
                        }
                        if (e4.match_length = 0, e4.lookahead >= 3 && 0 < e4.strstart && (n3 = a3[i4 = e4.strstart - 1]) === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4]) {
                          o4 = e4.strstart + u2;
                          do {
                          } while (n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && n3 === a3[++i4] && i4 < o4);
                          e4.match_length = u2 - (o4 - i4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                        }
                        if (e4.match_length >= 3 ? (r4 = s2._tr_tally(e4, 1, e4.match_length - 3), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = s2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (g(e4, false), 0 === e4.strm.avail_out)) return 1;
                      }
                      return e4.insert = 0, 4 === t5 ? (g(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (g(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
                    })(i3, t4) : n2[i3.level].func(i3, t4);
                    if (3 !== w2 && 4 !== w2 || (i3.status = 666), 1 === w2 || 3 === w2) return 0 === e3.avail_out && (i3.last_flush = -1), 0;
                    if (2 === w2 && (1 === t4 ? s2._tr_align(i3) : 5 !== t4 && (s2._tr_stored_block(i3, 0, 0, false), 3 === t4 && (m(i3.head), 0 === i3.lookahead && (i3.strstart = 0, i3.block_start = 0, i3.insert = 0))), b(e3), 0 === e3.avail_out)) return i3.last_flush = -1, 0;
                  }
                  return 4 !== t4 ? 0 : i3.wrap <= 0 ? 1 : (2 === i3.wrap ? (y(i3, 255 & e3.adler), y(i3, e3.adler >> 8 & 255), y(i3, e3.adler >> 16 & 255), y(i3, e3.adler >> 24 & 255), y(i3, 255 & e3.total_in), y(i3, e3.total_in >> 8 & 255), y(i3, e3.total_in >> 16 & 255), y(i3, e3.total_in >> 24 & 255)) : (v(i3, e3.adler >>> 16), v(i3, 65535 & e3.adler)), b(e3), 0 < i3.wrap && (i3.wrap = -i3.wrap), 0 !== i3.pending ? 0 : 1);
                }, r2.deflateEnd = function(e3) {
                  var t4;
                  return e3 && e3.state ? 42 !== (t4 = e3.state.status) && 69 !== t4 && 73 !== t4 && 91 !== t4 && 103 !== t4 && t4 !== f && 666 !== t4 ? d(e3, c2) : (e3.state = null, t4 === f ? d(e3, -3) : 0) : c2;
                }, r2.deflateSetDictionary = function(e3, t4) {
                  var r3, n3, s3, a3, l3, u3, h2, f2, d2 = t4.length;
                  if (!e3 || !e3.state) return c2;
                  if (2 === (a3 = (r3 = e3.state).wrap) || 1 === a3 && 42 !== r3.status || r3.lookahead) return c2;
                  for (1 === a3 && (e3.adler = o2(e3.adler, t4, d2, 0)), r3.wrap = 0, d2 >= r3.w_size && (0 === a3 && (m(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), f2 = new i2.Buf8(r3.w_size), i2.arraySet(f2, t4, d2 - r3.w_size, r3.w_size, 0), t4 = f2, d2 = r3.w_size), l3 = e3.avail_in, u3 = e3.next_in, h2 = e3.input, e3.avail_in = d2, e3.next_in = 0, e3.input = t4, _(r3); r3.lookahead >= 3; ) {
                    for (n3 = r3.strstart, s3 = r3.lookahead - 2; r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + 3 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --s3; ) ;
                    r3.strstart = n3, r3.lookahead = 2, _(r3);
                  }
                  return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = 2, r3.match_available = 0, e3.next_in = u3, e3.input = h2, e3.avail_in = l3, r3.wrap = a3, 0;
                }, r2.deflateInfo = "pako deflate (from Nodeca project)";
              }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t3, r2) {
                t3.exports = function() {
                  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
                };
              }, {}], 48: [function(e2, t3, r2) {
                t3.exports = function(e3, t4) {
                  var r3, n2, i2, s2, o2, a2, l2, c2, u2, h, f, d, p, m, b, g, y, v, w, _, x, k, S, M, C2;
                  r3 = e3.state, n2 = e3.next_in, M = e3.input, i2 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C2 = e3.output, o2 = s2 - (t4 - e3.avail_out), a2 = s2 + (e3.avail_out - 257), l2 = r3.dmax, c2 = r3.wsize, u2 = r3.whave, h = r3.wnext, f = r3.window, d = r3.hold, p = r3.bits, m = r3.lencode, b = r3.distcode, g = (1 << r3.lenbits) - 1, y = (1 << r3.distbits) - 1;
                  e: do {
                    p < 15 && (d += M[n2++] << p, p += 8, d += M[n2++] << p, p += 8), v = m[d & g];
                    t: for (; ; ) {
                      if (d >>>= w = v >>> 24, p -= w, 0 == (w = v >>> 16 & 255)) C2[s2++] = 65535 & v;
                      else {
                        if (!(16 & w)) {
                          if (0 == (64 & w)) {
                            v = m[(65535 & v) + (d & (1 << w) - 1)];
                            continue t;
                          }
                          if (32 & w) {
                            r3.mode = 12;
                            break e;
                          }
                          e3.msg = "invalid literal/length code", r3.mode = 30;
                          break e;
                        }
                        _ = 65535 & v, (w &= 15) && (p < w && (d += M[n2++] << p, p += 8), _ += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += M[n2++] << p, p += 8, d += M[n2++] << p, p += 8), v = b[d & y];
                        r: for (; ; ) {
                          if (d >>>= w = v >>> 24, p -= w, !(16 & (w = v >>> 16 & 255))) {
                            if (0 == (64 & w)) {
                              v = b[(65535 & v) + (d & (1 << w) - 1)];
                              continue r;
                            }
                            e3.msg = "invalid distance code", r3.mode = 30;
                            break e;
                          }
                          if (x = 65535 & v, p < (w &= 15) && (d += M[n2++] << p, (p += 8) < w && (d += M[n2++] << p, p += 8)), l2 < (x += d & (1 << w) - 1)) {
                            e3.msg = "invalid distance too far back", r3.mode = 30;
                            break e;
                          }
                          if (d >>>= w, p -= w, (w = s2 - o2) < x) {
                            if (u2 < (w = x - w) && r3.sane) {
                              e3.msg = "invalid distance too far back", r3.mode = 30;
                              break e;
                            }
                            if (S = f, (k = 0) === h) {
                              if (k += c2 - w, w < _) {
                                for (_ -= w; C2[s2++] = f[k++], --w; ) ;
                                k = s2 - x, S = C2;
                              }
                            } else if (h < w) {
                              if (k += c2 + h - w, (w -= h) < _) {
                                for (_ -= w; C2[s2++] = f[k++], --w; ) ;
                                if (k = 0, h < _) {
                                  for (_ -= w = h; C2[s2++] = f[k++], --w; ) ;
                                  k = s2 - x, S = C2;
                                }
                              }
                            } else if (k += h - w, w < _) {
                              for (_ -= w; C2[s2++] = f[k++], --w; ) ;
                              k = s2 - x, S = C2;
                            }
                            for (; 2 < _; ) C2[s2++] = S[k++], C2[s2++] = S[k++], C2[s2++] = S[k++], _ -= 3;
                            _ && (C2[s2++] = S[k++], 1 < _ && (C2[s2++] = S[k++]));
                          } else {
                            for (k = s2 - x; C2[s2++] = C2[k++], C2[s2++] = C2[k++], C2[s2++] = C2[k++], 2 < (_ -= 3); ) ;
                            _ && (C2[s2++] = C2[k++], 1 < _ && (C2[s2++] = C2[k++]));
                          }
                          break;
                        }
                      }
                      break;
                    }
                  } while (n2 < i2 && s2 < a2);
                  n2 -= _ = p >> 3, d &= (1 << (p -= _ << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e3.avail_out = s2 < a2 ? a2 - s2 + 257 : 257 - (s2 - a2), r3.hold = d, r3.bits = p;
                };
              }, {}], 49: [function(e2, t3, r2) {
                var n2 = e2("../utils/common"), i2 = e2("./adler32"), s2 = e2("./crc32"), o2 = e2("./inffast"), a2 = e2("./inftrees"), l2 = -2;
                function c2(e3) {
                  return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
                }
                function u2() {
                  this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n2.Buf16(320), this.work = new n2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                }
                function h(e3) {
                  var t4;
                  return e3 && e3.state ? (t4 = e3.state, e3.total_in = e3.total_out = t4.total = 0, e3.msg = "", t4.wrap && (e3.adler = 1 & t4.wrap), t4.mode = 1, t4.last = 0, t4.havedict = 0, t4.dmax = 32768, t4.head = null, t4.hold = 0, t4.bits = 0, t4.lencode = t4.lendyn = new n2.Buf32(852), t4.distcode = t4.distdyn = new n2.Buf32(592), t4.sane = 1, t4.back = -1, 0) : l2;
                }
                function f(e3) {
                  var t4;
                  return e3 && e3.state ? ((t4 = e3.state).wsize = 0, t4.whave = 0, t4.wnext = 0, h(e3)) : l2;
                }
                function d(e3, t4) {
                  var r3, n3;
                  return e3 && e3.state ? (n3 = e3.state, t4 < 0 ? (r3 = 0, t4 = -t4) : (r3 = 1 + (t4 >> 4), t4 < 48 && (t4 &= 15)), t4 && (t4 < 8 || 15 < t4) ? l2 : (null !== n3.window && n3.wbits !== t4 && (n3.window = null), n3.wrap = r3, n3.wbits = t4, f(e3))) : l2;
                }
                function p(e3, t4) {
                  var r3, n3;
                  return e3 ? (n3 = new u2(), (e3.state = n3).window = null, 0 !== (r3 = d(e3, t4)) && (e3.state = null), r3) : l2;
                }
                var m, b, g = true;
                function y(e3) {
                  if (g) {
                    var t4;
                    for (m = new n2.Buf32(512), b = new n2.Buf32(32), t4 = 0; t4 < 144; ) e3.lens[t4++] = 8;
                    for (; t4 < 256; ) e3.lens[t4++] = 9;
                    for (; t4 < 280; ) e3.lens[t4++] = 7;
                    for (; t4 < 288; ) e3.lens[t4++] = 8;
                    for (a2(1, e3.lens, 0, 288, m, 0, e3.work, { bits: 9 }), t4 = 0; t4 < 32; ) e3.lens[t4++] = 5;
                    a2(2, e3.lens, 0, 32, b, 0, e3.work, { bits: 5 }), g = false;
                  }
                  e3.lencode = m, e3.lenbits = 9, e3.distcode = b, e3.distbits = 5;
                }
                function v(e3, t4, r3, i3) {
                  var s3, o3 = e3.state;
                  return null === o3.window && (o3.wsize = 1 << o3.wbits, o3.wnext = 0, o3.whave = 0, o3.window = new n2.Buf8(o3.wsize)), i3 >= o3.wsize ? (n2.arraySet(o3.window, t4, r3 - o3.wsize, o3.wsize, 0), o3.wnext = 0, o3.whave = o3.wsize) : (i3 < (s3 = o3.wsize - o3.wnext) && (s3 = i3), n2.arraySet(o3.window, t4, r3 - i3, s3, o3.wnext), (i3 -= s3) ? (n2.arraySet(o3.window, t4, r3 - i3, i3, 0), o3.wnext = i3, o3.whave = o3.wsize) : (o3.wnext += s3, o3.wnext === o3.wsize && (o3.wnext = 0), o3.whave < o3.wsize && (o3.whave += s3))), 0;
                }
                r2.inflateReset = f, r2.inflateReset2 = d, r2.inflateResetKeep = h, r2.inflateInit = function(e3) {
                  return p(e3, 15);
                }, r2.inflateInit2 = p, r2.inflate = function(e3, t4) {
                  var r3, u3, h2, f2, d2, p2, m2, b2, g2, w, _, x, k, S, M, C2, T, E, A, R, O, j, I, N, P = 0, B = new n2.Buf8(4), D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                  if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in) return l2;
                  12 === (r3 = e3.state).mode && (r3.mode = 13), d2 = e3.next_out, h2 = e3.output, m2 = e3.avail_out, f2 = e3.next_in, u3 = e3.input, p2 = e3.avail_in, b2 = r3.hold, g2 = r3.bits, w = p2, _ = m2, j = 0;
                  e: for (; ; ) switch (r3.mode) {
                    case 1:
                      if (0 === r3.wrap) {
                        r3.mode = 13;
                        break;
                      }
                      for (; g2 < 16; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if (2 & r3.wrap && 35615 === b2) {
                        B[r3.check = 0] = 255 & b2, B[1] = b2 >>> 8 & 255, r3.check = s2(r3.check, B, 2, 0), g2 = b2 = 0, r3.mode = 2;
                        break;
                      }
                      if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & b2) << 8) + (b2 >> 8)) % 31) {
                        e3.msg = "incorrect header check", r3.mode = 30;
                        break;
                      }
                      if (8 != (15 & b2)) {
                        e3.msg = "unknown compression method", r3.mode = 30;
                        break;
                      }
                      if (g2 -= 4, O = 8 + (15 & (b2 >>>= 4)), 0 === r3.wbits) r3.wbits = O;
                      else if (O > r3.wbits) {
                        e3.msg = "invalid window size", r3.mode = 30;
                        break;
                      }
                      r3.dmax = 1 << O, e3.adler = r3.check = 1, r3.mode = 512 & b2 ? 10 : 12, g2 = b2 = 0;
                      break;
                    case 2:
                      for (; g2 < 16; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if (r3.flags = b2, 8 != (255 & r3.flags)) {
                        e3.msg = "unknown compression method", r3.mode = 30;
                        break;
                      }
                      if (57344 & r3.flags) {
                        e3.msg = "unknown header flags set", r3.mode = 30;
                        break;
                      }
                      r3.head && (r3.head.text = b2 >> 8 & 1), 512 & r3.flags && (B[0] = 255 & b2, B[1] = b2 >>> 8 & 255, r3.check = s2(r3.check, B, 2, 0)), g2 = b2 = 0, r3.mode = 3;
                    case 3:
                      for (; g2 < 32; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      r3.head && (r3.head.time = b2), 512 & r3.flags && (B[0] = 255 & b2, B[1] = b2 >>> 8 & 255, B[2] = b2 >>> 16 & 255, B[3] = b2 >>> 24 & 255, r3.check = s2(r3.check, B, 4, 0)), g2 = b2 = 0, r3.mode = 4;
                    case 4:
                      for (; g2 < 16; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      r3.head && (r3.head.xflags = 255 & b2, r3.head.os = b2 >> 8), 512 & r3.flags && (B[0] = 255 & b2, B[1] = b2 >>> 8 & 255, r3.check = s2(r3.check, B, 2, 0)), g2 = b2 = 0, r3.mode = 5;
                    case 5:
                      if (1024 & r3.flags) {
                        for (; g2 < 16; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        r3.length = b2, r3.head && (r3.head.extra_len = b2), 512 & r3.flags && (B[0] = 255 & b2, B[1] = b2 >>> 8 & 255, r3.check = s2(r3.check, B, 2, 0)), g2 = b2 = 0;
                      } else r3.head && (r3.head.extra = null);
                      r3.mode = 6;
                    case 6:
                      if (1024 & r3.flags && (p2 < (x = r3.length) && (x = p2), x && (r3.head && (O = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), n2.arraySet(r3.head.extra, u3, f2, x, O)), 512 & r3.flags && (r3.check = s2(r3.check, u3, x, f2)), p2 -= x, f2 += x, r3.length -= x), r3.length)) break e;
                      r3.length = 0, r3.mode = 7;
                    case 7:
                      if (2048 & r3.flags) {
                        if (0 === p2) break e;
                        for (x = 0; O = u3[f2 + x++], r3.head && O && r3.length < 65536 && (r3.head.name += String.fromCharCode(O)), O && x < p2; ) ;
                        if (512 & r3.flags && (r3.check = s2(r3.check, u3, x, f2)), p2 -= x, f2 += x, O) break e;
                      } else r3.head && (r3.head.name = null);
                      r3.length = 0, r3.mode = 8;
                    case 8:
                      if (4096 & r3.flags) {
                        if (0 === p2) break e;
                        for (x = 0; O = u3[f2 + x++], r3.head && O && r3.length < 65536 && (r3.head.comment += String.fromCharCode(O)), O && x < p2; ) ;
                        if (512 & r3.flags && (r3.check = s2(r3.check, u3, x, f2)), p2 -= x, f2 += x, O) break e;
                      } else r3.head && (r3.head.comment = null);
                      r3.mode = 9;
                    case 9:
                      if (512 & r3.flags) {
                        for (; g2 < 16; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        if (b2 !== (65535 & r3.check)) {
                          e3.msg = "header crc mismatch", r3.mode = 30;
                          break;
                        }
                        g2 = b2 = 0;
                      }
                      r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                      break;
                    case 10:
                      for (; g2 < 32; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      e3.adler = r3.check = c2(b2), g2 = b2 = 0, r3.mode = 11;
                    case 11:
                      if (0 === r3.havedict) return e3.next_out = d2, e3.avail_out = m2, e3.next_in = f2, e3.avail_in = p2, r3.hold = b2, r3.bits = g2, 2;
                      e3.adler = r3.check = 1, r3.mode = 12;
                    case 12:
                      if (5 === t4 || 6 === t4) break e;
                    case 13:
                      if (r3.last) {
                        b2 >>>= 7 & g2, g2 -= 7 & g2, r3.mode = 27;
                        break;
                      }
                      for (; g2 < 3; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      switch (r3.last = 1 & b2, g2 -= 1, 3 & (b2 >>>= 1)) {
                        case 0:
                          r3.mode = 14;
                          break;
                        case 1:
                          if (y(r3), r3.mode = 20, 6 !== t4) break;
                          b2 >>>= 2, g2 -= 2;
                          break e;
                        case 2:
                          r3.mode = 17;
                          break;
                        case 3:
                          e3.msg = "invalid block type", r3.mode = 30;
                      }
                      b2 >>>= 2, g2 -= 2;
                      break;
                    case 14:
                      for (b2 >>>= 7 & g2, g2 -= 7 & g2; g2 < 32; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if ((65535 & b2) != (b2 >>> 16 ^ 65535)) {
                        e3.msg = "invalid stored block lengths", r3.mode = 30;
                        break;
                      }
                      if (r3.length = 65535 & b2, g2 = b2 = 0, r3.mode = 15, 6 === t4) break e;
                    case 15:
                      r3.mode = 16;
                    case 16:
                      if (x = r3.length) {
                        if (p2 < x && (x = p2), m2 < x && (x = m2), 0 === x) break e;
                        n2.arraySet(h2, u3, f2, x, d2), p2 -= x, f2 += x, m2 -= x, d2 += x, r3.length -= x;
                        break;
                      }
                      r3.mode = 12;
                      break;
                    case 17:
                      for (; g2 < 14; ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if (r3.nlen = 257 + (31 & b2), b2 >>>= 5, g2 -= 5, r3.ndist = 1 + (31 & b2), b2 >>>= 5, g2 -= 5, r3.ncode = 4 + (15 & b2), b2 >>>= 4, g2 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                        e3.msg = "too many length or distance symbols", r3.mode = 30;
                        break;
                      }
                      r3.have = 0, r3.mode = 18;
                    case 18:
                      for (; r3.have < r3.ncode; ) {
                        for (; g2 < 3; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        r3.lens[D[r3.have++]] = 7 & b2, b2 >>>= 3, g2 -= 3;
                      }
                      for (; r3.have < 19; ) r3.lens[D[r3.have++]] = 0;
                      if (r3.lencode = r3.lendyn, r3.lenbits = 7, I = { bits: r3.lenbits }, j = a2(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, I), r3.lenbits = I.bits, j) {
                        e3.msg = "invalid code lengths set", r3.mode = 30;
                        break;
                      }
                      r3.have = 0, r3.mode = 19;
                    case 19:
                      for (; r3.have < r3.nlen + r3.ndist; ) {
                        for (; C2 = (P = r3.lencode[b2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, T = 65535 & P, !((M = P >>> 24) <= g2); ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        if (T < 16) b2 >>>= M, g2 -= M, r3.lens[r3.have++] = T;
                        else {
                          if (16 === T) {
                            for (N = M + 2; g2 < N; ) {
                              if (0 === p2) break e;
                              p2--, b2 += u3[f2++] << g2, g2 += 8;
                            }
                            if (b2 >>>= M, g2 -= M, 0 === r3.have) {
                              e3.msg = "invalid bit length repeat", r3.mode = 30;
                              break;
                            }
                            O = r3.lens[r3.have - 1], x = 3 + (3 & b2), b2 >>>= 2, g2 -= 2;
                          } else if (17 === T) {
                            for (N = M + 3; g2 < N; ) {
                              if (0 === p2) break e;
                              p2--, b2 += u3[f2++] << g2, g2 += 8;
                            }
                            g2 -= M, O = 0, x = 3 + (7 & (b2 >>>= M)), b2 >>>= 3, g2 -= 3;
                          } else {
                            for (N = M + 7; g2 < N; ) {
                              if (0 === p2) break e;
                              p2--, b2 += u3[f2++] << g2, g2 += 8;
                            }
                            g2 -= M, O = 0, x = 11 + (127 & (b2 >>>= M)), b2 >>>= 7, g2 -= 7;
                          }
                          if (r3.have + x > r3.nlen + r3.ndist) {
                            e3.msg = "invalid bit length repeat", r3.mode = 30;
                            break;
                          }
                          for (; x--; ) r3.lens[r3.have++] = O;
                        }
                      }
                      if (30 === r3.mode) break;
                      if (0 === r3.lens[256]) {
                        e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                        break;
                      }
                      if (r3.lenbits = 9, I = { bits: r3.lenbits }, j = a2(1, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, I), r3.lenbits = I.bits, j) {
                        e3.msg = "invalid literal/lengths set", r3.mode = 30;
                        break;
                      }
                      if (r3.distbits = 6, r3.distcode = r3.distdyn, I = { bits: r3.distbits }, j = a2(2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, I), r3.distbits = I.bits, j) {
                        e3.msg = "invalid distances set", r3.mode = 30;
                        break;
                      }
                      if (r3.mode = 20, 6 === t4) break e;
                    case 20:
                      r3.mode = 21;
                    case 21:
                      if (6 <= p2 && 258 <= m2) {
                        e3.next_out = d2, e3.avail_out = m2, e3.next_in = f2, e3.avail_in = p2, r3.hold = b2, r3.bits = g2, o2(e3, _), d2 = e3.next_out, h2 = e3.output, m2 = e3.avail_out, f2 = e3.next_in, u3 = e3.input, p2 = e3.avail_in, b2 = r3.hold, g2 = r3.bits, 12 === r3.mode && (r3.back = -1);
                        break;
                      }
                      for (r3.back = 0; C2 = (P = r3.lencode[b2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, T = 65535 & P, !((M = P >>> 24) <= g2); ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if (C2 && 0 == (240 & C2)) {
                        for (E = M, A = C2, R = T; C2 = (P = r3.lencode[R + ((b2 & (1 << E + A) - 1) >> E)]) >>> 16 & 255, T = 65535 & P, !(E + (M = P >>> 24) <= g2); ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        b2 >>>= E, g2 -= E, r3.back += E;
                      }
                      if (b2 >>>= M, g2 -= M, r3.back += M, r3.length = T, 0 === C2) {
                        r3.mode = 26;
                        break;
                      }
                      if (32 & C2) {
                        r3.back = -1, r3.mode = 12;
                        break;
                      }
                      if (64 & C2) {
                        e3.msg = "invalid literal/length code", r3.mode = 30;
                        break;
                      }
                      r3.extra = 15 & C2, r3.mode = 22;
                    case 22:
                      if (r3.extra) {
                        for (N = r3.extra; g2 < N; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        r3.length += b2 & (1 << r3.extra) - 1, b2 >>>= r3.extra, g2 -= r3.extra, r3.back += r3.extra;
                      }
                      r3.was = r3.length, r3.mode = 23;
                    case 23:
                      for (; C2 = (P = r3.distcode[b2 & (1 << r3.distbits) - 1]) >>> 16 & 255, T = 65535 & P, !((M = P >>> 24) <= g2); ) {
                        if (0 === p2) break e;
                        p2--, b2 += u3[f2++] << g2, g2 += 8;
                      }
                      if (0 == (240 & C2)) {
                        for (E = M, A = C2, R = T; C2 = (P = r3.distcode[R + ((b2 & (1 << E + A) - 1) >> E)]) >>> 16 & 255, T = 65535 & P, !(E + (M = P >>> 24) <= g2); ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        b2 >>>= E, g2 -= E, r3.back += E;
                      }
                      if (b2 >>>= M, g2 -= M, r3.back += M, 64 & C2) {
                        e3.msg = "invalid distance code", r3.mode = 30;
                        break;
                      }
                      r3.offset = T, r3.extra = 15 & C2, r3.mode = 24;
                    case 24:
                      if (r3.extra) {
                        for (N = r3.extra; g2 < N; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        r3.offset += b2 & (1 << r3.extra) - 1, b2 >>>= r3.extra, g2 -= r3.extra, r3.back += r3.extra;
                      }
                      if (r3.offset > r3.dmax) {
                        e3.msg = "invalid distance too far back", r3.mode = 30;
                        break;
                      }
                      r3.mode = 25;
                    case 25:
                      if (0 === m2) break e;
                      if (x = _ - m2, r3.offset > x) {
                        if ((x = r3.offset - x) > r3.whave && r3.sane) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break;
                        }
                        k = x > r3.wnext ? (x -= r3.wnext, r3.wsize - x) : r3.wnext - x, x > r3.length && (x = r3.length), S = r3.window;
                      } else S = h2, k = d2 - r3.offset, x = r3.length;
                      for (m2 < x && (x = m2), m2 -= x, r3.length -= x; h2[d2++] = S[k++], --x; ) ;
                      0 === r3.length && (r3.mode = 21);
                      break;
                    case 26:
                      if (0 === m2) break e;
                      h2[d2++] = r3.length, m2--, r3.mode = 21;
                      break;
                    case 27:
                      if (r3.wrap) {
                        for (; g2 < 32; ) {
                          if (0 === p2) break e;
                          p2--, b2 |= u3[f2++] << g2, g2 += 8;
                        }
                        if (_ -= m2, e3.total_out += _, r3.total += _, _ && (e3.adler = r3.check = r3.flags ? s2(r3.check, h2, _, d2 - _) : i2(r3.check, h2, _, d2 - _)), _ = m2, (r3.flags ? b2 : c2(b2)) !== r3.check) {
                          e3.msg = "incorrect data check", r3.mode = 30;
                          break;
                        }
                        g2 = b2 = 0;
                      }
                      r3.mode = 28;
                    case 28:
                      if (r3.wrap && r3.flags) {
                        for (; g2 < 32; ) {
                          if (0 === p2) break e;
                          p2--, b2 += u3[f2++] << g2, g2 += 8;
                        }
                        if (b2 !== (4294967295 & r3.total)) {
                          e3.msg = "incorrect length check", r3.mode = 30;
                          break;
                        }
                        g2 = b2 = 0;
                      }
                      r3.mode = 29;
                    case 29:
                      j = 1;
                      break e;
                    case 30:
                      j = -3;
                      break e;
                    case 31:
                      return -4;
                    case 32:
                    default:
                      return l2;
                  }
                  return e3.next_out = d2, e3.avail_out = m2, e3.next_in = f2, e3.avail_in = p2, r3.hold = b2, r3.bits = g2, (r3.wsize || _ !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t4)) && v(e3, e3.output, e3.next_out, _ - e3.avail_out) ? (r3.mode = 31, -4) : (w -= e3.avail_in, _ -= e3.avail_out, e3.total_in += w, e3.total_out += _, r3.total += _, r3.wrap && _ && (e3.adler = r3.check = r3.flags ? s2(r3.check, h2, _, e3.next_out - _) : i2(r3.check, h2, _, e3.next_out - _)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == w && 0 === _ || 4 === t4) && 0 === j && (j = -5), j);
                }, r2.inflateEnd = function(e3) {
                  if (!e3 || !e3.state) return l2;
                  var t4 = e3.state;
                  return t4.window && (t4.window = null), e3.state = null, 0;
                }, r2.inflateGetHeader = function(e3, t4) {
                  var r3;
                  return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? l2 : ((r3.head = t4).done = false, 0) : l2;
                }, r2.inflateSetDictionary = function(e3, t4) {
                  var r3, n3 = t4.length;
                  return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? l2 : 11 === r3.mode && i2(1, t4, n3, 0) !== r3.check ? -3 : v(e3, t4, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, 0) : l2;
                }, r2.inflateInfo = "pako inflate (from Nodeca project)";
              }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t3, r2) {
                var n2 = e2("../utils/common"), i2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], o2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                t3.exports = function(e3, t4, r3, l2, c2, u2, h, f) {
                  var d, p, m, b, g, y, v, w, _, x = f.bits, k = 0, S = 0, M = 0, C2 = 0, T = 0, E = 0, A = 0, R = 0, O = 0, j = 0, I = null, N = 0, P = new n2.Buf16(16), B = new n2.Buf16(16), D = null, F = 0;
                  for (k = 0; k <= 15; k++) P[k] = 0;
                  for (S = 0; S < l2; S++) P[t4[r3 + S]]++;
                  for (T = x, C2 = 15; 1 <= C2 && 0 === P[C2]; C2--) ;
                  if (C2 < T && (T = C2), 0 === C2) return c2[u2++] = 20971520, c2[u2++] = 20971520, f.bits = 1, 0;
                  for (M = 1; M < C2 && 0 === P[M]; M++) ;
                  for (T < M && (T = M), k = R = 1; k <= 15; k++) if (R <<= 1, (R -= P[k]) < 0) return -1;
                  if (0 < R && (0 === e3 || 1 !== C2)) return -1;
                  for (B[1] = 0, k = 1; k < 15; k++) B[k + 1] = B[k] + P[k];
                  for (S = 0; S < l2; S++) 0 !== t4[r3 + S] && (h[B[t4[r3 + S]]++] = S);
                  if (y = 0 === e3 ? (I = D = h, 19) : 1 === e3 ? (I = i2, N -= 257, D = s2, F -= 257, 256) : (I = o2, D = a2, -1), k = M, g = u2, A = S = j = 0, m = -1, b = (O = 1 << (E = T)) - 1, 1 === e3 && 852 < O || 2 === e3 && 592 < O) return 1;
                  for (; ; ) {
                    for (v = k - A, _ = h[S] < y ? (w = 0, h[S]) : h[S] > y ? (w = D[F + h[S]], I[N + h[S]]) : (w = 96, 0), d = 1 << k - A, M = p = 1 << E; c2[g + (j >> A) + (p -= d)] = v << 24 | w << 16 | _ | 0, 0 !== p; ) ;
                    for (d = 1 << k - 1; j & d; ) d >>= 1;
                    if (0 !== d ? (j &= d - 1, j += d) : j = 0, S++, 0 == --P[k]) {
                      if (k === C2) break;
                      k = t4[r3 + h[S]];
                    }
                    if (T < k && (j & b) !== m) {
                      for (0 === A && (A = T), g += M, R = 1 << (E = k - A); E + A < C2 && !((R -= P[E + A]) <= 0); ) E++, R <<= 1;
                      if (O += 1 << E, 1 === e3 && 852 < O || 2 === e3 && 592 < O) return 1;
                      c2[m = j & b] = T << 24 | E << 16 | g - u2 | 0;
                    }
                  }
                  return 0 !== j && (c2[g + j] = k - A << 24 | 64 << 16 | 0), f.bits = T, 0;
                };
              }, { "../utils/common": 41 }], 51: [function(e2, t3, r2) {
                t3.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
              }, {}], 52: [function(e2, t3, r2) {
                var n2 = e2("../utils/common");
                function i2(e3) {
                  for (var t4 = e3.length; 0 <= --t4; ) e3[t4] = 0;
                }
                var s2 = 256, o2 = 286, a2 = 30, l2 = 15, c2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], u2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], f = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], d = new Array(576);
                i2(d);
                var p = new Array(60);
                i2(p);
                var m = new Array(512);
                i2(m);
                var b = new Array(256);
                i2(b);
                var g = new Array(29);
                i2(g);
                var y, v, w, _ = new Array(a2);
                function x(e3, t4, r3, n3, i3) {
                  this.static_tree = e3, this.extra_bits = t4, this.extra_base = r3, this.elems = n3, this.max_length = i3, this.has_stree = e3 && e3.length;
                }
                function k(e3, t4) {
                  this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t4;
                }
                function S(e3) {
                  return e3 < 256 ? m[e3] : m[256 + (e3 >>> 7)];
                }
                function M(e3, t4) {
                  e3.pending_buf[e3.pending++] = 255 & t4, e3.pending_buf[e3.pending++] = t4 >>> 8 & 255;
                }
                function C2(e3, t4, r3) {
                  e3.bi_valid > 16 - r3 ? (e3.bi_buf |= t4 << e3.bi_valid & 65535, M(e3, e3.bi_buf), e3.bi_buf = t4 >> 16 - e3.bi_valid, e3.bi_valid += r3 - 16) : (e3.bi_buf |= t4 << e3.bi_valid & 65535, e3.bi_valid += r3);
                }
                function T(e3, t4, r3) {
                  C2(e3, r3[2 * t4], r3[2 * t4 + 1]);
                }
                function E(e3, t4) {
                  for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t4; ) ;
                  return r3 >>> 1;
                }
                function A(e3, t4, r3) {
                  var n3, i3, s3 = new Array(16), o3 = 0;
                  for (n3 = 1; n3 <= l2; n3++) s3[n3] = o3 = o3 + r3[n3 - 1] << 1;
                  for (i3 = 0; i3 <= t4; i3++) {
                    var a3 = e3[2 * i3 + 1];
                    0 !== a3 && (e3[2 * i3] = E(s3[a3]++, a3));
                  }
                }
                function R(e3) {
                  var t4;
                  for (t4 = 0; t4 < o2; t4++) e3.dyn_ltree[2 * t4] = 0;
                  for (t4 = 0; t4 < a2; t4++) e3.dyn_dtree[2 * t4] = 0;
                  for (t4 = 0; t4 < 19; t4++) e3.bl_tree[2 * t4] = 0;
                  e3.dyn_ltree[512] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
                }
                function O(e3) {
                  8 < e3.bi_valid ? M(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
                }
                function j(e3, t4, r3, n3) {
                  var i3 = 2 * t4, s3 = 2 * r3;
                  return e3[i3] < e3[s3] || e3[i3] === e3[s3] && n3[t4] <= n3[r3];
                }
                function I(e3, t4, r3) {
                  for (var n3 = e3.heap[r3], i3 = r3 << 1; i3 <= e3.heap_len && (i3 < e3.heap_len && j(t4, e3.heap[i3 + 1], e3.heap[i3], e3.depth) && i3++, !j(t4, n3, e3.heap[i3], e3.depth)); ) e3.heap[r3] = e3.heap[i3], r3 = i3, i3 <<= 1;
                  e3.heap[r3] = n3;
                }
                function N(e3, t4, r3) {
                  var n3, i3, o3, a3, l3 = 0;
                  if (0 !== e3.last_lit) for (; n3 = e3.pending_buf[e3.d_buf + 2 * l3] << 8 | e3.pending_buf[e3.d_buf + 2 * l3 + 1], i3 = e3.pending_buf[e3.l_buf + l3], l3++, 0 === n3 ? T(e3, i3, t4) : (T(e3, (o3 = b[i3]) + s2 + 1, t4), 0 !== (a3 = c2[o3]) && C2(e3, i3 -= g[o3], a3), T(e3, o3 = S(--n3), r3), 0 !== (a3 = u2[o3]) && C2(e3, n3 -= _[o3], a3)), l3 < e3.last_lit; ) ;
                  T(e3, 256, t4);
                }
                function P(e3, t4) {
                  var r3, n3, i3, s3 = t4.dyn_tree, o3 = t4.stat_desc.static_tree, a3 = t4.stat_desc.has_stree, c3 = t4.stat_desc.elems, u3 = -1;
                  for (e3.heap_len = 0, e3.heap_max = 573, r3 = 0; r3 < c3; r3++) 0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
                  for (; e3.heap_len < 2; ) s3[2 * (i3 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i3] = 0, e3.opt_len--, a3 && (e3.static_len -= o3[2 * i3 + 1]);
                  for (t4.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--) I(e3, s3, r3);
                  for (i3 = c3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], I(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i3] = s3[2 * r3] + s3[2 * n3], e3.depth[i3] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i3, e3.heap[1] = i3++, I(e3, s3, 1), 2 <= e3.heap_len; ) ;
                  e3.heap[--e3.heap_max] = e3.heap[1], (function(e4, t5) {
                    var r4, n4, i4, s4, o4, a4, c4 = t5.dyn_tree, u4 = t5.max_code, h2 = t5.stat_desc.static_tree, f2 = t5.stat_desc.has_stree, d2 = t5.stat_desc.extra_bits, p2 = t5.stat_desc.extra_base, m2 = t5.stat_desc.max_length, b2 = 0;
                    for (s4 = 0; s4 <= l2; s4++) e4.bl_count[s4] = 0;
                    for (c4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < 573; r4++) m2 < (s4 = c4[2 * c4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = m2, b2++), c4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, o4 = 0, p2 <= n4 && (o4 = d2[n4 - p2]), a4 = c4[2 * n4], e4.opt_len += a4 * (s4 + o4), f2 && (e4.static_len += a4 * (h2[2 * n4 + 1] + o4)));
                    if (0 !== b2) {
                      do {
                        for (s4 = m2 - 1; 0 === e4.bl_count[s4]; ) s4--;
                        e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[m2]--, b2 -= 2;
                      } while (0 < b2);
                      for (s4 = m2; 0 !== s4; s4--) for (n4 = e4.bl_count[s4]; 0 !== n4; ) u4 < (i4 = e4.heap[--r4]) || (c4[2 * i4 + 1] !== s4 && (e4.opt_len += (s4 - c4[2 * i4 + 1]) * c4[2 * i4], c4[2 * i4 + 1] = s4), n4--);
                    }
                  })(e3, t4), A(s3, u3, e3.bl_count);
                }
                function B(e3, t4, r3) {
                  var n3, i3, s3 = -1, o3 = t4[1], a3 = 0, l3 = 7, c3 = 4;
                  for (0 === o3 && (l3 = 138, c3 = 3), t4[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++) i3 = o3, o3 = t4[2 * (n3 + 1) + 1], ++a3 < l3 && i3 === o3 || (a3 < c3 ? e3.bl_tree[2 * i3] += a3 : 0 !== i3 ? (i3 !== s3 && e3.bl_tree[2 * i3]++, e3.bl_tree[32]++) : a3 <= 10 ? e3.bl_tree[34]++ : e3.bl_tree[36]++, s3 = i3, c3 = (a3 = 0) === o3 ? (l3 = 138, 3) : i3 === o3 ? (l3 = 6, 3) : (l3 = 7, 4));
                }
                function D(e3, t4, r3) {
                  var n3, i3, s3 = -1, o3 = t4[1], a3 = 0, l3 = 7, c3 = 4;
                  for (0 === o3 && (l3 = 138, c3 = 3), n3 = 0; n3 <= r3; n3++) if (i3 = o3, o3 = t4[2 * (n3 + 1) + 1], !(++a3 < l3 && i3 === o3)) {
                    if (a3 < c3) for (; T(e3, i3, e3.bl_tree), 0 != --a3; ) ;
                    else 0 !== i3 ? (i3 !== s3 && (T(e3, i3, e3.bl_tree), a3--), T(e3, 16, e3.bl_tree), C2(e3, a3 - 3, 2)) : a3 <= 10 ? (T(e3, 17, e3.bl_tree), C2(e3, a3 - 3, 3)) : (T(e3, 18, e3.bl_tree), C2(e3, a3 - 11, 7));
                    s3 = i3, c3 = (a3 = 0) === o3 ? (l3 = 138, 3) : i3 === o3 ? (l3 = 6, 3) : (l3 = 7, 4);
                  }
                }
                i2(_);
                var F = false;
                function L(e3, t4, r3, i3) {
                  C2(e3, 0 + (i3 ? 1 : 0), 3), (function(e4, t5, r4, i4) {
                    O(e4), M(e4, r4), M(e4, ~r4), n2.arraySet(e4.pending_buf, e4.window, t5, r4, e4.pending), e4.pending += r4;
                  })(e3, t4, r3);
                }
                r2._tr_init = function(e3) {
                  F || ((function() {
                    var e4, t4, r3, n3, i3, s3 = new Array(16);
                    for (n3 = r3 = 0; n3 < 28; n3++) for (g[n3] = r3, e4 = 0; e4 < 1 << c2[n3]; e4++) b[r3++] = n3;
                    for (b[r3 - 1] = n3, n3 = i3 = 0; n3 < 16; n3++) for (_[n3] = i3, e4 = 0; e4 < 1 << u2[n3]; e4++) m[i3++] = n3;
                    for (i3 >>= 7; n3 < a2; n3++) for (_[n3] = i3 << 7, e4 = 0; e4 < 1 << u2[n3] - 7; e4++) m[256 + i3++] = n3;
                    for (t4 = 0; t4 <= l2; t4++) s3[t4] = 0;
                    for (e4 = 0; e4 <= 143; ) d[2 * e4 + 1] = 8, e4++, s3[8]++;
                    for (; e4 <= 255; ) d[2 * e4 + 1] = 9, e4++, s3[9]++;
                    for (; e4 <= 279; ) d[2 * e4 + 1] = 7, e4++, s3[7]++;
                    for (; e4 <= 287; ) d[2 * e4 + 1] = 8, e4++, s3[8]++;
                    for (A(d, 287, s3), e4 = 0; e4 < a2; e4++) p[2 * e4 + 1] = 5, p[2 * e4] = E(e4, 5);
                    y = new x(d, c2, 257, o2, l2), v = new x(p, u2, 0, a2, l2), w = new x(new Array(0), h, 0, 19, 7);
                  })(), F = true), e3.l_desc = new k(e3.dyn_ltree, y), e3.d_desc = new k(e3.dyn_dtree, v), e3.bl_desc = new k(e3.bl_tree, w), e3.bi_buf = 0, e3.bi_valid = 0, R(e3);
                }, r2._tr_stored_block = L, r2._tr_flush_block = function(e3, t4, r3, n3) {
                  var i3, o3, a3 = 0;
                  0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = (function(e4) {
                    var t5, r4 = 4093624447;
                    for (t5 = 0; t5 <= 31; t5++, r4 >>>= 1) if (1 & r4 && 0 !== e4.dyn_ltree[2 * t5]) return 0;
                    if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26]) return 1;
                    for (t5 = 32; t5 < s2; t5++) if (0 !== e4.dyn_ltree[2 * t5]) return 1;
                    return 0;
                  })(e3)), P(e3, e3.l_desc), P(e3, e3.d_desc), a3 = (function(e4) {
                    var t5;
                    for (B(e4, e4.dyn_ltree, e4.l_desc.max_code), B(e4, e4.dyn_dtree, e4.d_desc.max_code), P(e4, e4.bl_desc), t5 = 18; 3 <= t5 && 0 === e4.bl_tree[2 * f[t5] + 1]; t5--) ;
                    return e4.opt_len += 3 * (t5 + 1) + 5 + 5 + 4, t5;
                  })(e3), i3 = e3.opt_len + 3 + 7 >>> 3, (o3 = e3.static_len + 3 + 7 >>> 3) <= i3 && (i3 = o3)) : i3 = o3 = r3 + 5, r3 + 4 <= i3 && -1 !== t4 ? L(e3, t4, r3, n3) : 4 === e3.strategy || o3 === i3 ? (C2(e3, 2 + (n3 ? 1 : 0), 3), N(e3, d, p)) : (C2(e3, 4 + (n3 ? 1 : 0), 3), (function(e4, t5, r4, n4) {
                    var i4;
                    for (C2(e4, t5 - 257, 5), C2(e4, r4 - 1, 5), C2(e4, n4 - 4, 4), i4 = 0; i4 < n4; i4++) C2(e4, e4.bl_tree[2 * f[i4] + 1], 3);
                    D(e4, e4.dyn_ltree, t5 - 1), D(e4, e4.dyn_dtree, r4 - 1);
                  })(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), N(e3, e3.dyn_ltree, e3.dyn_dtree)), R(e3), n3 && O(e3);
                }, r2._tr_tally = function(e3, t4, r3) {
                  return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t4 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t4, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t4 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t4--, e3.dyn_ltree[2 * (b[r3] + s2 + 1)]++, e3.dyn_dtree[2 * S(t4)]++), e3.last_lit === e3.lit_bufsize - 1;
                }, r2._tr_align = function(e3) {
                  C2(e3, 2, 3), T(e3, 256, d), (function(e4) {
                    16 === e4.bi_valid ? (M(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
                  })(e3);
                };
              }, { "../utils/common": 41 }], 53: [function(e2, t3, r2) {
                t3.exports = function() {
                  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                };
              }, {}], 54: [function(e2, t3, r2) {
                (function(e3) {
                  !(function(e4, t4) {
                    if (!e4.setImmediate) {
                      var r3, i2, s2, o2, a2 = 1, l2 = {}, c2 = false, u2 = e4.document, h = Object.getPrototypeOf && Object.getPrototypeOf(e4);
                      h = h && h.setTimeout ? h : e4, r3 = "[object process]" === {}.toString.call(e4.process) ? function(e5) {
                        n.nextTick((function() {
                          d(e5);
                        }));
                      } : (function() {
                        if (e4.postMessage && !e4.importScripts) {
                          var t5 = true, r4 = e4.onmessage;
                          return e4.onmessage = function() {
                            t5 = false;
                          }, e4.postMessage("", "*"), e4.onmessage = r4, t5;
                        }
                      })() ? (o2 = "setImmediate$" + Math.random() + "$", e4.addEventListener ? e4.addEventListener("message", p, false) : e4.attachEvent("onmessage", p), function(t5) {
                        e4.postMessage(o2 + t5, "*");
                      }) : e4.MessageChannel ? ((s2 = new MessageChannel()).port1.onmessage = function(e5) {
                        d(e5.data);
                      }, function(e5) {
                        s2.port2.postMessage(e5);
                      }) : u2 && "onreadystatechange" in u2.createElement("script") ? (i2 = u2.documentElement, function(e5) {
                        var t5 = u2.createElement("script");
                        t5.onreadystatechange = function() {
                          d(e5), t5.onreadystatechange = null, i2.removeChild(t5), t5 = null;
                        }, i2.appendChild(t5);
                      }) : function(e5) {
                        setTimeout(d, 0, e5);
                      }, h.setImmediate = function(e5) {
                        "function" != typeof e5 && (e5 = new Function("" + e5));
                        for (var t5 = new Array(arguments.length - 1), n2 = 0; n2 < t5.length; n2++) t5[n2] = arguments[n2 + 1];
                        var i3 = { callback: e5, args: t5 };
                        return l2[a2] = i3, r3(a2), a2++;
                      }, h.clearImmediate = f;
                    }
                    function f(e5) {
                      delete l2[e5];
                    }
                    function d(e5) {
                      if (c2) setTimeout(d, 0, e5);
                      else {
                        var t5 = l2[e5];
                        if (t5) {
                          c2 = true;
                          try {
                            !(function(e6) {
                              var t6 = e6.callback, r4 = e6.args;
                              switch (r4.length) {
                                case 0:
                                  t6();
                                  break;
                                case 1:
                                  t6(r4[0]);
                                  break;
                                case 2:
                                  t6(r4[0], r4[1]);
                                  break;
                                case 3:
                                  t6(r4[0], r4[1], r4[2]);
                                  break;
                                default:
                                  t6.apply(void 0, r4);
                              }
                            })(t5);
                          } finally {
                            f(e5), c2 = false;
                          }
                        }
                      }
                    }
                    function p(t5) {
                      t5.source === e4 && "string" == typeof t5.data && 0 === t5.data.indexOf(o2) && d(+t5.data.slice(o2.length));
                    }
                  })("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
                }).call(this, void 0 !== i ? i : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
              }, {}] }, {}, [10])(10);
            }));
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], e("timers").setImmediate);
      }, { _process: 467, buffer: 220, timers: 523 }], 442: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var r2 = /[\\^$.*+?()[\]{}|]/g, n = RegExp(r2.source), i = "object" == typeof e2 && e2 && e2.Object === Object && e2, s = "object" == typeof self && self && self.Object === Object && self, o = i || s || Function("return this")(), a = Object.prototype.toString, l = o.Symbol, c = l ? l.prototype : void 0, u = c ? c.toString : void 0;
            function h(e3) {
              if ("string" == typeof e3) return e3;
              if ((function(e4) {
                return "symbol" == typeof e4 || /* @__PURE__ */ (function(e5) {
                  return !!e5 && "object" == typeof e5;
                })(e4) && "[object Symbol]" == a.call(e4);
              })(e3)) return u ? u.call(e3) : "";
              var t3 = e3 + "";
              return "0" == t3 && 1 / e3 == -1 / 0 ? "-0" : t3;
            }
            t2.exports = function(e3) {
              var t3;
              return (e3 = null == (t3 = e3) ? "" : h(t3)) && n.test(e3) ? e3.replace(r2, "\\$&") : e3;
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 443: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var n = "[object Arguments]", i = "[object Map]", s = "[object Object]", o = "[object Set]", a = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, l = /^\w*$/, c = /^\./, u = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, h = /\\(\\)?/g, f = /^\[object .+?Constructor\]$/, d = /^(?:0|[1-9]\d*)$/, p = {};
            p["[object Float32Array]"] = p["[object Float64Array]"] = p["[object Int8Array]"] = p["[object Int16Array]"] = p["[object Int32Array]"] = p["[object Uint8Array]"] = p["[object Uint8ClampedArray]"] = p["[object Uint16Array]"] = p["[object Uint32Array]"] = true, p[n] = p["[object Array]"] = p["[object ArrayBuffer]"] = p["[object Boolean]"] = p["[object DataView]"] = p["[object Date]"] = p["[object Error]"] = p["[object Function]"] = p[i] = p["[object Number]"] = p[s] = p["[object RegExp]"] = p[o] = p["[object String]"] = p["[object WeakMap]"] = false;
            var m = "object" == typeof e2 && e2 && e2.Object === Object && e2, b = "object" == typeof self && self && self.Object === Object && self, g = m || b || Function("return this")(), y = "object" == typeof r && r && !r.nodeType && r, v = y && "object" == typeof t2 && t2 && !t2.nodeType && t2, w = v && v.exports === y && m.process, _ = (function() {
              try {
                return w && w.binding("util");
              } catch (e3) {
              }
            })(), x = _ && _.isTypedArray;
            function k(e3, t3, r2, n2) {
              for (var i2 = -1, s2 = e3 ? e3.length : 0; ++i2 < s2; ) {
                var o2 = e3[i2];
                t3(n2, o2, r2(o2), e3);
              }
              return n2;
            }
            function S(e3, t3) {
              for (var r2 = -1, n2 = e3 ? e3.length : 0; ++r2 < n2; ) if (t3(e3[r2], r2, e3)) return true;
              return false;
            }
            function M(e3) {
              var t3 = false;
              if (null != e3 && "function" != typeof e3.toString) try {
                t3 = !!(e3 + "");
              } catch (e4) {
              }
              return t3;
            }
            function C2(e3) {
              var t3 = -1, r2 = Array(e3.size);
              return e3.forEach((function(e4, n2) {
                r2[++t3] = [n2, e4];
              })), r2;
            }
            function T(e3) {
              var t3 = -1, r2 = Array(e3.size);
              return e3.forEach((function(e4) {
                r2[++t3] = e4;
              })), r2;
            }
            var E, A, R, O = Array.prototype, j = Function.prototype, I = Object.prototype, N = g["__core-js_shared__"], P = (E = /[^.]+$/.exec(N && N.keys && N.keys.IE_PROTO || "")) ? "Symbol(src)_1." + E : "", B = j.toString, D = I.hasOwnProperty, F = I.toString, L = RegExp("^" + B.call(D).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), z = g.Symbol, U = g.Uint8Array, $ = I.propertyIsEnumerable, H = O.splice, V = (A = Object.keys, R = Object, function(e3) {
              return A(R(e3));
            }), q = Ce(g, "DataView"), W = Ce(g, "Map"), X = Ce(g, "Promise"), K = Ce(g, "Set"), Y = Ce(g, "WeakMap"), Z = Ce(Object, "create"), G = Ne(q), J = Ne(W), Q = Ne(X), ee = Ne(K), te = Ne(Y), re = z ? z.prototype : void 0, ne = re ? re.valueOf : void 0, ie2 = re ? re.toString : void 0;
            function se(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function oe(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function ae(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function le(e3) {
              var t3 = -1, r2 = e3 ? e3.length : 0;
              for (this.__data__ = new ae(); ++t3 < r2; ) this.add(e3[t3]);
            }
            function ce(e3) {
              this.__data__ = new oe(e3);
            }
            function ue(e3, t3) {
              var r2 = Ue(e3) || ze(e3) ? (function(e4, t4) {
                for (var r3 = -1, n3 = Array(e4); ++r3 < e4; ) n3[r3] = t4(r3);
                return n3;
              })(e3.length, String) : [], n2 = r2.length, i2 = !!n2;
              for (var s2 in e3) !D.call(e3, s2) || i2 && ("length" == s2 || Ee(s2, n2)) || r2.push(s2);
              return r2;
            }
            function he(e3, t3) {
              for (var r2 = e3.length; r2--; ) if (Le(e3[r2][0], t3)) return r2;
              return -1;
            }
            function fe(e3, t3, r2, n2) {
              return me(e3, (function(e4, i2, s2) {
                t3(n2, e4, r2(e4), s2);
              })), n2;
            }
            se.prototype.clear = function() {
              this.__data__ = Z ? Z(null) : {};
            }, se.prototype.delete = function(e3) {
              return this.has(e3) && delete this.__data__[e3];
            }, se.prototype.get = function(e3) {
              var t3 = this.__data__;
              if (Z) {
                var r2 = t3[e3];
                return "__lodash_hash_undefined__" === r2 ? void 0 : r2;
              }
              return D.call(t3, e3) ? t3[e3] : void 0;
            }, se.prototype.has = function(e3) {
              var t3 = this.__data__;
              return Z ? void 0 !== t3[e3] : D.call(t3, e3);
            }, se.prototype.set = function(e3, t3) {
              return this.__data__[e3] = Z && void 0 === t3 ? "__lodash_hash_undefined__" : t3, this;
            }, oe.prototype.clear = function() {
              this.__data__ = [];
            }, oe.prototype.delete = function(e3) {
              var t3 = this.__data__, r2 = he(t3, e3);
              return !(r2 < 0) && (r2 == t3.length - 1 ? t3.pop() : H.call(t3, r2, 1), true);
            }, oe.prototype.get = function(e3) {
              var t3 = this.__data__, r2 = he(t3, e3);
              return r2 < 0 ? void 0 : t3[r2][1];
            }, oe.prototype.has = function(e3) {
              return he(this.__data__, e3) > -1;
            }, oe.prototype.set = function(e3, t3) {
              var r2 = this.__data__, n2 = he(r2, e3);
              return n2 < 0 ? r2.push([e3, t3]) : r2[n2][1] = t3, this;
            }, ae.prototype.clear = function() {
              this.__data__ = { hash: new se(), map: new (W || oe)(), string: new se() };
            }, ae.prototype.delete = function(e3) {
              return Me(this, e3).delete(e3);
            }, ae.prototype.get = function(e3) {
              return Me(this, e3).get(e3);
            }, ae.prototype.has = function(e3) {
              return Me(this, e3).has(e3);
            }, ae.prototype.set = function(e3, t3) {
              return Me(this, e3).set(e3, t3), this;
            }, le.prototype.add = le.prototype.push = function(e3) {
              return this.__data__.set(e3, "__lodash_hash_undefined__"), this;
            }, le.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, ce.prototype.clear = function() {
              this.__data__ = new oe();
            }, ce.prototype.delete = function(e3) {
              return this.__data__.delete(e3);
            }, ce.prototype.get = function(e3) {
              return this.__data__.get(e3);
            }, ce.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, ce.prototype.set = function(e3, t3) {
              var r2 = this.__data__;
              if (r2 instanceof oe) {
                var n2 = r2.__data__;
                if (!W || n2.length < 199) return n2.push([e3, t3]), this;
                r2 = this.__data__ = new ae(n2);
              }
              return r2.set(e3, t3), this;
            };
            var de, me = (de = function(e3, t3) {
              return e3 && be(e3, t3, Ye);
            }, function(e3, t3) {
              if (null == e3) return e3;
              if (!$e(e3)) return de(e3, t3);
              for (var r2 = e3.length, n2 = -1, i2 = Object(e3); ++n2 < r2 && false !== t3(i2[n2], n2, i2); ) ;
              return e3;
            }), be = /* @__PURE__ */ (function(e3) {
              return function(t3, r2, n2) {
                for (var i2 = -1, s2 = Object(t3), o2 = n2(t3), a2 = o2.length; a2--; ) {
                  var l2 = o2[++i2];
                  if (false === r2(s2[l2], l2, s2)) break;
                }
                return t3;
              };
            })();
            function ge(e3, t3) {
              for (var r2 = 0, n2 = (t3 = Ae(t3, e3) ? [t3] : ke(t3)).length; null != e3 && r2 < n2; ) e3 = e3[Ie(t3[r2++])];
              return r2 && r2 == n2 ? e3 : void 0;
            }
            function ye(e3, t3) {
              return null != e3 && t3 in Object(e3);
            }
            function ve(e3, t3, r2, a2, l2) {
              return e3 === t3 || (null == e3 || null == t3 || !qe(e3) && !We(t3) ? e3 != e3 && t3 != t3 : (function(e4, t4, r3, a3, l3, c2) {
                var u2 = Ue(e4), h2 = Ue(t4), f2 = "[object Array]", d2 = "[object Array]";
                u2 || (f2 = (f2 = Te(e4)) == n ? s : f2);
                h2 || (d2 = (d2 = Te(t4)) == n ? s : d2);
                var p2 = f2 == s && !M(e4), m2 = d2 == s && !M(t4), b2 = f2 == d2;
                if (b2 && !p2) return c2 || (c2 = new ce()), u2 || Ke(e4) ? Se(e4, t4, r3, a3, l3, c2) : (function(e5, t5, r4, n2, s2, a4, l4) {
                  switch (r4) {
                    case "[object DataView]":
                      if (e5.byteLength != t5.byteLength || e5.byteOffset != t5.byteOffset) return false;
                      e5 = e5.buffer, t5 = t5.buffer;
                    case "[object ArrayBuffer]":
                      return !(e5.byteLength != t5.byteLength || !n2(new U(e5), new U(t5)));
                    case "[object Boolean]":
                    case "[object Date]":
                    case "[object Number]":
                      return Le(+e5, +t5);
                    case "[object Error]":
                      return e5.name == t5.name && e5.message == t5.message;
                    case "[object RegExp]":
                    case "[object String]":
                      return e5 == t5 + "";
                    case i:
                      var c3 = C2;
                    case o:
                      var u3 = 2 & a4;
                      if (c3 || (c3 = T), e5.size != t5.size && !u3) return false;
                      var h3 = l4.get(e5);
                      if (h3) return h3 == t5;
                      a4 |= 1, l4.set(e5, t5);
                      var f3 = Se(c3(e5), c3(t5), n2, s2, a4, l4);
                      return l4.delete(e5), f3;
                    case "[object Symbol]":
                      if (ne) return ne.call(e5) == ne.call(t5);
                  }
                  return false;
                })(e4, t4, f2, r3, a3, l3, c2);
                if (!(2 & l3)) {
                  var g2 = p2 && D.call(e4, "__wrapped__"), y2 = m2 && D.call(t4, "__wrapped__");
                  if (g2 || y2) {
                    var v2 = g2 ? e4.value() : e4, w2 = y2 ? t4.value() : t4;
                    return c2 || (c2 = new ce()), r3(v2, w2, a3, l3, c2);
                  }
                }
                if (!b2) return false;
                return c2 || (c2 = new ce()), (function(e5, t5, r4, n2, i2, s2) {
                  var o2 = 2 & i2, a4 = Ye(e5), l4 = a4.length, c3 = Ye(t5).length;
                  if (l4 != c3 && !o2) return false;
                  var u3 = l4;
                  for (; u3--; ) {
                    var h3 = a4[u3];
                    if (!(o2 ? h3 in t5 : D.call(t5, h3))) return false;
                  }
                  var f3 = s2.get(e5);
                  if (f3 && s2.get(t5)) return f3 == t5;
                  var d3 = true;
                  s2.set(e5, t5), s2.set(t5, e5);
                  var p3 = o2;
                  for (; ++u3 < l4; ) {
                    h3 = a4[u3];
                    var m3 = e5[h3], b3 = t5[h3];
                    if (n2) var g3 = o2 ? n2(b3, m3, h3, t5, e5, s2) : n2(m3, b3, h3, e5, t5, s2);
                    if (!(void 0 === g3 ? m3 === b3 || r4(m3, b3, n2, i2, s2) : g3)) {
                      d3 = false;
                      break;
                    }
                    p3 || (p3 = "constructor" == h3);
                  }
                  if (d3 && !p3) {
                    var y3 = e5.constructor, v3 = t5.constructor;
                    y3 == v3 || !("constructor" in e5) || !("constructor" in t5) || "function" == typeof y3 && y3 instanceof y3 && "function" == typeof v3 && v3 instanceof v3 || (d3 = false);
                  }
                  return s2.delete(e5), s2.delete(t5), d3;
                })(e4, t4, r3, a3, l3, c2);
              })(e3, t3, ve, r2, a2, l2));
            }
            function we(e3) {
              return !(!qe(e3) || (function(e4) {
                return !!P && P in e4;
              })(e3)) && (He(e3) || M(e3) ? L : f).test(Ne(e3));
            }
            function _e(e3) {
              return "function" == typeof e3 ? e3 : null == e3 ? Ze : "object" == typeof e3 ? Ue(e3) ? (function(e4, t4) {
                if (Ae(e4) && Re(t4)) return Oe(Ie(e4), t4);
                return function(r3) {
                  var n2 = (function(e5, t5, r4) {
                    var n3 = null == e5 ? void 0 : ge(e5, t5);
                    return void 0 === n3 ? r4 : n3;
                  })(r3, e4);
                  return void 0 === n2 && n2 === t4 ? (function(e5, t5) {
                    return null != e5 && (function(e6, t6, r4) {
                      t6 = Ae(t6, e6) ? [t6] : ke(t6);
                      var n3, i2 = -1, s2 = t6.length;
                      for (; ++i2 < s2; ) {
                        var o2 = Ie(t6[i2]);
                        if (!(n3 = null != e6 && r4(e6, o2))) break;
                        e6 = e6[o2];
                      }
                      if (n3) return n3;
                      return !!(s2 = e6 ? e6.length : 0) && Ve(s2) && Ee(o2, s2) && (Ue(e6) || ze(e6));
                    })(e5, t5, ye);
                  })(r3, e4) : ve(t4, n2, void 0, 3);
                };
              })(e3[0], e3[1]) : (function(e4) {
                var t4 = (function(e5) {
                  var t5 = Ye(e5), r3 = t5.length;
                  for (; r3--; ) {
                    var n2 = t5[r3], i2 = e5[n2];
                    t5[r3] = [n2, i2, Re(i2)];
                  }
                  return t5;
                })(e4);
                if (1 == t4.length && t4[0][2]) return Oe(t4[0][0], t4[0][1]);
                return function(r3) {
                  return r3 === e4 || (function(e5, t5, r4, n2) {
                    var i2 = r4.length, s2 = i2;
                    if (null == e5) return !s2;
                    for (e5 = Object(e5); i2--; ) {
                      var a2 = r4[i2];
                      if (a2[2] ? a2[1] !== e5[a2[0]] : !(a2[0] in e5)) return false;
                    }
                    for (; ++i2 < s2; ) {
                      var l2 = (a2 = r4[i2])[0], c2 = e5[l2], u2 = a2[1];
                      if (a2[2]) {
                        if (void 0 === c2 && !(l2 in e5)) return false;
                      } else {
                        var h2 = new ce();
                        var f2;
                        if (!(void 0 === f2 ? ve(u2, c2, n2, 3, h2) : f2)) return false;
                      }
                    }
                    return true;
                  })(r3, e4, t4);
                };
              })(e3) : Ae(t3 = e3) ? (r2 = Ie(t3), function(e4) {
                return null == e4 ? void 0 : e4[r2];
              }) : /* @__PURE__ */ (function(e4) {
                return function(t4) {
                  return ge(t4, e4);
                };
              })(t3);
              var t3, r2;
            }
            function xe(e3) {
              if (r2 = (t3 = e3) && t3.constructor, n2 = "function" == typeof r2 && r2.prototype || I, t3 !== n2) return V(e3);
              var t3, r2, n2, i2 = [];
              for (var s2 in Object(e3)) D.call(e3, s2) && "constructor" != s2 && i2.push(s2);
              return i2;
            }
            function ke(e3) {
              return Ue(e3) ? e3 : je(e3);
            }
            function Se(e3, t3, r2, n2, i2, s2) {
              var o2 = 2 & i2, a2 = e3.length, l2 = t3.length;
              if (a2 != l2 && !(o2 && l2 > a2)) return false;
              var c2 = s2.get(e3);
              if (c2 && s2.get(t3)) return c2 == t3;
              var u2 = -1, h2 = true, f2 = 1 & i2 ? new le() : void 0;
              for (s2.set(e3, t3), s2.set(t3, e3); ++u2 < a2; ) {
                var d2 = e3[u2], p2 = t3[u2];
                if (n2) var m2 = o2 ? n2(p2, d2, u2, t3, e3, s2) : n2(d2, p2, u2, e3, t3, s2);
                if (void 0 !== m2) {
                  if (m2) continue;
                  h2 = false;
                  break;
                }
                if (f2) {
                  if (!S(t3, (function(e4, t4) {
                    if (!f2.has(t4) && (d2 === e4 || r2(d2, e4, n2, i2, s2))) return f2.add(t4);
                  }))) {
                    h2 = false;
                    break;
                  }
                } else if (d2 !== p2 && !r2(d2, p2, n2, i2, s2)) {
                  h2 = false;
                  break;
                }
              }
              return s2.delete(e3), s2.delete(t3), h2;
            }
            function Me(e3, t3) {
              var r2, n2, i2 = e3.__data__;
              return ("string" == (n2 = typeof (r2 = t3)) || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== r2 : null === r2) ? i2["string" == typeof t3 ? "string" : "hash"] : i2.map;
            }
            function Ce(e3, t3) {
              var r2 = (function(e4, t4) {
                return null == e4 ? void 0 : e4[t4];
              })(e3, t3);
              return we(r2) ? r2 : void 0;
            }
            var Te = function(e3) {
              return F.call(e3);
            };
            function Ee(e3, t3) {
              return !!(t3 = null == t3 ? 9007199254740991 : t3) && ("number" == typeof e3 || d.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t3;
            }
            function Ae(e3, t3) {
              if (Ue(e3)) return false;
              var r2 = typeof e3;
              return !("number" != r2 && "symbol" != r2 && "boolean" != r2 && null != e3 && !Xe(e3)) || (l.test(e3) || !a.test(e3) || null != t3 && e3 in Object(t3));
            }
            function Re(e3) {
              return e3 == e3 && !qe(e3);
            }
            function Oe(e3, t3) {
              return function(r2) {
                return null != r2 && (r2[e3] === t3 && (void 0 !== t3 || e3 in Object(r2)));
              };
            }
            (q && "[object DataView]" != Te(new q(new ArrayBuffer(1))) || W && Te(new W()) != i || X && "[object Promise]" != Te(X.resolve()) || K && Te(new K()) != o || Y && "[object WeakMap]" != Te(new Y())) && (Te = function(e3) {
              var t3 = F.call(e3), r2 = t3 == s ? e3.constructor : void 0, n2 = r2 ? Ne(r2) : void 0;
              if (n2) switch (n2) {
                case G:
                  return "[object DataView]";
                case J:
                  return i;
                case Q:
                  return "[object Promise]";
                case ee:
                  return o;
                case te:
                  return "[object WeakMap]";
              }
              return t3;
            });
            var je = Fe((function(e3) {
              var t3;
              e3 = null == (t3 = e3) ? "" : (function(e4) {
                if ("string" == typeof e4) return e4;
                if (Xe(e4)) return ie2 ? ie2.call(e4) : "";
                var t4 = e4 + "";
                return "0" == t4 && 1 / e4 == -1 / 0 ? "-0" : t4;
              })(t3);
              var r2 = [];
              return c.test(e3) && r2.push(""), e3.replace(u, (function(e4, t4, n2, i2) {
                r2.push(n2 ? i2.replace(h, "$1") : t4 || e4);
              })), r2;
            }));
            function Ie(e3) {
              if ("string" == typeof e3 || Xe(e3)) return e3;
              var t3 = e3 + "";
              return "0" == t3 && 1 / e3 == -1 / 0 ? "-0" : t3;
            }
            function Ne(e3) {
              if (null != e3) {
                try {
                  return B.call(e3);
                } catch (e4) {
                }
                try {
                  return e3 + "";
                } catch (e4) {
                }
              }
              return "";
            }
            var Pe, De = (Pe = function(e3, t3, r2) {
              D.call(e3, r2) ? e3[r2].push(t3) : e3[r2] = [t3];
            }, function(e3, t3) {
              var r2 = Ue(e3) ? k : fe, n2 = {};
              return r2(e3, Pe, _e(t3), n2);
            });
            function Fe(e3, t3) {
              if ("function" != typeof e3 || t3 && "function" != typeof t3) throw new TypeError("Expected a function");
              var r2 = function() {
                var n2 = arguments, i2 = t3 ? t3.apply(this, n2) : n2[0], s2 = r2.cache;
                if (s2.has(i2)) return s2.get(i2);
                var o2 = e3.apply(this, n2);
                return r2.cache = s2.set(i2, o2), o2;
              };
              return r2.cache = new (Fe.Cache || ae)(), r2;
            }
            function Le(e3, t3) {
              return e3 === t3 || e3 != e3 && t3 != t3;
            }
            function ze(e3) {
              return (function(e4) {
                return We(e4) && $e(e4);
              })(e3) && D.call(e3, "callee") && (!$.call(e3, "callee") || F.call(e3) == n);
            }
            Fe.Cache = ae;
            var Ue = Array.isArray;
            function $e(e3) {
              return null != e3 && Ve(e3.length) && !He(e3);
            }
            function He(e3) {
              var t3 = qe(e3) ? F.call(e3) : "";
              return "[object Function]" == t3 || "[object GeneratorFunction]" == t3;
            }
            function Ve(e3) {
              return "number" == typeof e3 && e3 > -1 && e3 % 1 == 0 && e3 <= 9007199254740991;
            }
            function qe(e3) {
              var t3 = typeof e3;
              return !!e3 && ("object" == t3 || "function" == t3);
            }
            function We(e3) {
              return !!e3 && "object" == typeof e3;
            }
            function Xe(e3) {
              return "symbol" == typeof e3 || We(e3) && "[object Symbol]" == F.call(e3);
            }
            var Ke = x ? /* @__PURE__ */ (function(e3) {
              return function(t3) {
                return e3(t3);
              };
            })(x) : function(e3) {
              return We(e3) && Ve(e3.length) && !!p[F.call(e3)];
            };
            function Ye(e3) {
              return $e(e3) ? ue(e3) : xe(e3);
            }
            function Ze(e3) {
              return e3;
            }
            t2.exports = De;
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 444: [function(e, t2, r) {
        var n = Object.prototype.toString;
        t2.exports = function(e2) {
          return true === e2 || false === e2 || /* @__PURE__ */ (function(e3) {
            return !!e3 && "object" == typeof e3;
          })(e2) && "[object Boolean]" == n.call(e2);
        };
      }, {}], 445: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var n = "[object Arguments]", i = "[object Map]", s = "[object Object]", o = "[object Set]", a = /^\[object .+?Constructor\]$/, l = /^(?:0|[1-9]\d*)$/, c = {};
            c["[object Float32Array]"] = c["[object Float64Array]"] = c["[object Int8Array]"] = c["[object Int16Array]"] = c["[object Int32Array]"] = c["[object Uint8Array]"] = c["[object Uint8ClampedArray]"] = c["[object Uint16Array]"] = c["[object Uint32Array]"] = true, c[n] = c["[object Array]"] = c["[object ArrayBuffer]"] = c["[object Boolean]"] = c["[object DataView]"] = c["[object Date]"] = c["[object Error]"] = c["[object Function]"] = c[i] = c["[object Number]"] = c[s] = c["[object RegExp]"] = c[o] = c["[object String]"] = c["[object WeakMap]"] = false;
            var u = "object" == typeof e2 && e2 && e2.Object === Object && e2, h = "object" == typeof self && self && self.Object === Object && self, f = u || h || Function("return this")(), d = "object" == typeof r && r && !r.nodeType && r, p = d && "object" == typeof t2 && t2 && !t2.nodeType && t2, m = p && p.exports === d, b = m && u.process, g = (function() {
              try {
                return b && b.binding && b.binding("util");
              } catch (e3) {
              }
            })(), y = g && g.isTypedArray;
            function v(e3, t3) {
              for (var r2 = -1, n2 = null == e3 ? 0 : e3.length; ++r2 < n2; ) if (t3(e3[r2], r2, e3)) return true;
              return false;
            }
            function w(e3) {
              var t3 = -1, r2 = Array(e3.size);
              return e3.forEach((function(e4, n2) {
                r2[++t3] = [n2, e4];
              })), r2;
            }
            function _(e3) {
              var t3 = -1, r2 = Array(e3.size);
              return e3.forEach((function(e4) {
                r2[++t3] = e4;
              })), r2;
            }
            var x, k, S, M = Array.prototype, C2 = Function.prototype, T = Object.prototype, E = f["__core-js_shared__"], A = C2.toString, R = T.hasOwnProperty, O = (x = /[^.]+$/.exec(E && E.keys && E.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "", j = T.toString, I = RegExp("^" + A.call(R).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), N = m ? f.Buffer : void 0, P = f.Symbol, B = f.Uint8Array, D = T.propertyIsEnumerable, F = M.splice, L = P ? P.toStringTag : void 0, z = Object.getOwnPropertySymbols, U = N ? N.isBuffer : void 0, $ = (k = Object.keys, S = Object, function(e3) {
              return k(S(e3));
            }), H = ge(f, "DataView"), V = ge(f, "Map"), q = ge(f, "Promise"), W = ge(f, "Set"), X = ge(f, "WeakMap"), K = ge(Object, "create"), Y = _e(H), Z = _e(V), G = _e(q), J = _e(W), Q = _e(X), ee = P ? P.prototype : void 0, te = ee ? ee.valueOf : void 0;
            function re(e3) {
              var t3 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function ne(e3) {
              var t3 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function ie2(e3) {
              var t3 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.clear(); ++t3 < r2; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function se(e3) {
              var t3 = -1, r2 = null == e3 ? 0 : e3.length;
              for (this.__data__ = new ie2(); ++t3 < r2; ) this.add(e3[t3]);
            }
            function oe(e3) {
              var t3 = this.__data__ = new ne(e3);
              this.size = t3.size;
            }
            function ae(e3, t3) {
              var r2 = Se(e3), n2 = !r2 && ke(e3), i2 = !r2 && !n2 && Me(e3), s2 = !r2 && !n2 && !i2 && Re(e3), o2 = r2 || n2 || i2 || s2, a2 = o2 ? (function(e4, t4) {
                for (var r3 = -1, n3 = Array(e4); ++r3 < e4; ) n3[r3] = t4(r3);
                return n3;
              })(e3.length, String) : [], l2 = a2.length;
              for (var c2 in e3) !R.call(e3, c2) || o2 && ("length" == c2 || i2 && ("offset" == c2 || "parent" == c2) || s2 && ("buffer" == c2 || "byteLength" == c2 || "byteOffset" == c2) || we(c2, l2)) || a2.push(c2);
              return a2;
            }
            function le(e3, t3) {
              for (var r2 = e3.length; r2--; ) if (xe(e3[r2][0], t3)) return r2;
              return -1;
            }
            function ce(e3) {
              return null == e3 ? void 0 === e3 ? "[object Undefined]" : "[object Null]" : L && L in Object(e3) ? (function(e4) {
                var t3 = R.call(e4, L), r2 = e4[L];
                try {
                  e4[L] = void 0;
                  var n2 = true;
                } catch (e5) {
                }
                var i2 = j.call(e4);
                n2 && (t3 ? e4[L] = r2 : delete e4[L]);
                return i2;
              })(e3) : (function(e4) {
                return j.call(e4);
              })(e3);
            }
            function ue(e3) {
              return Ae(e3) && ce(e3) == n;
            }
            function he(e3, t3, r2, a2, l2) {
              return e3 === t3 || (null == e3 || null == t3 || !Ae(e3) && !Ae(t3) ? e3 != e3 && t3 != t3 : (function(e4, t4, r3, a3, l3, c2) {
                var u2 = Se(e4), h2 = Se(t4), f2 = u2 ? "[object Array]" : ve(e4), d2 = h2 ? "[object Array]" : ve(t4), p2 = (f2 = f2 == n ? s : f2) == s, m2 = (d2 = d2 == n ? s : d2) == s, b2 = f2 == d2;
                if (b2 && Me(e4)) {
                  if (!Me(t4)) return false;
                  u2 = true, p2 = false;
                }
                if (b2 && !p2) return c2 || (c2 = new oe()), u2 || Re(e4) ? pe(e4, t4, r3, a3, l3, c2) : (function(e5, t5, r4, n2, s2, a4, l4) {
                  switch (r4) {
                    case "[object DataView]":
                      if (e5.byteLength != t5.byteLength || e5.byteOffset != t5.byteOffset) return false;
                      e5 = e5.buffer, t5 = t5.buffer;
                    case "[object ArrayBuffer]":
                      return !(e5.byteLength != t5.byteLength || !a4(new B(e5), new B(t5)));
                    case "[object Boolean]":
                    case "[object Date]":
                    case "[object Number]":
                      return xe(+e5, +t5);
                    case "[object Error]":
                      return e5.name == t5.name && e5.message == t5.message;
                    case "[object RegExp]":
                    case "[object String]":
                      return e5 == t5 + "";
                    case i:
                      var c3 = w;
                    case o:
                      var u3 = 1 & n2;
                      if (c3 || (c3 = _), e5.size != t5.size && !u3) return false;
                      var h3 = l4.get(e5);
                      if (h3) return h3 == t5;
                      n2 |= 2, l4.set(e5, t5);
                      var f3 = pe(c3(e5), c3(t5), n2, s2, a4, l4);
                      return l4.delete(e5), f3;
                    case "[object Symbol]":
                      if (te) return te.call(e5) == te.call(t5);
                  }
                  return false;
                })(e4, t4, f2, r3, a3, l3, c2);
                if (!(1 & r3)) {
                  var g2 = p2 && R.call(e4, "__wrapped__"), y2 = m2 && R.call(t4, "__wrapped__");
                  if (g2 || y2) {
                    var v2 = g2 ? e4.value() : e4, x2 = y2 ? t4.value() : t4;
                    return c2 || (c2 = new oe()), l3(v2, x2, r3, a3, c2);
                  }
                }
                if (!b2) return false;
                return c2 || (c2 = new oe()), (function(e5, t5, r4, n2, i2, s2) {
                  var o2 = 1 & r4, a4 = me(e5), l4 = a4.length, c3 = me(t5).length;
                  if (l4 != c3 && !o2) return false;
                  var u3 = l4;
                  for (; u3--; ) {
                    var h3 = a4[u3];
                    if (!(o2 ? h3 in t5 : R.call(t5, h3))) return false;
                  }
                  var f3 = s2.get(e5);
                  if (f3 && s2.get(t5)) return f3 == t5;
                  var d3 = true;
                  s2.set(e5, t5), s2.set(t5, e5);
                  var p3 = o2;
                  for (; ++u3 < l4; ) {
                    h3 = a4[u3];
                    var m3 = e5[h3], b3 = t5[h3];
                    if (n2) var g3 = o2 ? n2(b3, m3, h3, t5, e5, s2) : n2(m3, b3, h3, e5, t5, s2);
                    if (!(void 0 === g3 ? m3 === b3 || i2(m3, b3, r4, n2, s2) : g3)) {
                      d3 = false;
                      break;
                    }
                    p3 || (p3 = "constructor" == h3);
                  }
                  if (d3 && !p3) {
                    var y3 = e5.constructor, v3 = t5.constructor;
                    y3 == v3 || !("constructor" in e5) || !("constructor" in t5) || "function" == typeof y3 && y3 instanceof y3 && "function" == typeof v3 && v3 instanceof v3 || (d3 = false);
                  }
                  return s2.delete(e5), s2.delete(t5), d3;
                })(e4, t4, r3, a3, l3, c2);
              })(e3, t3, r2, a2, he, l2));
            }
            function fe(e3) {
              return !(!Ee(e3) || (function(e4) {
                return !!O && O in e4;
              })(e3)) && (Ce(e3) ? I : a).test(_e(e3));
            }
            function de(e3) {
              if (r2 = (t3 = e3) && t3.constructor, n2 = "function" == typeof r2 && r2.prototype || T, t3 !== n2) return $(e3);
              var t3, r2, n2, i2 = [];
              for (var s2 in Object(e3)) R.call(e3, s2) && "constructor" != s2 && i2.push(s2);
              return i2;
            }
            function pe(e3, t3, r2, n2, i2, s2) {
              var o2 = 1 & r2, a2 = e3.length, l2 = t3.length;
              if (a2 != l2 && !(o2 && l2 > a2)) return false;
              var c2 = s2.get(e3);
              if (c2 && s2.get(t3)) return c2 == t3;
              var u2 = -1, h2 = true, f2 = 2 & r2 ? new se() : void 0;
              for (s2.set(e3, t3), s2.set(t3, e3); ++u2 < a2; ) {
                var d2 = e3[u2], p2 = t3[u2];
                if (n2) var m2 = o2 ? n2(p2, d2, u2, t3, e3, s2) : n2(d2, p2, u2, e3, t3, s2);
                if (void 0 !== m2) {
                  if (m2) continue;
                  h2 = false;
                  break;
                }
                if (f2) {
                  if (!v(t3, (function(e4, t4) {
                    if (o3 = t4, !f2.has(o3) && (d2 === e4 || i2(d2, e4, r2, n2, s2))) return f2.push(t4);
                    var o3;
                  }))) {
                    h2 = false;
                    break;
                  }
                } else if (d2 !== p2 && !i2(d2, p2, r2, n2, s2)) {
                  h2 = false;
                  break;
                }
              }
              return s2.delete(e3), s2.delete(t3), h2;
            }
            function me(e3) {
              return (function(e4, t3, r2) {
                var n2 = t3(e4);
                return Se(e4) ? n2 : (function(e5, t4) {
                  for (var r3 = -1, n3 = t4.length, i2 = e5.length; ++r3 < n3; ) e5[i2 + r3] = t4[r3];
                  return e5;
                })(n2, r2(e4));
              })(e3, Oe, ye);
            }
            function be(e3, t3) {
              var r2, n2, i2 = e3.__data__;
              return ("string" == (n2 = typeof (r2 = t3)) || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== r2 : null === r2) ? i2["string" == typeof t3 ? "string" : "hash"] : i2.map;
            }
            function ge(e3, t3) {
              var r2 = (function(e4, t4) {
                return null == e4 ? void 0 : e4[t4];
              })(e3, t3);
              return fe(r2) ? r2 : void 0;
            }
            re.prototype.clear = function() {
              this.__data__ = K ? K(null) : {}, this.size = 0;
            }, re.prototype.delete = function(e3) {
              var t3 = this.has(e3) && delete this.__data__[e3];
              return this.size -= t3 ? 1 : 0, t3;
            }, re.prototype.get = function(e3) {
              var t3 = this.__data__;
              if (K) {
                var r2 = t3[e3];
                return "__lodash_hash_undefined__" === r2 ? void 0 : r2;
              }
              return R.call(t3, e3) ? t3[e3] : void 0;
            }, re.prototype.has = function(e3) {
              var t3 = this.__data__;
              return K ? void 0 !== t3[e3] : R.call(t3, e3);
            }, re.prototype.set = function(e3, t3) {
              var r2 = this.__data__;
              return this.size += this.has(e3) ? 0 : 1, r2[e3] = K && void 0 === t3 ? "__lodash_hash_undefined__" : t3, this;
            }, ne.prototype.clear = function() {
              this.__data__ = [], this.size = 0;
            }, ne.prototype.delete = function(e3) {
              var t3 = this.__data__, r2 = le(t3, e3);
              return !(r2 < 0) && (r2 == t3.length - 1 ? t3.pop() : F.call(t3, r2, 1), --this.size, true);
            }, ne.prototype.get = function(e3) {
              var t3 = this.__data__, r2 = le(t3, e3);
              return r2 < 0 ? void 0 : t3[r2][1];
            }, ne.prototype.has = function(e3) {
              return le(this.__data__, e3) > -1;
            }, ne.prototype.set = function(e3, t3) {
              var r2 = this.__data__, n2 = le(r2, e3);
              return n2 < 0 ? (++this.size, r2.push([e3, t3])) : r2[n2][1] = t3, this;
            }, ie2.prototype.clear = function() {
              this.size = 0, this.__data__ = { hash: new re(), map: new (V || ne)(), string: new re() };
            }, ie2.prototype.delete = function(e3) {
              var t3 = be(this, e3).delete(e3);
              return this.size -= t3 ? 1 : 0, t3;
            }, ie2.prototype.get = function(e3) {
              return be(this, e3).get(e3);
            }, ie2.prototype.has = function(e3) {
              return be(this, e3).has(e3);
            }, ie2.prototype.set = function(e3, t3) {
              var r2 = be(this, e3), n2 = r2.size;
              return r2.set(e3, t3), this.size += r2.size == n2 ? 0 : 1, this;
            }, se.prototype.add = se.prototype.push = function(e3) {
              return this.__data__.set(e3, "__lodash_hash_undefined__"), this;
            }, se.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, oe.prototype.clear = function() {
              this.__data__ = new ne(), this.size = 0;
            }, oe.prototype.delete = function(e3) {
              var t3 = this.__data__, r2 = t3.delete(e3);
              return this.size = t3.size, r2;
            }, oe.prototype.get = function(e3) {
              return this.__data__.get(e3);
            }, oe.prototype.has = function(e3) {
              return this.__data__.has(e3);
            }, oe.prototype.set = function(e3, t3) {
              var r2 = this.__data__;
              if (r2 instanceof ne) {
                var n2 = r2.__data__;
                if (!V || n2.length < 199) return n2.push([e3, t3]), this.size = ++r2.size, this;
                r2 = this.__data__ = new ie2(n2);
              }
              return r2.set(e3, t3), this.size = r2.size, this;
            };
            var ye = z ? function(e3) {
              return null == e3 ? [] : (e3 = Object(e3), (function(e4, t3) {
                for (var r2 = -1, n2 = null == e4 ? 0 : e4.length, i2 = 0, s2 = []; ++r2 < n2; ) {
                  var o2 = e4[r2];
                  t3(o2, r2, e4) && (s2[i2++] = o2);
                }
                return s2;
              })(z(e3), (function(t3) {
                return D.call(e3, t3);
              })));
            } : function() {
              return [];
            }, ve = ce;
            function we(e3, t3) {
              return !!(t3 = null == t3 ? 9007199254740991 : t3) && ("number" == typeof e3 || l.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t3;
            }
            function _e(e3) {
              if (null != e3) {
                try {
                  return A.call(e3);
                } catch (e4) {
                }
                try {
                  return e3 + "";
                } catch (e4) {
                }
              }
              return "";
            }
            function xe(e3, t3) {
              return e3 === t3 || e3 != e3 && t3 != t3;
            }
            (H && "[object DataView]" != ve(new H(new ArrayBuffer(1))) || V && ve(new V()) != i || q && "[object Promise]" != ve(q.resolve()) || W && ve(new W()) != o || X && "[object WeakMap]" != ve(new X())) && (ve = function(e3) {
              var t3 = ce(e3), r2 = t3 == s ? e3.constructor : void 0, n2 = r2 ? _e(r2) : "";
              if (n2) switch (n2) {
                case Y:
                  return "[object DataView]";
                case Z:
                  return i;
                case G:
                  return "[object Promise]";
                case J:
                  return o;
                case Q:
                  return "[object WeakMap]";
              }
              return t3;
            });
            var ke = ue(/* @__PURE__ */ (function() {
              return arguments;
            })()) ? ue : function(e3) {
              return Ae(e3) && R.call(e3, "callee") && !D.call(e3, "callee");
            }, Se = Array.isArray;
            var Me = U || function() {
              return false;
            };
            function Ce(e3) {
              if (!Ee(e3)) return false;
              var t3 = ce(e3);
              return "[object Function]" == t3 || "[object GeneratorFunction]" == t3 || "[object AsyncFunction]" == t3 || "[object Proxy]" == t3;
            }
            function Te(e3) {
              return "number" == typeof e3 && e3 > -1 && e3 % 1 == 0 && e3 <= 9007199254740991;
            }
            function Ee(e3) {
              var t3 = typeof e3;
              return null != e3 && ("object" == t3 || "function" == t3);
            }
            function Ae(e3) {
              return null != e3 && "object" == typeof e3;
            }
            var Re = y ? /* @__PURE__ */ (function(e3) {
              return function(t3) {
                return e3(t3);
              };
            })(y) : function(e3) {
              return Ae(e3) && Te(e3.length) && !!c[ce(e3)];
            };
            function Oe(e3) {
              return null != (t3 = e3) && Te(t3.length) && !Ce(t3) ? ae(e3) : de(e3);
              var t3;
            }
            t2.exports = function(e3, t3) {
              return he(e3, t3);
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 446: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var r2 = "object" == typeof e2 && e2 && e2.Object === Object && e2, n = "object" == typeof self && self && self.Object === Object && self, i = r2 || n || Function("return this")(), s = Object.prototype, o = s.hasOwnProperty, a = s.toString, l = i.Symbol, c = l ? l.toStringTag : void 0;
            function u(e3) {
              return null == e3 ? void 0 === e3 ? "[object Undefined]" : "[object Null]" : c && c in Object(e3) ? (function(e4) {
                var t3 = o.call(e4, c), r3 = e4[c];
                try {
                  e4[c] = void 0;
                  var n2 = true;
                } catch (e5) {
                }
                var i2 = a.call(e4);
                n2 && (t3 ? e4[c] = r3 : delete e4[c]);
                return i2;
              })(e3) : (function(e4) {
                return a.call(e4);
              })(e3);
            }
            t2.exports = function(e3) {
              if (!(function(e4) {
                var t4 = typeof e4;
                return null != e4 && ("object" == t4 || "function" == t4);
              })(e3)) return false;
              var t3 = u(e3);
              return "[object Function]" == t3 || "[object GeneratorFunction]" == t3 || "[object AsyncFunction]" == t3 || "[object Proxy]" == t3;
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 447: [function(e, t2, r) {
        t2.exports = function(e2) {
          return null == e2;
        };
      }, {}], 448: [function(e, t2, r) {
        t2.exports = function(e2) {
          return void 0 === e2;
        };
      }, {}], 449: [function(e, t2, r) {
        (function(e2) {
          (function() {
            var r2 = /^\[object .+?Constructor\]$/, n = "object" == typeof e2 && e2 && e2.Object === Object && e2, i = "object" == typeof self && self && self.Object === Object && self, s = n || i || Function("return this")();
            function o(e3, t3) {
              return !!(e3 ? e3.length : 0) && (function(e4, t4, r3) {
                if (t4 != t4) return (function(e5, t5, r4, n3) {
                  var i3 = e5.length, s2 = r4 + -1;
                  for (; ++s2 < i3; ) if (t5(e5[s2], s2, e5)) return s2;
                  return -1;
                })(e4, l, r3);
                var n2 = r3 - 1, i2 = e4.length;
                for (; ++n2 < i2; ) if (e4[n2] === t4) return n2;
                return -1;
              })(e3, t3, 0) > -1;
            }
            function l(e3) {
              return e3 != e3;
            }
            function c(e3, t3) {
              return e3.has(t3);
            }
            function u(e3) {
              var t3 = -1, r3 = Array(e3.size);
              return e3.forEach((function(e4) {
                r3[++t3] = e4;
              })), r3;
            }
            var h, f = Array.prototype, d = Function.prototype, p = Object.prototype, m = s["__core-js_shared__"], b = (h = /[^.]+$/.exec(m && m.keys && m.keys.IE_PROTO || "")) ? "Symbol(src)_1." + h : "", g = d.toString, y = p.hasOwnProperty, v = p.toString, w = RegExp("^" + g.call(y).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), _ = f.splice, x = I(s, "Map"), k = I(s, "Set"), S = I(Object, "create");
            function M(e3) {
              var t3 = -1, r3 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r3; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function C2(e3) {
              var t3 = -1, r3 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r3; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function T(e3) {
              var t3 = -1, r3 = e3 ? e3.length : 0;
              for (this.clear(); ++t3 < r3; ) {
                var n2 = e3[t3];
                this.set(n2[0], n2[1]);
              }
            }
            function E(e3) {
              var t3 = -1, r3 = e3 ? e3.length : 0;
              for (this.__data__ = new T(); ++t3 < r3; ) this.add(e3[t3]);
            }
            function A(e3, t3) {
              for (var r3, n2, i2 = e3.length; i2--; ) if ((r3 = e3[i2][0]) === (n2 = t3) || r3 != r3 && n2 != n2) return i2;
              return -1;
            }
            function R(e3) {
              return !(!N(e3) || (t3 = e3, b && b in t3)) && ((function(e4) {
                var t4 = N(e4) ? v.call(e4) : "";
                return "[object Function]" == t4 || "[object GeneratorFunction]" == t4;
              })(e3) || (function(e4) {
                var t4 = false;
                if (null != e4 && "function" != typeof e4.toString) try {
                  t4 = !!(e4 + "");
                } catch (e5) {
                }
                return t4;
              })(e3) ? w : r2).test((function(e4) {
                if (null != e4) {
                  try {
                    return g.call(e4);
                  } catch (e5) {
                  }
                  try {
                    return e4 + "";
                  } catch (e5) {
                  }
                }
                return "";
              })(e3));
              var t3;
            }
            M.prototype.clear = function() {
              this.__data__ = S ? S(null) : {};
            }, M.prototype.delete = function(e3) {
              return this.has(e3) && delete this.__data__[e3];
            }, M.prototype.get = function(e3) {
              var t3 = this.__data__;
              if (S) {
                var r3 = t3[e3];
                return "__lodash_hash_undefined__" === r3 ? void 0 : r3;
              }
              return y.call(t3, e3) ? t3[e3] : void 0;
            }, M.prototype.has = function(e3) {
              var t3 = this.__data__;
              return S ? void 0 !== t3[e3] : y.call(t3, e3);
            }, M.prototype.set = function(e3, t3) {
              return this.__data__[e3] = S && void 0 === t3 ? "__lodash_hash_undefined__" : t3, this;
            }, C2.prototype.clear = function() {
              this.__data__ = [];
            }, C2.prototype.delete = function(e3) {
              var t3 = this.__data__, r3 = A(t3, e3);
              return !(r3 < 0) && (r3 == t3.length - 1 ? t3.pop() : _.call(t3, r3, 1), true);
            }, C2.prototype.get = function(e3) {
              var t3 = this.__data__, r3 = A(t3, e3);
              return r3 < 0 ? void 0 : t3[r3][1];
            }, C2.prototype.has = function(e3) {
              return A(this.__data__, e3) > -1;
            }, C2.prototype.set = function(e3, t3) {
              var r3 = this.__data__, n2 = A(r3, e3);
              return n2 < 0 ? r3.push([e3, t3]) : r3[n2][1] = t3, this;
            }, T.prototype.clear = function() {
              this.__data__ = { hash: new M(), map: new (x || C2)(), string: new M() };
            }, T.prototype.delete = function(e3) {
              return j(this, e3).delete(e3);
            }, T.prototype.get = function(e3) {
              return j(this, e3).get(e3);
            }, T.prototype.has = function(e3) {
              return j(this, e3).has(e3);
            }, T.prototype.set = function(e3, t3) {
              return j(this, e3).set(e3, t3), this;
            }, E.prototype.add = E.prototype.push = function(e3) {
              return this.__data__.set(e3, "__lodash_hash_undefined__"), this;
            }, E.prototype.has = function(e3) {
              return this.__data__.has(e3);
            };
            var O = k && 1 / u(new k([, -0]))[1] == 1 / 0 ? function(e3) {
              return new k(e3);
            } : function() {
            };
            function j(e3, t3) {
              var r3, n2, i2 = e3.__data__;
              return ("string" == (n2 = typeof (r3 = t3)) || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== r3 : null === r3) ? i2["string" == typeof t3 ? "string" : "hash"] : i2.map;
            }
            function I(e3, t3) {
              var r3 = (function(e4, t4) {
                return null == e4 ? void 0 : e4[t4];
              })(e3, t3);
              return R(r3) ? r3 : void 0;
            }
            function N(e3) {
              var t3 = typeof e3;
              return !!e3 && ("object" == t3 || "function" == t3);
            }
            t2.exports = function(e3) {
              return e3 && e3.length ? (function(e4, t3, r3) {
                var n2 = -1, i2 = o, s2 = e4.length, l2 = true, h2 = [], f2 = h2;
                if (s2 >= 200) {
                  var d2 = O(e4);
                  if (d2) return u(d2);
                  l2 = false, i2 = c, f2 = new E();
                } else f2 = h2;
                e: for (; ++n2 < s2; ) {
                  var p2 = e4[n2], m2 = p2;
                  if (p2 = 0 !== p2 ? p2 : 0, l2 && m2 == m2) {
                    for (var b2 = f2.length; b2--; ) if (f2[b2] === m2) continue e;
                    h2.push(p2);
                  } else i2(f2, m2, r3) || (f2 !== h2 && f2.push(m2), h2.push(p2));
                }
                return h2;
              })(e3) : [];
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 450: [function(e, t2, r) {
        var n = e("inherits"), i = e("hash-base"), s = e("safe-buffer").Buffer, o = new Array(16);
        function a() {
          i.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
        }
        function l(e2, t3) {
          return e2 << t3 | e2 >>> 32 - t3;
        }
        function c(e2, t3, r2, n2, i2, s2, o2) {
          return l(e2 + (t3 & r2 | ~t3 & n2) + i2 + s2 | 0, o2) + t3 | 0;
        }
        function u(e2, t3, r2, n2, i2, s2, o2) {
          return l(e2 + (t3 & n2 | r2 & ~n2) + i2 + s2 | 0, o2) + t3 | 0;
        }
        function h(e2, t3, r2, n2, i2, s2, o2) {
          return l(e2 + (t3 ^ r2 ^ n2) + i2 + s2 | 0, o2) + t3 | 0;
        }
        function f(e2, t3, r2, n2, i2, s2, o2) {
          return l(e2 + (r2 ^ (t3 | ~n2)) + i2 + s2 | 0, o2) + t3 | 0;
        }
        n(a, i), a.prototype._update = function() {
          for (var e2 = o, t3 = 0; t3 < 16; ++t3) e2[t3] = this._block.readInt32LE(4 * t3);
          var r2 = this._a, n2 = this._b, i2 = this._c, s2 = this._d;
          r2 = c(r2, n2, i2, s2, e2[0], 3614090360, 7), s2 = c(s2, r2, n2, i2, e2[1], 3905402710, 12), i2 = c(i2, s2, r2, n2, e2[2], 606105819, 17), n2 = c(n2, i2, s2, r2, e2[3], 3250441966, 22), r2 = c(r2, n2, i2, s2, e2[4], 4118548399, 7), s2 = c(s2, r2, n2, i2, e2[5], 1200080426, 12), i2 = c(i2, s2, r2, n2, e2[6], 2821735955, 17), n2 = c(n2, i2, s2, r2, e2[7], 4249261313, 22), r2 = c(r2, n2, i2, s2, e2[8], 1770035416, 7), s2 = c(s2, r2, n2, i2, e2[9], 2336552879, 12), i2 = c(i2, s2, r2, n2, e2[10], 4294925233, 17), n2 = c(n2, i2, s2, r2, e2[11], 2304563134, 22), r2 = c(r2, n2, i2, s2, e2[12], 1804603682, 7), s2 = c(s2, r2, n2, i2, e2[13], 4254626195, 12), i2 = c(i2, s2, r2, n2, e2[14], 2792965006, 17), r2 = u(r2, n2 = c(n2, i2, s2, r2, e2[15], 1236535329, 22), i2, s2, e2[1], 4129170786, 5), s2 = u(s2, r2, n2, i2, e2[6], 3225465664, 9), i2 = u(i2, s2, r2, n2, e2[11], 643717713, 14), n2 = u(n2, i2, s2, r2, e2[0], 3921069994, 20), r2 = u(r2, n2, i2, s2, e2[5], 3593408605, 5), s2 = u(s2, r2, n2, i2, e2[10], 38016083, 9), i2 = u(i2, s2, r2, n2, e2[15], 3634488961, 14), n2 = u(n2, i2, s2, r2, e2[4], 3889429448, 20), r2 = u(r2, n2, i2, s2, e2[9], 568446438, 5), s2 = u(s2, r2, n2, i2, e2[14], 3275163606, 9), i2 = u(i2, s2, r2, n2, e2[3], 4107603335, 14), n2 = u(n2, i2, s2, r2, e2[8], 1163531501, 20), r2 = u(r2, n2, i2, s2, e2[13], 2850285829, 5), s2 = u(s2, r2, n2, i2, e2[2], 4243563512, 9), i2 = u(i2, s2, r2, n2, e2[7], 1735328473, 14), r2 = h(r2, n2 = u(n2, i2, s2, r2, e2[12], 2368359562, 20), i2, s2, e2[5], 4294588738, 4), s2 = h(s2, r2, n2, i2, e2[8], 2272392833, 11), i2 = h(i2, s2, r2, n2, e2[11], 1839030562, 16), n2 = h(n2, i2, s2, r2, e2[14], 4259657740, 23), r2 = h(r2, n2, i2, s2, e2[1], 2763975236, 4), s2 = h(s2, r2, n2, i2, e2[4], 1272893353, 11), i2 = h(i2, s2, r2, n2, e2[7], 4139469664, 16), n2 = h(n2, i2, s2, r2, e2[10], 3200236656, 23), r2 = h(r2, n2, i2, s2, e2[13], 681279174, 4), s2 = h(s2, r2, n2, i2, e2[0], 3936430074, 11), i2 = h(i2, s2, r2, n2, e2[3], 3572445317, 16), n2 = h(n2, i2, s2, r2, e2[6], 76029189, 23), r2 = h(r2, n2, i2, s2, e2[9], 3654602809, 4), s2 = h(s2, r2, n2, i2, e2[12], 3873151461, 11), i2 = h(i2, s2, r2, n2, e2[15], 530742520, 16), r2 = f(r2, n2 = h(n2, i2, s2, r2, e2[2], 3299628645, 23), i2, s2, e2[0], 4096336452, 6), s2 = f(s2, r2, n2, i2, e2[7], 1126891415, 10), i2 = f(i2, s2, r2, n2, e2[14], 2878612391, 15), n2 = f(n2, i2, s2, r2, e2[5], 4237533241, 21), r2 = f(r2, n2, i2, s2, e2[12], 1700485571, 6), s2 = f(s2, r2, n2, i2, e2[3], 2399980690, 10), i2 = f(i2, s2, r2, n2, e2[10], 4293915773, 15), n2 = f(n2, i2, s2, r2, e2[1], 2240044497, 21), r2 = f(r2, n2, i2, s2, e2[8], 1873313359, 6), s2 = f(s2, r2, n2, i2, e2[15], 4264355552, 10), i2 = f(i2, s2, r2, n2, e2[6], 2734768916, 15), n2 = f(n2, i2, s2, r2, e2[13], 1309151649, 21), r2 = f(r2, n2, i2, s2, e2[4], 4149444226, 6), s2 = f(s2, r2, n2, i2, e2[11], 3174756917, 10), i2 = f(i2, s2, r2, n2, e2[2], 718787259, 15), n2 = f(n2, i2, s2, r2, e2[9], 3951481745, 21), this._a = this._a + r2 | 0, this._b = this._b + n2 | 0, this._c = this._c + i2 | 0, this._d = this._d + s2 | 0;
        }, a.prototype._digest = function() {
          this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
          var e2 = s.allocUnsafe(16);
          return e2.writeInt32LE(this._a, 0), e2.writeInt32LE(this._b, 4), e2.writeInt32LE(this._c, 8), e2.writeInt32LE(this._d, 12), e2;
        }, t2.exports = a;
      }, { "hash-base": 425, inherits: 440, "safe-buffer": 494 }], 451: [function(e, t2, r) {
        var n = e("bn.js"), i = e("brorand");
        function s(e2) {
          this.rand = e2 || new i.Rand();
        }
        t2.exports = s, s.create = function(e2) {
          return new s(e2);
        }, s.prototype._randbelow = function(e2) {
          var t3 = e2.bitLength(), r2 = Math.ceil(t3 / 8);
          do {
            var i2 = new n(this.rand.generate(r2));
          } while (i2.cmp(e2) >= 0);
          return i2;
        }, s.prototype._randrange = function(e2, t3) {
          var r2 = t3.sub(e2);
          return e2.add(this._randbelow(r2));
        }, s.prototype.test = function(e2, t3, r2) {
          var i2 = e2.bitLength(), s2 = n.mont(e2), o = new n(1).toRed(s2);
          t3 || (t3 = Math.max(1, i2 / 48 | 0));
          for (var a = e2.subn(1), l = 0; !a.testn(l); l++) ;
          for (var c = e2.shrn(l), u = a.toRed(s2); t3 > 0; t3--) {
            var h = this._randrange(new n(2), a);
            r2 && r2(h);
            var f = h.toRed(s2).redPow(c);
            if (0 !== f.cmp(o) && 0 !== f.cmp(u)) {
              for (var d = 1; d < l; d++) {
                if (0 === (f = f.redSqr()).cmp(o)) return false;
                if (0 === f.cmp(u)) break;
              }
              if (d === l) return false;
            }
          }
          return true;
        }, s.prototype.getDivisor = function(e2, t3) {
          var r2 = e2.bitLength(), i2 = n.mont(e2), s2 = new n(1).toRed(i2);
          t3 || (t3 = Math.max(1, r2 / 48 | 0));
          for (var o = e2.subn(1), a = 0; !o.testn(a); a++) ;
          for (var l = e2.shrn(a), c = o.toRed(i2); t3 > 0; t3--) {
            var u = this._randrange(new n(2), o), h = e2.gcd(u);
            if (0 !== h.cmpn(1)) return h;
            var f = u.toRed(i2).redPow(l);
            if (0 !== f.cmp(s2) && 0 !== f.cmp(c)) {
              for (var d = 1; d < a; d++) {
                if (0 === (f = f.redSqr()).cmp(s2)) return f.fromRed().subn(1).gcd(e2);
                if (0 === f.cmp(c)) break;
              }
              if (d === a) return (f = f.redSqr()).fromRed().subn(1).gcd(e2);
            }
          }
          return false;
        };
      }, { "bn.js": 452, brorand: 187 }], 452: [function(e, t2, r) {
        arguments[4][184][0].apply(r, arguments);
      }, { buffer: 188, dup: 184 }], 453: [function(e, t2, r) {
        function n(e2, t3) {
          if (!e2) throw new Error(t3 || "Assertion failed");
        }
        t2.exports = n, n.equal = function(e2, t3, r2) {
          if (e2 != t3) throw new Error(r2 || "Assertion failed: " + e2 + " != " + t3);
        };
      }, {}], 454: [function(e, t2, r) {
        var n = r;
        function i(e2) {
          return 1 === e2.length ? "0" + e2 : e2;
        }
        function s(e2) {
          for (var t3 = "", r2 = 0; r2 < e2.length; r2++) t3 += i(e2[r2].toString(16));
          return t3;
        }
        n.toArray = function(e2, t3) {
          if (Array.isArray(e2)) return e2.slice();
          if (!e2) return [];
          var r2 = [];
          if ("string" != typeof e2) {
            for (var n2 = 0; n2 < e2.length; n2++) r2[n2] = 0 | e2[n2];
            return r2;
          }
          if ("hex" === t3) {
            (e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2);
            for (n2 = 0; n2 < e2.length; n2 += 2) r2.push(parseInt(e2[n2] + e2[n2 + 1], 16));
          } else for (n2 = 0; n2 < e2.length; n2++) {
            var i2 = e2.charCodeAt(n2), s2 = i2 >> 8, o = 255 & i2;
            s2 ? r2.push(s2, o) : r2.push(o);
          }
          return r2;
        }, n.zero2 = i, n.toHex = s, n.encode = function(e2, t3) {
          return "hex" === t3 ? s(e2) : e2;
        };
      }, {}], 455: [function(e, t2, r) {
        t2.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
      }, {}], 456: [function(e, t2, r) {
        var n = e("asn1.js");
        r.certificate = e("./certificate");
        var i = n.define("RSAPrivateKey", (function() {
          this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
        }));
        r.RSAPrivateKey = i;
        var s = n.define("RSAPublicKey", (function() {
          this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
        }));
        r.RSAPublicKey = s;
        var o = n.define("SubjectPublicKeyInfo", (function() {
          this.seq().obj(this.key("algorithm").use(a), this.key("subjectPublicKey").bitstr());
        }));
        r.PublicKey = o;
        var a = n.define("AlgorithmIdentifier", (function() {
          this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
        })), l = n.define("PrivateKeyInfo", (function() {
          this.seq().obj(this.key("version").int(), this.key("algorithm").use(a), this.key("subjectPrivateKey").octstr());
        }));
        r.PrivateKey = l;
        var c = n.define("EncryptedPrivateKeyInfo", (function() {
          this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
        }));
        r.EncryptedPrivateKey = c;
        var u = n.define("DSAPrivateKey", (function() {
          this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
        }));
        r.DSAPrivateKey = u, r.DSAparam = n.define("DSAparam", (function() {
          this.int();
        }));
        var h = n.define("ECPrivateKey", (function() {
          this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(f), this.key("publicKey").optional().explicit(1).bitstr());
        }));
        r.ECPrivateKey = h;
        var f = n.define("ECParameters", (function() {
          this.choice({ namedCurve: this.objid() });
        }));
        r.signature = n.define("signature", (function() {
          this.seq().obj(this.key("r").int(), this.key("s").int());
        }));
      }, { "./certificate": 457, "asn1.js": 170 }], 457: [function(e, t2, r) {
        var n = e("asn1.js"), i = n.define("Time", (function() {
          this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
        })), s = n.define("AttributeTypeValue", (function() {
          this.seq().obj(this.key("type").objid(), this.key("value").any());
        })), o = n.define("AlgorithmIdentifier", (function() {
          this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
        })), a = n.define("SubjectPublicKeyInfo", (function() {
          this.seq().obj(this.key("algorithm").use(o), this.key("subjectPublicKey").bitstr());
        })), l = n.define("RelativeDistinguishedName", (function() {
          this.setof(s);
        })), c = n.define("RDNSequence", (function() {
          this.seqof(l);
        })), u = n.define("Name", (function() {
          this.choice({ rdnSequence: this.use(c) });
        })), h = n.define("Validity", (function() {
          this.seq().obj(this.key("notBefore").use(i), this.key("notAfter").use(i));
        })), f = n.define("Extension", (function() {
          this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
        })), d = n.define("TBSCertificate", (function() {
          this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(o), this.key("issuer").use(u), this.key("validity").use(h), this.key("subject").use(u), this.key("subjectPublicKeyInfo").use(a), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(f).optional());
        })), p = n.define("X509Certificate", (function() {
          this.seq().obj(this.key("tbsCertificate").use(d), this.key("signatureAlgorithm").use(o), this.key("signatureValue").bitstr());
        }));
        t2.exports = p;
      }, { "asn1.js": 170 }], 458: [function(e, t2, r) {
        var n = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, i = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, s = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, o = e("evp_bytestokey"), a = e("browserify-aes"), l = e("safe-buffer").Buffer;
        t2.exports = function(e2, t3) {
          var r2, c = e2.toString(), u = c.match(n);
          if (u) {
            var h = "aes" + u[1], f = l.from(u[2], "hex"), d = l.from(u[3].replace(/[\r\n]/g, ""), "base64"), p = o(t3, f.slice(0, 8), parseInt(u[1], 10)).key, m = [], b = a.createDecipheriv(h, p, f);
            m.push(b.update(d)), m.push(b.final()), r2 = l.concat(m);
          } else {
            var g = c.match(s);
            r2 = l.from(g[2].replace(/[\r\n]/g, ""), "base64");
          }
          return { tag: c.match(i)[1], data: r2 };
        };
      }, { "browserify-aes": 191, evp_bytestokey: 423, "safe-buffer": 494 }], 459: [function(e, t2, r) {
        var n = e("./asn1"), i = e("./aesid.json"), s = e("./fixProc"), o = e("browserify-aes"), a = e("pbkdf2"), l = e("safe-buffer").Buffer;
        function c(e2) {
          var t3;
          "object" != typeof e2 || l.isBuffer(e2) || (t3 = e2.passphrase, e2 = e2.key), "string" == typeof e2 && (e2 = l.from(e2));
          var r2, c2, u = s(e2, t3), h = u.tag, f = u.data;
          switch (h) {
            case "CERTIFICATE":
              c2 = n.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
              switch (c2 || (c2 = n.PublicKey.decode(f, "der")), r2 = c2.algorithm.algorithm.join(".")) {
                case "1.2.840.113549.1.1.1":
                  return n.RSAPublicKey.decode(c2.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                  return c2.subjectPrivateKey = c2.subjectPublicKey, { type: "ec", data: c2 };
                case "1.2.840.10040.4.1":
                  return c2.algorithm.params.pub_key = n.DSAparam.decode(c2.subjectPublicKey.data, "der"), { type: "dsa", data: c2.algorithm.params };
                default:
                  throw new Error("unknown key id " + r2);
              }
            case "ENCRYPTED PRIVATE KEY":
              f = (function(e3, t4) {
                var r3 = e3.algorithm.decrypt.kde.kdeparams.salt, n2 = parseInt(e3.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), s2 = i[e3.algorithm.decrypt.cipher.algo.join(".")], c3 = e3.algorithm.decrypt.cipher.iv, u2 = e3.subjectPrivateKey, h2 = parseInt(s2.split("-")[1], 10) / 8, f2 = a.pbkdf2Sync(t4, r3, n2, h2, "sha1"), d = o.createDecipheriv(s2, f2, c3), p = [];
                return p.push(d.update(u2)), p.push(d.final()), l.concat(p);
              })(f = n.EncryptedPrivateKey.decode(f, "der"), t3);
            case "PRIVATE KEY":
              switch (r2 = (c2 = n.PrivateKey.decode(f, "der")).algorithm.algorithm.join(".")) {
                case "1.2.840.113549.1.1.1":
                  return n.RSAPrivateKey.decode(c2.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                  return { curve: c2.algorithm.curve, privateKey: n.ECPrivateKey.decode(c2.subjectPrivateKey, "der").privateKey };
                case "1.2.840.10040.4.1":
                  return c2.algorithm.params.priv_key = n.DSAparam.decode(c2.subjectPrivateKey, "der"), { type: "dsa", params: c2.algorithm.params };
                default:
                  throw new Error("unknown key id " + r2);
              }
            case "RSA PUBLIC KEY":
              return n.RSAPublicKey.decode(f, "der");
            case "RSA PRIVATE KEY":
              return n.RSAPrivateKey.decode(f, "der");
            case "DSA PRIVATE KEY":
              return { type: "dsa", params: n.DSAPrivateKey.decode(f, "der") };
            case "EC PRIVATE KEY":
              return { curve: (f = n.ECPrivateKey.decode(f, "der")).parameters.value, privateKey: f.privateKey };
            default:
              throw new Error("unknown key type " + h);
          }
        }
        t2.exports = c, c.signature = n.signature;
      }, { "./aesid.json": 455, "./asn1": 456, "./fixProc": 458, "browserify-aes": 191, pbkdf2: 460, "safe-buffer": 494 }], 460: [function(e, t2, r) {
        r.pbkdf2 = e("./lib/async"), r.pbkdf2Sync = e("./lib/sync");
      }, { "./lib/async": 461, "./lib/sync": 464 }], 461: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n, i, s = e("safe-buffer").Buffer, o = e("./precondition"), a = e("./default-encoding"), l = e("./sync"), c = e("./to-buffer"), u = r2.crypto && r2.crypto.subtle, h = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, f = [];
            function d() {
              return i || (i = r2.process && r2.process.nextTick ? r2.process.nextTick : r2.queueMicrotask ? r2.queueMicrotask : r2.setImmediate ? r2.setImmediate : r2.setTimeout);
            }
            function p(e2, t3, r3, n2, i2) {
              return u.importKey("raw", e2, { name: "PBKDF2" }, false, ["deriveBits"]).then((function(e3) {
                return u.deriveBits({ name: "PBKDF2", salt: t3, iterations: r3, hash: { name: i2 } }, e3, n2 << 3);
              })).then((function(e3) {
                return s.from(e3);
              }));
            }
            t2.exports = function(e2, t3, i2, m, b, g) {
              "function" == typeof b && (g = b, b = void 0);
              var y = h[(b = b || "sha1").toLowerCase()];
              if (y && "function" == typeof r2.Promise) {
                if (o(i2, m), e2 = c(e2, a, "Password"), t3 = c(t3, a, "Salt"), "function" != typeof g) throw new Error("No callback provided to pbkdf2");
                !(function(e3, t4) {
                  e3.then((function(e4) {
                    d()((function() {
                      t4(null, e4);
                    }));
                  }), (function(e4) {
                    d()((function() {
                      t4(e4);
                    }));
                  }));
                })((function(e3) {
                  if (r2.process && !r2.process.browser) return Promise.resolve(false);
                  if (!u || !u.importKey || !u.deriveBits) return Promise.resolve(false);
                  if (void 0 !== f[e3]) return f[e3];
                  var t4 = p(n = n || s.alloc(8), n, 10, 128, e3).then((function() {
                    return true;
                  })).catch((function() {
                    return false;
                  }));
                  return f[e3] = t4, t4;
                })(y).then((function(r3) {
                  return r3 ? p(e2, t3, i2, m, y) : l(e2, t3, i2, m, b);
                })), g);
              } else d()((function() {
                var r3;
                try {
                  r3 = l(e2, t3, i2, m, b);
                } catch (e3) {
                  return g(e3);
                }
                g(null, r3);
              }));
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "./default-encoding": 462, "./precondition": 463, "./sync": 464, "./to-buffer": 465, "safe-buffer": 494 }], 462: [function(e, t2, r) {
        (function(e2, r2) {
          (function() {
            var n;
            if (r2.process && r2.process.browser) n = "utf-8";
            else if (r2.process && r2.process.version) {
              n = parseInt(e2.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
            } else n = "utf-8";
            t2.exports = n;
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { _process: 467 }], 463: [function(e, t2, r) {
        var n = Math.pow(2, 30) - 1;
        t2.exports = function(e2, t3) {
          if ("number" != typeof e2) throw new TypeError("Iterations not a number");
          if (e2 < 0) throw new TypeError("Bad iterations");
          if ("number" != typeof t3) throw new TypeError("Key length not a number");
          if (t3 < 0 || t3 > n || t3 != t3) throw new TypeError("Bad key length");
        };
      }, {}], 464: [function(e, t2, r) {
        var n = e("create-hash/md5"), i = e("ripemd160"), s = e("sha.js"), o = e("safe-buffer").Buffer, a = e("./precondition"), l = e("./default-encoding"), c = e("./to-buffer"), u = o.alloc(128), h = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
        function f(e2, t3, r2) {
          var a2 = /* @__PURE__ */ (function(e3) {
            function t4(t5) {
              return s(e3).update(t5).digest();
            }
            return "rmd160" === e3 || "ripemd160" === e3 ? function(e4) {
              return new i().update(e4).digest();
            } : "md5" === e3 ? n : t4;
          })(e2), l2 = "sha512" === e2 || "sha384" === e2 ? 128 : 64;
          t3.length > l2 ? t3 = a2(t3) : t3.length < l2 && (t3 = o.concat([t3, u], l2));
          for (var c2 = o.allocUnsafe(l2 + h[e2]), f2 = o.allocUnsafe(l2 + h[e2]), d = 0; d < l2; d++) c2[d] = 54 ^ t3[d], f2[d] = 92 ^ t3[d];
          var p = o.allocUnsafe(l2 + r2 + 4);
          c2.copy(p, 0, 0, l2), this.ipad1 = p, this.ipad2 = c2, this.opad = f2, this.alg = e2, this.blocksize = l2, this.hash = a2, this.size = h[e2];
        }
        f.prototype.run = function(e2, t3) {
          return e2.copy(t3, this.blocksize), this.hash(t3).copy(this.opad, this.blocksize), this.hash(this.opad);
        }, t2.exports = function(e2, t3, r2, n2, i2) {
          a(r2, n2);
          var s2 = new f(i2 = i2 || "sha1", e2 = c(e2, l, "Password"), (t3 = c(t3, l, "Salt")).length), u2 = o.allocUnsafe(n2), d = o.allocUnsafe(t3.length + 4);
          t3.copy(d, 0, 0, t3.length);
          for (var p = 0, m = h[i2], b = Math.ceil(n2 / m), g = 1; g <= b; g++) {
            d.writeUInt32BE(g, t3.length);
            for (var y = s2.run(d, s2.ipad1), v = y, w = 1; w < r2; w++) {
              v = s2.run(v, s2.ipad2);
              for (var _ = 0; _ < m; _++) y[_] ^= v[_];
            }
            y.copy(u2, p), p += m;
          }
          return u2;
        };
      }, { "./default-encoding": 462, "./precondition": 463, "./to-buffer": 465, "create-hash/md5": 387, ripemd160: 493, "safe-buffer": 494, "sha.js": 498 }], 465: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer;
        t2.exports = function(e2, t3, r2) {
          if (n.isBuffer(e2)) return e2;
          if ("string" == typeof e2) return n.from(e2, t3);
          if (ArrayBuffer.isView(e2)) return n.from(e2.buffer);
          throw new TypeError(r2 + " must be a string, a Buffer, a typed array or a DataView");
        };
      }, { "safe-buffer": 494 }], 466: [function(e, t2, r) {
        (function(e2) {
          (function() {
            void 0 === e2 || !e2.version || 0 === e2.version.indexOf("v0.") || 0 === e2.version.indexOf("v1.") && 0 !== e2.version.indexOf("v1.8.") ? t2.exports = { nextTick: function(t3, r2, n, i) {
              if ("function" != typeof t3) throw new TypeError('"callback" argument must be a function');
              var s, o, a = arguments.length;
              switch (a) {
                case 0:
                case 1:
                  return e2.nextTick(t3);
                case 2:
                  return e2.nextTick((function() {
                    t3.call(null, r2);
                  }));
                case 3:
                  return e2.nextTick((function() {
                    t3.call(null, r2, n);
                  }));
                case 4:
                  return e2.nextTick((function() {
                    t3.call(null, r2, n, i);
                  }));
                default:
                  for (s = new Array(a - 1), o = 0; o < s.length; ) s[o++] = arguments[o];
                  return e2.nextTick((function() {
                    t3.apply(null, s);
                  }));
              }
            } } : t2.exports = e2;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 467 }], 467: [function(e, t2, r) {
        var n, i, s = t2.exports = {};
        function o() {
          throw new Error("setTimeout has not been defined");
        }
        function a() {
          throw new Error("clearTimeout has not been defined");
        }
        function l(e2) {
          if (n === setTimeout) return setTimeout(e2, 0);
          if ((n === o || !n) && setTimeout) return n = setTimeout, setTimeout(e2, 0);
          try {
            return n(e2, 0);
          } catch (t3) {
            try {
              return n.call(null, e2, 0);
            } catch (t4) {
              return n.call(this, e2, 0);
            }
          }
        }
        !(function() {
          try {
            n = "function" == typeof setTimeout ? setTimeout : o;
          } catch (e2) {
            n = o;
          }
          try {
            i = "function" == typeof clearTimeout ? clearTimeout : a;
          } catch (e2) {
            i = a;
          }
        })();
        var c, u = [], h = false, f = -1;
        function d() {
          h && c && (h = false, c.length ? u = c.concat(u) : f = -1, u.length && p());
        }
        function p() {
          if (!h) {
            var e2 = l(d);
            h = true;
            for (var t3 = u.length; t3; ) {
              for (c = u, u = []; ++f < t3; ) c && c[f].run();
              f = -1, t3 = u.length;
            }
            c = null, h = false, (function(e3) {
              if (i === clearTimeout) return clearTimeout(e3);
              if ((i === a || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e3);
              try {
                i(e3);
              } catch (t4) {
                try {
                  return i.call(null, e3);
                } catch (t5) {
                  return i.call(this, e3);
                }
              }
            })(e2);
          }
        }
        function m(e2, t3) {
          this.fun = e2, this.array = t3;
        }
        function b() {
        }
        s.nextTick = function(e2) {
          var t3 = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var r2 = 1; r2 < arguments.length; r2++) t3[r2 - 1] = arguments[r2];
          u.push(new m(e2, t3)), 1 !== u.length || h || l(p);
        }, m.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = true, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = b, s.addListener = b, s.once = b, s.off = b, s.removeListener = b, s.removeAllListeners = b, s.emit = b, s.prependListener = b, s.prependOnceListener = b, s.listeners = function(e2) {
          return [];
        }, s.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 468: [function(e, t2, r) {
        r.publicEncrypt = e("./publicEncrypt"), r.privateDecrypt = e("./privateDecrypt"), r.privateEncrypt = function(e2, t3) {
          return r.publicEncrypt(e2, t3, true);
        }, r.publicDecrypt = function(e2, t3) {
          return r.privateDecrypt(e2, t3, true);
        };
      }, { "./privateDecrypt": 471, "./publicEncrypt": 472 }], 469: [function(e, t2, r) {
        var n = e("create-hash"), i = e("safe-buffer").Buffer;
        function s(e2) {
          var t3 = i.allocUnsafe(4);
          return t3.writeUInt32BE(e2, 0), t3;
        }
        t2.exports = function(e2, t3) {
          for (var r2, o = i.alloc(0), a = 0; o.length < t3; ) r2 = s(a++), o = i.concat([o, n("sha1").update(e2).update(r2).digest()]);
          return o.slice(0, t3);
        };
      }, { "create-hash": 386, "safe-buffer": 494 }], 470: [function(e, t2, r) {
        arguments[4][184][0].apply(r, arguments);
      }, { buffer: 188, dup: 184 }], 471: [function(e, t2, r) {
        var n = e("parse-asn1"), i = e("./mgf"), s = e("./xor"), o = e("bn.js"), a = e("browserify-rsa"), l = e("create-hash"), c = e("./withPublic"), u = e("safe-buffer").Buffer;
        t2.exports = function(e2, t3, r2) {
          var h;
          h = e2.padding ? e2.padding : r2 ? 1 : 4;
          var f, d = n(e2), p = d.modulus.byteLength();
          if (t3.length > p || new o(t3).cmp(d.modulus) >= 0) throw new Error("decryption error");
          f = r2 ? c(new o(t3), d) : a(t3, d);
          var m = u.alloc(p - f.length);
          if (f = u.concat([m, f], p), 4 === h) return (function(e3, t4) {
            var r3 = e3.modulus.byteLength(), n2 = l("sha1").update(u.alloc(0)).digest(), o2 = n2.length;
            if (0 !== t4[0]) throw new Error("decryption error");
            var a2 = t4.slice(1, o2 + 1), c2 = t4.slice(o2 + 1), h2 = s(a2, i(c2, o2)), f2 = s(c2, i(h2, r3 - o2 - 1));
            if ((function(e4, t5) {
              e4 = u.from(e4), t5 = u.from(t5);
              var r4 = 0, n3 = e4.length;
              e4.length !== t5.length && (r4++, n3 = Math.min(e4.length, t5.length));
              var i2 = -1;
              for (; ++i2 < n3; ) r4 += e4[i2] ^ t5[i2];
              return r4;
            })(n2, f2.slice(0, o2))) throw new Error("decryption error");
            var d2 = o2;
            for (; 0 === f2[d2]; ) d2++;
            if (1 !== f2[d2++]) throw new Error("decryption error");
            return f2.slice(d2);
          })(d, f);
          if (1 === h) return (function(e3, t4, r3) {
            var n2 = t4.slice(0, 2), i2 = 2, s2 = 0;
            for (; 0 !== t4[i2++]; ) if (i2 >= t4.length) {
              s2++;
              break;
            }
            var o2 = t4.slice(2, i2 - 1);
            ("0002" !== n2.toString("hex") && !r3 || "0001" !== n2.toString("hex") && r3) && s2++;
            o2.length < 8 && s2++;
            if (s2) throw new Error("decryption error");
            return t4.slice(i2);
          })(0, f, r2);
          if (3 === h) return f;
          throw new Error("unknown padding");
        };
      }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 209, "create-hash": 386, "parse-asn1": 459, "safe-buffer": 494 }], 472: [function(e, t2, r) {
        var n = e("parse-asn1"), i = e("randombytes"), s = e("create-hash"), o = e("./mgf"), a = e("./xor"), l = e("bn.js"), c = e("./withPublic"), u = e("browserify-rsa"), h = e("safe-buffer").Buffer;
        t2.exports = function(e2, t3, r2) {
          var f;
          f = e2.padding ? e2.padding : r2 ? 1 : 4;
          var d, p = n(e2);
          if (4 === f) d = (function(e3, t4) {
            var r3 = e3.modulus.byteLength(), n2 = t4.length, c2 = s("sha1").update(h.alloc(0)).digest(), u2 = c2.length, f2 = 2 * u2;
            if (n2 > r3 - f2 - 2) throw new Error("message too long");
            var d2 = h.alloc(r3 - n2 - f2 - 2), p2 = r3 - u2 - 1, m = i(u2), b = a(h.concat([c2, d2, h.alloc(1, 1), t4], p2), o(m, p2)), g = a(m, o(b, u2));
            return new l(h.concat([h.alloc(1), g, b], r3));
          })(p, t3);
          else if (1 === f) d = (function(e3, t4, r3) {
            var n2, s2 = t4.length, o2 = e3.modulus.byteLength();
            if (s2 > o2 - 11) throw new Error("message too long");
            n2 = r3 ? h.alloc(o2 - s2 - 3, 255) : (function(e4) {
              var t5, r4 = h.allocUnsafe(e4), n3 = 0, s3 = i(2 * e4), o3 = 0;
              for (; n3 < e4; ) o3 === s3.length && (s3 = i(2 * e4), o3 = 0), (t5 = s3[o3++]) && (r4[n3++] = t5);
              return r4;
            })(o2 - s2 - 3);
            return new l(h.concat([h.from([0, r3 ? 1 : 2]), n2, h.alloc(1), t4], o2));
          })(p, t3, r2);
          else {
            if (3 !== f) throw new Error("unknown padding");
            if ((d = new l(t3)).cmp(p.modulus) >= 0) throw new Error("data too long for modulus");
          }
          return r2 ? u(d, p) : c(d, p);
        };
      }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 209, "create-hash": 386, "parse-asn1": 459, randombytes: 475, "safe-buffer": 494 }], 473: [function(e, t2, r) {
        var n = e("bn.js"), i = e("safe-buffer").Buffer;
        t2.exports = function(e2, t3) {
          return i.from(e2.toRed(n.mont(t3.modulus)).redPow(new n(t3.publicExponent)).fromRed().toArray());
        };
      }, { "bn.js": 470, "safe-buffer": 494 }], 474: [function(e, t2, r) {
        t2.exports = function(e2, t3) {
          for (var r2 = e2.length, n = -1; ++n < r2; ) e2[n] ^= t3[n];
          return e2;
        };
      }, {}], 475: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            var i = e("safe-buffer").Buffer, s = n.crypto || n.msCrypto;
            s && s.getRandomValues ? t2.exports = function(e2, t3) {
              if (e2 > 4294967295) throw new RangeError("requested too many random bytes");
              var n2 = i.allocUnsafe(e2);
              if (e2 > 0) if (e2 > 65536) for (var o = 0; o < e2; o += 65536) s.getRandomValues(n2.slice(o, o + 65536));
              else s.getRandomValues(n2);
              if ("function" == typeof t3) return r2.nextTick((function() {
                t3(null, n2);
              }));
              return n2;
            } : t2.exports = function() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { _process: 467, "safe-buffer": 494 }], 476: [function(e, t2, r) {
        (function(t3, n) {
          (function() {
            function i() {
              throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
            }
            var s = e("safe-buffer"), o = e("randombytes"), a = s.Buffer, l = s.kMaxLength, c = n.crypto || n.msCrypto, u = Math.pow(2, 32) - 1;
            function h(e2, t4) {
              if ("number" != typeof e2 || e2 != e2) throw new TypeError("offset must be a number");
              if (e2 > u || e2 < 0) throw new TypeError("offset must be a uint32");
              if (e2 > l || e2 > t4) throw new RangeError("offset out of range");
            }
            function f(e2, t4, r2) {
              if ("number" != typeof e2 || e2 != e2) throw new TypeError("size must be a number");
              if (e2 > u || e2 < 0) throw new TypeError("size must be a uint32");
              if (e2 + t4 > r2 || e2 > l) throw new RangeError("buffer too small");
            }
            function d(e2, r2, n2, i2) {
              if (t3.browser) {
                var s2 = e2.buffer, a2 = new Uint8Array(s2, r2, n2);
                return c.getRandomValues(a2), i2 ? void t3.nextTick((function() {
                  i2(null, e2);
                })) : e2;
              }
              if (!i2) return o(n2).copy(e2, r2), e2;
              o(n2, (function(t4, n3) {
                if (t4) return i2(t4);
                n3.copy(e2, r2), i2(null, e2);
              }));
            }
            c && c.getRandomValues || !t3.browser ? (r.randomFill = function(e2, t4, r2, i2) {
              if (!(a.isBuffer(e2) || e2 instanceof n.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
              if ("function" == typeof t4) i2 = t4, t4 = 0, r2 = e2.length;
              else if ("function" == typeof r2) i2 = r2, r2 = e2.length - t4;
              else if ("function" != typeof i2) throw new TypeError('"cb" argument must be a function');
              return h(t4, e2.length), f(r2, t4, e2.length), d(e2, t4, r2, i2);
            }, r.randomFillSync = function(e2, t4, r2) {
              void 0 === t4 && (t4 = 0);
              if (!(a.isBuffer(e2) || e2 instanceof n.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
              h(t4, e2.length), void 0 === r2 && (r2 = e2.length - t4);
              return f(r2, t4, e2.length), d(e2, t4, r2);
            }) : (r.randomFill = i, r.randomFillSync = i);
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { _process: 467, randombytes: 475, "safe-buffer": 494 }], 477: [function(e, t2, r) {
        var n = {};
        function i(e2, t3, r2) {
          r2 || (r2 = Error);
          var i2 = (function(e3) {
            var r3, n2;
            function i3(r4, n3, i4) {
              return e3.call(this, (function(e4, r5, n4) {
                return "string" == typeof t3 ? t3 : t3(e4, r5, n4);
              })(r4, n3, i4)) || this;
            }
            return n2 = e3, (r3 = i3).prototype = Object.create(n2.prototype), r3.prototype.constructor = r3, r3.__proto__ = n2, i3;
          })(r2);
          i2.prototype.name = r2.name, i2.prototype.code = e2, n[e2] = i2;
        }
        function s(e2, t3) {
          if (Array.isArray(e2)) {
            var r2 = e2.length;
            return e2 = e2.map((function(e3) {
              return String(e3);
            })), r2 > 2 ? "one of ".concat(t3, " ").concat(e2.slice(0, r2 - 1).join(", "), ", or ") + e2[r2 - 1] : 2 === r2 ? "one of ".concat(t3, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t3, " ").concat(e2[0]);
          }
          return "of ".concat(t3, " ").concat(String(e2));
        }
        i("ERR_INVALID_OPT_VALUE", (function(e2, t3) {
          return 'The value "' + t3 + '" is invalid for option "' + e2 + '"';
        }), TypeError), i("ERR_INVALID_ARG_TYPE", (function(e2, t3, r2) {
          var n2, i2, a;
          if ("string" == typeof t3 && (i2 = "not ", t3.substr(0, i2.length) === i2) ? (n2 = "must not be", t3 = t3.replace(/^not /, "")) : n2 = "must be", (function(e3, t4, r3) {
            return (void 0 === r3 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t4.length, r3) === t4;
          })(e2, " argument")) a = "The ".concat(e2, " ").concat(n2, " ").concat(s(t3, "type"));
          else {
            var l = (function(e3, t4, r3) {
              return "number" != typeof r3 && (r3 = 0), !(r3 + t4.length > e3.length) && -1 !== e3.indexOf(t4, r3);
            })(e2, ".") ? "property" : "argument";
            a = 'The "'.concat(e2, '" ').concat(l, " ").concat(n2, " ").concat(s(t3, "type"));
          }
          return a += ". Received type ".concat(typeof r2);
        }), TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", (function(e2) {
          return "The " + e2 + " method is not implemented";
        })), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", (function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        })), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", (function(e2) {
          return "Unknown encoding: " + e2;
        }), TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t2.exports.codes = n;
      }, {}], 478: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n = Object.keys || function(e2) {
              var t3 = [];
              for (var r3 in e2) t3.push(r3);
              return t3;
            };
            t2.exports = c;
            var i = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(c, i);
            for (var o = n(s.prototype), a = 0; a < o.length; a++) {
              var l = o[a];
              c.prototype[l] || (c.prototype[l] = s.prototype[l]);
            }
            function c(e2) {
              if (!(this instanceof c)) return new c(e2);
              i.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", u)));
            }
            function u() {
              this._writableState.ended || r2.nextTick(h, this);
            }
            function h(e2) {
              e2.end();
            }
            Object.defineProperty(c.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(c.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(c.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(c.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
            }, set: function(e2) {
              void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 480, "./_stream_writable": 482, _process: 467, inherits: 440 }], 479: [function(e, t2, r) {
        t2.exports = i;
        var n = e("./_stream_transform");
        function i(e2) {
          if (!(this instanceof i)) return new i(e2);
          n.call(this, e2);
        }
        e("inherits")(i, n), i.prototype._transform = function(e2, t3, r2) {
          r2(null, e2);
        };
      }, { "./_stream_transform": 481, inherits: 440 }], 480: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            var i;
            t2.exports = M, M.ReadableState = S;
            e("events").EventEmitter;
            var s = function(e2, t3) {
              return e2.listeners(t3).length;
            }, o = e("./internal/streams/stream"), a = e("buffer").Buffer, l = (void 0 !== n ? n : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
            };
            var c, u = e("util");
            c = u && u.debuglog ? u.debuglog("stream") : function() {
            };
            var h, f, d, p = e("./internal/streams/buffer_list"), m = e("./internal/streams/destroy"), b = e("./internal/streams/state").getHighWaterMark, g = e("../errors").codes, y = g.ERR_INVALID_ARG_TYPE, v = g.ERR_STREAM_PUSH_AFTER_EOF, w = g.ERR_METHOD_NOT_IMPLEMENTED, _ = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(M, o);
            var x = m.errorOrDestroy, k = ["error", "close", "destroy", "pause", "resume"];
            function S(t3, r3, n2) {
              i = i || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof n2 && (n2 = r3 instanceof i), this.objectMode = !!t3.objectMode, n2 && (this.objectMode = this.objectMode || !!t3.readableObjectMode), this.highWaterMark = b(this, t3, "readableHighWaterMark", n2), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (h || (h = e("string_decoder/").StringDecoder), this.decoder = new h(t3.encoding), this.encoding = t3.encoding);
            }
            function M(t3) {
              if (i = i || e("./_stream_duplex"), !(this instanceof M)) return new M(t3);
              var r3 = this instanceof i;
              this._readableState = new S(t3, this, r3), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), o.call(this);
            }
            function C2(e2, t3, r3, n2, i2) {
              c("readableAddChunk", t3);
              var s2, o2 = e2._readableState;
              if (null === t3) o2.reading = false, (function(e3, t4) {
                if (c("onEofChunk"), t4.ended) return;
                if (t4.decoder) {
                  var r4 = t4.decoder.end();
                  r4 && r4.length && (t4.buffer.push(r4), t4.length += t4.objectMode ? 1 : r4.length);
                }
                t4.ended = true, t4.sync ? A(e3) : (t4.needReadable = false, t4.emittedReadable || (t4.emittedReadable = true, R(e3)));
              })(e2, o2);
              else if (i2 || (s2 = (function(e3, t4) {
                var r4;
                n3 = t4, a.isBuffer(n3) || n3 instanceof l || "string" == typeof t4 || void 0 === t4 || e3.objectMode || (r4 = new y("chunk", ["string", "Buffer", "Uint8Array"], t4));
                var n3;
                return r4;
              })(o2, t3)), s2) x(e2, s2);
              else if (o2.objectMode || t3 && t3.length > 0) if ("string" == typeof t3 || o2.objectMode || Object.getPrototypeOf(t3) === a.prototype || (t3 = (function(e3) {
                return a.from(e3);
              })(t3)), n2) o2.endEmitted ? x(e2, new _()) : T(e2, o2, t3, true);
              else if (o2.ended) x(e2, new v());
              else {
                if (o2.destroyed) return false;
                o2.reading = false, o2.decoder && !r3 ? (t3 = o2.decoder.write(t3), o2.objectMode || 0 !== t3.length ? T(e2, o2, t3, false) : O(e2, o2)) : T(e2, o2, t3, false);
              }
              else n2 || (o2.reading = false, O(e2, o2));
              return !o2.ended && (o2.length < o2.highWaterMark || 0 === o2.length);
            }
            function T(e2, t3, r3, n2) {
              t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e2.emit("data", r3)) : (t3.length += t3.objectMode ? 1 : r3.length, n2 ? t3.buffer.unshift(r3) : t3.buffer.push(r3), t3.needReadable && A(e2)), O(e2, t3);
            }
            Object.defineProperty(M.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), M.prototype.destroy = m.destroy, M.prototype._undestroy = m.undestroy, M.prototype._destroy = function(e2, t3) {
              t3(e2);
            }, M.prototype.push = function(e2, t3) {
              var r3, n2 = this._readableState;
              return n2.objectMode ? r3 = true : "string" == typeof e2 && ((t3 = t3 || n2.defaultEncoding) !== n2.encoding && (e2 = a.from(e2, t3), t3 = ""), r3 = true), C2(this, e2, t3, false, r3);
            }, M.prototype.unshift = function(e2) {
              return C2(this, e2, null, true, false);
            }, M.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, M.prototype.setEncoding = function(t3) {
              h || (h = e("string_decoder/").StringDecoder);
              var r3 = new h(t3);
              this._readableState.decoder = r3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var n2 = this._readableState.buffer.head, i2 = ""; null !== n2; ) i2 += r3.write(n2.data), n2 = n2.next;
              return this._readableState.buffer.clear(), "" !== i2 && this._readableState.buffer.push(i2), this._readableState.length = i2.length, this;
            };
            function E(e2, t3) {
              return e2 <= 0 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e2 != e2 ? t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length : (e2 > t3.highWaterMark && (t3.highWaterMark = (function(e3) {
                return e3 >= 1073741824 ? e3 = 1073741824 : (e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, e3++), e3;
              })(e2)), e2 <= t3.length ? e2 : t3.ended ? t3.length : (t3.needReadable = true, 0));
            }
            function A(e2) {
              var t3 = e2._readableState;
              c("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (c("emitReadable", t3.flowing), t3.emittedReadable = true, r2.nextTick(R, e2));
            }
            function R(e2) {
              var t3 = e2._readableState;
              c("emitReadable_", t3.destroyed, t3.length, t3.ended), t3.destroyed || !t3.length && !t3.ended || (e2.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, B(e2);
            }
            function O(e2, t3) {
              t3.readingMore || (t3.readingMore = true, r2.nextTick(j, e2, t3));
            }
            function j(e2, t3) {
              for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
                var r3 = t3.length;
                if (c("maybeReadMore read 0"), e2.read(0), r3 === t3.length) break;
              }
              t3.readingMore = false;
            }
            function I(e2) {
              var t3 = e2._readableState;
              t3.readableListening = e2.listenerCount("readable") > 0, t3.resumeScheduled && !t3.paused ? t3.flowing = true : e2.listenerCount("data") > 0 && e2.resume();
            }
            function N(e2) {
              c("readable nexttick read 0"), e2.read(0);
            }
            function P(e2, t3) {
              c("resume", t3.reading), t3.reading || e2.read(0), t3.resumeScheduled = false, e2.emit("resume"), B(e2), t3.flowing && !t3.reading && e2.read(0);
            }
            function B(e2) {
              var t3 = e2._readableState;
              for (c("flow", t3.flowing); t3.flowing && null !== e2.read(); ) ;
            }
            function D(e2, t3) {
              return 0 === t3.length ? null : (t3.objectMode ? r3 = t3.buffer.shift() : !e2 || e2 >= t3.length ? (r3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : r3 = t3.buffer.consume(e2, t3.decoder), r3);
              var r3;
            }
            function F(e2) {
              var t3 = e2._readableState;
              c("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, r2.nextTick(L, t3, e2));
            }
            function L(e2, t3) {
              if (c("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t3.readable = false, t3.emit("end"), e2.autoDestroy)) {
                var r3 = t3._writableState;
                (!r3 || r3.autoDestroy && r3.finished) && t3.destroy();
              }
            }
            function z(e2, t3) {
              for (var r3 = 0, n2 = e2.length; r3 < n2; r3++) if (e2[r3] === t3) return r3;
              return -1;
            }
            M.prototype.read = function(e2) {
              c("read", e2), e2 = parseInt(e2, 10);
              var t3 = this._readableState, r3 = e2;
              if (0 !== e2 && (t3.emittedReadable = false), 0 === e2 && t3.needReadable && ((0 !== t3.highWaterMark ? t3.length >= t3.highWaterMark : t3.length > 0) || t3.ended)) return c("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? F(this) : A(this), null;
              if (0 === (e2 = E(e2, t3)) && t3.ended) return 0 === t3.length && F(this), null;
              var n2, i2 = t3.needReadable;
              return c("need readable", i2), (0 === t3.length || t3.length - e2 < t3.highWaterMark) && c("length less than watermark", i2 = true), t3.ended || t3.reading ? c("reading or ended", i2 = false) : i2 && (c("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, t3.reading || (e2 = E(r3, t3))), null === (n2 = e2 > 0 ? D(e2, t3) : null) ? (t3.needReadable = t3.length <= t3.highWaterMark, e2 = 0) : (t3.length -= e2, t3.awaitDrain = 0), 0 === t3.length && (t3.ended || (t3.needReadable = true), r3 !== e2 && t3.ended && F(this)), null !== n2 && this.emit("data", n2), n2;
            }, M.prototype._read = function(e2) {
              x(this, new w("_read()"));
            }, M.prototype.pipe = function(e2, t3) {
              var n2 = this, i2 = this._readableState;
              switch (i2.pipesCount) {
                case 0:
                  i2.pipes = e2;
                  break;
                case 1:
                  i2.pipes = [i2.pipes, e2];
                  break;
                default:
                  i2.pipes.push(e2);
              }
              i2.pipesCount += 1, c("pipe count=%d opts=%j", i2.pipesCount, t3);
              var o2 = (!t3 || false !== t3.end) && e2 !== r2.stdout && e2 !== r2.stderr ? l2 : b2;
              function a2(t4, r3) {
                c("onunpipe"), t4 === n2 && r3 && false === r3.hasUnpiped && (r3.hasUnpiped = true, c("cleanup"), e2.removeListener("close", p2), e2.removeListener("finish", m2), e2.removeListener("drain", u2), e2.removeListener("error", d2), e2.removeListener("unpipe", a2), n2.removeListener("end", l2), n2.removeListener("end", b2), n2.removeListener("data", f2), h2 = true, !i2.awaitDrain || e2._writableState && !e2._writableState.needDrain || u2());
              }
              function l2() {
                c("onend"), e2.end();
              }
              i2.endEmitted ? r2.nextTick(o2) : n2.once("end", o2), e2.on("unpipe", a2);
              var u2 = /* @__PURE__ */ (function(e3) {
                return function() {
                  var t4 = e3._readableState;
                  c("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && s(e3, "data") && (t4.flowing = true, B(e3));
                };
              })(n2);
              e2.on("drain", u2);
              var h2 = false;
              function f2(t4) {
                c("ondata");
                var r3 = e2.write(t4);
                c("dest.write", r3), false === r3 && ((1 === i2.pipesCount && i2.pipes === e2 || i2.pipesCount > 1 && -1 !== z(i2.pipes, e2)) && !h2 && (c("false write response, pause", i2.awaitDrain), i2.awaitDrain++), n2.pause());
              }
              function d2(t4) {
                c("onerror", t4), b2(), e2.removeListener("error", d2), 0 === s(e2, "error") && x(e2, t4);
              }
              function p2() {
                e2.removeListener("finish", m2), b2();
              }
              function m2() {
                c("onfinish"), e2.removeListener("close", p2), b2();
              }
              function b2() {
                c("unpipe"), n2.unpipe(e2);
              }
              return n2.on("data", f2), (function(e3, t4, r3) {
                if ("function" == typeof e3.prependListener) return e3.prependListener(t4, r3);
                e3._events && e3._events[t4] ? Array.isArray(e3._events[t4]) ? e3._events[t4].unshift(r3) : e3._events[t4] = [r3, e3._events[t4]] : e3.on(t4, r3);
              })(e2, "error", d2), e2.once("close", p2), e2.once("finish", m2), e2.emit("pipe", n2), i2.flowing || (c("pipe resume"), n2.resume()), e2;
            }, M.prototype.unpipe = function(e2) {
              var t3 = this._readableState, r3 = { hasUnpiped: false };
              if (0 === t3.pipesCount) return this;
              if (1 === t3.pipesCount) return e2 && e2 !== t3.pipes || (e2 || (e2 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e2 && e2.emit("unpipe", this, r3)), this;
              if (!e2) {
                var n2 = t3.pipes, i2 = t3.pipesCount;
                t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
                for (var s2 = 0; s2 < i2; s2++) n2[s2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var o2 = z(t3.pipes, e2);
              return -1 === o2 || (t3.pipes.splice(o2, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e2.emit("unpipe", this, r3)), this;
            }, M.prototype.on = function(e2, t3) {
              var n2 = o.prototype.on.call(this, e2, t3), i2 = this._readableState;
              return "data" === e2 ? (i2.readableListening = this.listenerCount("readable") > 0, false !== i2.flowing && this.resume()) : "readable" === e2 && (i2.endEmitted || i2.readableListening || (i2.readableListening = i2.needReadable = true, i2.flowing = false, i2.emittedReadable = false, c("on readable", i2.length, i2.reading), i2.length ? A(this) : i2.reading || r2.nextTick(N, this))), n2;
            }, M.prototype.addListener = M.prototype.on, M.prototype.removeListener = function(e2, t3) {
              var n2 = o.prototype.removeListener.call(this, e2, t3);
              return "readable" === e2 && r2.nextTick(I, this), n2;
            }, M.prototype.removeAllListeners = function(e2) {
              var t3 = o.prototype.removeAllListeners.apply(this, arguments);
              return "readable" !== e2 && void 0 !== e2 || r2.nextTick(I, this), t3;
            }, M.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (c("resume"), e2.flowing = !e2.readableListening, (function(e3, t3) {
                t3.resumeScheduled || (t3.resumeScheduled = true, r2.nextTick(P, e3, t3));
              })(this, e2)), e2.paused = false, this;
            }, M.prototype.pause = function() {
              return c("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (c("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, M.prototype.wrap = function(e2) {
              var t3 = this, r3 = this._readableState, n2 = false;
              for (var i2 in e2.on("end", (function() {
                if (c("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t3.push(e3);
                }
                t3.push(null);
              })), e2.on("data", (function(i3) {
                (c("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), r3.objectMode && null == i3) || (r3.objectMode || i3 && i3.length) && (t3.push(i3) || (n2 = true, e2.pause()));
              })), e2) void 0 === this[i2] && "function" == typeof e2[i2] && (this[i2] = /* @__PURE__ */ (function(t4) {
                return function() {
                  return e2[t4].apply(e2, arguments);
                };
              })(i2));
              for (var s2 = 0; s2 < k.length; s2++) e2.on(k[s2], this.emit.bind(this, k[s2]));
              return this._read = function(t4) {
                c("wrapped _read", t4), n2 && (n2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (M.prototype[Symbol.asyncIterator] = function() {
              return void 0 === f && (f = e("./internal/streams/async_iterator")), f(this);
            }), Object.defineProperty(M.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(M.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(M.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), M._fromList = D, Object.defineProperty(M.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (M.from = function(t3, r3) {
              return void 0 === d && (d = e("./internal/streams/from")), d(M, t3, r3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/async_iterator": 483, "./internal/streams/buffer_list": 484, "./internal/streams/destroy": 485, "./internal/streams/from": 487, "./internal/streams/state": 489, "./internal/streams/stream": 490, _process: 467, buffer: 220, events: 422, inherits: 440, "string_decoder/": 522, util: 188 }], 481: [function(e, t2, r) {
        t2.exports = u;
        var n = e("../errors").codes, i = n.ERR_METHOD_NOT_IMPLEMENTED, s = n.ERR_MULTIPLE_CALLBACK, o = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = n.ERR_TRANSFORM_WITH_LENGTH_0, l = e("./_stream_duplex");
        function c(e2, t3) {
          var r2 = this._transformState;
          r2.transforming = false;
          var n2 = r2.writecb;
          if (null === n2) return this.emit("error", new s());
          r2.writechunk = null, r2.writecb = null, null != t3 && this.push(t3), n2(e2);
          var i2 = this._readableState;
          i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
        }
        function u(e2) {
          if (!(this instanceof u)) return new u(e2);
          l.call(this, e2), this._transformState = { afterTransform: c.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", h);
        }
        function h() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? f(this, null, null) : this._flush((function(t3, r2) {
            f(e2, t3, r2);
          }));
        }
        function f(e2, t3, r2) {
          if (t3) return e2.emit("error", t3);
          if (null != r2 && e2.push(r2), e2._writableState.length) throw new a();
          if (e2._transformState.transforming) throw new o();
          return e2.push(null);
        }
        e("inherits")(u, l), u.prototype.push = function(e2, t3) {
          return this._transformState.needTransform = false, l.prototype.push.call(this, e2, t3);
        }, u.prototype._transform = function(e2, t3, r2) {
          r2(new i("_transform()"));
        }, u.prototype._write = function(e2, t3, r2) {
          var n2 = this._transformState;
          if (n2.writecb = r2, n2.writechunk = e2, n2.writeencoding = t3, !n2.transforming) {
            var i2 = this._readableState;
            (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
        }, u.prototype._read = function(e2) {
          var t3 = this._transformState;
          null === t3.writechunk || t3.transforming ? t3.needTransform = true : (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
        }, u.prototype._destroy = function(e2, t3) {
          l.prototype._destroy.call(this, e2, (function(e3) {
            t3(e3);
          }));
        };
      }, { "../errors": 477, "./_stream_duplex": 478, inherits: 440 }], 482: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            function i(e2) {
              var t3 = this;
              this.next = null, this.entry = null, this.finish = function() {
                !(function(e3, t4, r3) {
                  var n2 = e3.entry;
                  e3.entry = null;
                  for (; n2; ) {
                    var i2 = n2.callback;
                    t4.pendingcb--, i2(r3), n2 = n2.next;
                  }
                  t4.corkedRequestsFree.next = e3;
                })(t3, e2);
              };
            }
            var s;
            t2.exports = M, M.WritableState = S;
            var o = { deprecate: e("util-deprecate") }, a = e("./internal/streams/stream"), l = e("buffer").Buffer, c = (void 0 !== n ? n : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
            };
            var u, h = e("./internal/streams/destroy"), f = e("./internal/streams/state").getHighWaterMark, d = e("../errors").codes, p = d.ERR_INVALID_ARG_TYPE, m = d.ERR_METHOD_NOT_IMPLEMENTED, b = d.ERR_MULTIPLE_CALLBACK, g = d.ERR_STREAM_CANNOT_PIPE, y = d.ERR_STREAM_DESTROYED, v = d.ERR_STREAM_NULL_VALUES, w = d.ERR_STREAM_WRITE_AFTER_END, _ = d.ERR_UNKNOWN_ENCODING, x = h.errorOrDestroy;
            function k() {
            }
            function S(t3, n2, o2) {
              s = s || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof o2 && (o2 = n2 instanceof s), this.objectMode = !!t3.objectMode, o2 && (this.objectMode = this.objectMode || !!t3.writableObjectMode), this.highWaterMark = f(this, t3, "writableHighWaterMark", o2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var a2 = false === t3.decodeStrings;
              this.decodeStrings = !a2, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                !(function(e3, t4) {
                  var n3 = e3._writableState, i2 = n3.sync, s2 = n3.writecb;
                  if ("function" != typeof s2) throw new b();
                  if ((function(e4) {
                    e4.writing = false, e4.writecb = null, e4.length -= e4.writelen, e4.writelen = 0;
                  })(n3), t4) !(function(e4, t5, n4, i3, s3) {
                    --t5.pendingcb, n4 ? (r2.nextTick(s3, i3), r2.nextTick(O, e4, t5), e4._writableState.errorEmitted = true, x(e4, i3)) : (s3(i3), e4._writableState.errorEmitted = true, x(e4, i3), O(e4, t5));
                  })(e3, n3, i2, t4, s2);
                  else {
                    var o3 = A(n3) || e3.destroyed;
                    o3 || n3.corked || n3.bufferProcessing || !n3.bufferedRequest || E(e3, n3), i2 ? r2.nextTick(T, e3, n3, o3, s2) : T(e3, n3, o3, s2);
                  }
                })(n2, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this);
            }
            function M(t3) {
              var r3 = this instanceof (s = s || e("./_stream_duplex"));
              if (!r3 && !u.call(M, this)) return new M(t3);
              this._writableState = new S(t3, this, r3), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), a.call(this);
            }
            function C2(e2, t3, r3, n2, i2, s2, o2) {
              t3.writelen = n2, t3.writecb = o2, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new y("write")) : r3 ? e2._writev(i2, t3.onwrite) : e2._write(i2, s2, t3.onwrite), t3.sync = false;
            }
            function T(e2, t3, r3, n2) {
              r3 || (function(e3, t4) {
                0 === t4.length && t4.needDrain && (t4.needDrain = false, e3.emit("drain"));
              })(e2, t3), t3.pendingcb--, n2(), O(e2, t3);
            }
            function E(e2, t3) {
              t3.bufferProcessing = true;
              var r3 = t3.bufferedRequest;
              if (e2._writev && r3 && r3.next) {
                var n2 = t3.bufferedRequestCount, s2 = new Array(n2), o2 = t3.corkedRequestsFree;
                o2.entry = r3;
                for (var a2 = 0, l2 = true; r3; ) s2[a2] = r3, r3.isBuf || (l2 = false), r3 = r3.next, a2 += 1;
                s2.allBuffers = l2, C2(e2, t3, true, t3.length, s2, "", o2.finish), t3.pendingcb++, t3.lastBufferedRequest = null, o2.next ? (t3.corkedRequestsFree = o2.next, o2.next = null) : t3.corkedRequestsFree = new i(t3), t3.bufferedRequestCount = 0;
              } else {
                for (; r3; ) {
                  var c2 = r3.chunk, u2 = r3.encoding, h2 = r3.callback;
                  if (C2(e2, t3, false, t3.objectMode ? 1 : c2.length, c2, u2, h2), r3 = r3.next, t3.bufferedRequestCount--, t3.writing) break;
                }
                null === r3 && (t3.lastBufferedRequest = null);
              }
              t3.bufferedRequest = r3, t3.bufferProcessing = false;
            }
            function A(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function R(e2, t3) {
              e2._final((function(r3) {
                t3.pendingcb--, r3 && x(e2, r3), t3.prefinished = true, e2.emit("prefinish"), O(e2, t3);
              }));
            }
            function O(e2, t3) {
              var n2 = A(t3);
              if (n2 && ((function(e3, t4) {
                t4.prefinished || t4.finalCalled || ("function" != typeof e3._final || t4.destroyed ? (t4.prefinished = true, e3.emit("prefinish")) : (t4.pendingcb++, t4.finalCalled = true, r2.nextTick(R, e3, t4)));
              })(e2, t3), 0 === t3.pendingcb && (t3.finished = true, e2.emit("finish"), t3.autoDestroy))) {
                var i2 = e2._readableState;
                (!i2 || i2.autoDestroy && i2.endEmitted) && e2.destroy();
              }
              return n2;
            }
            e("inherits")(M, a), S.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t3 = []; e2; ) t3.push(e2), e2 = e2.next;
              return t3;
            }, (function() {
              try {
                Object.defineProperty(S.prototype, "buffer", { get: o.deprecate((function() {
                  return this.getBuffer();
                }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            })(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(M, Symbol.hasInstance, { value: function(e2) {
              return !!u.call(this, e2) || this === M && (e2 && e2._writableState instanceof S);
            } })) : u = function(e2) {
              return e2 instanceof this;
            }, M.prototype.pipe = function() {
              x(this, new g());
            }, M.prototype.write = function(e2, t3, n2) {
              var i2, s2 = this._writableState, o2 = false, a2 = !s2.objectMode && (i2 = e2, l.isBuffer(i2) || i2 instanceof c);
              return a2 && !l.isBuffer(e2) && (e2 = (function(e3) {
                return l.from(e3);
              })(e2)), "function" == typeof t3 && (n2 = t3, t3 = null), a2 ? t3 = "buffer" : t3 || (t3 = s2.defaultEncoding), "function" != typeof n2 && (n2 = k), s2.ending ? (function(e3, t4) {
                var n3 = new w();
                x(e3, n3), r2.nextTick(t4, n3);
              })(this, n2) : (a2 || (function(e3, t4, n3, i3) {
                var s3;
                return null === n3 ? s3 = new v() : "string" == typeof n3 || t4.objectMode || (s3 = new p("chunk", ["string", "Buffer"], n3)), !s3 || (x(e3, s3), r2.nextTick(i3, s3), false);
              })(this, s2, e2, n2)) && (s2.pendingcb++, o2 = (function(e3, t4, r3, n3, i3, s3) {
                if (!r3) {
                  var o3 = (function(e4, t5, r4) {
                    e4.objectMode || false === e4.decodeStrings || "string" != typeof t5 || (t5 = l.from(t5, r4));
                    return t5;
                  })(t4, n3, i3);
                  n3 !== o3 && (r3 = true, i3 = "buffer", n3 = o3);
                }
                var a3 = t4.objectMode ? 1 : n3.length;
                t4.length += a3;
                var c2 = t4.length < t4.highWaterMark;
                c2 || (t4.needDrain = true);
                if (t4.writing || t4.corked) {
                  var u2 = t4.lastBufferedRequest;
                  t4.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r3, callback: s3, next: null }, u2 ? u2.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
                } else C2(e3, t4, false, a3, n3, i3, s3);
                return c2;
              })(this, s2, a2, e2, t3, n2)), o2;
            }, M.prototype.cork = function() {
              this._writableState.corked++;
            }, M.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, e2.writing || e2.corked || e2.bufferProcessing || !e2.bufferedRequest || E(this, e2));
            }, M.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1)) throw new _(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(M.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(M.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), M.prototype._write = function(e2, t3, r3) {
              r3(new m("_write()"));
            }, M.prototype._writev = null, M.prototype.end = function(e2, t3, n2) {
              var i2 = this._writableState;
              return "function" == typeof e2 ? (n2 = e2, e2 = null, t3 = null) : "function" == typeof t3 && (n2 = t3, t3 = null), null != e2 && this.write(e2, t3), i2.corked && (i2.corked = 1, this.uncork()), i2.ending || (function(e3, t4, n3) {
                t4.ending = true, O(e3, t4), n3 && (t4.finished ? r2.nextTick(n3) : e3.once("finish", n3));
                t4.ended = true, e3.writable = false;
              })(this, i2, n2), this;
            }, Object.defineProperty(M.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(M.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), M.prototype.destroy = h.destroy, M.prototype._undestroy = h.undestroy, M.prototype._destroy = function(e2, t3) {
              t3(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/destroy": 485, "./internal/streams/state": 489, "./internal/streams/stream": 490, _process: 467, buffer: 220, inherits: 440, "util-deprecate": 524 }], 483: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n;
            function i(e2, t3, r3) {
              return (t3 = (function(e3) {
                var t4 = (function(e4, t5) {
                  if ("object" != typeof e4 || null === e4) return e4;
                  var r4 = e4[Symbol.toPrimitive];
                  if (void 0 !== r4) {
                    var n2 = r4.call(e4, t5);
                    if ("object" != typeof n2) return n2;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return ("string" === t5 ? String : Number)(e4);
                })(e3, "string");
                return "symbol" == typeof t4 ? t4 : String(t4);
              })(t3)) in e2 ? Object.defineProperty(e2, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t3] = r3, e2;
            }
            var s = e("./end-of-stream"), o = /* @__PURE__ */ Symbol("lastResolve"), a = /* @__PURE__ */ Symbol("lastReject"), l = /* @__PURE__ */ Symbol("error"), c = /* @__PURE__ */ Symbol("ended"), u = /* @__PURE__ */ Symbol("lastPromise"), h = /* @__PURE__ */ Symbol("handlePromise"), f = /* @__PURE__ */ Symbol("stream");
            function d(e2, t3) {
              return { value: e2, done: t3 };
            }
            function p(e2) {
              var t3 = e2[o];
              if (null !== t3) {
                var r3 = e2[f].read();
                null !== r3 && (e2[u] = null, e2[o] = null, e2[a] = null, t3(d(r3, false)));
              }
            }
            function m(e2) {
              r2.nextTick(p, e2);
            }
            var b = Object.getPrototypeOf((function() {
            })), g = Object.setPrototypeOf((i(n = { get stream() {
              return this[f];
            }, next: function() {
              var e2 = this, t3 = this[l];
              if (null !== t3) return Promise.reject(t3);
              if (this[c]) return Promise.resolve(d(void 0, true));
              if (this[f].destroyed) return new Promise((function(t4, n3) {
                r2.nextTick((function() {
                  e2[l] ? n3(e2[l]) : t4(d(void 0, true));
                }));
              }));
              var n2, i2 = this[u];
              if (i2) n2 = new Promise(/* @__PURE__ */ (function(e3, t4) {
                return function(r3, n3) {
                  e3.then((function() {
                    t4[c] ? r3(d(void 0, true)) : t4[h](r3, n3);
                  }), n3);
                };
              })(i2, this));
              else {
                var s2 = this[f].read();
                if (null !== s2) return Promise.resolve(d(s2, false));
                n2 = new Promise(this[h]);
              }
              return this[u] = n2, n2;
            } }, Symbol.asyncIterator, (function() {
              return this;
            })), i(n, "return", (function() {
              var e2 = this;
              return new Promise((function(t3, r3) {
                e2[f].destroy(null, (function(e3) {
                  e3 ? r3(e3) : t3(d(void 0, true));
                }));
              }));
            })), n), b);
            t2.exports = function(e2) {
              var t3, r3 = Object.create(g, (i(t3 = {}, f, { value: e2, writable: true }), i(t3, o, { value: null, writable: true }), i(t3, a, { value: null, writable: true }), i(t3, l, { value: null, writable: true }), i(t3, c, { value: e2._readableState.endEmitted, writable: true }), i(t3, h, { value: function(e3, t4) {
                var n2 = r3[f].read();
                n2 ? (r3[u] = null, r3[o] = null, r3[a] = null, e3(d(n2, false))) : (r3[o] = e3, r3[a] = t4);
              }, writable: true }), t3));
              return r3[u] = null, s(e2, (function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t4 = r3[a];
                  return null !== t4 && (r3[u] = null, r3[o] = null, r3[a] = null, t4(e3)), void (r3[l] = e3);
                }
                var n2 = r3[o];
                null !== n2 && (r3[u] = null, r3[o] = null, r3[a] = null, n2(d(void 0, true))), r3[c] = true;
              })), e2.on("readable", m.bind(null, r3)), r3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 486, _process: 467 }], 484: [function(e, t2, r) {
        function n(e2, t3) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t3 && (n2 = n2.filter((function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            }))), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function i(e2) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? n(Object(r2), true).forEach((function(t4) {
              s(e2, t4, r2[t4]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : n(Object(r2)).forEach((function(t4) {
              Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(r2, t4));
            }));
          }
          return e2;
        }
        function s(e2, t3, r2) {
          return (t3 = a(t3)) in e2 ? Object.defineProperty(e2, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t3] = r2, e2;
        }
        function o(e2, t3) {
          for (var r2 = 0; r2 < t3.length; r2++) {
            var n2 = t3[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, a(n2.key), n2);
          }
        }
        function a(e2) {
          var t3 = (function(e3, t4) {
            if ("object" != typeof e3 || null === e3) return e3;
            var r2 = e3[Symbol.toPrimitive];
            if (void 0 !== r2) {
              var n2 = r2.call(e3, t4);
              if ("object" != typeof n2) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t4 ? String : Number)(e3);
          })(e2, "string");
          return "symbol" == typeof t3 ? t3 : String(t3);
        }
        var l = e("buffer").Buffer, c = e("util").inspect, u = c && c.custom || "inspect";
        t2.exports = (function() {
          function e2() {
            !(function(e3, t4) {
              if (!(e3 instanceof t4)) throw new TypeError("Cannot call a class as a function");
            })(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          var t3, r2;
          return t3 = e2, (r2 = [{ key: "push", value: function(e3) {
            var t4 = { data: e3, next: null };
            this.length > 0 ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t4 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length) return "";
            for (var t4 = this.head, r3 = "" + t4.data; t4 = t4.next; ) r3 += e3 + t4.data;
            return r3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length) return l.alloc(0);
            for (var t4, r3, n2, i2 = l.allocUnsafe(e3 >>> 0), s2 = this.head, o2 = 0; s2; ) t4 = s2.data, r3 = i2, n2 = o2, l.prototype.copy.call(t4, r3, n2), o2 += s2.data.length, s2 = s2.next;
            return i2;
          } }, { key: "consume", value: function(e3, t4) {
            var r3;
            return e3 < this.head.data.length ? (r3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : r3 = e3 === this.head.data.length ? this.shift() : t4 ? this._getString(e3) : this._getBuffer(e3), r3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t4 = this.head, r3 = 1, n2 = t4.data;
            for (e3 -= n2.length; t4 = t4.next; ) {
              var i2 = t4.data, s2 = e3 > i2.length ? i2.length : e3;
              if (s2 === i2.length ? n2 += i2 : n2 += i2.slice(0, e3), 0 == (e3 -= s2)) {
                s2 === i2.length ? (++r3, t4.next ? this.head = t4.next : this.head = this.tail = null) : (this.head = t4, t4.data = i2.slice(s2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, n2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t4 = l.allocUnsafe(e3), r3 = this.head, n2 = 1;
            for (r3.data.copy(t4), e3 -= r3.data.length; r3 = r3.next; ) {
              var i2 = r3.data, s2 = e3 > i2.length ? i2.length : e3;
              if (i2.copy(t4, t4.length - e3, 0, s2), 0 == (e3 -= s2)) {
                s2 === i2.length ? (++n2, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = i2.slice(s2));
                break;
              }
              ++n2;
            }
            return this.length -= n2, t4;
          } }, { key: u, value: function(e3, t4) {
            return c(this, i(i({}, t4), {}, { depth: 0, customInspect: false }));
          } }]) && o(t3.prototype, r2), Object.defineProperty(t3, "prototype", { writable: false }), e2;
        })();
      }, { buffer: 220, util: 188 }], 485: [function(e, t2, r) {
        (function(e2) {
          (function() {
            function r2(e3, t3) {
              i(e3, t3), n(e3);
            }
            function n(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function i(e3, t3) {
              e3.emit("error", t3);
            }
            t2.exports = { destroy: function(t3, s) {
              var o = this, a = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
              return a || l ? (s ? s(t3) : t3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e2.nextTick(i, this, t3)) : e2.nextTick(i, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, (function(t4) {
                !s && t4 ? o._writableState ? o._writableState.errorEmitted ? e2.nextTick(n, o) : (o._writableState.errorEmitted = true, e2.nextTick(r2, o, t4)) : e2.nextTick(r2, o, t4) : s ? (e2.nextTick(n, o), s(t4)) : e2.nextTick(n, o);
              })), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t3) {
              var r3 = e3._readableState, n2 = e3._writableState;
              r3 && r3.autoDestroy || n2 && n2.autoDestroy ? e3.destroy(t3) : e3.emit("error", t3);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 467 }], 486: [function(e, t2, r) {
        var n = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function i() {
        }
        t2.exports = function e2(t3, r2, s) {
          if ("function" == typeof r2) return e2(t3, null, r2);
          r2 || (r2 = {}), s = /* @__PURE__ */ (function(e3) {
            var t4 = false;
            return function() {
              if (!t4) {
                t4 = true;
                for (var r3 = arguments.length, n2 = new Array(r3), i2 = 0; i2 < r3; i2++) n2[i2] = arguments[i2];
                e3.apply(this, n2);
              }
            };
          })(s || i);
          var o = r2.readable || false !== r2.readable && t3.readable, a = r2.writable || false !== r2.writable && t3.writable, l = function() {
            t3.writable || u();
          }, c = t3._writableState && t3._writableState.finished, u = function() {
            a = false, c = true, o || s.call(t3);
          }, h = t3._readableState && t3._readableState.endEmitted, f = function() {
            o = false, h = true, a || s.call(t3);
          }, d = function(e3) {
            s.call(t3, e3);
          }, p = function() {
            var e3;
            return o && !h ? (t3._readableState && t3._readableState.ended || (e3 = new n()), s.call(t3, e3)) : a && !c ? (t3._writableState && t3._writableState.ended || (e3 = new n()), s.call(t3, e3)) : void 0;
          }, m = function() {
            t3.req.on("finish", u);
          };
          return !(function(e3) {
            return e3.setHeader && "function" == typeof e3.abort;
          })(t3) ? a && !t3._writableState && (t3.on("end", l), t3.on("close", l)) : (t3.on("complete", u), t3.on("abort", p), t3.req ? m() : t3.on("request", m)), t3.on("end", f), t3.on("finish", u), false !== r2.error && t3.on("error", d), t3.on("close", p), function() {
            t3.removeListener("complete", u), t3.removeListener("abort", p), t3.removeListener("request", m), t3.req && t3.req.removeListener("finish", u), t3.removeListener("end", l), t3.removeListener("close", l), t3.removeListener("finish", u), t3.removeListener("end", f), t3.removeListener("error", d), t3.removeListener("close", p);
          };
        };
      }, { "../../../errors": 477 }], 487: [function(e, t2, r) {
        t2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 488: [function(e, t2, r) {
        var n;
        var i = e("../../../errors").codes, s = i.ERR_MISSING_ARGS, o = i.ERR_STREAM_DESTROYED;
        function a(e2) {
          if (e2) throw e2;
        }
        function l(t3, r2, i2, s2) {
          s2 = /* @__PURE__ */ (function(e2) {
            var t4 = false;
            return function() {
              t4 || (t4 = true, e2.apply(void 0, arguments));
            };
          })(s2);
          var a2 = false;
          t3.on("close", (function() {
            a2 = true;
          })), void 0 === n && (n = e("./end-of-stream")), n(t3, { readable: r2, writable: i2 }, (function(e2) {
            if (e2) return s2(e2);
            a2 = true, s2();
          }));
          var l2 = false;
          return function(e2) {
            if (!a2 && !l2) return l2 = true, (function(e3) {
              return e3.setHeader && "function" == typeof e3.abort;
            })(t3) ? t3.abort() : "function" == typeof t3.destroy ? t3.destroy() : void s2(e2 || new o("pipe"));
          };
        }
        function c(e2) {
          e2();
        }
        function u(e2, t3) {
          return e2.pipe(t3);
        }
        function h(e2) {
          return e2.length ? "function" != typeof e2[e2.length - 1] ? a : e2.pop() : a;
        }
        t2.exports = function() {
          for (var e2 = arguments.length, t3 = new Array(e2), r2 = 0; r2 < e2; r2++) t3[r2] = arguments[r2];
          var n2, i2 = h(t3);
          if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2) throw new s("streams");
          var o2 = t3.map((function(e3, r3) {
            var s2 = r3 < t3.length - 1;
            return l(e3, s2, r3 > 0, (function(e4) {
              n2 || (n2 = e4), e4 && o2.forEach(c), s2 || (o2.forEach(c), i2(n2));
            }));
          }));
          return t3.reduce(u);
        };
      }, { "../../../errors": 477, "./end-of-stream": 486 }], 489: [function(e, t2, r) {
        var n = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        t2.exports = { getHighWaterMark: function(e2, t3, r2, i) {
          var s = (function(e3, t4, r3) {
            return null != e3.highWaterMark ? e3.highWaterMark : t4 ? e3[r3] : null;
          })(t3, i, r2);
          if (null != s) {
            if (!isFinite(s) || Math.floor(s) !== s || s < 0) throw new n(i ? r2 : "highWaterMark", s);
            return Math.floor(s);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 477 }], 490: [function(e, t2, r) {
        t2.exports = e("events").EventEmitter;
      }, { events: 422 }], 491: [function(e, t2, r) {
        (r = t2.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js"), r.finished = e("./lib/internal/streams/end-of-stream.js"), r.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 478, "./lib/_stream_passthrough.js": 479, "./lib/_stream_readable.js": 480, "./lib/_stream_transform.js": 481, "./lib/_stream_writable.js": 482, "./lib/internal/streams/end-of-stream.js": 486, "./lib/internal/streams/pipeline.js": 488 }], 492: [function(e, t2, r) {
        var n = (function(e2) {
          var t3 = Object.prototype, r2 = t3.hasOwnProperty, n2 = Object.defineProperty || function(e3, t4, r3) {
            e3[t4] = r3.value;
          }, i = "function" == typeof Symbol ? Symbol : {}, s = i.iterator || "@@iterator", o = i.asyncIterator || "@@asyncIterator", a = i.toStringTag || "@@toStringTag";
          function l(e3, t4, r3) {
            return Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true, writable: true }), e3[t4];
          }
          try {
            l({}, "");
          } catch (e3) {
            l = function(e4, t4, r3) {
              return e4[t4] = r3;
            };
          }
          function c(e3, t4, r3, i2) {
            var s2 = t4 && t4.prototype instanceof f ? t4 : f, o2 = Object.create(s2.prototype), a2 = new M(i2 || []);
            return n2(o2, "_invoke", { value: _(e3, r3, a2) }), o2;
          }
          function u(e3, t4, r3) {
            try {
              return { type: "normal", arg: e3.call(t4, r3) };
            } catch (e4) {
              return { type: "throw", arg: e4 };
            }
          }
          e2.wrap = c;
          var h = {};
          function f() {
          }
          function d() {
          }
          function p() {
          }
          var m = {};
          l(m, s, (function() {
            return this;
          }));
          var b = Object.getPrototypeOf, g = b && b(b(C2([])));
          g && g !== t3 && r2.call(g, s) && (m = g);
          var y = p.prototype = f.prototype = Object.create(m);
          function v(e3) {
            ["next", "throw", "return"].forEach((function(t4) {
              l(e3, t4, (function(e4) {
                return this._invoke(t4, e4);
              }));
            }));
          }
          function w(e3, t4) {
            var i2;
            n2(this, "_invoke", { value: function(n3, s2) {
              function o2() {
                return new t4((function(i3, o3) {
                  !(function n4(i4, s3, o4, a2) {
                    var l2 = u(e3[i4], e3, s3);
                    if ("throw" !== l2.type) {
                      var c2 = l2.arg, h2 = c2.value;
                      return h2 && "object" == typeof h2 && r2.call(h2, "__await") ? t4.resolve(h2.__await).then((function(e4) {
                        n4("next", e4, o4, a2);
                      }), (function(e4) {
                        n4("throw", e4, o4, a2);
                      })) : t4.resolve(h2).then((function(e4) {
                        c2.value = e4, o4(c2);
                      }), (function(e4) {
                        return n4("throw", e4, o4, a2);
                      }));
                    }
                    a2(l2.arg);
                  })(n3, s2, i3, o3);
                }));
              }
              return i2 = i2 ? i2.then(o2, o2) : o2();
            } });
          }
          function _(e3, t4, r3) {
            var n3 = "suspendedStart";
            return function(i2, s2) {
              if ("executing" === n3) throw new Error("Generator is already running");
              if ("completed" === n3) {
                if ("throw" === i2) throw s2;
                return T();
              }
              for (r3.method = i2, r3.arg = s2; ; ) {
                var o2 = r3.delegate;
                if (o2) {
                  var a2 = x(o2, r3);
                  if (a2) {
                    if (a2 === h) continue;
                    return a2;
                  }
                }
                if ("next" === r3.method) r3.sent = r3._sent = r3.arg;
                else if ("throw" === r3.method) {
                  if ("suspendedStart" === n3) throw n3 = "completed", r3.arg;
                  r3.dispatchException(r3.arg);
                } else "return" === r3.method && r3.abrupt("return", r3.arg);
                n3 = "executing";
                var l2 = u(e3, t4, r3);
                if ("normal" === l2.type) {
                  if (n3 = r3.done ? "completed" : "suspendedYield", l2.arg === h) continue;
                  return { value: l2.arg, done: r3.done };
                }
                "throw" === l2.type && (n3 = "completed", r3.method = "throw", r3.arg = l2.arg);
              }
            };
          }
          function x(e3, t4) {
            var r3 = t4.method, n3 = e3.iterator[r3];
            if (void 0 === n3) return t4.delegate = null, "throw" === r3 && e3.iterator.return && (t4.method = "return", t4.arg = void 0, x(e3, t4), "throw" === t4.method) || "return" !== r3 && (t4.method = "throw", t4.arg = new TypeError("The iterator does not provide a '" + r3 + "' method")), h;
            var i2 = u(n3, e3.iterator, t4.arg);
            if ("throw" === i2.type) return t4.method = "throw", t4.arg = i2.arg, t4.delegate = null, h;
            var s2 = i2.arg;
            return s2 ? s2.done ? (t4[e3.resultName] = s2.value, t4.next = e3.nextLoc, "return" !== t4.method && (t4.method = "next", t4.arg = void 0), t4.delegate = null, h) : s2 : (t4.method = "throw", t4.arg = new TypeError("iterator result is not an object"), t4.delegate = null, h);
          }
          function k(e3) {
            var t4 = { tryLoc: e3[0] };
            1 in e3 && (t4.catchLoc = e3[1]), 2 in e3 && (t4.finallyLoc = e3[2], t4.afterLoc = e3[3]), this.tryEntries.push(t4);
          }
          function S(e3) {
            var t4 = e3.completion || {};
            t4.type = "normal", delete t4.arg, e3.completion = t4;
          }
          function M(e3) {
            this.tryEntries = [{ tryLoc: "root" }], e3.forEach(k, this), this.reset(true);
          }
          function C2(e3) {
            if (e3) {
              var t4 = e3[s];
              if (t4) return t4.call(e3);
              if ("function" == typeof e3.next) return e3;
              if (!isNaN(e3.length)) {
                var n3 = -1, i2 = function t5() {
                  for (; ++n3 < e3.length; ) if (r2.call(e3, n3)) return t5.value = e3[n3], t5.done = false, t5;
                  return t5.value = void 0, t5.done = true, t5;
                };
                return i2.next = i2;
              }
            }
            return { next: T };
          }
          function T() {
            return { value: void 0, done: true };
          }
          return d.prototype = p, n2(y, "constructor", { value: p, configurable: true }), n2(p, "constructor", { value: d, configurable: true }), d.displayName = l(p, a, "GeneratorFunction"), e2.isGeneratorFunction = function(e3) {
            var t4 = "function" == typeof e3 && e3.constructor;
            return !!t4 && (t4 === d || "GeneratorFunction" === (t4.displayName || t4.name));
          }, e2.mark = function(e3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e3, p) : (e3.__proto__ = p, l(e3, a, "GeneratorFunction")), e3.prototype = Object.create(y), e3;
          }, e2.awrap = function(e3) {
            return { __await: e3 };
          }, v(w.prototype), l(w.prototype, o, (function() {
            return this;
          })), e2.AsyncIterator = w, e2.async = function(t4, r3, n3, i2, s2) {
            void 0 === s2 && (s2 = Promise);
            var o2 = new w(c(t4, r3, n3, i2), s2);
            return e2.isGeneratorFunction(r3) ? o2 : o2.next().then((function(e3) {
              return e3.done ? e3.value : o2.next();
            }));
          }, v(y), l(y, a, "Generator"), l(y, s, (function() {
            return this;
          })), l(y, "toString", (function() {
            return "[object Generator]";
          })), e2.keys = function(e3) {
            var t4 = Object(e3), r3 = [];
            for (var n3 in t4) r3.push(n3);
            return r3.reverse(), function e4() {
              for (; r3.length; ) {
                var n4 = r3.pop();
                if (n4 in t4) return e4.value = n4, e4.done = false, e4;
              }
              return e4.done = true, e4;
            };
          }, e2.values = C2, M.prototype = { constructor: M, reset: function(e3) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(S), !e3) for (var t4 in this) "t" === t4.charAt(0) && r2.call(this, t4) && !isNaN(+t4.slice(1)) && (this[t4] = void 0);
          }, stop: function() {
            this.done = true;
            var e3 = this.tryEntries[0].completion;
            if ("throw" === e3.type) throw e3.arg;
            return this.rval;
          }, dispatchException: function(e3) {
            if (this.done) throw e3;
            var t4 = this;
            function n3(r3, n4) {
              return o2.type = "throw", o2.arg = e3, t4.next = r3, n4 && (t4.method = "next", t4.arg = void 0), !!n4;
            }
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var s2 = this.tryEntries[i2], o2 = s2.completion;
              if ("root" === s2.tryLoc) return n3("end");
              if (s2.tryLoc <= this.prev) {
                var a2 = r2.call(s2, "catchLoc"), l2 = r2.call(s2, "finallyLoc");
                if (a2 && l2) {
                  if (this.prev < s2.catchLoc) return n3(s2.catchLoc, true);
                  if (this.prev < s2.finallyLoc) return n3(s2.finallyLoc);
                } else if (a2) {
                  if (this.prev < s2.catchLoc) return n3(s2.catchLoc, true);
                } else {
                  if (!l2) throw new Error("try statement without catch or finally");
                  if (this.prev < s2.finallyLoc) return n3(s2.finallyLoc);
                }
              }
            }
          }, abrupt: function(e3, t4) {
            for (var n3 = this.tryEntries.length - 1; n3 >= 0; --n3) {
              var i2 = this.tryEntries[n3];
              if (i2.tryLoc <= this.prev && r2.call(i2, "finallyLoc") && this.prev < i2.finallyLoc) {
                var s2 = i2;
                break;
              }
            }
            s2 && ("break" === e3 || "continue" === e3) && s2.tryLoc <= t4 && t4 <= s2.finallyLoc && (s2 = null);
            var o2 = s2 ? s2.completion : {};
            return o2.type = e3, o2.arg = t4, s2 ? (this.method = "next", this.next = s2.finallyLoc, h) : this.complete(o2);
          }, complete: function(e3, t4) {
            if ("throw" === e3.type) throw e3.arg;
            return "break" === e3.type || "continue" === e3.type ? this.next = e3.arg : "return" === e3.type ? (this.rval = this.arg = e3.arg, this.method = "return", this.next = "end") : "normal" === e3.type && t4 && (this.next = t4), h;
          }, finish: function(e3) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r3 = this.tryEntries[t4];
              if (r3.finallyLoc === e3) return this.complete(r3.completion, r3.afterLoc), S(r3), h;
            }
          }, catch: function(e3) {
            for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
              var r3 = this.tryEntries[t4];
              if (r3.tryLoc === e3) {
                var n3 = r3.completion;
                if ("throw" === n3.type) {
                  var i2 = n3.arg;
                  S(r3);
                }
                return i2;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(e3, t4, r3) {
            return this.delegate = { iterator: C2(e3), resultName: t4, nextLoc: r3 }, "next" === this.method && (this.arg = void 0), h;
          } }, e2;
        })("object" == typeof t2 ? t2.exports : {});
        try {
          regeneratorRuntime = n;
        } catch (e2) {
          "object" == typeof globalThis ? globalThis.regeneratorRuntime = n : Function("r", "regeneratorRuntime = r")(n);
        }
      }, {}], 493: [function(e, t2, r) {
        var n = e("buffer").Buffer, i = e("inherits"), s = e("hash-base"), o = new Array(16), a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], l = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], c = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], u = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], h = [0, 1518500249, 1859775393, 2400959708, 2840853838], f = [1352829926, 1548603684, 1836072691, 2053994217, 0];
        function d() {
          s.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
        }
        function p(e2, t3) {
          return e2 << t3 | e2 >>> 32 - t3;
        }
        function m(e2, t3, r2, n2, i2, s2, o2, a2) {
          return p(e2 + (t3 ^ r2 ^ n2) + s2 + o2 | 0, a2) + i2 | 0;
        }
        function b(e2, t3, r2, n2, i2, s2, o2, a2) {
          return p(e2 + (t3 & r2 | ~t3 & n2) + s2 + o2 | 0, a2) + i2 | 0;
        }
        function g(e2, t3, r2, n2, i2, s2, o2, a2) {
          return p(e2 + ((t3 | ~r2) ^ n2) + s2 + o2 | 0, a2) + i2 | 0;
        }
        function y(e2, t3, r2, n2, i2, s2, o2, a2) {
          return p(e2 + (t3 & n2 | r2 & ~n2) + s2 + o2 | 0, a2) + i2 | 0;
        }
        function v(e2, t3, r2, n2, i2, s2, o2, a2) {
          return p(e2 + (t3 ^ (r2 | ~n2)) + s2 + o2 | 0, a2) + i2 | 0;
        }
        i(d, s), d.prototype._update = function() {
          for (var e2 = o, t3 = 0; t3 < 16; ++t3) e2[t3] = this._block.readInt32LE(4 * t3);
          for (var r2 = 0 | this._a, n2 = 0 | this._b, i2 = 0 | this._c, s2 = 0 | this._d, d2 = 0 | this._e, w = 0 | this._a, _ = 0 | this._b, x = 0 | this._c, k = 0 | this._d, S = 0 | this._e, M = 0; M < 80; M += 1) {
            var C2, T;
            M < 16 ? (C2 = m(r2, n2, i2, s2, d2, e2[a[M]], h[0], c[M]), T = v(w, _, x, k, S, e2[l[M]], f[0], u[M])) : M < 32 ? (C2 = b(r2, n2, i2, s2, d2, e2[a[M]], h[1], c[M]), T = y(w, _, x, k, S, e2[l[M]], f[1], u[M])) : M < 48 ? (C2 = g(r2, n2, i2, s2, d2, e2[a[M]], h[2], c[M]), T = g(w, _, x, k, S, e2[l[M]], f[2], u[M])) : M < 64 ? (C2 = y(r2, n2, i2, s2, d2, e2[a[M]], h[3], c[M]), T = b(w, _, x, k, S, e2[l[M]], f[3], u[M])) : (C2 = v(r2, n2, i2, s2, d2, e2[a[M]], h[4], c[M]), T = m(w, _, x, k, S, e2[l[M]], f[4], u[M])), r2 = d2, d2 = s2, s2 = p(i2, 10), i2 = n2, n2 = C2, w = S, S = k, k = p(x, 10), x = _, _ = T;
          }
          var E = this._b + i2 + k | 0;
          this._b = this._c + s2 + S | 0, this._c = this._d + d2 + w | 0, this._d = this._e + r2 + _ | 0, this._e = this._a + n2 + x | 0, this._a = E;
        }, d.prototype._digest = function() {
          this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
          var e2 = n.alloc ? n.alloc(20) : new n(20);
          return e2.writeInt32LE(this._a, 0), e2.writeInt32LE(this._b, 4), e2.writeInt32LE(this._c, 8), e2.writeInt32LE(this._d, 12), e2.writeInt32LE(this._e, 16), e2;
        }, t2.exports = d;
      }, { buffer: 220, "hash-base": 425, inherits: 440 }], 494: [function(e, t2, r) {
        var n = e("buffer"), i = n.Buffer;
        function s(e2, t3) {
          for (var r2 in e2) t3[r2] = e2[r2];
        }
        function o(e2, t3, r2) {
          return i(e2, t3, r2);
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t2.exports = n : (s(n, r), r.Buffer = o), o.prototype = Object.create(i.prototype), s(i, o), o.from = function(e2, t3, r2) {
          if ("number" == typeof e2) throw new TypeError("Argument must not be a number");
          return i(e2, t3, r2);
        }, o.alloc = function(e2, t3, r2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          var n2 = i(e2);
          return void 0 !== t3 ? "string" == typeof r2 ? n2.fill(t3, r2) : n2.fill(t3) : n2.fill(0), n2;
        }, o.allocUnsafe = function(e2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          return i(e2);
        }, o.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2) throw new TypeError("Argument must be a number");
          return n.SlowBuffer(e2);
        };
      }, { buffer: 220 }], 495: [function(e, t2, r) {
        (function(r2) {
          (function() {
            var n, i = e("buffer"), s = i.Buffer, o = {};
            for (n in i) i.hasOwnProperty(n) && "SlowBuffer" !== n && "Buffer" !== n && (o[n] = i[n]);
            var a = o.Buffer = {};
            for (n in s) s.hasOwnProperty(n) && "allocUnsafe" !== n && "allocUnsafeSlow" !== n && (a[n] = s[n]);
            if (o.Buffer.prototype = s.prototype, a.from && a.from !== Uint8Array.from || (a.from = function(e2, t3, r3) {
              if ("number" == typeof e2) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e2);
              if (e2 && void 0 === e2.length) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              return s(e2, t3, r3);
            }), a.alloc || (a.alloc = function(e2, t3, r3) {
              if ("number" != typeof e2) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e2);
              if (e2 < 0 || e2 >= 2 * (1 << 30)) throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var n2 = s(e2);
              return t3 && 0 !== t3.length ? "string" == typeof r3 ? n2.fill(t3, r3) : n2.fill(t3) : n2.fill(0), n2;
            }), !o.kStringMaxLength) try {
              o.kStringMaxLength = r2.binding("buffer").kStringMaxLength;
            } catch (e2) {
            }
            o.constants || (o.constants = { MAX_LENGTH: o.kMaxLength }, o.kStringMaxLength && (o.constants.MAX_STRING_LENGTH = o.kStringMaxLength)), t2.exports = o;
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 467, buffer: 220 }], 496: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true });
        const n = e("xmlchars/xml/1.0/ed5"), i = e("xmlchars/xml/1.1/ed2"), s = e("xmlchars/xmlns/1.0/ed3");
        var o = n.isS, a = n.isChar, l = n.isNameStartChar, c = n.isNameChar, u = n.S_LIST, h = n.NAME_RE, f = i.isChar, d = s.isNCNameStartChar, p = s.isNCNameChar, m = s.NC_NAME_RE;
        const b = "http://www.w3.org/XML/1998/namespace", g = "http://www.w3.org/2000/xmlns/", y = { __proto__: null, xml: b, xmlns: g }, v = { __proto__: null, amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, w = (e2) => 34 === e2 || 39 === e2, _ = [34, 39], x = [..._, 91, 62], k = [..._, 60, 93], S = [61, 63, ...u], M = [...u, 62, 38, 60];
        function C2(e2, t3, r2) {
          switch (t3) {
            case "xml":
              r2 !== b && e2.fail(`xml prefix must be bound to ${b}.`);
              break;
            case "xmlns":
              r2 !== g && e2.fail(`xmlns prefix must be bound to ${g}.`);
          }
          switch (r2) {
            case g:
              e2.fail("" === t3 ? `the default namespace may not be set to ${r2}.` : `may not assign a prefix (even "xmlns") to the URI ${g}.`);
              break;
            case b:
              switch (t3) {
                case "xml":
                  break;
                case "":
                  e2.fail(`the default namespace may not be set to ${r2}.`);
                  break;
                default:
                  e2.fail("may not assign the xml namespace to another prefix.");
              }
          }
        }
        const T = (e2) => m.test(e2), E = (e2) => h.test(e2);
        r.EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
        const A = { xmldecl: "xmldeclHandler", text: "textHandler", processinginstruction: "piHandler", doctype: "doctypeHandler", comment: "commentHandler", opentagstart: "openTagStartHandler", attribute: "attributeHandler", opentag: "openTagHandler", closetag: "closeTagHandler", cdata: "cdataHandler", error: "errorHandler", end: "endHandler", ready: "readyHandler" };
        r.SaxesParser = class {
          constructor(e2) {
            this.opt = null != e2 ? e2 : {}, this.fragmentOpt = !!this.opt.fragment;
            const t3 = this.xmlnsOpt = !!this.opt.xmlns;
            if (this.trackPosition = false !== this.opt.position, this.fileName = this.opt.fileName, t3) {
              this.nameStartCheck = d, this.nameCheck = p, this.isName = T, this.processAttribs = this.processAttribsNS, this.pushAttrib = this.pushAttribNS, this.ns = Object.assign({ __proto__: null }, y);
              const e3 = this.opt.additionalNamespaces;
              null != e3 && (!(function(e4, t4) {
                for (const r2 of Object.keys(t4)) C2(e4, r2, t4[r2]);
              })(this, e3), Object.assign(this.ns, e3));
            } else this.nameStartCheck = l, this.nameCheck = c, this.isName = E, this.processAttribs = this.processAttribsPlain, this.pushAttrib = this.pushAttribPlain;
            this.stateTable = [this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite], this._init();
          }
          get closed() {
            return this._closed;
          }
          _init() {
            var e2;
            this.openWakaBang = "", this.text = "", this.name = "", this.piTarget = "", this.entity = "", this.q = null, this.tags = [], this.tag = null, this.topNS = null, this.chunk = "", this.chunkPosition = 0, this.i = 0, this.prevI = 0, this.carriedFromPrevious = void 0, this.forbiddenState = 0, this.attribList = [];
            const { fragmentOpt: t3 } = this;
            this.state = t3 ? 13 : 0, this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = t3, this.xmlDeclPossible = !t3, this.xmlDeclExpects = ["version"], this.entityReturnState = void 0;
            let { defaultXMLVersion: r2 } = this.opt;
            if (void 0 === r2) {
              if (true === this.opt.forceXMLVersion) throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
              r2 = "1.0";
            }
            this.setXMLVersion(r2), this.positionAtNewLine = 0, this.doctype = false, this._closed = false, this.xmlDecl = { version: void 0, encoding: void 0, standalone: void 0 }, this.line = 1, this.column = 0, this.ENTITIES = Object.create(v), null === (e2 = this.readyHandler) || void 0 === e2 || e2.call(this);
          }
          get position() {
            return this.chunkPosition + this.i;
          }
          get columnIndex() {
            return this.position - this.positionAtNewLine;
          }
          on(e2, t3) {
            this[A[e2]] = t3;
          }
          off(e2) {
            this[A[e2]] = void 0;
          }
          makeError(e2) {
            var t3;
            let r2 = null !== (t3 = this.fileName) && void 0 !== t3 ? t3 : "";
            return this.trackPosition && (r2.length > 0 && (r2 += ":"), r2 += `${this.line}:${this.column}`), r2.length > 0 && (r2 += ": "), new Error(r2 + e2);
          }
          fail(e2) {
            const t3 = this.makeError(e2), r2 = this.errorHandler;
            if (void 0 === r2) throw t3;
            return r2(t3), this;
          }
          write(e2) {
            if (this.closed) return this.fail("cannot write after close; assign an onready handler.");
            let t3 = false;
            null === e2 ? (t3 = true, e2 = "") : "object" == typeof e2 && (e2 = e2.toString()), void 0 !== this.carriedFromPrevious && (e2 = `${this.carriedFromPrevious}${e2}`, this.carriedFromPrevious = void 0);
            let r2 = e2.length;
            const n2 = e2.charCodeAt(r2 - 1);
            !t3 && (13 === n2 || n2 >= 55296 && n2 <= 56319) && (this.carriedFromPrevious = e2[r2 - 1], r2--, e2 = e2.slice(0, r2));
            const { stateTable: i2 } = this;
            for (this.chunk = e2, this.i = 0; this.i < r2; ) i2[this.state].call(this);
            return this.chunkPosition += r2, t3 ? this.end() : this;
          }
          close() {
            return this.write(null);
          }
          getCode10() {
            const { chunk: e2, i: t3 } = this;
            if (this.prevI = t3, this.i = t3 + 1, t3 >= e2.length) return -1;
            const r2 = e2.charCodeAt(t3);
            if (this.column++, r2 < 55296) {
              if (r2 >= 32 || 9 === r2) return r2;
              switch (r2) {
                case 10:
                  return this.line++, this.column = 0, this.positionAtNewLine = this.position, 10;
                case 13:
                  return 10 === e2.charCodeAt(t3 + 1) && (this.i = t3 + 2), this.line++, this.column = 0, this.positionAtNewLine = this.position, -2;
                default:
                  return this.fail("disallowed character."), r2;
              }
            }
            if (r2 > 56319) return r2 >= 57344 && r2 <= 65533 || this.fail("disallowed character."), r2;
            const n2 = 65536 + 1024 * (r2 - 55296) + (e2.charCodeAt(t3 + 1) - 56320);
            return this.i = t3 + 2, n2 > 1114111 && this.fail("disallowed character."), n2;
          }
          getCode11() {
            const { chunk: e2, i: t3 } = this;
            if (this.prevI = t3, this.i = t3 + 1, t3 >= e2.length) return -1;
            const r2 = e2.charCodeAt(t3);
            if (this.column++, r2 < 55296) {
              if (r2 > 31 && r2 < 127 || r2 > 159 && 8232 !== r2 || 9 === r2) return r2;
              switch (r2) {
                case 10:
                  return this.line++, this.column = 0, this.positionAtNewLine = this.position, 10;
                case 13: {
                  const r3 = e2.charCodeAt(t3 + 1);
                  10 !== r3 && 133 !== r3 || (this.i = t3 + 2);
                }
                case 133:
                case 8232:
                  return this.line++, this.column = 0, this.positionAtNewLine = this.position, -2;
                default:
                  return this.fail("disallowed character."), r2;
              }
            }
            if (r2 > 56319) return r2 >= 57344 && r2 <= 65533 || this.fail("disallowed character."), r2;
            const n2 = 65536 + 1024 * (r2 - 55296) + (e2.charCodeAt(t3 + 1) - 56320);
            return this.i = t3 + 2, n2 > 1114111 && this.fail("disallowed character."), n2;
          }
          getCodeNorm() {
            const e2 = this.getCode();
            return -2 === e2 ? 10 : e2;
          }
          unget() {
            this.i = this.prevI, this.column--;
          }
          captureTo(e2) {
            let { i: t3 } = this;
            const { chunk: r2 } = this;
            for (; ; ) {
              const n2 = this.getCode(), i2 = -2 === n2, s2 = i2 ? 10 : n2;
              if (-1 === s2 || e2.includes(s2)) return this.text += r2.slice(t3, this.prevI), s2;
              i2 && (this.text += r2.slice(t3, this.prevI) + "\n", t3 = this.i);
            }
          }
          captureToChar(e2) {
            let { i: t3 } = this;
            const { chunk: r2 } = this;
            for (; ; ) {
              let n2 = this.getCode();
              switch (n2) {
                case -2:
                  this.text += r2.slice(t3, this.prevI) + "\n", t3 = this.i, n2 = 10;
                  break;
                case -1:
                  return this.text += r2.slice(t3), false;
              }
              if (n2 === e2) return this.text += r2.slice(t3, this.prevI), true;
            }
          }
          captureNameChars() {
            const { chunk: e2, i: t3 } = this;
            for (; ; ) {
              const r2 = this.getCode();
              if (-1 === r2) return this.name += e2.slice(t3), -1;
              if (!c(r2)) return this.name += e2.slice(t3, this.prevI), -2 === r2 ? 10 : r2;
            }
          }
          skipSpaces() {
            for (; ; ) {
              const e2 = this.getCodeNorm();
              if (-1 === e2 || !o(e2)) return e2;
            }
          }
          setXMLVersion(e2) {
            this.currentXMLVersion = e2, "1.0" === e2 ? (this.isChar = a, this.getCode = this.getCode10) : (this.isChar = f, this.getCode = this.getCode11);
          }
          sBegin() {
            65279 === this.chunk.charCodeAt(0) && (this.i++, this.column++), this.state = 1;
          }
          sBeginWhitespace() {
            const e2 = this.i, t3 = this.skipSpaces();
            switch (this.prevI !== e2 && (this.xmlDeclPossible = false), t3) {
              case 60:
                if (this.state = 15, 0 !== this.text.length) throw new Error("no-empty text at start");
                break;
              case -1:
                break;
              default:
                this.unget(), this.state = 13, this.xmlDeclPossible = false;
            }
          }
          sDoctype() {
            var e2;
            const t3 = this.captureTo(x);
            switch (t3) {
              case 62:
                null === (e2 = this.doctypeHandler) || void 0 === e2 || e2.call(this, this.text), this.text = "", this.state = 13, this.doctype = true;
                break;
              case -1:
                break;
              default:
                this.text += String.fromCodePoint(t3), 91 === t3 ? this.state = 4 : w(t3) && (this.state = 3, this.q = t3);
            }
          }
          sDoctypeQuote() {
            const e2 = this.q;
            this.captureToChar(e2) && (this.text += String.fromCodePoint(e2), this.q = null, this.state = 2);
          }
          sDTD() {
            const e2 = this.captureTo(k);
            -1 !== e2 && (this.text += String.fromCodePoint(e2), 93 === e2 ? this.state = 2 : 60 === e2 ? this.state = 6 : w(e2) && (this.state = 5, this.q = e2));
          }
          sDTDQuoted() {
            const e2 = this.q;
            this.captureToChar(e2) && (this.text += String.fromCodePoint(e2), this.state = 4, this.q = null);
          }
          sDTDOpenWaka() {
            const e2 = this.getCodeNorm();
            switch (this.text += String.fromCodePoint(e2), e2) {
              case 33:
                this.state = 7, this.openWakaBang = "";
                break;
              case 63:
                this.state = 11;
                break;
              default:
                this.state = 4;
            }
          }
          sDTDOpenWakaBang() {
            const e2 = String.fromCodePoint(this.getCodeNorm()), t3 = this.openWakaBang += e2;
            this.text += e2, "-" !== t3 && (this.state = "--" === t3 ? 8 : 4, this.openWakaBang = "");
          }
          sDTDComment() {
            this.captureToChar(45) && (this.text += "-", this.state = 9);
          }
          sDTDCommentEnding() {
            const e2 = this.getCodeNorm();
            this.text += String.fromCodePoint(e2), this.state = 45 === e2 ? 10 : 8;
          }
          sDTDCommentEnded() {
            const e2 = this.getCodeNorm();
            this.text += String.fromCodePoint(e2), 62 === e2 ? this.state = 4 : (this.fail("malformed comment."), this.state = 8);
          }
          sDTDPI() {
            this.captureToChar(63) && (this.text += "?", this.state = 12);
          }
          sDTDPIEnding() {
            const e2 = this.getCodeNorm();
            this.text += String.fromCodePoint(e2), 62 === e2 && (this.state = 4);
          }
          sText() {
            0 !== this.tags.length ? this.handleTextInRoot() : this.handleTextOutsideRoot();
          }
          sEntity() {
            let { i: e2 } = this;
            const { chunk: t3 } = this;
            e: for (; ; ) switch (this.getCode()) {
              case -2:
                this.entity += t3.slice(e2, this.prevI) + "\n", e2 = this.i;
                break;
              case 59: {
                const { entityReturnState: r2 } = this, n2 = this.entity + t3.slice(e2, this.prevI);
                let i2;
                this.state = r2, "" === n2 ? (this.fail("empty entity name."), i2 = "&;") : (i2 = this.parseEntity(n2), this.entity = ""), 13 === r2 && void 0 === this.textHandler || (this.text += i2);
                break e;
              }
              case -1:
                this.entity += t3.slice(e2);
                break e;
            }
          }
          sOpenWaka() {
            const e2 = this.getCode();
            if (l(e2)) this.state = 34, this.unget(), this.xmlDeclPossible = false;
            else switch (e2) {
              case 47:
                this.state = 43, this.xmlDeclPossible = false;
                break;
              case 33:
                this.state = 16, this.openWakaBang = "", this.xmlDeclPossible = false;
                break;
              case 63:
                this.state = 23;
                break;
              default:
                this.fail("disallowed character in tag name"), this.state = 13, this.xmlDeclPossible = false;
            }
          }
          sOpenWakaBang() {
            switch (this.openWakaBang += String.fromCodePoint(this.getCodeNorm()), this.openWakaBang) {
              case "[CDATA[":
                this.sawRoot || this.reportedTextBeforeRoot || (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = true), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = true), this.state = 20, this.openWakaBang = "";
                break;
              case "--":
                this.state = 17, this.openWakaBang = "";
                break;
              case "DOCTYPE":
                this.state = 2, (this.doctype || this.sawRoot) && this.fail("inappropriately located doctype declaration."), this.openWakaBang = "";
                break;
              default:
                this.openWakaBang.length >= 7 && this.fail("incorrect syntax.");
            }
          }
          sComment() {
            this.captureToChar(45) && (this.state = 18);
          }
          sCommentEnding() {
            var e2;
            const t3 = this.getCodeNorm();
            45 === t3 ? (this.state = 19, null === (e2 = this.commentHandler) || void 0 === e2 || e2.call(this, this.text), this.text = "") : (this.text += "-" + String.fromCodePoint(t3), this.state = 17);
          }
          sCommentEnded() {
            const e2 = this.getCodeNorm();
            62 !== e2 ? (this.fail("malformed comment."), this.text += "--" + String.fromCodePoint(e2), this.state = 17) : this.state = 13;
          }
          sCData() {
            this.captureToChar(93) && (this.state = 21);
          }
          sCDataEnding() {
            const e2 = this.getCodeNorm();
            93 === e2 ? this.state = 22 : (this.text += "]" + String.fromCodePoint(e2), this.state = 20);
          }
          sCDataEnding2() {
            var e2;
            const t3 = this.getCodeNorm();
            switch (t3) {
              case 62:
                null === (e2 = this.cdataHandler) || void 0 === e2 || e2.call(this, this.text), this.text = "", this.state = 13;
                break;
              case 93:
                this.text += "]";
                break;
              default:
                this.text += "]]" + String.fromCodePoint(t3), this.state = 20;
            }
          }
          sPIFirstChar() {
            const e2 = this.getCodeNorm();
            this.nameStartCheck(e2) ? (this.piTarget += String.fromCodePoint(e2), this.state = 24) : 63 === e2 || o(e2) ? (this.fail("processing instruction without a target."), this.state = 63 === e2 ? 26 : 25) : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(e2), this.state = 24);
          }
          sPIRest() {
            const { chunk: e2, i: t3 } = this;
            for (; ; ) {
              const r2 = this.getCodeNorm();
              if (-1 === r2) return void (this.piTarget += e2.slice(t3));
              if (!this.nameCheck(r2)) {
                this.piTarget += e2.slice(t3, this.prevI);
                const n2 = 63 === r2;
                n2 || o(r2) ? "xml" === this.piTarget ? (this.xmlDeclPossible || this.fail("an XML declaration must be at the start of the document."), this.state = n2 ? 33 : 27) : this.state = n2 ? 26 : 25 : (this.fail("disallowed character in processing instruction name."), this.piTarget += String.fromCodePoint(r2));
                break;
              }
            }
          }
          sPIBody() {
            if (0 === this.text.length) {
              const e2 = this.getCodeNorm();
              63 === e2 ? this.state = 26 : o(e2) || (this.text = String.fromCodePoint(e2));
            } else this.captureToChar(63) && (this.state = 26);
          }
          sPIEnding() {
            var e2;
            const t3 = this.getCodeNorm();
            if (62 === t3) {
              const { piTarget: t4 } = this;
              "xml" === t4.toLowerCase() && this.fail("the XML declaration must appear at the start of the document."), null === (e2 = this.piHandler) || void 0 === e2 || e2.call(this, { target: t4, body: this.text }), this.piTarget = this.text = "", this.state = 13;
            } else 63 === t3 ? this.text += "?" : (this.text += "?" + String.fromCodePoint(t3), this.state = 25);
            this.xmlDeclPossible = false;
          }
          sXMLDeclNameStart() {
            const e2 = this.skipSpaces();
            63 !== e2 ? -1 !== e2 && (this.state = 28, this.name = String.fromCodePoint(e2)) : this.state = 33;
          }
          sXMLDeclName() {
            const e2 = this.captureTo(S);
            if (63 === e2) return this.state = 33, this.name += this.text, this.text = "", void this.fail("XML declaration is incomplete.");
            if (o(e2) || 61 === e2) {
              if (this.name += this.text, this.text = "", !this.xmlDeclExpects.includes(this.name)) switch (this.name.length) {
                case 0:
                  this.fail("did not expect any more name/value pairs.");
                  break;
                case 1:
                  this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
                  break;
                default:
                  this.fail("expected one of " + this.xmlDeclExpects.join(", "));
              }
              this.state = 61 === e2 ? 30 : 29;
            }
          }
          sXMLDeclEq() {
            const e2 = this.getCodeNorm();
            if (63 === e2) return this.state = 33, void this.fail("XML declaration is incomplete.");
            o(e2) || (61 !== e2 && this.fail("value required."), this.state = 30);
          }
          sXMLDeclValueStart() {
            const e2 = this.getCodeNorm();
            if (63 === e2) return this.state = 33, void this.fail("XML declaration is incomplete.");
            o(e2) || (w(e2) ? this.q = e2 : (this.fail("value must be quoted."), this.q = 32), this.state = 31);
          }
          sXMLDeclValue() {
            const e2 = this.captureTo([this.q, 63]);
            if (63 === e2) return this.state = 33, this.text = "", void this.fail("XML declaration is incomplete.");
            if (-1 === e2) return;
            const t3 = this.text;
            switch (this.text = "", this.name) {
              case "version": {
                this.xmlDeclExpects = ["encoding", "standalone"];
                const e3 = t3;
                this.xmlDecl.version = e3, /^1\.[0-9]+$/.test(e3) ? this.opt.forceXMLVersion || this.setXMLVersion(e3) : this.fail("version number must match /^1\\.[0-9]+$/.");
                break;
              }
              case "encoding":
                /^[A-Za-z][A-Za-z0-9._-]*$/.test(t3) || this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/."), this.xmlDeclExpects = ["standalone"], this.xmlDecl.encoding = t3;
                break;
              case "standalone":
                "yes" !== t3 && "no" !== t3 && this.fail('standalone value must match "yes" or "no".'), this.xmlDeclExpects = [], this.xmlDecl.standalone = t3;
            }
            this.name = "", this.state = 32;
          }
          sXMLDeclSeparator() {
            const e2 = this.getCodeNorm();
            63 !== e2 ? (o(e2) || (this.fail("whitespace required."), this.unget()), this.state = 27) : this.state = 33;
          }
          sXMLDeclEnding() {
            var e2;
            62 === this.getCodeNorm() ? ("xml" !== this.piTarget ? this.fail("processing instructions are not allowed before root.") : "version" !== this.name && this.xmlDeclExpects.includes("version") && this.fail("XML declaration must contain a version."), null === (e2 = this.xmldeclHandler) || void 0 === e2 || e2.call(this, this.xmlDecl), this.name = "", this.piTarget = this.text = "", this.state = 13) : this.fail("The character ? is disallowed anywhere in XML declarations."), this.xmlDeclPossible = false;
          }
          sOpenTag() {
            var e2;
            const t3 = this.captureNameChars();
            if (-1 === t3) return;
            const r2 = this.tag = { name: this.name, attributes: /* @__PURE__ */ Object.create(null) };
            switch (this.name = "", this.xmlnsOpt && (this.topNS = r2.ns = /* @__PURE__ */ Object.create(null)), null === (e2 = this.openTagStartHandler) || void 0 === e2 || e2.call(this, r2), this.sawRoot = true, !this.fragmentOpt && this.closedRoot && this.fail("documents may contain only one root."), t3) {
              case 62:
                this.openTag();
                break;
              case 47:
                this.state = 35;
                break;
              default:
                o(t3) || this.fail("disallowed character in tag name."), this.state = 36;
            }
          }
          sOpenTagSlash() {
            62 === this.getCode() ? this.openSelfClosingTag() : (this.fail("forward-slash in opening tag not followed by >."), this.state = 36);
          }
          sAttrib() {
            const e2 = this.skipSpaces();
            -1 !== e2 && (l(e2) ? (this.unget(), this.state = 37) : 62 === e2 ? this.openTag() : 47 === e2 ? this.state = 35 : this.fail("disallowed character in attribute name."));
          }
          sAttribName() {
            const e2 = this.captureNameChars();
            61 === e2 ? this.state = 39 : o(e2) ? this.state = 38 : 62 === e2 ? (this.fail("attribute without value."), this.pushAttrib(this.name, this.name), this.name = this.text = "", this.openTag()) : -1 !== e2 && this.fail("disallowed character in attribute name.");
          }
          sAttribNameSawWhite() {
            const e2 = this.skipSpaces();
            switch (e2) {
              case -1:
                return;
              case 61:
                this.state = 39;
                break;
              default:
                this.fail("attribute without value."), this.text = "", this.name = "", 62 === e2 ? this.openTag() : l(e2) ? (this.unget(), this.state = 37) : (this.fail("disallowed character in attribute name."), this.state = 36);
            }
          }
          sAttribValue() {
            const e2 = this.getCodeNorm();
            w(e2) ? (this.q = e2, this.state = 40) : o(e2) || (this.fail("unquoted attribute value."), this.state = 42, this.unget());
          }
          sAttribValueQuoted() {
            const { q: e2, chunk: t3 } = this;
            let { i: r2 } = this;
            for (; ; ) switch (this.getCode()) {
              case e2:
                return this.pushAttrib(this.name, this.text + t3.slice(r2, this.prevI)), this.name = this.text = "", this.q = null, void (this.state = 41);
              case 38:
                return this.text += t3.slice(r2, this.prevI), this.state = 14, void (this.entityReturnState = 40);
              case 10:
              case -2:
              case 9:
                this.text += t3.slice(r2, this.prevI) + " ", r2 = this.i;
                break;
              case 60:
                return this.text += t3.slice(r2, this.prevI), void this.fail("disallowed character.");
              case -1:
                return void (this.text += t3.slice(r2));
            }
          }
          sAttribValueClosed() {
            const e2 = this.getCodeNorm();
            o(e2) ? this.state = 36 : 62 === e2 ? this.openTag() : 47 === e2 ? this.state = 35 : l(e2) ? (this.fail("no whitespace between attributes."), this.unget(), this.state = 37) : this.fail("disallowed character in attribute name.");
          }
          sAttribValueUnquoted() {
            const e2 = this.captureTo(M);
            switch (e2) {
              case 38:
                this.state = 14, this.entityReturnState = 42;
                break;
              case 60:
                this.fail("disallowed character.");
                break;
              case -1:
                break;
              default:
                this.text.includes("]]>") && this.fail('the string "]]>" is disallowed in char data.'), this.pushAttrib(this.name, this.text), this.name = this.text = "", 62 === e2 ? this.openTag() : this.state = 36;
            }
          }
          sCloseTag() {
            const e2 = this.captureNameChars();
            62 === e2 ? this.closeTag() : o(e2) ? this.state = 44 : -1 !== e2 && this.fail("disallowed character in closing tag.");
          }
          sCloseTagSawWhite() {
            switch (this.skipSpaces()) {
              case 62:
                this.closeTag();
                break;
              case -1:
                break;
              default:
                this.fail("disallowed character in closing tag.");
            }
          }
          handleTextInRoot() {
            let { i: e2, forbiddenState: t3 } = this;
            const { chunk: r2, textHandler: n2 } = this;
            e: for (; ; ) switch (this.getCode()) {
              case 60:
                if (this.state = 15, void 0 !== n2) {
                  const { text: t4 } = this, i2 = r2.slice(e2, this.prevI);
                  0 !== t4.length ? (n2(t4 + i2), this.text = "") : 0 !== i2.length && n2(i2);
                }
                t3 = 0;
                break e;
              case 38:
                this.state = 14, this.entityReturnState = 13, void 0 !== n2 && (this.text += r2.slice(e2, this.prevI)), t3 = 0;
                break e;
              case 93:
                switch (t3) {
                  case 0:
                    t3 = 1;
                    break;
                  case 1:
                    t3 = 2;
                    break;
                  case 2:
                    break;
                  default:
                    throw new Error("impossible state");
                }
                break;
              case 62:
                2 === t3 && this.fail('the string "]]>" is disallowed in char data.'), t3 = 0;
                break;
              case -2:
                void 0 !== n2 && (this.text += r2.slice(e2, this.prevI) + "\n"), e2 = this.i, t3 = 0;
                break;
              case -1:
                void 0 !== n2 && (this.text += r2.slice(e2));
                break e;
              default:
                t3 = 0;
            }
            this.forbiddenState = t3;
          }
          handleTextOutsideRoot() {
            let { i: e2 } = this;
            const { chunk: t3, textHandler: r2 } = this;
            let n2 = false;
            e: for (; ; ) {
              const i2 = this.getCode();
              switch (i2) {
                case 60:
                  if (this.state = 15, void 0 !== r2) {
                    const { text: n3 } = this, i3 = t3.slice(e2, this.prevI);
                    0 !== n3.length ? (r2(n3 + i3), this.text = "") : 0 !== i3.length && r2(i3);
                  }
                  break e;
                case 38:
                  this.state = 14, this.entityReturnState = 13, void 0 !== r2 && (this.text += t3.slice(e2, this.prevI)), n2 = true;
                  break e;
                case -2:
                  void 0 !== r2 && (this.text += t3.slice(e2, this.prevI) + "\n"), e2 = this.i;
                  break;
                case -1:
                  void 0 !== r2 && (this.text += t3.slice(e2));
                  break e;
                default:
                  o(i2) || (n2 = true);
              }
            }
            n2 && (this.sawRoot || this.reportedTextBeforeRoot || (this.fail("text data outside of root node."), this.reportedTextBeforeRoot = true), this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."), this.reportedTextAfterRoot = true));
          }
          pushAttribNS(e2, t3) {
            var r2;
            const { prefix: n2, local: i2 } = this.qname(e2), s2 = { name: e2, prefix: n2, local: i2, value: t3 };
            if (this.attribList.push(s2), null === (r2 = this.attributeHandler) || void 0 === r2 || r2.call(this, s2), "xmlns" === n2) {
              const e3 = t3.trim();
              "1.0" === this.currentXMLVersion && "" === e3 && this.fail("invalid attempt to undefine prefix in XML 1.0"), this.topNS[i2] = e3, C2(this, i2, e3);
            } else if ("xmlns" === e2) {
              const e3 = t3.trim();
              this.topNS[""] = e3, C2(this, "", e3);
            }
          }
          pushAttribPlain(e2, t3) {
            var r2;
            const n2 = { name: e2, value: t3 };
            this.attribList.push(n2), null === (r2 = this.attributeHandler) || void 0 === r2 || r2.call(this, n2);
          }
          end() {
            var e2, t3;
            this.sawRoot || this.fail("document must contain a root element.");
            const { tags: r2 } = this;
            for (; r2.length > 0; ) {
              const e3 = r2.pop();
              this.fail("unclosed tag: " + e3.name);
            }
            0 !== this.state && 13 !== this.state && this.fail("unexpected end.");
            const { text: n2 } = this;
            return 0 !== n2.length && (null === (e2 = this.textHandler) || void 0 === e2 || e2.call(this, n2), this.text = ""), this._closed = true, null === (t3 = this.endHandler) || void 0 === t3 || t3.call(this), this._init(), this;
          }
          resolve(e2) {
            var t3, r2;
            let n2 = this.topNS[e2];
            if (void 0 !== n2) return n2;
            const { tags: i2 } = this;
            for (let t4 = i2.length - 1; t4 >= 0; t4--) if (n2 = i2[t4].ns[e2], void 0 !== n2) return n2;
            return n2 = this.ns[e2], void 0 !== n2 ? n2 : null === (r2 = (t3 = this.opt).resolvePrefix) || void 0 === r2 ? void 0 : r2.call(t3, e2);
          }
          qname(e2) {
            const t3 = e2.indexOf(":");
            if (-1 === t3) return { prefix: "", local: e2 };
            const r2 = e2.slice(t3 + 1), n2 = e2.slice(0, t3);
            return ("" === n2 || "" === r2 || r2.includes(":")) && this.fail(`malformed name: ${e2}.`), { prefix: n2, local: r2 };
          }
          processAttribsNS() {
            var e2;
            const { attribList: t3 } = this, r2 = this.tag;
            {
              const { prefix: t4, local: n3 } = this.qname(r2.name);
              r2.prefix = t4, r2.local = n3;
              const i3 = r2.uri = null !== (e2 = this.resolve(t4)) && void 0 !== e2 ? e2 : "";
              "" !== t4 && ("xmlns" === t4 && this.fail('tags may not have "xmlns" as prefix.'), "" === i3 && (this.fail(`unbound namespace prefix: ${JSON.stringify(t4)}.`), r2.uri = t4));
            }
            if (0 === t3.length) return;
            const { attributes: n2 } = r2, i2 = /* @__PURE__ */ new Set();
            for (const e3 of t3) {
              const { name: t4, prefix: r3, local: s2 } = e3;
              let o2, a2;
              "" === r3 ? (o2 = "xmlns" === t4 ? g : "", a2 = t4) : (o2 = this.resolve(r3), void 0 === o2 && (this.fail(`unbound namespace prefix: ${JSON.stringify(r3)}.`), o2 = r3), a2 = `{${o2}}${s2}`), i2.has(a2) && this.fail(`duplicate attribute: ${a2}.`), i2.add(a2), e3.uri = o2, n2[t4] = e3;
            }
            this.attribList = [];
          }
          processAttribsPlain() {
            const { attribList: e2 } = this, t3 = this.tag.attributes;
            for (const { name: r2, value: n2 } of e2) void 0 !== t3[r2] && this.fail(`duplicate attribute: ${r2}.`), t3[r2] = n2;
            this.attribList = [];
          }
          openTag() {
            var e2;
            this.processAttribs();
            const { tags: t3 } = this, r2 = this.tag;
            r2.isSelfClosing = false, null === (e2 = this.openTagHandler) || void 0 === e2 || e2.call(this, r2), t3.push(r2), this.state = 13, this.name = "";
          }
          openSelfClosingTag() {
            var e2, t3, r2;
            this.processAttribs();
            const { tags: n2 } = this, i2 = this.tag;
            i2.isSelfClosing = true, null === (e2 = this.openTagHandler) || void 0 === e2 || e2.call(this, i2), null === (t3 = this.closeTagHandler) || void 0 === t3 || t3.call(this, i2);
            null === (this.tag = null !== (r2 = n2[n2.length - 1]) && void 0 !== r2 ? r2 : null) && (this.closedRoot = true), this.state = 13, this.name = "";
          }
          closeTag() {
            const { tags: e2, name: t3 } = this;
            if (this.state = 13, this.name = "", "" === t3) return this.fail("weird empty close tag."), void (this.text += "</>");
            const r2 = this.closeTagHandler;
            let n2 = e2.length;
            for (; n2-- > 0; ) {
              const n3 = this.tag = e2.pop();
              if (this.topNS = n3.ns, null == r2 || r2(n3), n3.name === t3) break;
              this.fail("unexpected close tag.");
            }
            0 === n2 ? this.closedRoot = true : n2 < 0 && (this.fail(`unmatched closing tag: ${t3}.`), this.text += `</${t3}>`);
          }
          parseEntity(e2) {
            if ("#" !== e2[0]) {
              const t4 = this.ENTITIES[e2];
              return void 0 !== t4 ? t4 : (this.fail(this.isName(e2) ? "undefined entity." : "disallowed character in entity name."), `&${e2};`);
            }
            let t3 = NaN;
            return "x" === e2[1] && /^#x[0-9a-f]+$/i.test(e2) ? t3 = parseInt(e2.slice(2), 16) : /^#[0-9]+$/.test(e2) && (t3 = parseInt(e2.slice(1), 10)), this.isChar(t3) ? String.fromCodePoint(t3) : (this.fail("malformed character entity."), `&${e2};`);
          }
        };
      }, { "xmlchars/xml/1.0/ed5": 543, "xmlchars/xml/1.1/ed2": 544, "xmlchars/xmlns/1.0/ed3": 545 }], 497: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer;
        function i(e2, t3) {
          this._block = n.alloc(e2), this._finalSize = t3, this._blockSize = e2, this._len = 0;
        }
        i.prototype.update = function(e2, t3) {
          "string" == typeof e2 && (t3 = t3 || "utf8", e2 = n.from(e2, t3));
          for (var r2 = this._block, i2 = this._blockSize, s = e2.length, o = this._len, a = 0; a < s; ) {
            for (var l = o % i2, c = Math.min(s - a, i2 - l), u = 0; u < c; u++) r2[l + u] = e2[a + u];
            a += c, (o += c) % i2 == 0 && this._update(r2);
          }
          return this._len += s, this;
        }, i.prototype.digest = function(e2) {
          var t3 = this._len % this._blockSize;
          this._block[t3] = 128, this._block.fill(0, t3 + 1), t3 >= this._finalSize && (this._update(this._block), this._block.fill(0));
          var r2 = 8 * this._len;
          if (r2 <= 4294967295) this._block.writeUInt32BE(r2, this._blockSize - 4);
          else {
            var n2 = (4294967295 & r2) >>> 0, i2 = (r2 - n2) / 4294967296;
            this._block.writeUInt32BE(i2, this._blockSize - 8), this._block.writeUInt32BE(n2, this._blockSize - 4);
          }
          this._update(this._block);
          var s = this._hash();
          return e2 ? s.toString(e2) : s;
        }, i.prototype._update = function() {
          throw new Error("_update must be implemented by subclass");
        }, t2.exports = i;
      }, { "safe-buffer": 494 }], 498: [function(e, t2, r) {
        var n = t2.exports = function(e2) {
          e2 = e2.toLowerCase();
          var t3 = n[e2];
          if (!t3) throw new Error(e2 + " is not supported (we accept pull requests)");
          return new t3();
        };
        n.sha = e("./sha"), n.sha1 = e("./sha1"), n.sha224 = e("./sha224"), n.sha256 = e("./sha256"), n.sha384 = e("./sha384"), n.sha512 = e("./sha512");
      }, { "./sha": 499, "./sha1": 500, "./sha224": 501, "./sha256": 502, "./sha384": 503, "./sha512": 504 }], 499: [function(e, t2, r) {
        var n = e("inherits"), i = e("./hash"), s = e("safe-buffer").Buffer, o = [1518500249, 1859775393, -1894007588, -899497514], a = new Array(80);
        function l() {
          this.init(), this._w = a, i.call(this, 64, 56);
        }
        function c(e2) {
          return e2 << 30 | e2 >>> 2;
        }
        function u(e2, t3, r2, n2) {
          return 0 === e2 ? t3 & r2 | ~t3 & n2 : 2 === e2 ? t3 & r2 | t3 & n2 | r2 & n2 : t3 ^ r2 ^ n2;
        }
        n(l, i), l.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, l.prototype._update = function(e2) {
          for (var t3, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, s2 = 0 | this._c, a2 = 0 | this._d, l2 = 0 | this._e, h = 0; h < 16; ++h) r2[h] = e2.readInt32BE(4 * h);
          for (; h < 80; ++h) r2[h] = r2[h - 3] ^ r2[h - 8] ^ r2[h - 14] ^ r2[h - 16];
          for (var f = 0; f < 80; ++f) {
            var d = ~~(f / 20), p = 0 | ((t3 = n2) << 5 | t3 >>> 27) + u(d, i2, s2, a2) + l2 + r2[f] + o[d];
            l2 = a2, a2 = s2, s2 = c(i2), i2 = n2, n2 = p;
          }
          this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = s2 + this._c | 0, this._d = a2 + this._d | 0, this._e = l2 + this._e | 0;
        }, l.prototype._hash = function() {
          var e2 = s.allocUnsafe(20);
          return e2.writeInt32BE(0 | this._a, 0), e2.writeInt32BE(0 | this._b, 4), e2.writeInt32BE(0 | this._c, 8), e2.writeInt32BE(0 | this._d, 12), e2.writeInt32BE(0 | this._e, 16), e2;
        }, t2.exports = l;
      }, { "./hash": 497, inherits: 440, "safe-buffer": 494 }], 500: [function(e, t2, r) {
        var n = e("inherits"), i = e("./hash"), s = e("safe-buffer").Buffer, o = [1518500249, 1859775393, -1894007588, -899497514], a = new Array(80);
        function l() {
          this.init(), this._w = a, i.call(this, 64, 56);
        }
        function c(e2) {
          return e2 << 5 | e2 >>> 27;
        }
        function u(e2) {
          return e2 << 30 | e2 >>> 2;
        }
        function h(e2, t3, r2, n2) {
          return 0 === e2 ? t3 & r2 | ~t3 & n2 : 2 === e2 ? t3 & r2 | t3 & n2 | r2 & n2 : t3 ^ r2 ^ n2;
        }
        n(l, i), l.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, l.prototype._update = function(e2) {
          for (var t3, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, s2 = 0 | this._c, a2 = 0 | this._d, l2 = 0 | this._e, f = 0; f < 16; ++f) r2[f] = e2.readInt32BE(4 * f);
          for (; f < 80; ++f) r2[f] = (t3 = r2[f - 3] ^ r2[f - 8] ^ r2[f - 14] ^ r2[f - 16]) << 1 | t3 >>> 31;
          for (var d = 0; d < 80; ++d) {
            var p = ~~(d / 20), m = c(n2) + h(p, i2, s2, a2) + l2 + r2[d] + o[p] | 0;
            l2 = a2, a2 = s2, s2 = u(i2), i2 = n2, n2 = m;
          }
          this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = s2 + this._c | 0, this._d = a2 + this._d | 0, this._e = l2 + this._e | 0;
        }, l.prototype._hash = function() {
          var e2 = s.allocUnsafe(20);
          return e2.writeInt32BE(0 | this._a, 0), e2.writeInt32BE(0 | this._b, 4), e2.writeInt32BE(0 | this._c, 8), e2.writeInt32BE(0 | this._d, 12), e2.writeInt32BE(0 | this._e, 16), e2;
        }, t2.exports = l;
      }, { "./hash": 497, inherits: 440, "safe-buffer": 494 }], 501: [function(e, t2, r) {
        var n = e("inherits"), i = e("./sha256"), s = e("./hash"), o = e("safe-buffer").Buffer, a = new Array(64);
        function l() {
          this.init(), this._w = a, s.call(this, 64, 56);
        }
        n(l, i), l.prototype.init = function() {
          return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
        }, l.prototype._hash = function() {
          var e2 = o.allocUnsafe(28);
          return e2.writeInt32BE(this._a, 0), e2.writeInt32BE(this._b, 4), e2.writeInt32BE(this._c, 8), e2.writeInt32BE(this._d, 12), e2.writeInt32BE(this._e, 16), e2.writeInt32BE(this._f, 20), e2.writeInt32BE(this._g, 24), e2;
        }, t2.exports = l;
      }, { "./hash": 497, "./sha256": 502, inherits: 440, "safe-buffer": 494 }], 502: [function(e, t2, r) {
        var n = e("inherits"), i = e("./hash"), s = e("safe-buffer").Buffer, o = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], a = new Array(64);
        function l() {
          this.init(), this._w = a, i.call(this, 64, 56);
        }
        function c(e2, t3, r2) {
          return r2 ^ e2 & (t3 ^ r2);
        }
        function u(e2, t3, r2) {
          return e2 & t3 | r2 & (e2 | t3);
        }
        function h(e2) {
          return (e2 >>> 2 | e2 << 30) ^ (e2 >>> 13 | e2 << 19) ^ (e2 >>> 22 | e2 << 10);
        }
        function f(e2) {
          return (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
        }
        function d(e2) {
          return (e2 >>> 7 | e2 << 25) ^ (e2 >>> 18 | e2 << 14) ^ e2 >>> 3;
        }
        n(l, i), l.prototype.init = function() {
          return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
        }, l.prototype._update = function(e2) {
          for (var t3, r2 = this._w, n2 = 0 | this._a, i2 = 0 | this._b, s2 = 0 | this._c, a2 = 0 | this._d, l2 = 0 | this._e, p = 0 | this._f, m = 0 | this._g, b = 0 | this._h, g = 0; g < 16; ++g) r2[g] = e2.readInt32BE(4 * g);
          for (; g < 64; ++g) r2[g] = 0 | (((t3 = r2[g - 2]) >>> 17 | t3 << 15) ^ (t3 >>> 19 | t3 << 13) ^ t3 >>> 10) + r2[g - 7] + d(r2[g - 15]) + r2[g - 16];
          for (var y = 0; y < 64; ++y) {
            var v = b + f(l2) + c(l2, p, m) + o[y] + r2[y] | 0, w = h(n2) + u(n2, i2, s2) | 0;
            b = m, m = p, p = l2, l2 = a2 + v | 0, a2 = s2, s2 = i2, i2 = n2, n2 = v + w | 0;
          }
          this._a = n2 + this._a | 0, this._b = i2 + this._b | 0, this._c = s2 + this._c | 0, this._d = a2 + this._d | 0, this._e = l2 + this._e | 0, this._f = p + this._f | 0, this._g = m + this._g | 0, this._h = b + this._h | 0;
        }, l.prototype._hash = function() {
          var e2 = s.allocUnsafe(32);
          return e2.writeInt32BE(this._a, 0), e2.writeInt32BE(this._b, 4), e2.writeInt32BE(this._c, 8), e2.writeInt32BE(this._d, 12), e2.writeInt32BE(this._e, 16), e2.writeInt32BE(this._f, 20), e2.writeInt32BE(this._g, 24), e2.writeInt32BE(this._h, 28), e2;
        }, t2.exports = l;
      }, { "./hash": 497, inherits: 440, "safe-buffer": 494 }], 503: [function(e, t2, r) {
        var n = e("inherits"), i = e("./sha512"), s = e("./hash"), o = e("safe-buffer").Buffer, a = new Array(160);
        function l() {
          this.init(), this._w = a, s.call(this, 128, 112);
        }
        n(l, i), l.prototype.init = function() {
          return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
        }, l.prototype._hash = function() {
          var e2 = o.allocUnsafe(48);
          function t3(t4, r2, n2) {
            e2.writeInt32BE(t4, n2), e2.writeInt32BE(r2, n2 + 4);
          }
          return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), e2;
        }, t2.exports = l;
      }, { "./hash": 497, "./sha512": 504, inherits: 440, "safe-buffer": 494 }], 504: [function(e, t2, r) {
        var n = e("inherits"), i = e("./hash"), s = e("safe-buffer").Buffer, o = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], a = new Array(160);
        function l() {
          this.init(), this._w = a, i.call(this, 128, 112);
        }
        function c(e2, t3, r2) {
          return r2 ^ e2 & (t3 ^ r2);
        }
        function u(e2, t3, r2) {
          return e2 & t3 | r2 & (e2 | t3);
        }
        function h(e2, t3) {
          return (e2 >>> 28 | t3 << 4) ^ (t3 >>> 2 | e2 << 30) ^ (t3 >>> 7 | e2 << 25);
        }
        function f(e2, t3) {
          return (e2 >>> 14 | t3 << 18) ^ (e2 >>> 18 | t3 << 14) ^ (t3 >>> 9 | e2 << 23);
        }
        function d(e2, t3) {
          return (e2 >>> 1 | t3 << 31) ^ (e2 >>> 8 | t3 << 24) ^ e2 >>> 7;
        }
        function p(e2, t3) {
          return (e2 >>> 1 | t3 << 31) ^ (e2 >>> 8 | t3 << 24) ^ (e2 >>> 7 | t3 << 25);
        }
        function m(e2, t3) {
          return (e2 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e2 << 3) ^ e2 >>> 6;
        }
        function b(e2, t3) {
          return (e2 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e2 << 3) ^ (e2 >>> 6 | t3 << 26);
        }
        function g(e2, t3) {
          return e2 >>> 0 < t3 >>> 0 ? 1 : 0;
        }
        n(l, i), l.prototype.init = function() {
          return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
        }, l.prototype._update = function(e2) {
          for (var t3 = this._w, r2 = 0 | this._ah, n2 = 0 | this._bh, i2 = 0 | this._ch, s2 = 0 | this._dh, a2 = 0 | this._eh, l2 = 0 | this._fh, y = 0 | this._gh, v = 0 | this._hh, w = 0 | this._al, _ = 0 | this._bl, x = 0 | this._cl, k = 0 | this._dl, S = 0 | this._el, M = 0 | this._fl, C2 = 0 | this._gl, T = 0 | this._hl, E = 0; E < 32; E += 2) t3[E] = e2.readInt32BE(4 * E), t3[E + 1] = e2.readInt32BE(4 * E + 4);
          for (; E < 160; E += 2) {
            var A = t3[E - 30], R = t3[E - 30 + 1], O = d(A, R), j = p(R, A), I = m(A = t3[E - 4], R = t3[E - 4 + 1]), N = b(R, A), P = t3[E - 14], B = t3[E - 14 + 1], D = t3[E - 32], F = t3[E - 32 + 1], L = j + B | 0, z = O + P + g(L, j) | 0;
            z = (z = z + I + g(L = L + N | 0, N) | 0) + D + g(L = L + F | 0, F) | 0, t3[E] = z, t3[E + 1] = L;
          }
          for (var U = 0; U < 160; U += 2) {
            z = t3[U], L = t3[U + 1];
            var $ = u(r2, n2, i2), H = u(w, _, x), V = h(r2, w), q = h(w, r2), W = f(a2, S), X = f(S, a2), K = o[U], Y = o[U + 1], Z = c(a2, l2, y), G = c(S, M, C2), J = T + X | 0, Q = v + W + g(J, T) | 0;
            Q = (Q = (Q = Q + Z + g(J = J + G | 0, G) | 0) + K + g(J = J + Y | 0, Y) | 0) + z + g(J = J + L | 0, L) | 0;
            var ee = q + H | 0, te = V + $ + g(ee, q) | 0;
            v = y, T = C2, y = l2, C2 = M, l2 = a2, M = S, a2 = s2 + Q + g(S = k + J | 0, k) | 0, s2 = i2, k = x, i2 = n2, x = _, n2 = r2, _ = w, r2 = Q + te + g(w = J + ee | 0, J) | 0;
          }
          this._al = this._al + w | 0, this._bl = this._bl + _ | 0, this._cl = this._cl + x | 0, this._dl = this._dl + k | 0, this._el = this._el + S | 0, this._fl = this._fl + M | 0, this._gl = this._gl + C2 | 0, this._hl = this._hl + T | 0, this._ah = this._ah + r2 + g(this._al, w) | 0, this._bh = this._bh + n2 + g(this._bl, _) | 0, this._ch = this._ch + i2 + g(this._cl, x) | 0, this._dh = this._dh + s2 + g(this._dl, k) | 0, this._eh = this._eh + a2 + g(this._el, S) | 0, this._fh = this._fh + l2 + g(this._fl, M) | 0, this._gh = this._gh + y + g(this._gl, C2) | 0, this._hh = this._hh + v + g(this._hl, T) | 0;
        }, l.prototype._hash = function() {
          var e2 = s.allocUnsafe(64);
          function t3(t4, r2, n2) {
            e2.writeInt32BE(t4, n2), e2.writeInt32BE(r2, n2 + 4);
          }
          return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), t3(this._gh, this._gl, 48), t3(this._hh, this._hl, 56), e2;
        }, t2.exports = l;
      }, { "./hash": 497, inherits: 440, "safe-buffer": 494 }], 505: [function(e, t2, r) {
        t2.exports = i;
        var n = e("events").EventEmitter;
        function i() {
          n.call(this);
        }
        e("inherits")(i, n), i.Readable = e("readable-stream/readable.js"), i.Writable = e("readable-stream/writable.js"), i.Duplex = e("readable-stream/duplex.js"), i.Transform = e("readable-stream/transform.js"), i.PassThrough = e("readable-stream/passthrough.js"), i.Stream = i, i.prototype.pipe = function(e2, t3) {
          var r2 = this;
          function i2(t4) {
            e2.writable && false === e2.write(t4) && r2.pause && r2.pause();
          }
          function s() {
            r2.readable && r2.resume && r2.resume();
          }
          r2.on("data", i2), e2.on("drain", s), e2._isStdio || t3 && false === t3.end || (r2.on("end", a), r2.on("close", l));
          var o = false;
          function a() {
            o || (o = true, e2.end());
          }
          function l() {
            o || (o = true, "function" == typeof e2.destroy && e2.destroy());
          }
          function c(e3) {
            if (u(), 0 === n.listenerCount(this, "error")) throw e3;
          }
          function u() {
            r2.removeListener("data", i2), e2.removeListener("drain", s), r2.removeListener("end", a), r2.removeListener("close", l), r2.removeListener("error", c), e2.removeListener("error", c), r2.removeListener("end", u), r2.removeListener("close", u), e2.removeListener("close", u);
          }
          return r2.on("error", c), e2.on("error", c), r2.on("end", u), r2.on("close", u), e2.on("close", u), e2.emit("pipe", r2), e2;
        };
      }, { events: 422, inherits: 440, "readable-stream/duplex.js": 507, "readable-stream/passthrough.js": 516, "readable-stream/readable.js": 517, "readable-stream/transform.js": 518, "readable-stream/writable.js": 519 }], 506: [function(e, t2, r) {
        var n = {}.toString;
        t2.exports = Array.isArray || function(e2) {
          return "[object Array]" == n.call(e2);
        };
      }, {}], 507: [function(e, t2, r) {
        t2.exports = e("./lib/_stream_duplex.js");
      }, { "./lib/_stream_duplex.js": 508 }], 508: [function(e, t2, r) {
        var n = e("process-nextick-args"), i = Object.keys || function(e2) {
          var t3 = [];
          for (var r2 in e2) t3.push(r2);
          return t3;
        };
        t2.exports = h;
        var s = Object.create(e("core-util-is"));
        s.inherits = e("inherits");
        var o = e("./_stream_readable"), a = e("./_stream_writable");
        s.inherits(h, o);
        for (var l = i(a.prototype), c = 0; c < l.length; c++) {
          var u = l[c];
          h.prototype[u] || (h.prototype[u] = a.prototype[u]);
        }
        function h(e2) {
          if (!(this instanceof h)) return new h(e2);
          o.call(this, e2), a.call(this, e2), e2 && false === e2.readable && (this.readable = false), e2 && false === e2.writable && (this.writable = false), this.allowHalfOpen = true, e2 && false === e2.allowHalfOpen && (this.allowHalfOpen = false), this.once("end", f);
        }
        function f() {
          this.allowHalfOpen || this._writableState.ended || n.nextTick(d, this);
        }
        function d(e2) {
          e2.end();
        }
        Object.defineProperty(h.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(h.prototype, "destroyed", { get: function() {
          return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
        }, set: function(e2) {
          void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
        } }), h.prototype._destroy = function(e2, t3) {
          this.push(null), this.end(), n.nextTick(t3, e2);
        };
      }, { "./_stream_readable": 510, "./_stream_writable": 512, "core-util-is": 383, inherits: 440, "process-nextick-args": 466 }], 509: [function(e, t2, r) {
        t2.exports = s;
        var n = e("./_stream_transform"), i = Object.create(e("core-util-is"));
        function s(e2) {
          if (!(this instanceof s)) return new s(e2);
          n.call(this, e2);
        }
        i.inherits = e("inherits"), i.inherits(s, n), s.prototype._transform = function(e2, t3, r2) {
          r2(null, e2);
        };
      }, { "./_stream_transform": 511, "core-util-is": 383, inherits: 440 }], 510: [function(e, t2, r) {
        (function(r2, n) {
          (function() {
            var i = e("process-nextick-args");
            t2.exports = v;
            var s, o = e("isarray");
            v.ReadableState = y;
            e("events").EventEmitter;
            var a = function(e2, t3) {
              return e2.listeners(t3).length;
            }, l = e("./internal/streams/stream"), c = e("safe-buffer").Buffer, u = (void 0 !== n ? n : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
            };
            var h = Object.create(e("core-util-is"));
            h.inherits = e("inherits");
            var f = e("util"), d = void 0;
            d = f && f.debuglog ? f.debuglog("stream") : function() {
            };
            var p, m = e("./internal/streams/BufferList"), b = e("./internal/streams/destroy");
            h.inherits(v, l);
            var g = ["error", "close", "destroy", "pause", "resume"];
            function y(t3, r3) {
              t3 = t3 || {};
              var n2 = r3 instanceof (s = s || e("./_stream_duplex"));
              this.objectMode = !!t3.objectMode, n2 && (this.objectMode = this.objectMode || !!t3.readableObjectMode);
              var i2 = t3.highWaterMark, o2 = t3.readableHighWaterMark, a2 = this.objectMode ? 16 : 16384;
              this.highWaterMark = i2 || 0 === i2 ? i2 : n2 && (o2 || 0 === o2) ? o2 : a2, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (p || (p = e("string_decoder/").StringDecoder), this.decoder = new p(t3.encoding), this.encoding = t3.encoding);
            }
            function v(t3) {
              if (s = s || e("./_stream_duplex"), !(this instanceof v)) return new v(t3);
              this._readableState = new y(t3, this), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), l.call(this);
            }
            function w(e2, t3, r3, n2, i2) {
              var s2, o2 = e2._readableState;
              null === t3 ? (o2.reading = false, (function(e3, t4) {
                if (t4.ended) return;
                if (t4.decoder) {
                  var r4 = t4.decoder.end();
                  r4 && r4.length && (t4.buffer.push(r4), t4.length += t4.objectMode ? 1 : r4.length);
                }
                t4.ended = true, k(e3);
              })(e2, o2)) : (i2 || (s2 = (function(e3, t4) {
                var r4;
                n3 = t4, c.isBuffer(n3) || n3 instanceof u || "string" == typeof t4 || void 0 === t4 || e3.objectMode || (r4 = new TypeError("Invalid non-string/buffer chunk"));
                var n3;
                return r4;
              })(o2, t3)), s2 ? e2.emit("error", s2) : o2.objectMode || t3 && t3.length > 0 ? ("string" == typeof t3 || o2.objectMode || Object.getPrototypeOf(t3) === c.prototype || (t3 = (function(e3) {
                return c.from(e3);
              })(t3)), n2 ? o2.endEmitted ? e2.emit("error", new Error("stream.unshift() after end event")) : _(e2, o2, t3, true) : o2.ended ? e2.emit("error", new Error("stream.push() after EOF")) : (o2.reading = false, o2.decoder && !r3 ? (t3 = o2.decoder.write(t3), o2.objectMode || 0 !== t3.length ? _(e2, o2, t3, false) : M(e2, o2)) : _(e2, o2, t3, false))) : n2 || (o2.reading = false));
              return (function(e3) {
                return !e3.ended && (e3.needReadable || e3.length < e3.highWaterMark || 0 === e3.length);
              })(o2);
            }
            function _(e2, t3, r3, n2) {
              t3.flowing && 0 === t3.length && !t3.sync ? (e2.emit("data", r3), e2.read(0)) : (t3.length += t3.objectMode ? 1 : r3.length, n2 ? t3.buffer.unshift(r3) : t3.buffer.push(r3), t3.needReadable && k(e2)), M(e2, t3);
            }
            Object.defineProperty(v.prototype, "destroyed", { get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), v.prototype.destroy = b.destroy, v.prototype._undestroy = b.undestroy, v.prototype._destroy = function(e2, t3) {
              this.push(null), t3(e2);
            }, v.prototype.push = function(e2, t3) {
              var r3, n2 = this._readableState;
              return n2.objectMode ? r3 = true : "string" == typeof e2 && ((t3 = t3 || n2.defaultEncoding) !== n2.encoding && (e2 = c.from(e2, t3), t3 = ""), r3 = true), w(this, e2, t3, false, r3);
            }, v.prototype.unshift = function(e2) {
              return w(this, e2, null, true, false);
            }, v.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, v.prototype.setEncoding = function(t3) {
              return p || (p = e("string_decoder/").StringDecoder), this._readableState.decoder = new p(t3), this._readableState.encoding = t3, this;
            };
            function x(e2, t3) {
              return e2 <= 0 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e2 != e2 ? t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length : (e2 > t3.highWaterMark && (t3.highWaterMark = (function(e3) {
                return e3 >= 8388608 ? e3 = 8388608 : (e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, e3++), e3;
              })(e2)), e2 <= t3.length ? e2 : t3.ended ? t3.length : (t3.needReadable = true, 0));
            }
            function k(e2) {
              var t3 = e2._readableState;
              t3.needReadable = false, t3.emittedReadable || (d("emitReadable", t3.flowing), t3.emittedReadable = true, t3.sync ? i.nextTick(S, e2) : S(e2));
            }
            function S(e2) {
              d("emit readable"), e2.emit("readable"), A(e2);
            }
            function M(e2, t3) {
              t3.readingMore || (t3.readingMore = true, i.nextTick(C2, e2, t3));
            }
            function C2(e2, t3) {
              for (var r3 = t3.length; !t3.reading && !t3.flowing && !t3.ended && t3.length < t3.highWaterMark && (d("maybeReadMore read 0"), e2.read(0), r3 !== t3.length); ) r3 = t3.length;
              t3.readingMore = false;
            }
            function T(e2) {
              d("readable nexttick read 0"), e2.read(0);
            }
            function E(e2, t3) {
              t3.reading || (d("resume read 0"), e2.read(0)), t3.resumeScheduled = false, t3.awaitDrain = 0, e2.emit("resume"), A(e2), t3.flowing && !t3.reading && e2.read(0);
            }
            function A(e2) {
              var t3 = e2._readableState;
              for (d("flow", t3.flowing); t3.flowing && null !== e2.read(); ) ;
            }
            function R(e2, t3) {
              return 0 === t3.length ? null : (t3.objectMode ? r3 = t3.buffer.shift() : !e2 || e2 >= t3.length ? (r3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.head.data : t3.buffer.concat(t3.length), t3.buffer.clear()) : r3 = (function(e3, t4, r4) {
                var n2;
                e3 < t4.head.data.length ? (n2 = t4.head.data.slice(0, e3), t4.head.data = t4.head.data.slice(e3)) : n2 = e3 === t4.head.data.length ? t4.shift() : r4 ? (function(e4, t5) {
                  var r5 = t5.head, n3 = 1, i2 = r5.data;
                  e4 -= i2.length;
                  for (; r5 = r5.next; ) {
                    var s2 = r5.data, o2 = e4 > s2.length ? s2.length : e4;
                    if (o2 === s2.length ? i2 += s2 : i2 += s2.slice(0, e4), 0 === (e4 -= o2)) {
                      o2 === s2.length ? (++n3, r5.next ? t5.head = r5.next : t5.head = t5.tail = null) : (t5.head = r5, r5.data = s2.slice(o2));
                      break;
                    }
                    ++n3;
                  }
                  return t5.length -= n3, i2;
                })(e3, t4) : (function(e4, t5) {
                  var r5 = c.allocUnsafe(e4), n3 = t5.head, i2 = 1;
                  n3.data.copy(r5), e4 -= n3.data.length;
                  for (; n3 = n3.next; ) {
                    var s2 = n3.data, o2 = e4 > s2.length ? s2.length : e4;
                    if (s2.copy(r5, r5.length - e4, 0, o2), 0 === (e4 -= o2)) {
                      o2 === s2.length ? (++i2, n3.next ? t5.head = n3.next : t5.head = t5.tail = null) : (t5.head = n3, n3.data = s2.slice(o2));
                      break;
                    }
                    ++i2;
                  }
                  return t5.length -= i2, r5;
                })(e3, t4);
                return n2;
              })(e2, t3.buffer, t3.decoder), r3);
              var r3;
            }
            function O(e2) {
              var t3 = e2._readableState;
              if (t3.length > 0) throw new Error('"endReadable()" called on non-empty stream');
              t3.endEmitted || (t3.ended = true, i.nextTick(j, t3, e2));
            }
            function j(e2, t3) {
              e2.endEmitted || 0 !== e2.length || (e2.endEmitted = true, t3.readable = false, t3.emit("end"));
            }
            function I(e2, t3) {
              for (var r3 = 0, n2 = e2.length; r3 < n2; r3++) if (e2[r3] === t3) return r3;
              return -1;
            }
            v.prototype.read = function(e2) {
              d("read", e2), e2 = parseInt(e2, 10);
              var t3 = this._readableState, r3 = e2;
              if (0 !== e2 && (t3.emittedReadable = false), 0 === e2 && t3.needReadable && (t3.length >= t3.highWaterMark || t3.ended)) return d("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? O(this) : k(this), null;
              if (0 === (e2 = x(e2, t3)) && t3.ended) return 0 === t3.length && O(this), null;
              var n2, i2 = t3.needReadable;
              return d("need readable", i2), (0 === t3.length || t3.length - e2 < t3.highWaterMark) && d("length less than watermark", i2 = true), t3.ended || t3.reading ? d("reading or ended", i2 = false) : i2 && (d("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, t3.reading || (e2 = x(r3, t3))), null === (n2 = e2 > 0 ? R(e2, t3) : null) ? (t3.needReadable = true, e2 = 0) : t3.length -= e2, 0 === t3.length && (t3.ended || (t3.needReadable = true), r3 !== e2 && t3.ended && O(this)), null !== n2 && this.emit("data", n2), n2;
            }, v.prototype._read = function(e2) {
              this.emit("error", new Error("_read() is not implemented"));
            }, v.prototype.pipe = function(e2, t3) {
              var n2 = this, s2 = this._readableState;
              switch (s2.pipesCount) {
                case 0:
                  s2.pipes = e2;
                  break;
                case 1:
                  s2.pipes = [s2.pipes, e2];
                  break;
                default:
                  s2.pipes.push(e2);
              }
              s2.pipesCount += 1, d("pipe count=%d opts=%j", s2.pipesCount, t3);
              var l2 = (!t3 || false !== t3.end) && e2 !== r2.stdout && e2 !== r2.stderr ? u2 : v2;
              function c2(t4, r3) {
                d("onunpipe"), t4 === n2 && r3 && false === r3.hasUnpiped && (r3.hasUnpiped = true, d("cleanup"), e2.removeListener("close", g2), e2.removeListener("finish", y2), e2.removeListener("drain", h2), e2.removeListener("error", b2), e2.removeListener("unpipe", c2), n2.removeListener("end", u2), n2.removeListener("end", v2), n2.removeListener("data", m2), f2 = true, !s2.awaitDrain || e2._writableState && !e2._writableState.needDrain || h2());
              }
              function u2() {
                d("onend"), e2.end();
              }
              s2.endEmitted ? i.nextTick(l2) : n2.once("end", l2), e2.on("unpipe", c2);
              var h2 = /* @__PURE__ */ (function(e3) {
                return function() {
                  var t4 = e3._readableState;
                  d("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && a(e3, "data") && (t4.flowing = true, A(e3));
                };
              })(n2);
              e2.on("drain", h2);
              var f2 = false;
              var p2 = false;
              function m2(t4) {
                d("ondata"), p2 = false, false !== e2.write(t4) || p2 || ((1 === s2.pipesCount && s2.pipes === e2 || s2.pipesCount > 1 && -1 !== I(s2.pipes, e2)) && !f2 && (d("false write response, pause", s2.awaitDrain), s2.awaitDrain++, p2 = true), n2.pause());
              }
              function b2(t4) {
                d("onerror", t4), v2(), e2.removeListener("error", b2), 0 === a(e2, "error") && e2.emit("error", t4);
              }
              function g2() {
                e2.removeListener("finish", y2), v2();
              }
              function y2() {
                d("onfinish"), e2.removeListener("close", g2), v2();
              }
              function v2() {
                d("unpipe"), n2.unpipe(e2);
              }
              return n2.on("data", m2), (function(e3, t4, r3) {
                if ("function" == typeof e3.prependListener) return e3.prependListener(t4, r3);
                e3._events && e3._events[t4] ? o(e3._events[t4]) ? e3._events[t4].unshift(r3) : e3._events[t4] = [r3, e3._events[t4]] : e3.on(t4, r3);
              })(e2, "error", b2), e2.once("close", g2), e2.once("finish", y2), e2.emit("pipe", n2), s2.flowing || (d("pipe resume"), n2.resume()), e2;
            }, v.prototype.unpipe = function(e2) {
              var t3 = this._readableState, r3 = { hasUnpiped: false };
              if (0 === t3.pipesCount) return this;
              if (1 === t3.pipesCount) return e2 && e2 !== t3.pipes || (e2 || (e2 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e2 && e2.emit("unpipe", this, r3)), this;
              if (!e2) {
                var n2 = t3.pipes, i2 = t3.pipesCount;
                t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
                for (var s2 = 0; s2 < i2; s2++) n2[s2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var o2 = I(t3.pipes, e2);
              return -1 === o2 || (t3.pipes.splice(o2, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e2.emit("unpipe", this, r3)), this;
            }, v.prototype.on = function(e2, t3) {
              var r3 = l.prototype.on.call(this, e2, t3);
              if ("data" === e2) false !== this._readableState.flowing && this.resume();
              else if ("readable" === e2) {
                var n2 = this._readableState;
                n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.emittedReadable = false, n2.reading ? n2.length && k(this) : i.nextTick(T, this));
              }
              return r3;
            }, v.prototype.addListener = v.prototype.on, v.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (d("resume"), e2.flowing = true, (function(e3, t3) {
                t3.resumeScheduled || (t3.resumeScheduled = true, i.nextTick(E, e3, t3));
              })(this, e2)), this;
            }, v.prototype.pause = function() {
              return d("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (d("pause"), this._readableState.flowing = false, this.emit("pause")), this;
            }, v.prototype.wrap = function(e2) {
              var t3 = this, r3 = this._readableState, n2 = false;
              for (var i2 in e2.on("end", (function() {
                if (d("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t3.push(e3);
                }
                t3.push(null);
              })), e2.on("data", (function(i3) {
                (d("wrapped data"), r3.decoder && (i3 = r3.decoder.write(i3)), r3.objectMode && null == i3) || (r3.objectMode || i3 && i3.length) && (t3.push(i3) || (n2 = true, e2.pause()));
              })), e2) void 0 === this[i2] && "function" == typeof e2[i2] && (this[i2] = /* @__PURE__ */ (function(t4) {
                return function() {
                  return e2[t4].apply(e2, arguments);
                };
              })(i2));
              for (var s2 = 0; s2 < g.length; s2++) e2.on(g[s2], this.emit.bind(this, g[s2]));
              return this._read = function(t4) {
                d("wrapped _read", t4), n2 && (n2 = false, e2.resume());
              }, this;
            }, Object.defineProperty(v.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), v._fromList = R;
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "./_stream_duplex": 508, "./internal/streams/BufferList": 513, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, _process: 467, "core-util-is": 383, events: 422, inherits: 440, isarray: 506, "process-nextick-args": 466, "safe-buffer": 520, "string_decoder/": 521, util: 188 }], 511: [function(e, t2, r) {
        t2.exports = o;
        var n = e("./_stream_duplex"), i = Object.create(e("core-util-is"));
        function s(e2, t3) {
          var r2 = this._transformState;
          r2.transforming = false;
          var n2 = r2.writecb;
          if (!n2) return this.emit("error", new Error("write callback called multiple times"));
          r2.writechunk = null, r2.writecb = null, null != t3 && this.push(t3), n2(e2);
          var i2 = this._readableState;
          i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
        }
        function o(e2) {
          if (!(this instanceof o)) return new o(e2);
          n.call(this, e2), this._transformState = { afterTransform: s.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a);
        }
        function a() {
          var e2 = this;
          "function" == typeof this._flush ? this._flush((function(t3, r2) {
            l(e2, t3, r2);
          })) : l(this, null, null);
        }
        function l(e2, t3, r2) {
          if (t3) return e2.emit("error", t3);
          if (null != r2 && e2.push(r2), e2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
          if (e2._transformState.transforming) throw new Error("Calling transform done when still transforming");
          return e2.push(null);
        }
        i.inherits = e("inherits"), i.inherits(o, n), o.prototype.push = function(e2, t3) {
          return this._transformState.needTransform = false, n.prototype.push.call(this, e2, t3);
        }, o.prototype._transform = function(e2, t3, r2) {
          throw new Error("_transform() is not implemented");
        }, o.prototype._write = function(e2, t3, r2) {
          var n2 = this._transformState;
          if (n2.writecb = r2, n2.writechunk = e2, n2.writeencoding = t3, !n2.transforming) {
            var i2 = this._readableState;
            (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
        }, o.prototype._read = function(e2) {
          var t3 = this._transformState;
          null !== t3.writechunk && t3.writecb && !t3.transforming ? (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform)) : t3.needTransform = true;
        }, o.prototype._destroy = function(e2, t3) {
          var r2 = this;
          n.prototype._destroy.call(this, e2, (function(e3) {
            t3(e3), r2.emit("close");
          }));
        };
      }, { "./_stream_duplex": 508, "core-util-is": 383, inherits: 440 }], 512: [function(e, t2, r) {
        (function(r2, n, i) {
          (function() {
            var s = e("process-nextick-args");
            function o(e2) {
              var t3 = this;
              this.next = null, this.entry = null, this.finish = function() {
                !(function(e3, t4, r3) {
                  var n2 = e3.entry;
                  e3.entry = null;
                  for (; n2; ) {
                    var i2 = n2.callback;
                    t4.pendingcb--, i2(r3), n2 = n2.next;
                  }
                  t4.corkedRequestsFree.next = e3;
                })(t3, e2);
              };
            }
            t2.exports = y;
            var a, l = !r2.browser && ["v0.10", "v0.9."].indexOf(r2.version.slice(0, 5)) > -1 ? i : s.nextTick;
            y.WritableState = g;
            var c = Object.create(e("core-util-is"));
            c.inherits = e("inherits");
            var u = { deprecate: e("util-deprecate") }, h = e("./internal/streams/stream"), f = e("safe-buffer").Buffer, d = (void 0 !== n ? n : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
            };
            var p, m = e("./internal/streams/destroy");
            function b() {
            }
            function g(t3, r3) {
              a = a || e("./_stream_duplex"), t3 = t3 || {};
              var n2 = r3 instanceof a;
              this.objectMode = !!t3.objectMode, n2 && (this.objectMode = this.objectMode || !!t3.writableObjectMode);
              var i2 = t3.highWaterMark, c2 = t3.writableHighWaterMark, u2 = this.objectMode ? 16 : 16384;
              this.highWaterMark = i2 || 0 === i2 ? i2 : n2 && (c2 || 0 === c2) ? c2 : u2, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var h2 = false === t3.decodeStrings;
              this.decodeStrings = !h2, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                !(function(e3, t4) {
                  var r4 = e3._writableState, n3 = r4.sync, i3 = r4.writecb;
                  if ((function(e4) {
                    e4.writing = false, e4.writecb = null, e4.length -= e4.writelen, e4.writelen = 0;
                  })(r4), t4) !(function(e4, t5, r5, n4, i4) {
                    --t5.pendingcb, r5 ? (s.nextTick(i4, n4), s.nextTick(S, e4, t5), e4._writableState.errorEmitted = true, e4.emit("error", n4)) : (i4(n4), e4._writableState.errorEmitted = true, e4.emit("error", n4), S(e4, t5));
                  })(e3, r4, n3, t4, i3);
                  else {
                    var o2 = x(r4);
                    o2 || r4.corked || r4.bufferProcessing || !r4.bufferedRequest || _(e3, r4), n3 ? l(w, e3, r4, o2, i3) : w(e3, r4, o2, i3);
                  }
                })(r3, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this);
            }
            function y(t3) {
              if (a = a || e("./_stream_duplex"), !(p.call(y, this) || this instanceof a)) return new y(t3);
              this._writableState = new g(t3, this), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), h.call(this);
            }
            function v(e2, t3, r3, n2, i2, s2, o2) {
              t3.writelen = n2, t3.writecb = o2, t3.writing = true, t3.sync = true, r3 ? e2._writev(i2, t3.onwrite) : e2._write(i2, s2, t3.onwrite), t3.sync = false;
            }
            function w(e2, t3, r3, n2) {
              r3 || (function(e3, t4) {
                0 === t4.length && t4.needDrain && (t4.needDrain = false, e3.emit("drain"));
              })(e2, t3), t3.pendingcb--, n2(), S(e2, t3);
            }
            function _(e2, t3) {
              t3.bufferProcessing = true;
              var r3 = t3.bufferedRequest;
              if (e2._writev && r3 && r3.next) {
                var n2 = t3.bufferedRequestCount, i2 = new Array(n2), s2 = t3.corkedRequestsFree;
                s2.entry = r3;
                for (var a2 = 0, l2 = true; r3; ) i2[a2] = r3, r3.isBuf || (l2 = false), r3 = r3.next, a2 += 1;
                i2.allBuffers = l2, v(e2, t3, true, t3.length, i2, "", s2.finish), t3.pendingcb++, t3.lastBufferedRequest = null, s2.next ? (t3.corkedRequestsFree = s2.next, s2.next = null) : t3.corkedRequestsFree = new o(t3), t3.bufferedRequestCount = 0;
              } else {
                for (; r3; ) {
                  var c2 = r3.chunk, u2 = r3.encoding, h2 = r3.callback;
                  if (v(e2, t3, false, t3.objectMode ? 1 : c2.length, c2, u2, h2), r3 = r3.next, t3.bufferedRequestCount--, t3.writing) break;
                }
                null === r3 && (t3.lastBufferedRequest = null);
              }
              t3.bufferedRequest = r3, t3.bufferProcessing = false;
            }
            function x(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function k(e2, t3) {
              e2._final((function(r3) {
                t3.pendingcb--, r3 && e2.emit("error", r3), t3.prefinished = true, e2.emit("prefinish"), S(e2, t3);
              }));
            }
            function S(e2, t3) {
              var r3 = x(t3);
              return r3 && (!(function(e3, t4) {
                t4.prefinished || t4.finalCalled || ("function" == typeof e3._final ? (t4.pendingcb++, t4.finalCalled = true, s.nextTick(k, e3, t4)) : (t4.prefinished = true, e3.emit("prefinish")));
              })(e2, t3), 0 === t3.pendingcb && (t3.finished = true, e2.emit("finish"))), r3;
            }
            c.inherits(y, h), g.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t3 = []; e2; ) t3.push(e2), e2 = e2.next;
              return t3;
            }, (function() {
              try {
                Object.defineProperty(g.prototype, "buffer", { get: u.deprecate((function() {
                  return this.getBuffer();
                }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            })(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (p = Function.prototype[Symbol.hasInstance], Object.defineProperty(y, Symbol.hasInstance, { value: function(e2) {
              return !!p.call(this, e2) || this === y && (e2 && e2._writableState instanceof g);
            } })) : p = function(e2) {
              return e2 instanceof this;
            }, y.prototype.pipe = function() {
              this.emit("error", new Error("Cannot pipe, not readable"));
            }, y.prototype.write = function(e2, t3, r3) {
              var n2, i2 = this._writableState, o2 = false, a2 = !i2.objectMode && (n2 = e2, f.isBuffer(n2) || n2 instanceof d);
              return a2 && !f.isBuffer(e2) && (e2 = (function(e3) {
                return f.from(e3);
              })(e2)), "function" == typeof t3 && (r3 = t3, t3 = null), a2 ? t3 = "buffer" : t3 || (t3 = i2.defaultEncoding), "function" != typeof r3 && (r3 = b), i2.ended ? (function(e3, t4) {
                var r4 = new Error("write after end");
                e3.emit("error", r4), s.nextTick(t4, r4);
              })(this, r3) : (a2 || (function(e3, t4, r4, n3) {
                var i3 = true, o3 = false;
                return null === r4 ? o3 = new TypeError("May not write null values to stream") : "string" == typeof r4 || void 0 === r4 || t4.objectMode || (o3 = new TypeError("Invalid non-string/buffer chunk")), o3 && (e3.emit("error", o3), s.nextTick(n3, o3), i3 = false), i3;
              })(this, i2, e2, r3)) && (i2.pendingcb++, o2 = (function(e3, t4, r4, n3, i3, s2) {
                if (!r4) {
                  var o3 = (function(e4, t5, r5) {
                    e4.objectMode || false === e4.decodeStrings || "string" != typeof t5 || (t5 = f.from(t5, r5));
                    return t5;
                  })(t4, n3, i3);
                  n3 !== o3 && (r4 = true, i3 = "buffer", n3 = o3);
                }
                var a3 = t4.objectMode ? 1 : n3.length;
                t4.length += a3;
                var l2 = t4.length < t4.highWaterMark;
                l2 || (t4.needDrain = true);
                if (t4.writing || t4.corked) {
                  var c2 = t4.lastBufferedRequest;
                  t4.lastBufferedRequest = { chunk: n3, encoding: i3, isBuf: r4, callback: s2, next: null }, c2 ? c2.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
                } else v(e3, t4, false, a3, n3, i3, s2);
                return l2;
              })(this, i2, a2, e2, t3, r3)), o2;
            }, y.prototype.cork = function() {
              this._writableState.corked++;
            }, y.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, e2.writing || e2.corked || e2.bufferProcessing || !e2.bufferedRequest || _(this, e2));
            }, y.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(y.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), y.prototype._write = function(e2, t3, r3) {
              r3(new Error("_write() is not implemented"));
            }, y.prototype._writev = null, y.prototype.end = function(e2, t3, r3) {
              var n2 = this._writableState;
              "function" == typeof e2 ? (r3 = e2, e2 = null, t3 = null) : "function" == typeof t3 && (r3 = t3, t3 = null), null != e2 && this.write(e2, t3), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || (function(e3, t4, r4) {
                t4.ending = true, S(e3, t4), r4 && (t4.finished ? s.nextTick(r4) : e3.once("finish", r4));
                t4.ended = true, e3.writable = false;
              })(this, n2, r3);
            }, Object.defineProperty(y.prototype, "destroyed", { get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), y.prototype.destroy = m.destroy, y.prototype._undestroy = m.undestroy, y.prototype._destroy = function(e2, t3) {
              this.end(), t3(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("timers").setImmediate);
      }, { "./_stream_duplex": 508, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, _process: 467, "core-util-is": 383, inherits: 440, "process-nextick-args": 466, "safe-buffer": 520, timers: 523, "util-deprecate": 524 }], 513: [function(e, t2, r) {
        var n = e("safe-buffer").Buffer, i = e("util");
        t2.exports = (function() {
          function e2() {
            !(function(e3, t3) {
              if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
            })(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          return e2.prototype.push = function(e3) {
            var t3 = { data: e3, next: null };
            this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          }, e2.prototype.unshift = function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          }, e2.prototype.shift = function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
            }
          }, e2.prototype.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, e2.prototype.join = function(e3) {
            if (0 === this.length) return "";
            for (var t3 = this.head, r2 = "" + t3.data; t3 = t3.next; ) r2 += e3 + t3.data;
            return r2;
          }, e2.prototype.concat = function(e3) {
            if (0 === this.length) return n.alloc(0);
            for (var t3, r2, i2, s = n.allocUnsafe(e3 >>> 0), o = this.head, a = 0; o; ) t3 = o.data, r2 = s, i2 = a, t3.copy(r2, i2), a += o.data.length, o = o.next;
            return s;
          }, e2;
        })(), i && i.inspect && i.inspect.custom && (t2.exports.prototype[i.inspect.custom] = function() {
          var e2 = i.inspect({ length: this.length });
          return this.constructor.name + " " + e2;
        });
      }, { "safe-buffer": 520, util: 188 }], 514: [function(e, t2, r) {
        var n = e("process-nextick-args");
        function i(e2, t3) {
          e2.emit("error", t3);
        }
        t2.exports = { destroy: function(e2, t3) {
          var r2 = this, s = this._readableState && this._readableState.destroyed, o = this._writableState && this._writableState.destroyed;
          return s || o ? (t3 ? t3(e2) : e2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, n.nextTick(i, this, e2)) : n.nextTick(i, this, e2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e2 || null, (function(e3) {
            !t3 && e3 ? r2._writableState ? r2._writableState.errorEmitted || (r2._writableState.errorEmitted = true, n.nextTick(i, r2, e3)) : n.nextTick(i, r2, e3) : t3 && t3(e3);
          })), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
        } };
      }, { "process-nextick-args": 466 }], 515: [function(e, t2, r) {
        arguments[4][490][0].apply(r, arguments);
      }, { dup: 490, events: 422 }], 516: [function(e, t2, r) {
        t2.exports = e("./readable").PassThrough;
      }, { "./readable": 517 }], 517: [function(e, t2, r) {
        (r = t2.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 508, "./lib/_stream_passthrough.js": 509, "./lib/_stream_readable.js": 510, "./lib/_stream_transform.js": 511, "./lib/_stream_writable.js": 512 }], 518: [function(e, t2, r) {
        t2.exports = e("./readable").Transform;
      }, { "./readable": 517 }], 519: [function(e, t2, r) {
        t2.exports = e("./lib/_stream_writable.js");
      }, { "./lib/_stream_writable.js": 512 }], 520: [function(e, t2, r) {
        arguments[4][217][0].apply(r, arguments);
      }, { buffer: 220, dup: 217 }], 521: [function(e, t2, r) {
        arguments[4][218][0].apply(r, arguments);
      }, { dup: 218, "safe-buffer": 520 }], 522: [function(e, t2, r) {
        arguments[4][218][0].apply(r, arguments);
      }, { dup: 218, "safe-buffer": 494 }], 523: [function(e, t2, r) {
        (function(t3, n) {
          (function() {
            var i = e("process/browser.js").nextTick, s = Function.prototype.apply, o = Array.prototype.slice, a = {}, l = 0;
            function c(e2, t4) {
              this._id = e2, this._clearFn = t4;
            }
            r.setTimeout = function() {
              return new c(s.call(setTimeout, window, arguments), clearTimeout);
            }, r.setInterval = function() {
              return new c(s.call(setInterval, window, arguments), clearInterval);
            }, r.clearTimeout = r.clearInterval = function(e2) {
              e2.close();
            }, c.prototype.unref = c.prototype.ref = function() {
            }, c.prototype.close = function() {
              this._clearFn.call(window, this._id);
            }, r.enroll = function(e2, t4) {
              clearTimeout(e2._idleTimeoutId), e2._idleTimeout = t4;
            }, r.unenroll = function(e2) {
              clearTimeout(e2._idleTimeoutId), e2._idleTimeout = -1;
            }, r._unrefActive = r.active = function(e2) {
              clearTimeout(e2._idleTimeoutId);
              var t4 = e2._idleTimeout;
              t4 >= 0 && (e2._idleTimeoutId = setTimeout((function() {
                e2._onTimeout && e2._onTimeout();
              }), t4));
            }, r.setImmediate = "function" == typeof t3 ? t3 : function(e2) {
              var t4 = l++, n2 = !(arguments.length < 2) && o.call(arguments, 1);
              return a[t4] = true, i((function() {
                a[t4] && (n2 ? e2.apply(null, n2) : e2.call(null), r.clearImmediate(t4));
              })), t4;
            }, r.clearImmediate = "function" == typeof n ? n : function(e2) {
              delete a[e2];
            };
          }).call(this);
        }).call(this, e("timers").setImmediate, e("timers").clearImmediate);
      }, { "process/browser.js": 467, timers: 523 }], 524: [function(e, t2, r) {
        (function(e2) {
          (function() {
            function r2(t3) {
              try {
                if (!e2.localStorage) return false;
              } catch (e3) {
                return false;
              }
              var r3 = e2.localStorage[t3];
              return null != r3 && "true" === String(r3).toLowerCase();
            }
            t2.exports = function(e3, t3) {
              if (r2("noDeprecation")) return e3;
              var n = false;
              return function() {
                if (!n) {
                  if (r2("throwDeprecation")) throw new Error(t3);
                  r2("traceDeprecation") ? console.trace(t3) : console.warn(t3), n = true;
                }
                return e3.apply(this, arguments);
              };
            };
          }).call(this);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 525: [function(e, t2, r) {
        "function" == typeof Object.create ? t2.exports = function(e2, t3) {
          e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
        } : t2.exports = function(e2, t3) {
          e2.super_ = t3;
          var r2 = function() {
          };
          r2.prototype = t3.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
        };
      }, {}], 526: [function(e, t2, r) {
        t2.exports = function(e2) {
          return e2 && "object" == typeof e2 && "function" == typeof e2.copy && "function" == typeof e2.fill && "function" == typeof e2.readUInt8;
        };
      }, {}], 527: [function(e, t2, r) {
        (function(t3, n) {
          (function() {
            var i = /%[sdj%]/g;
            r.format = function(e2) {
              if (!g(e2)) {
                for (var t4 = [], r2 = 0; r2 < arguments.length; r2++) t4.push(a(arguments[r2]));
                return t4.join(" ");
              }
              r2 = 1;
              for (var n2 = arguments, s2 = n2.length, o2 = String(e2).replace(i, (function(e3) {
                if ("%%" === e3) return "%";
                if (r2 >= s2) return e3;
                switch (e3) {
                  case "%s":
                    return String(n2[r2++]);
                  case "%d":
                    return Number(n2[r2++]);
                  case "%j":
                    try {
                      return JSON.stringify(n2[r2++]);
                    } catch (e4) {
                      return "[Circular]";
                    }
                  default:
                    return e3;
                }
              })), l2 = n2[r2]; r2 < s2; l2 = n2[++r2]) m(l2) || !w(l2) ? o2 += " " + l2 : o2 += " " + a(l2);
              return o2;
            }, r.deprecate = function(e2, i2) {
              if (y(n.process)) return function() {
                return r.deprecate(e2, i2).apply(this, arguments);
              };
              if (true === t3.noDeprecation) return e2;
              var s2 = false;
              return function() {
                if (!s2) {
                  if (t3.throwDeprecation) throw new Error(i2);
                  t3.traceDeprecation ? console.trace(i2) : console.error(i2), s2 = true;
                }
                return e2.apply(this, arguments);
              };
            };
            var s, o = {};
            function a(e2, t4) {
              var n2 = { seen: [], stylize: c };
              return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), p(t4) ? n2.showHidden = t4 : t4 && r._extend(n2, t4), y(n2.showHidden) && (n2.showHidden = false), y(n2.depth) && (n2.depth = 2), y(n2.colors) && (n2.colors = false), y(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = l), u(n2, e2, n2.depth);
            }
            function l(e2, t4) {
              var r2 = a.styles[t4];
              return r2 ? "\x1B[" + a.colors[r2][0] + "m" + e2 + "\x1B[" + a.colors[r2][1] + "m" : e2;
            }
            function c(e2, t4) {
              return e2;
            }
            function u(e2, t4, n2) {
              if (e2.customInspect && t4 && k(t4.inspect) && t4.inspect !== r.inspect && (!t4.constructor || t4.constructor.prototype !== t4)) {
                var i2 = t4.inspect(n2, e2);
                return g(i2) || (i2 = u(e2, i2, n2)), i2;
              }
              var s2 = (function(e3, t5) {
                if (y(t5)) return e3.stylize("undefined", "undefined");
                if (g(t5)) {
                  var r2 = "'" + JSON.stringify(t5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return e3.stylize(r2, "string");
                }
                if (b(t5)) return e3.stylize("" + t5, "number");
                if (p(t5)) return e3.stylize("" + t5, "boolean");
                if (m(t5)) return e3.stylize("null", "null");
              })(e2, t4);
              if (s2) return s2;
              var o2 = Object.keys(t4), a2 = (function(e3) {
                var t5 = {};
                return e3.forEach((function(e4, r2) {
                  t5[e4] = true;
                })), t5;
              })(o2);
              if (e2.showHidden && (o2 = Object.getOwnPropertyNames(t4)), x(t4) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0)) return h(t4);
              if (0 === o2.length) {
                if (k(t4)) {
                  var l2 = t4.name ? ": " + t4.name : "";
                  return e2.stylize("[Function" + l2 + "]", "special");
                }
                if (v(t4)) return e2.stylize(RegExp.prototype.toString.call(t4), "regexp");
                if (_(t4)) return e2.stylize(Date.prototype.toString.call(t4), "date");
                if (x(t4)) return h(t4);
              }
              var c2, w2 = "", S2 = false, M2 = ["{", "}"];
              (d(t4) && (S2 = true, M2 = ["[", "]"]), k(t4)) && (w2 = " [Function" + (t4.name ? ": " + t4.name : "") + "]");
              return v(t4) && (w2 = " " + RegExp.prototype.toString.call(t4)), _(t4) && (w2 = " " + Date.prototype.toUTCString.call(t4)), x(t4) && (w2 = " " + h(t4)), 0 !== o2.length || S2 && 0 != t4.length ? n2 < 0 ? v(t4) ? e2.stylize(RegExp.prototype.toString.call(t4), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t4), c2 = S2 ? (function(e3, t5, r2, n3, i3) {
                for (var s3 = [], o3 = 0, a3 = t5.length; o3 < a3; ++o3) E(t5, String(o3)) ? s3.push(f(e3, t5, r2, n3, String(o3), true)) : s3.push("");
                return i3.forEach((function(i4) {
                  i4.match(/^\d+$/) || s3.push(f(e3, t5, r2, n3, i4, true));
                })), s3;
              })(e2, t4, n2, a2, o2) : o2.map((function(r2) {
                return f(e2, t4, n2, a2, r2, S2);
              })), e2.seen.pop(), (function(e3, t5, r2) {
                if (e3.reduce((function(e4, t6) {
                  return t6.indexOf("\n") >= 0 && 0, e4 + t6.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }), 0) > 60) return r2[0] + ("" === t5 ? "" : t5 + "\n ") + " " + e3.join(",\n  ") + " " + r2[1];
                return r2[0] + t5 + " " + e3.join(", ") + " " + r2[1];
              })(c2, w2, M2)) : M2[0] + w2 + M2[1];
            }
            function h(e2) {
              return "[" + Error.prototype.toString.call(e2) + "]";
            }
            function f(e2, t4, r2, n2, i2, s2) {
              var o2, a2, l2;
              if ((l2 = Object.getOwnPropertyDescriptor(t4, i2) || { value: t4[i2] }).get ? a2 = l2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : l2.set && (a2 = e2.stylize("[Setter]", "special")), E(n2, i2) || (o2 = "[" + i2 + "]"), a2 || (e2.seen.indexOf(l2.value) < 0 ? (a2 = m(r2) ? u(e2, l2.value, null) : u(e2, l2.value, r2 - 1)).indexOf("\n") > -1 && (a2 = s2 ? a2.split("\n").map((function(e3) {
                return "  " + e3;
              })).join("\n").substr(2) : "\n" + a2.split("\n").map((function(e3) {
                return "   " + e3;
              })).join("\n")) : a2 = e2.stylize("[Circular]", "special")), y(o2)) {
                if (s2 && i2.match(/^\d+$/)) return a2;
                (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e2.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e2.stylize(o2, "string"));
              }
              return o2 + ": " + a2;
            }
            function d(e2) {
              return Array.isArray(e2);
            }
            function p(e2) {
              return "boolean" == typeof e2;
            }
            function m(e2) {
              return null === e2;
            }
            function b(e2) {
              return "number" == typeof e2;
            }
            function g(e2) {
              return "string" == typeof e2;
            }
            function y(e2) {
              return void 0 === e2;
            }
            function v(e2) {
              return w(e2) && "[object RegExp]" === S(e2);
            }
            function w(e2) {
              return "object" == typeof e2 && null !== e2;
            }
            function _(e2) {
              return w(e2) && "[object Date]" === S(e2);
            }
            function x(e2) {
              return w(e2) && ("[object Error]" === S(e2) || e2 instanceof Error);
            }
            function k(e2) {
              return "function" == typeof e2;
            }
            function S(e2) {
              return Object.prototype.toString.call(e2);
            }
            function M(e2) {
              return e2 < 10 ? "0" + e2.toString(10) : e2.toString(10);
            }
            r.debuglog = function(e2) {
              if (y(s) && (s = t3.env.NODE_DEBUG || ""), e2 = e2.toUpperCase(), !o[e2]) if (new RegExp("\\b" + e2 + "\\b", "i").test(s)) {
                var n2 = t3.pid;
                o[e2] = function() {
                  var t4 = r.format.apply(r, arguments);
                  console.error("%s %d: %s", e2, n2, t4);
                };
              } else o[e2] = function() {
              };
              return o[e2];
            }, r.inspect = a, a.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, a.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, r.isArray = d, r.isBoolean = p, r.isNull = m, r.isNullOrUndefined = function(e2) {
              return null == e2;
            }, r.isNumber = b, r.isString = g, r.isSymbol = function(e2) {
              return "symbol" == typeof e2;
            }, r.isUndefined = y, r.isRegExp = v, r.isObject = w, r.isDate = _, r.isError = x, r.isFunction = k, r.isPrimitive = function(e2) {
              return null === e2 || "boolean" == typeof e2 || "number" == typeof e2 || "string" == typeof e2 || "symbol" == typeof e2 || void 0 === e2;
            }, r.isBuffer = e("./support/isBuffer");
            var C2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            function T() {
              var e2 = /* @__PURE__ */ new Date(), t4 = [M(e2.getHours()), M(e2.getMinutes()), M(e2.getSeconds())].join(":");
              return [e2.getDate(), C2[e2.getMonth()], t4].join(" ");
            }
            function E(e2, t4) {
              return Object.prototype.hasOwnProperty.call(e2, t4);
            }
            r.log = function() {
              console.log("%s - %s", T(), r.format.apply(r, arguments));
            }, r.inherits = e("inherits"), r._extend = function(e2, t4) {
              if (!t4 || !w(t4)) return e2;
              for (var r2 = Object.keys(t4), n2 = r2.length; n2--; ) e2[r2[n2]] = t4[r2[n2]];
              return e2;
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, { "./support/isBuffer": 526, _process: 467, inherits: 525 }], 528: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), Object.defineProperty(r, "v1", { enumerable: true, get: function() {
          return n.default;
        } }), Object.defineProperty(r, "v3", { enumerable: true, get: function() {
          return i.default;
        } }), Object.defineProperty(r, "v4", { enumerable: true, get: function() {
          return s.default;
        } }), Object.defineProperty(r, "v5", { enumerable: true, get: function() {
          return o.default;
        } }), Object.defineProperty(r, "NIL", { enumerable: true, get: function() {
          return a.default;
        } }), Object.defineProperty(r, "version", { enumerable: true, get: function() {
          return l.default;
        } }), Object.defineProperty(r, "validate", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(r, "stringify", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(r, "parse", { enumerable: true, get: function() {
          return h.default;
        } });
        var n = f(e("./v1.js")), i = f(e("./v3.js")), s = f(e("./v4.js")), o = f(e("./v5.js")), a = f(e("./nil.js")), l = f(e("./version.js")), c = f(e("./validate.js")), u = f(e("./stringify.js")), h = f(e("./parse.js"));
        function f(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
      }, { "./nil.js": 530, "./parse.js": 531, "./stringify.js": 535, "./v1.js": 536, "./v3.js": 537, "./v4.js": 539, "./v5.js": 540, "./validate.js": 541, "./version.js": 542 }], 529: [function(e, t2, r) {
        function n(e2) {
          return 14 + (e2 + 64 >>> 9 << 4) + 1;
        }
        function i(e2, t3) {
          const r2 = (65535 & e2) + (65535 & t3);
          return (e2 >> 16) + (t3 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
        }
        function s(e2, t3, r2, n2, s2, o2) {
          return i((a2 = i(i(t3, e2), i(n2, o2))) << (l2 = s2) | a2 >>> 32 - l2, r2);
          var a2, l2;
        }
        function o(e2, t3, r2, n2, i2, o2, a2) {
          return s(t3 & r2 | ~t3 & n2, e2, t3, i2, o2, a2);
        }
        function a(e2, t3, r2, n2, i2, o2, a2) {
          return s(t3 & n2 | r2 & ~n2, e2, t3, i2, o2, a2);
        }
        function l(e2, t3, r2, n2, i2, o2, a2) {
          return s(t3 ^ r2 ^ n2, e2, t3, i2, o2, a2);
        }
        function c(e2, t3, r2, n2, i2, o2, a2) {
          return s(r2 ^ (t3 | ~n2), e2, t3, i2, o2, a2);
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var u = function(e2) {
          if ("string" == typeof e2) {
            const t3 = unescape(encodeURIComponent(e2));
            e2 = new Uint8Array(t3.length);
            for (let r2 = 0; r2 < t3.length; ++r2) e2[r2] = t3.charCodeAt(r2);
          }
          return (function(e3) {
            const t3 = [], r2 = 32 * e3.length;
            for (let n2 = 0; n2 < r2; n2 += 8) {
              const r3 = e3[n2 >> 5] >>> n2 % 32 & 255, i2 = parseInt("0123456789abcdef".charAt(r3 >>> 4 & 15) + "0123456789abcdef".charAt(15 & r3), 16);
              t3.push(i2);
            }
            return t3;
          })((function(e3, t3) {
            e3[t3 >> 5] |= 128 << t3 % 32, e3[n(t3) - 1] = t3;
            let r2 = 1732584193, s2 = -271733879, u2 = -1732584194, h = 271733878;
            for (let t4 = 0; t4 < e3.length; t4 += 16) {
              const n2 = r2, f = s2, d = u2, p = h;
              r2 = o(r2, s2, u2, h, e3[t4], 7, -680876936), h = o(h, r2, s2, u2, e3[t4 + 1], 12, -389564586), u2 = o(u2, h, r2, s2, e3[t4 + 2], 17, 606105819), s2 = o(s2, u2, h, r2, e3[t4 + 3], 22, -1044525330), r2 = o(r2, s2, u2, h, e3[t4 + 4], 7, -176418897), h = o(h, r2, s2, u2, e3[t4 + 5], 12, 1200080426), u2 = o(u2, h, r2, s2, e3[t4 + 6], 17, -1473231341), s2 = o(s2, u2, h, r2, e3[t4 + 7], 22, -45705983), r2 = o(r2, s2, u2, h, e3[t4 + 8], 7, 1770035416), h = o(h, r2, s2, u2, e3[t4 + 9], 12, -1958414417), u2 = o(u2, h, r2, s2, e3[t4 + 10], 17, -42063), s2 = o(s2, u2, h, r2, e3[t4 + 11], 22, -1990404162), r2 = o(r2, s2, u2, h, e3[t4 + 12], 7, 1804603682), h = o(h, r2, s2, u2, e3[t4 + 13], 12, -40341101), u2 = o(u2, h, r2, s2, e3[t4 + 14], 17, -1502002290), s2 = o(s2, u2, h, r2, e3[t4 + 15], 22, 1236535329), r2 = a(r2, s2, u2, h, e3[t4 + 1], 5, -165796510), h = a(h, r2, s2, u2, e3[t4 + 6], 9, -1069501632), u2 = a(u2, h, r2, s2, e3[t4 + 11], 14, 643717713), s2 = a(s2, u2, h, r2, e3[t4], 20, -373897302), r2 = a(r2, s2, u2, h, e3[t4 + 5], 5, -701558691), h = a(h, r2, s2, u2, e3[t4 + 10], 9, 38016083), u2 = a(u2, h, r2, s2, e3[t4 + 15], 14, -660478335), s2 = a(s2, u2, h, r2, e3[t4 + 4], 20, -405537848), r2 = a(r2, s2, u2, h, e3[t4 + 9], 5, 568446438), h = a(h, r2, s2, u2, e3[t4 + 14], 9, -1019803690), u2 = a(u2, h, r2, s2, e3[t4 + 3], 14, -187363961), s2 = a(s2, u2, h, r2, e3[t4 + 8], 20, 1163531501), r2 = a(r2, s2, u2, h, e3[t4 + 13], 5, -1444681467), h = a(h, r2, s2, u2, e3[t4 + 2], 9, -51403784), u2 = a(u2, h, r2, s2, e3[t4 + 7], 14, 1735328473), s2 = a(s2, u2, h, r2, e3[t4 + 12], 20, -1926607734), r2 = l(r2, s2, u2, h, e3[t4 + 5], 4, -378558), h = l(h, r2, s2, u2, e3[t4 + 8], 11, -2022574463), u2 = l(u2, h, r2, s2, e3[t4 + 11], 16, 1839030562), s2 = l(s2, u2, h, r2, e3[t4 + 14], 23, -35309556), r2 = l(r2, s2, u2, h, e3[t4 + 1], 4, -1530992060), h = l(h, r2, s2, u2, e3[t4 + 4], 11, 1272893353), u2 = l(u2, h, r2, s2, e3[t4 + 7], 16, -155497632), s2 = l(s2, u2, h, r2, e3[t4 + 10], 23, -1094730640), r2 = l(r2, s2, u2, h, e3[t4 + 13], 4, 681279174), h = l(h, r2, s2, u2, e3[t4], 11, -358537222), u2 = l(u2, h, r2, s2, e3[t4 + 3], 16, -722521979), s2 = l(s2, u2, h, r2, e3[t4 + 6], 23, 76029189), r2 = l(r2, s2, u2, h, e3[t4 + 9], 4, -640364487), h = l(h, r2, s2, u2, e3[t4 + 12], 11, -421815835), u2 = l(u2, h, r2, s2, e3[t4 + 15], 16, 530742520), s2 = l(s2, u2, h, r2, e3[t4 + 2], 23, -995338651), r2 = c(r2, s2, u2, h, e3[t4], 6, -198630844), h = c(h, r2, s2, u2, e3[t4 + 7], 10, 1126891415), u2 = c(u2, h, r2, s2, e3[t4 + 14], 15, -1416354905), s2 = c(s2, u2, h, r2, e3[t4 + 5], 21, -57434055), r2 = c(r2, s2, u2, h, e3[t4 + 12], 6, 1700485571), h = c(h, r2, s2, u2, e3[t4 + 3], 10, -1894986606), u2 = c(u2, h, r2, s2, e3[t4 + 10], 15, -1051523), s2 = c(s2, u2, h, r2, e3[t4 + 1], 21, -2054922799), r2 = c(r2, s2, u2, h, e3[t4 + 8], 6, 1873313359), h = c(h, r2, s2, u2, e3[t4 + 15], 10, -30611744), u2 = c(u2, h, r2, s2, e3[t4 + 6], 15, -1560198380), s2 = c(s2, u2, h, r2, e3[t4 + 13], 21, 1309151649), r2 = c(r2, s2, u2, h, e3[t4 + 4], 6, -145523070), h = c(h, r2, s2, u2, e3[t4 + 11], 10, -1120210379), u2 = c(u2, h, r2, s2, e3[t4 + 2], 15, 718787259), s2 = c(s2, u2, h, r2, e3[t4 + 9], 21, -343485551), r2 = i(r2, n2), s2 = i(s2, f), u2 = i(u2, d), h = i(h, p);
            }
            return [r2, s2, u2, h];
          })((function(e3) {
            if (0 === e3.length) return [];
            const t3 = 8 * e3.length, r2 = new Uint32Array(n(t3));
            for (let n2 = 0; n2 < t3; n2 += 8) r2[n2 >> 5] |= (255 & e3[n2 / 8]) << n2 % 32;
            return r2;
          })(e2), 8 * e2.length));
        };
        r.default = u;
      }, {}], 530: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        r.default = "00000000-0000-0000-0000-000000000000";
      }, {}], 531: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n, i = (n = e("./validate.js")) && n.__esModule ? n : { default: n };
        var s = function(e2) {
          if (!(0, i.default)(e2)) throw TypeError("Invalid UUID");
          let t3;
          const r2 = new Uint8Array(16);
          return r2[0] = (t3 = parseInt(e2.slice(0, 8), 16)) >>> 24, r2[1] = t3 >>> 16 & 255, r2[2] = t3 >>> 8 & 255, r2[3] = 255 & t3, r2[4] = (t3 = parseInt(e2.slice(9, 13), 16)) >>> 8, r2[5] = 255 & t3, r2[6] = (t3 = parseInt(e2.slice(14, 18), 16)) >>> 8, r2[7] = 255 & t3, r2[8] = (t3 = parseInt(e2.slice(19, 23), 16)) >>> 8, r2[9] = 255 & t3, r2[10] = (t3 = parseInt(e2.slice(24, 36), 16)) / 1099511627776 & 255, r2[11] = t3 / 4294967296 & 255, r2[12] = t3 >>> 24 & 255, r2[13] = t3 >>> 16 & 255, r2[14] = t3 >>> 8 & 255, r2[15] = 255 & t3, r2;
        };
        r.default = s;
      }, { "./validate.js": 541 }], 532: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        r.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      }, {}], 533: [function(e, t2, r) {
        let n;
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function() {
          if (!n && (n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto), !n)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          return n(i);
        };
        const i = new Uint8Array(16);
      }, {}], 534: [function(e, t2, r) {
        function n(e2, t3, r2, n2) {
          switch (e2) {
            case 0:
              return t3 & r2 ^ ~t3 & n2;
            case 1:
              return t3 ^ r2 ^ n2;
            case 2:
              return t3 & r2 ^ t3 & n2 ^ r2 & n2;
            case 3:
              return t3 ^ r2 ^ n2;
          }
        }
        function i(e2, t3) {
          return e2 << t3 | e2 >>> 32 - t3;
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var s = function(e2) {
          const t3 = [1518500249, 1859775393, 2400959708, 3395469782], r2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
          if ("string" == typeof e2) {
            const t4 = unescape(encodeURIComponent(e2));
            e2 = [];
            for (let r3 = 0; r3 < t4.length; ++r3) e2.push(t4.charCodeAt(r3));
          } else Array.isArray(e2) || (e2 = Array.prototype.slice.call(e2));
          e2.push(128);
          const s2 = e2.length / 4 + 2, o = Math.ceil(s2 / 16), a = new Array(o);
          for (let t4 = 0; t4 < o; ++t4) {
            const r3 = new Uint32Array(16);
            for (let n2 = 0; n2 < 16; ++n2) r3[n2] = e2[64 * t4 + 4 * n2] << 24 | e2[64 * t4 + 4 * n2 + 1] << 16 | e2[64 * t4 + 4 * n2 + 2] << 8 | e2[64 * t4 + 4 * n2 + 3];
            a[t4] = r3;
          }
          a[o - 1][14] = 8 * (e2.length - 1) / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = 8 * (e2.length - 1) & 4294967295;
          for (let e3 = 0; e3 < o; ++e3) {
            const s3 = new Uint32Array(80);
            for (let t4 = 0; t4 < 16; ++t4) s3[t4] = a[e3][t4];
            for (let e4 = 16; e4 < 80; ++e4) s3[e4] = i(s3[e4 - 3] ^ s3[e4 - 8] ^ s3[e4 - 14] ^ s3[e4 - 16], 1);
            let o2 = r2[0], l = r2[1], c = r2[2], u = r2[3], h = r2[4];
            for (let e4 = 0; e4 < 80; ++e4) {
              const r3 = Math.floor(e4 / 20), a2 = i(o2, 5) + n(r3, l, c, u) + h + t3[r3] + s3[e4] >>> 0;
              h = u, u = c, c = i(l, 30) >>> 0, l = o2, o2 = a2;
            }
            r2[0] = r2[0] + o2 >>> 0, r2[1] = r2[1] + l >>> 0, r2[2] = r2[2] + c >>> 0, r2[3] = r2[3] + u >>> 0, r2[4] = r2[4] + h >>> 0;
          }
          return [r2[0] >> 24 & 255, r2[0] >> 16 & 255, r2[0] >> 8 & 255, 255 & r2[0], r2[1] >> 24 & 255, r2[1] >> 16 & 255, r2[1] >> 8 & 255, 255 & r2[1], r2[2] >> 24 & 255, r2[2] >> 16 & 255, r2[2] >> 8 & 255, 255 & r2[2], r2[3] >> 24 & 255, r2[3] >> 16 & 255, r2[3] >> 8 & 255, 255 & r2[3], r2[4] >> 24 & 255, r2[4] >> 16 & 255, r2[4] >> 8 & 255, 255 & r2[4]];
        };
        r.default = s;
      }, {}], 535: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n, i = (n = e("./validate.js")) && n.__esModule ? n : { default: n };
        const s = [];
        for (let e2 = 0; e2 < 256; ++e2) s.push((e2 + 256).toString(16).substr(1));
        var o = function(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const r2 = (s[e2[t3 + 0]] + s[e2[t3 + 1]] + s[e2[t3 + 2]] + s[e2[t3 + 3]] + "-" + s[e2[t3 + 4]] + s[e2[t3 + 5]] + "-" + s[e2[t3 + 6]] + s[e2[t3 + 7]] + "-" + s[e2[t3 + 8]] + s[e2[t3 + 9]] + "-" + s[e2[t3 + 10]] + s[e2[t3 + 11]] + s[e2[t3 + 12]] + s[e2[t3 + 13]] + s[e2[t3 + 14]] + s[e2[t3 + 15]]).toLowerCase();
          if (!(0, i.default)(r2)) throw TypeError("Stringified UUID is invalid");
          return r2;
        };
        r.default = o;
      }, { "./validate.js": 541 }], 536: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n = s(e("./rng.js")), i = s(e("./stringify.js"));
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        let o, a, l = 0, c = 0;
        var u = function(e2, t3, r2) {
          let s2 = t3 && r2 || 0;
          const u2 = t3 || new Array(16);
          let h = (e2 = e2 || {}).node || o, f = void 0 !== e2.clockseq ? e2.clockseq : a;
          if (null == h || null == f) {
            const t4 = e2.random || (e2.rng || n.default)();
            null == h && (h = o = [1 | t4[0], t4[1], t4[2], t4[3], t4[4], t4[5]]), null == f && (f = a = 16383 & (t4[6] << 8 | t4[7]));
          }
          let d = void 0 !== e2.msecs ? e2.msecs : Date.now(), p = void 0 !== e2.nsecs ? e2.nsecs : c + 1;
          const m = d - l + (p - c) / 1e4;
          if (m < 0 && void 0 === e2.clockseq && (f = f + 1 & 16383), (m < 0 || d > l) && void 0 === e2.nsecs && (p = 0), p >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
          l = d, c = p, a = f, d += 122192928e5;
          const b = (1e4 * (268435455 & d) + p) % 4294967296;
          u2[s2++] = b >>> 24 & 255, u2[s2++] = b >>> 16 & 255, u2[s2++] = b >>> 8 & 255, u2[s2++] = 255 & b;
          const g = d / 4294967296 * 1e4 & 268435455;
          u2[s2++] = g >>> 8 & 255, u2[s2++] = 255 & g, u2[s2++] = g >>> 24 & 15 | 16, u2[s2++] = g >>> 16 & 255, u2[s2++] = f >>> 8 | 128, u2[s2++] = 255 & f;
          for (let e3 = 0; e3 < 6; ++e3) u2[s2 + e3] = h[e3];
          return t3 || (0, i.default)(u2);
        };
        r.default = u;
      }, { "./rng.js": 533, "./stringify.js": 535 }], 537: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n = s(e("./v35.js")), i = s(e("./md5.js"));
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = (0, n.default)("v3", 48, i.default);
        r.default = o;
      }, { "./md5.js": 529, "./v35.js": 538 }], 538: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = function(e2, t3, r2) {
          function s2(e3, s3, o2, a2) {
            if ("string" == typeof e3 && (e3 = (function(e4) {
              e4 = unescape(encodeURIComponent(e4));
              const t4 = [];
              for (let r3 = 0; r3 < e4.length; ++r3) t4.push(e4.charCodeAt(r3));
              return t4;
            })(e3)), "string" == typeof s3 && (s3 = (0, i.default)(s3)), 16 !== s3.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            let l = new Uint8Array(16 + e3.length);
            if (l.set(s3), l.set(e3, s3.length), l = r2(l), l[6] = 15 & l[6] | t3, l[8] = 63 & l[8] | 128, o2) {
              a2 = a2 || 0;
              for (let e4 = 0; e4 < 16; ++e4) o2[a2 + e4] = l[e4];
              return o2;
            }
            return (0, n.default)(l);
          }
          try {
            s2.name = e2;
          } catch (e3) {
          }
          return s2.DNS = o, s2.URL = a, s2;
        }, r.URL = r.DNS = void 0;
        var n = s(e("./stringify.js")), i = s(e("./parse.js"));
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        const o = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
        r.DNS = o;
        const a = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
        r.URL = a;
      }, { "./parse.js": 531, "./stringify.js": 535 }], 539: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n = s(e("./rng.js")), i = s(e("./stringify.js"));
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = function(e2, t3, r2) {
          const s2 = (e2 = e2 || {}).random || (e2.rng || n.default)();
          if (s2[6] = 15 & s2[6] | 64, s2[8] = 63 & s2[8] | 128, t3) {
            r2 = r2 || 0;
            for (let e3 = 0; e3 < 16; ++e3) t3[r2 + e3] = s2[e3];
            return t3;
          }
          return (0, i.default)(s2);
        };
        r.default = o;
      }, { "./rng.js": 533, "./stringify.js": 535 }], 540: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n = s(e("./v35.js")), i = s(e("./sha1.js"));
        function s(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = (0, n.default)("v5", 80, i.default);
        r.default = o;
      }, { "./sha1.js": 534, "./v35.js": 538 }], 541: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n, i = (n = e("./regex.js")) && n.__esModule ? n : { default: n };
        var s = function(e2) {
          return "string" == typeof e2 && i.default.test(e2);
        };
        r.default = s;
      }, { "./regex.js": 532 }], 542: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n, i = (n = e("./validate.js")) && n.__esModule ? n : { default: n };
        var s = function(e2) {
          if (!(0, i.default)(e2)) throw TypeError("Invalid UUID");
          return parseInt(e2.substr(14, 1), 16);
        };
        r.default = s;
      }, { "./validate.js": 541 }], 543: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.CHAR = "	\n\r -퟿-�𐀀-􏿿", r.S = " 	\r\n", r.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿", r.NAME_CHAR = "-" + r.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀", r.CHAR_RE = new RegExp("^[" + r.CHAR + "]$", "u"), r.S_RE = new RegExp("^[" + r.S + "]+$", "u"), r.NAME_START_CHAR_RE = new RegExp("^[" + r.NAME_START_CHAR + "]$", "u"), r.NAME_CHAR_RE = new RegExp("^[" + r.NAME_CHAR + "]$", "u"), r.NAME_RE = new RegExp("^[" + r.NAME_START_CHAR + "][" + r.NAME_CHAR + "]*$", "u"), r.NMTOKEN_RE = new RegExp("^[" + r.NAME_CHAR + "]+$", "u");
        function n(e2) {
          return e2 >= 65 && e2 <= 90 || e2 >= 97 && e2 <= 122 || 58 === e2 || 95 === e2 || 8204 === e2 || 8205 === e2 || e2 >= 192 && e2 <= 214 || e2 >= 216 && e2 <= 246 || e2 >= 248 && e2 <= 767 || e2 >= 880 && e2 <= 893 || e2 >= 895 && e2 <= 8191 || e2 >= 8304 && e2 <= 8591 || e2 >= 11264 && e2 <= 12271 || e2 >= 12289 && e2 <= 55295 || e2 >= 63744 && e2 <= 64975 || e2 >= 65008 && e2 <= 65533 || e2 >= 65536 && e2 <= 983039;
        }
        r.S_LIST = [32, 10, 13, 9], r.isChar = function(e2) {
          return e2 >= 32 && e2 <= 55295 || 10 === e2 || 13 === e2 || 9 === e2 || e2 >= 57344 && e2 <= 65533 || e2 >= 65536 && e2 <= 1114111;
        }, r.isS = function(e2) {
          return 32 === e2 || 10 === e2 || 13 === e2 || 9 === e2;
        }, r.isNameStartChar = n, r.isNameChar = function(e2) {
          return n(e2) || e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2 || 183 === e2 || e2 >= 768 && e2 <= 879 || e2 >= 8255 && e2 <= 8256;
        };
      }, {}], 544: [function(e, t2, r) {
        Object.defineProperty(r, "__esModule", { value: true }), r.CHAR = "-퟿-�𐀀-􏿿", r.RESTRICTED_CHAR = "-\b\v\f---", r.S = " 	\r\n", r.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿", r.NAME_CHAR = "-" + r.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀", r.CHAR_RE = new RegExp("^[" + r.CHAR + "]$", "u"), r.RESTRICTED_CHAR_RE = new RegExp("^[" + r.RESTRICTED_CHAR + "]$", "u"), r.S_RE = new RegExp("^[" + r.S + "]+$", "u"), r.NAME_START_CHAR_RE = new RegExp("^[" + r.NAME_START_CHAR + "]$", "u"), r.NAME_CHAR_RE = new RegExp("^[" + r.NAME_CHAR + "]$", "u"), r.NAME_RE = new RegExp("^[" + r.NAME_START_CHAR + "][" + r.NAME_CHAR + "]*$", "u"), r.NMTOKEN_RE = new RegExp("^[" + r.NAME_CHAR + "]+$", "u");
        function n(e2) {
          return e2 >= 65 && e2 <= 90 || e2 >= 97 && e2 <= 122 || 58 === e2 || 95 === e2 || 8204 === e2 || 8205 === e2 || e2 >= 192 && e2 <= 214 || e2 >= 216 && e2 <= 246 || e2 >= 248 && e2 <= 767 || e2 >= 880 && e2 <= 893 || e2 >= 895 && e2 <= 8191 || e2 >= 8304 && e2 <= 8591 || e2 >= 11264 && e2 <= 12271 || e2 >= 12289 && e2 <= 55295 || e2 >= 63744 && e2 <= 64975 || e2 >= 65008 && e2 <= 65533 || e2 >= 65536 && e2 <= 983039;
        }
        r.S_LIST = [32, 10, 13, 9], r.isChar = function(e2) {
          return e2 >= 1 && e2 <= 55295 || e2 >= 57344 && e2 <= 65533 || e2 >= 65536 && e2 <= 1114111;
        }, r.isRestrictedChar = function(e2) {
          return e2 >= 1 && e2 <= 8 || 11 === e2 || 12 === e2 || e2 >= 14 && e2 <= 31 || e2 >= 127 && e2 <= 132 || e2 >= 134 && e2 <= 159;
        }, r.isCharAndNotRestricted = function(e2) {
          return 9 === e2 || 10 === e2 || 13 === e2 || e2 > 31 && e2 < 127 || 133 === e2 || e2 > 159 && e2 <= 55295 || e2 >= 57344 && e2 <= 65533 || e2 >= 65536 && e2 <= 1114111;
        }, r.isS = function(e2) {
          return 32 === e2 || 10 === e2 || 13 === e2 || 9 === e2;
        }, r.isNameStartChar = n, r.isNameChar = function(e2) {
          return n(e2) || e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2 || 183 === e2 || e2 >= 768 && e2 <= 879 || e2 >= 8255 && e2 <= 8256;
        };
      }, {}], 545: [function(e, t2, r) {
        function n(e2) {
          return e2 >= 65 && e2 <= 90 || 95 === e2 || e2 >= 97 && e2 <= 122 || e2 >= 192 && e2 <= 214 || e2 >= 216 && e2 <= 246 || e2 >= 248 && e2 <= 767 || e2 >= 880 && e2 <= 893 || e2 >= 895 && e2 <= 8191 || e2 >= 8204 && e2 <= 8205 || e2 >= 8304 && e2 <= 8591 || e2 >= 11264 && e2 <= 12271 || e2 >= 12289 && e2 <= 55295 || e2 >= 63744 && e2 <= 64975 || e2 >= 65008 && e2 <= 65533 || e2 >= 65536 && e2 <= 983039;
        }
        Object.defineProperty(r, "__esModule", { value: true }), r.NC_NAME_START_CHAR = "A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿", r.NC_NAME_CHAR = "-" + r.NC_NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀", r.NC_NAME_START_CHAR_RE = new RegExp("^[" + r.NC_NAME_START_CHAR + "]$", "u"), r.NC_NAME_CHAR_RE = new RegExp("^[" + r.NC_NAME_CHAR + "]$", "u"), r.NC_NAME_RE = new RegExp("^[" + r.NC_NAME_START_CHAR + "][" + r.NC_NAME_CHAR + "]*$", "u"), r.isNCNameStartChar = n, r.isNCNameChar = function(e2) {
          return n(e2) || 45 === e2 || 46 === e2 || e2 >= 48 && e2 <= 57 || 183 === e2 || e2 >= 768 && e2 <= 879 || e2 >= 8255 && e2 <= 8256;
        };
      }, {}] }, {}, [15])(15);
    }));
  })(exceljs_min);
  return exceljs_min.exports;
}
requireExceljs_min();
function exportDataToJSON(data, filename = "export.json") {
  if (data.length === 0) {
    console.warn("没有数据可导出");
    return;
  }
  const jsonContent = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonContent], {
    type: "application/json;charset=utf-8;"
  });
  downloadFile(blob, filename);
}
function downloadFile(blob, filename) {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  link.style.display = "none";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function formatFileName(baseName, extension) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").slice(0, 19);
  return `${baseName}_${timestamp}.${extension}`;
}
const _hoisted_1$7 = { class: "sql-executor" };
const _hoisted_2$7 = { class: "sql-toolbar" };
const _hoisted_3$7 = { class: "toolbar-left" };
const _hoisted_4$7 = ["disabled"];
const _hoisted_5$7 = { class: "sql-editor" };
const _hoisted_6$7 = { class: "sql-result" };
const _hoisted_7$7 = { class: "result-content" };
const _hoisted_8$7 = { class: "result-header" };
const _hoisted_9$7 = { class: "result-title" };
const _hoisted_10$7 = {
  key: 0,
  class: "sql-loading"
};
const _hoisted_11$7 = {
  key: 0,
  class: "bi bi-check-circle-fill text-success"
};
const _hoisted_12$7 = {
  key: 1,
  class: "bi bi-x-circle-fill text-danger"
};
const _hoisted_13$7 = {
  key: 0,
  class: "result-actions"
};
const _hoisted_14$7 = {
  key: 0,
  class: "sql-loading-state"
};
const _hoisted_15$7 = { class: "json-result" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "sql-executor",
  props: {
    connection: {},
    database: {},
    height: {}
  },
  setup(__props) {
    const props = __props;
    const databaseService2 = new DatabaseService();
    const sqlQuery = ref("");
    const loading = ref(false);
    const sqlResult = ref(null);
    const containerRef = ref(null);
    const editorRef = ref(null);
    const resultEditorRef = ref(null);
    const editor = ref(null);
    const resultEditor = ref(null);
    const isResizing = ref(false);
    const height = ref(props.height || 0);
    const editorHeight = ref(0);
    computed(() => height.value - editorHeight.value - 8);
    function startResize(event) {
      isResizing.value = true;
      const startY = event.clientY;
      const container = containerRef.value;
      if (!container) return;
      const containerHeight = container.clientHeight;
      const startEditorHeight = container.querySelector(".sql-editor")?.clientHeight || 0;
      function onMouseMove(e) {
        if (!isResizing.value || !container) return;
        const deltaY = e.clientY - startY;
        const newEditorHeight = startEditorHeight + deltaY;
        const newEditorRatio = newEditorHeight / containerHeight;
        if (newEditorRatio > 0.2 && newEditorRatio < 0.8) {
          const sqlEditor = container.querySelector(".sql-editor");
          if (sqlEditor) {
            sqlEditor.style.flex = `0 0 ${newEditorRatio * 100}%`;
          }
        }
      }
      function onMouseUp() {
        isResizing.value = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    async function executeSql() {
      if (!sqlQuery.value.trim()) {
        modal.warning("请输入SQL语句");
        return;
      }
      if (!props.connection) {
        modal.error("请先选择数据库连接");
        return;
      }
      loading.value = true;
      sqlResult.value = null;
      try {
        const result = await databaseService2.executeQuery(
          props.connection.id,
          sqlQuery.value,
          props.database
        );
        if (typeof result.data === "object" && result.data !== null) {
          const isSuccess = result.ret === 0;
          sqlResult.value = {
            success: isSuccess,
            data: isSuccess ? result.data || [] : null,
            error: !isSuccess ? result.msg : null
          };
        } else {
          sqlResult.value = {
            success: true,
            data: result,
            error: null
          };
        }
      } catch (error) {
        sqlResult.value = {
          success: false,
          error: error.message || "执行SQL时发生未知错误"
        };
      } finally {
        loading.value = false;
        if (!loading.value && sqlResult.value) {
          updateResultEditor();
        }
      }
    }
    function formatSql() {
      let formatted = sqlQuery.value.replace(/\bSELECT\b/gi, "\nSELECT ").replace(/\bFROM\b/gi, "\nFROM ").replace(/\bWHERE\b/gi, "\nWHERE ").replace(/\bJOIN\b/gi, "\nJOIN ").replace(/\bAND\b/gi, "\n  AND ").replace(/\bOR\b/gi, "\n  OR ").replace(/\bGROUP BY\b/gi, "\nGROUP BY ").replace(/\bORDER BY\b/gi, "\nORDER BY ");
      sqlQuery.value = formatted.trim();
      if (editor.value) {
        editor.value.dispatch({
          changes: {
            from: 0,
            to: editor.value.state.doc.length,
            insert: sqlQuery.value
          }
        });
      }
    }
    function clearSql() {
      sqlQuery.value = "";
      sqlResult.value = null;
      if (editor.value) {
        editor.value.dispatch({
          changes: {
            from: 0,
            to: editor.value.state.doc.length,
            insert: ""
          }
        });
      }
    }
    function exportResult(format) {
      if (!sqlResult.value) {
        return;
      }
      const filename = formatFileName("sql_result", format);
      let jsonData;
      if (sqlResult.value.success) {
        jsonData = sqlResult.value.data;
      } else {
        jsonData = {
          error: sqlResult.value.error
        };
      }
      exportDataToJSON(jsonData, filename);
    }
    function initEditor() {
      if (!editorRef.value) return;
      const state = EditorState.create({
        doc: sqlQuery.value,
        extensions: [
          lineNumbers(),
          highlightActiveLineGutter(),
          highlightActiveLine(),
          drawSelection(),
          placeholder("输入SQL查询语句..."),
          sql(),
          oneDark,
          keymap.of(defaultKeymap),
          EditorView.updateListener.of((update) => {
            if (update.docChanged) {
              sqlQuery.value = update.state.doc.toString();
            }
          }),
          EditorView.lineWrapping,
          EditorView.theme({
            "&": {
              height: "100%",
              fontSize: "14px",
              fontFamily: 'Monaco, Menlo, Consolas, "Courier New", monospace'
            },
            ".cm-content": {
              padding: "10px",
              minHeight: "100%"
            },
            ".cm-gutters": {
              backgroundColor: "#282c34",
              color: "#abb2bf",
              border: "none"
            },
            ".cm-activeLineGutter": {
              backgroundColor: "#282c34"
            },
            ".cm-activeLine": {
              backgroundColor: "rgba(255, 255, 255, 0.1)"
            }
          })
        ]
      });
      editor.value = new EditorView({
        state,
        parent: editorRef.value
      });
    }
    function initResultEditor() {
      if (!resultEditorRef.value) return;
      const state = EditorState.create({
        doc: "",
        extensions: [
          lineNumbers(),
          highlightActiveLineGutter(),
          highlightActiveLine(),
          drawSelection(),
          placeholder("执行SQL以查看结果..."),
          json(),
          syntaxHighlighting(defaultHighlightStyle),
          keymap.of(defaultKeymap),
          EditorView.lineWrapping,
          // 设置只读
          EditorState.readOnly.of(true),
          EditorView.theme({
            "&": {
              height: "100%",
              fontSize: "14px",
              fontFamily: 'Monaco, Menlo, Consolas, "Courier New", monospace',
              backgroundColor: "#f8f9fa",
              color: "#212529"
            },
            ".cm-content": {
              padding: "10px",
              minHeight: "100%",
              backgroundColor: "#ffffff",
              color: "#212529",
              border: "1px solid #dee2e6"
            },
            ".cm-gutters": {
              backgroundColor: "#f8f9fa",
              color: "#6c757d",
              border: "1px solid #dee2e6",
              borderRight: "none"
            },
            ".cm-activeLineGutter": {
              backgroundColor: "#e9ecef"
            },
            ".cm-activeLine": {
              backgroundColor: "#e9ecef"
            },
            ".cm-selectionBackground": {
              backgroundColor: "#cce7ff"
            },
            ".cm-line": {
              color: "#212529"
            }
          })
        ]
      });
      resultEditor.value = new EditorView({
        state,
        parent: resultEditorRef.value
      });
    }
    function updateResultEditor() {
      if (!resultEditor.value || !sqlResult.value) return;
      let jsonData;
      if (sqlResult.value.success) {
        jsonData = sqlResult.value.data || sqlResult.value;
      } else {
        jsonData = {
          error: sqlResult.value.error
        };
      }
      try {
        const jsonString = JSON.stringify(jsonData, null, 2);
        resultEditor.value.dispatch({
          changes: {
            from: 0,
            to: resultEditor.value.state.doc.length,
            insert: jsonString
          }
        });
      } catch (error) {
        resultEditor.value.dispatch({
          changes: {
            from: 0,
            to: resultEditor.value.state.doc.length,
            insert: String(jsonData)
          }
        });
      }
    }
    function formatJsonResult() {
      if (!resultEditor.value || !sqlResult.value) return;
      let jsonData;
      if (sqlResult.value.success) {
        jsonData = sqlResult.value.data || sqlResult.value;
      } else {
        jsonData = {
          error: sqlResult.value.error
        };
      }
      try {
        const jsonString = JSON.stringify(jsonData, null, 2);
        resultEditor.value.dispatch({
          changes: {
            from: 0,
            to: resultEditor.value.state.doc.length,
            insert: jsonString
          }
        });
      } catch (error) {
        resultEditor.value.dispatch({
          changes: {
            from: 0,
            to: resultEditor.value.state.doc.length,
            insert: "无法格式化结果: " + String(error)
          }
        });
      }
    }
    onMounted(() => {
      initEditor();
      initResultEditor();
    });
    watch(sqlResult, () => {
      if (sqlResult.value && resultEditor.value) {
        updateResultEditor();
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode("div", _hoisted_2$7, [
          createBaseVNode("div", _hoisted_3$7, [
            createBaseVNode("button", {
              class: "btn btn-primary btn-sm",
              onClick: executeSql,
              disabled: loading.value
            }, [..._cache[1] || (_cache[1] = [
              createBaseVNode("i", { class: "bi bi-play-fill" }, null, -1),
              createTextVNode(" 执行SQL ", -1)
            ])], 8, _hoisted_4$7),
            createBaseVNode("button", {
              class: "btn btn-outline-secondary btn-sm",
              onClick: formatSql
            }, [..._cache[2] || (_cache[2] = [
              createBaseVNode("i", { class: "bi bi-braces" }, null, -1),
              createTextVNode(" 格式化 ", -1)
            ])])
          ]),
          createBaseVNode("div", { class: "toolbar-right" }, [
            createBaseVNode("button", {
              class: "btn btn-outline-primary btn-sm",
              onClick: clearSql
            }, [..._cache[3] || (_cache[3] = [
              createBaseVNode("i", { class: "bi bi-trash" }, null, -1),
              createTextVNode(" 清空 ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", {
          class: "sql-container",
          ref_key: "containerRef",
          ref: containerRef
        }, [
          createBaseVNode("div", _hoisted_5$7, [
            createBaseVNode("div", {
              ref_key: "editorRef",
              ref: editorRef,
              class: "codemirror-editor"
            }, null, 512)
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["resizer", { "resizing": isResizing.value }]),
            onMousedown: startResize
          }, null, 34),
          createBaseVNode("div", _hoisted_6$7, [
            createBaseVNode("div", _hoisted_7$7, [
              createBaseVNode("div", _hoisted_8$7, [
                createBaseVNode("h6", _hoisted_9$7, [
                  loading.value ? (openBlock(), createElementBlock("div", _hoisted_10$7, [..._cache[4] || (_cache[4] = [
                    createBaseVNode("div", { class: "spinner-border spinner-border-sm me-2" }, null, -1),
                    createTextVNode(" 执行中... ", -1)
                  ])])) : sqlResult.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    sqlResult.value.success ? (openBlock(), createElementBlock("i", _hoisted_11$7)) : (openBlock(), createElementBlock("i", _hoisted_12$7)),
                    _cache[5] || (_cache[5] = createTextVNode(" 执行结果 ", -1))
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode(" 执行结果 ")
                  ], 64))
                ]),
                sqlResult.value && !loading.value ? (openBlock(), createElementBlock("div", _hoisted_13$7, [
                  createBaseVNode("button", {
                    class: "btn btn-sm btn-outline-secondary me-2",
                    onClick: formatJsonResult
                  }, [..._cache[6] || (_cache[6] = [
                    createBaseVNode("i", { class: "bi bi-braces" }, null, -1),
                    createTextVNode(" 格式化 ", -1)
                  ])]),
                  createBaseVNode("button", {
                    class: "btn btn-sm btn-outline-secondary",
                    onClick: _cache[0] || (_cache[0] = ($event) => exportResult("json"))
                  }, [..._cache[7] || (_cache[7] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-code" }, null, -1),
                    createTextVNode(" 导出JSON ", -1)
                  ])])
                ])) : createCommentVNode("", true)
              ]),
              loading.value ? (openBlock(), createElementBlock("div", _hoisted_14$7, [..._cache[8] || (_cache[8] = [
                createBaseVNode("div", { class: "d-flex align-items-center justify-content-center py-4" }, [
                  createBaseVNode("div", { class: "spinner-border text-primary me-3" }),
                  createBaseVNode("div", null, [
                    createBaseVNode("div", { class: "fw-bold" }, "正在执行SQL..."),
                    createBaseVNode("div", { class: "text-muted small" }, "请稍候，复杂查询可能需要较长时间")
                  ])
                ], -1)
              ])])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_15$7, [
                createBaseVNode("div", {
                  ref_key: "resultEditorRef",
                  ref: resultEditorRef,
                  class: "codemirror-editor"
                }, null, 512)
              ])
            ])
          ])
        ], 512)
      ]);
    };
  }
});
const SqlExecutor = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-ac4aced1"]]);
const _hoisted_1$6 = { class: "connection-detail" };
const _hoisted_2$6 = { class: "connection-header" };
const _hoisted_3$6 = { class: "connection-info" };
const _hoisted_4$6 = { class: "connection-avatar" };
const _hoisted_5$6 = { class: "connection-meta" };
const _hoisted_6$6 = { class: "connection-name" };
const _hoisted_7$6 = { class: "connection-type-info" };
const _hoisted_8$6 = { class: "db-type" };
const _hoisted_9$6 = { class: "connection-actions" };
const _hoisted_10$6 = {
  key: 0,
  class: "connection-details-panel"
};
const _hoisted_11$6 = { class: "detail-card" };
const _hoisted_12$6 = { class: "card-body" };
const _hoisted_13$6 = { class: "row" };
const _hoisted_14$6 = { class: "col-md-6" };
const _hoisted_15$6 = { class: "info-grid" };
const _hoisted_16$6 = { class: "info-item" };
const _hoisted_17$6 = { class: "info-value" };
const _hoisted_18$6 = { class: "info-item" };
const _hoisted_19$5 = { class: "info-value" };
const _hoisted_20$5 = { class: "info-item" };
const _hoisted_21$5 = { class: "info-value" };
const _hoisted_22$5 = { class: "info-item" };
const _hoisted_23$5 = { class: "info-value" };
const _hoisted_24$5 = { class: "col-md-6" };
const _hoisted_25$5 = { class: "stats-grid" };
const _hoisted_26$5 = { class: "stat-item" };
const _hoisted_27$5 = { class: "stat-value" };
const _hoisted_28$5 = { class: "stat-item" };
const _hoisted_29$4 = { class: "stat-value" };
const _hoisted_30$4 = { class: "stat-item" };
const _hoisted_31$4 = { class: "stat-value" };
const _hoisted_32$4 = { class: "stat-item" };
const _hoisted_33$4 = { class: "stat-value" };
const _hoisted_34$4 = { class: "connection-tabs" };
const _hoisted_35$3 = { class: "nav nav-tabs" };
const _hoisted_36$3 = { class: "nav-item" };
const _hoisted_37$3 = { class: "badge bg-primary ms-1" };
const _hoisted_38$3 = { class: "nav-item" };
const _hoisted_39$3 = { class: "tab-content" };
const _hoisted_40$3 = { class: "tab-panel" };
const _hoisted_41$2 = { class: "databases-section" };
const _hoisted_42$2 = { class: "section-header" };
const _hoisted_43$2 = { class: "section-actions" };
const _hoisted_44$2 = { class: "search-box" };
const _hoisted_45$2 = ["disabled"];
const _hoisted_46$2 = {
  key: 0,
  class: "spinner-border spinner-border-sm me-1"
};
const _hoisted_47$2 = { class: "databases-list" };
const _hoisted_48$2 = {
  key: 0,
  class: "loading-state"
};
const _hoisted_49$2 = {
  key: 1,
  class: "empty-state"
};
const _hoisted_50$2 = {
  key: 2,
  class: "databases-list-simple"
};
const _hoisted_51$2 = ["onClick"];
const _hoisted_52$2 = { class: "database-item-name" };
const _hoisted_53$2 = { class: "database-item-actions" };
const _hoisted_54$2 = { class: "tab-panel" };
const _hoisted_55$2 = { class: "sql-section" };
const _hoisted_56$2 = { class: "sql-header" };
const _hoisted_57$2 = {
  key: 0,
  class: "sql-db-info"
};
const _hoisted_58$2 = { class: "badge bg-info" };
const _hoisted_59$2 = {
  key: 1,
  class: "modal fade show d-block",
  style: { "background": "rgba(0,0,0,0.5)" }
};
const _hoisted_60$2 = { class: "modal-dialog" };
const _hoisted_61$2 = { class: "modal-content" };
const _hoisted_62$2 = { class: "modal-header" };
const _hoisted_63$2 = { class: "modal-body" };
const _hoisted_64$2 = { class: "mb-3" };
const _hoisted_65$2 = { key: 0 };
const _hoisted_66$2 = { class: "mb-3" };
const _hoisted_67$2 = { class: "mb-3" };
const _hoisted_68$2 = { key: 1 };
const _hoisted_69$2 = { class: "mb-3" };
const _hoisted_70$2 = { class: "mb-3" };
const _hoisted_71$2 = { class: "mb-3" };
const _hoisted_72$2 = { class: "mb-3" };
const _hoisted_73$2 = { key: 2 };
const _hoisted_74$2 = { class: "mb-3" };
const _hoisted_75$2 = { class: "modal-footer" };
const _hoisted_76$2 = ["disabled"];
const _hoisted_77$2 = {
  key: 0,
  class: "spinner-border spinner-border-sm me-2"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "connection-detail",
  props: {
    connection: {}
  },
  emits: ["test-connection", "edit-connection", "refresh-all", "open-sql-query", "export-schema", "view-logs", "create-database", "open-database"],
  setup(__props, { emit: __emit }) {
    const router = useRouter();
    const props = __props;
    const emit = __emit;
    const connectionStore = useConnectionStore();
    const connectionStats = ref({
      databaseCount: 0,
      tableCount: 0,
      totalSize: 0,
      lastConnected: null
    });
    const connectionStatus = ref("unknown");
    const searchKeyword = ref("");
    const isDetailsExpanded = ref(false);
    function toggleDetails() {
      isDetailsExpanded.value = !isDetailsExpanded.value;
    }
    const showCreateDatabase = ref(false);
    const creatingDatabase = ref(false);
    const newDatabase = ref({
      name: "",
      options: {
        charset: "",
        collation: "",
        owner: "",
        template: "",
        encoding: "",
        tablespace: ""
      }
    });
    const activeTab = ref("databases");
    watch(() => props.connection, (newConnection) => {
      connectionStore.setCurrentConnection(newConnection);
      if (newConnection) {
        loadConnectionStats();
        connectionStatus.value = "unknown";
        testConnection();
      }
    }, { immediate: true });
    onMounted(() => {
      if (props.connection) {
        loadConnectionStats();
      }
    });
    const databases = computed(() => connectionStore.databases);
    const loadingDatabases = computed(() => connectionStore.isLoadingDatabases);
    const connectionStatusClass = computed(() => {
      switch (connectionStatus.value) {
        case "connected":
          return "status-online";
        case "disconnected":
          return "status-offline";
        case "testing":
          return "status-testing";
        default:
          return "status-offline";
      }
    });
    const connectionStatusText = computed(() => {
      switch (connectionStatus.value) {
        case "connected":
          return "已连接";
        case "disconnected":
          return "未连接";
        case "testing":
          return "测试中...";
        default:
          return "未知";
      }
    });
    function loadConnectionStats() {
      connectionStats.value = {
        databaseCount: connectionStore.databaseCount,
        tableCount: connectionStore.tableCount,
        totalSize: 1024 * 1024 * 512,
        // 512MB
        lastConnected: "2小时前"
      };
    }
    function loadDatabases() {
      connectionStore.loadDatabases();
    }
    const filteredDatabases = computed(() => {
      if (!searchKeyword.value) {
        return databases.value;
      }
      const keyword2 = searchKeyword.value.toLowerCase();
      return databases.value.filter(
        (db) => db.name.toLowerCase().includes(keyword2)
      );
    });
    function openDatabase(database) {
      if (props.connection) {
        emit("open-database", props.connection, database.name);
        router.push({
          path: `/database/explorer`,
          query: { connectionId: props.connection.id, database: database.name }
        });
      }
    }
    async function testConnection() {
      if (!props.connection) return;
      connectionStatus.value = "testing";
      try {
        const isConnected = await connectionStore.testConnection(props.connection);
        connectionStatus.value = isConnected ? "connected" : "disconnected";
      } catch (error) {
        console.error("连接测试失败:", error);
        connectionStatus.value = "disconnected";
      }
    }
    function editConnection() {
      if (props.connection) {
        emit("edit-connection", props.connection);
      }
    }
    function exportSchema() {
      if (props.connection) {
        emit("export-schema", props.connection);
      }
    }
    function viewLogs() {
      if (props.connection) {
        emit("view-logs", props.connection);
      }
    }
    function showCreateDatabaseModal() {
      emit("create-database");
      showCreateDatabase.value = true;
    }
    async function createDatabase() {
      if (!newDatabase.value.name) {
        modal.warning("请输入数据库名称");
        return;
      }
      if (props.connection) {
        creatingDatabase.value = true;
        try {
          await connectionStore.createDatabase(newDatabase.value.name);
          modal.success("数据库创建成功");
          showCreateDatabase.value = false;
          newDatabase.value = {
            name: "",
            options: {
              charset: "",
              collation: "",
              owner: "",
              template: "",
              encoding: "",
              tablespace: ""
            }
          };
          loadDatabases();
        } catch (error) {
          modal.error(error.message || "创建数据库失败");
        } finally {
          creatingDatabase.value = false;
        }
      }
    }
    function formatFileSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB", "TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }
    function getDbTypeLabel(type) {
      const typeMap = {
        mysql: "MySQL",
        postgres: "PostgreSQL",
        mssql: "SQL Server",
        sqlite: "SQLite",
        oracle: "Oracle"
      };
      return typeMap[type || ""] || "Unknown";
    }
    function getDbLogoClass(type) {
      return `db-${type || ""}`;
    }
    function getDbLogoText(type) {
      const textMap = {
        mysql: "MY",
        postgres: "PG",
        mssql: "MS",
        sqlite: "SQ",
        oracle: "OR"
      };
      return textMap[type || ""] || "DB";
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", _hoisted_2$6, [
          createBaseVNode("div", _hoisted_3$6, [
            createBaseVNode("div", _hoisted_4$6, [
              createBaseVNode("div", {
                class: normalizeClass(["db-logo", getDbLogoClass(__props.connection?.type)])
              }, toDisplayString(getDbLogoText(__props.connection?.type)), 3)
            ]),
            createBaseVNode("div", _hoisted_5$6, [
              createBaseVNode("h4", _hoisted_6$6, toDisplayString(__props.connection?.name), 1),
              createBaseVNode("div", _hoisted_7$6, [
                createBaseVNode("span", _hoisted_8$6, toDisplayString(getDbTypeLabel(__props.connection?.type)), 1),
                createBaseVNode("span", {
                  class: normalizeClass(["connection-status", connectionStatusClass.value])
                }, [
                  _cache[14] || (_cache[14] = createBaseVNode("div", { class: "status-dot" }, null, -1)),
                  createTextVNode(" " + toDisplayString(connectionStatusText.value), 1)
                ], 2)
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_9$6, [
            createBaseVNode("button", {
              class: "btn btn-sm btn-outline-info",
              onClick: toggleDetails,
              title: "查看/隐藏详细信息"
            }, [
              createBaseVNode("i", {
                class: normalizeClass(["bi", isDetailsExpanded.value ? "bi-chevron-up" : "bi-chevron-down"])
              }, null, 2),
              _cache[15] || (_cache[15] = createTextVNode(" 详情 ", -1))
            ]),
            createBaseVNode("button", {
              class: "btn btn-sm btn-outline-primary",
              onClick: testConnection
            }, [..._cache[16] || (_cache[16] = [
              createBaseVNode("i", { class: "bi bi-wifi" }, null, -1)
            ])]),
            createBaseVNode("button", {
              class: "btn btn-sm btn-outline-secondary",
              onClick: editConnection
            }, [..._cache[17] || (_cache[17] = [
              createBaseVNode("i", { class: "bi bi-pencil" }, null, -1),
              createTextVNode(" 编辑 ", -1)
            ])])
          ])
        ]),
        isDetailsExpanded.value ? (openBlock(), createElementBlock("div", _hoisted_10$6, [
          createBaseVNode("div", _hoisted_11$6, [
            createBaseVNode("div", _hoisted_12$6, [
              createBaseVNode("div", _hoisted_13$6, [
                createBaseVNode("div", _hoisted_14$6, [
                  _cache[22] || (_cache[22] = createBaseVNode("h6", { class: "section-title" }, [
                    createBaseVNode("i", { class: "bi bi-info-circle" }),
                    createTextVNode(" 基本信息 ")
                  ], -1)),
                  createBaseVNode("div", _hoisted_15$6, [
                    createBaseVNode("div", _hoisted_16$6, [
                      _cache[18] || (_cache[18] = createBaseVNode("label", { class: "info-label" }, "主机地址", -1)),
                      createBaseVNode("div", _hoisted_17$6, toDisplayString(__props.connection?.host), 1)
                    ]),
                    createBaseVNode("div", _hoisted_18$6, [
                      _cache[19] || (_cache[19] = createBaseVNode("label", { class: "info-label" }, "端口", -1)),
                      createBaseVNode("div", _hoisted_19$5, toDisplayString(__props.connection?.port), 1)
                    ]),
                    createBaseVNode("div", _hoisted_20$5, [
                      _cache[20] || (_cache[20] = createBaseVNode("label", { class: "info-label" }, "用户名", -1)),
                      createBaseVNode("div", _hoisted_21$5, toDisplayString(__props.connection?.username), 1)
                    ]),
                    createBaseVNode("div", _hoisted_22$5, [
                      _cache[21] || (_cache[21] = createBaseVNode("label", { class: "info-label" }, "数据库类型", -1)),
                      createBaseVNode("div", _hoisted_23$5, [
                        createBaseVNode("span", {
                          class: normalizeClass(["db-type-badge", getDbLogoClass(__props.connection?.type)])
                        }, toDisplayString(getDbTypeLabel(__props.connection?.type)), 3)
                      ])
                    ])
                  ])
                ]),
                createBaseVNode("div", _hoisted_24$5, [
                  _cache[27] || (_cache[27] = createBaseVNode("h6", { class: "section-title" }, [
                    createBaseVNode("i", { class: "bi bi-bar-chart" }),
                    createTextVNode(" 连接统计 ")
                  ], -1)),
                  createBaseVNode("div", _hoisted_25$5, [
                    createBaseVNode("div", _hoisted_26$5, [
                      createBaseVNode("div", _hoisted_27$5, toDisplayString(connectionStats.value.databaseCount || 0), 1),
                      _cache[23] || (_cache[23] = createBaseVNode("div", { class: "stat-label" }, "数据库数量", -1))
                    ]),
                    createBaseVNode("div", _hoisted_28$5, [
                      createBaseVNode("div", _hoisted_29$4, toDisplayString(connectionStats.value.tableCount || 0), 1),
                      _cache[24] || (_cache[24] = createBaseVNode("div", { class: "stat-label" }, "表总数", -1))
                    ]),
                    createBaseVNode("div", _hoisted_30$4, [
                      createBaseVNode("div", _hoisted_31$4, toDisplayString(formatFileSize(connectionStats.value.totalSize || 0)), 1),
                      _cache[25] || (_cache[25] = createBaseVNode("div", { class: "stat-label" }, "总大小", -1))
                    ]),
                    createBaseVNode("div", _hoisted_32$4, [
                      createBaseVNode("div", _hoisted_33$4, toDisplayString(connectionStats.value.lastConnected || "从未"), 1),
                      _cache[26] || (_cache[26] = createBaseVNode("div", { class: "stat-label" }, "最后连接", -1))
                    ])
                  ])
                ])
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", { class: "quick-actions" }, [
          _cache[31] || (_cache[31] = createBaseVNode("div", { class: "actions-header" }, [
            createBaseVNode("h6", { class: "actions-title" }, [
              createBaseVNode("i", { class: "bi bi-lightning" }),
              createTextVNode(" 快速操作 ")
            ])
          ], -1)),
          createBaseVNode("div", { class: "actions-grid" }, [
            createBaseVNode("button", {
              class: "action-btn",
              onClick: showCreateDatabaseModal
            }, [..._cache[28] || (_cache[28] = [
              createBaseVNode("div", { class: "action-icon" }, [
                createBaseVNode("i", { class: "bi bi-plus-circle" })
              ], -1),
              createBaseVNode("div", { class: "action-text" }, "创建数据库", -1)
            ])]),
            createBaseVNode("button", {
              class: "action-btn",
              onClick: exportSchema
            }, [..._cache[29] || (_cache[29] = [
              createBaseVNode("div", { class: "action-icon" }, [
                createBaseVNode("i", { class: "bi bi-download" })
              ], -1),
              createBaseVNode("div", { class: "action-text" }, "导出架构", -1)
            ])]),
            createBaseVNode("button", {
              class: "action-btn",
              onClick: viewLogs
            }, [..._cache[30] || (_cache[30] = [
              createBaseVNode("div", { class: "action-icon" }, [
                createBaseVNode("i", { class: "bi bi-file-text" })
              ], -1),
              createBaseVNode("div", { class: "action-text" }, "查看日志", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_34$4, [
          createBaseVNode("ul", _hoisted_35$3, [
            createBaseVNode("li", _hoisted_36$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "databases" }]),
                onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "databases")
              }, [
                _cache[32] || (_cache[32] = createBaseVNode("i", { class: "bi bi-database-fill" }, null, -1)),
                _cache[33] || (_cache[33] = createTextVNode(" 数据库列表 ", -1)),
                createBaseVNode("span", _hoisted_37$3, toDisplayString(databases.value.length), 1)
              ], 2)
            ]),
            createBaseVNode("li", _hoisted_38$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "sql" }]),
                onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "sql")
              }, [..._cache[34] || (_cache[34] = [
                createBaseVNode("i", { class: "bi bi-terminal" }, null, -1),
                createTextVNode(" SQL查询 ", -1)
              ])], 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_39$3, [
            withDirectives(createBaseVNode("div", _hoisted_40$3, [
              createBaseVNode("div", _hoisted_41$2, [
                createBaseVNode("div", _hoisted_42$2, [
                  createBaseVNode("div", _hoisted_43$2, [
                    createBaseVNode("div", _hoisted_44$2, [
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control form-control-sm",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => searchKeyword.value = $event),
                        placeholder: "搜索数据库...",
                        style: { "width": "200px" }
                      }, null, 512), [
                        [vModelText, searchKeyword.value]
                      ])
                    ]),
                    createBaseVNode("button", {
                      class: "btn btn-sm btn-outline-primary ms-2",
                      onClick: loadDatabases,
                      disabled: loadingDatabases.value
                    }, [
                      loadingDatabases.value ? (openBlock(), createElementBlock("span", _hoisted_46$2)) : createCommentVNode("", true),
                      _cache[35] || (_cache[35] = createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1)),
                      _cache[36] || (_cache[36] = createTextVNode(" 刷新 ", -1))
                    ], 8, _hoisted_45$2)
                  ])
                ]),
                createBaseVNode("div", _hoisted_47$2, [
                  loadingDatabases.value ? (openBlock(), createElementBlock("div", _hoisted_48$2, [..._cache[37] || (_cache[37] = [
                    createBaseVNode("div", { class: "spinner-border text-primary" }, null, -1),
                    createBaseVNode("span", null, "加载数据库列表...", -1)
                  ])])) : filteredDatabases.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_49$2, [
                    _cache[39] || (_cache[39] = createBaseVNode("i", { class: "bi bi-database" }, null, -1)),
                    createBaseVNode("p", null, toDisplayString(searchKeyword.value ? "没有找到匹配的数据库" : "暂无数据库"), 1),
                    createBaseVNode("button", {
                      class: "btn btn-sm btn-primary",
                      onClick: showCreateDatabaseModal
                    }, [..._cache[38] || (_cache[38] = [
                      createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                      createTextVNode(" 创建数据库 ", -1)
                    ])])
                  ])) : (openBlock(), createElementBlock("div", _hoisted_50$2, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(filteredDatabases.value, (database) => {
                      return openBlock(), createElementBlock("div", {
                        key: database.name,
                        class: "database-item",
                        onClick: ($event) => openDatabase(database)
                      }, [
                        _cache[41] || (_cache[41] = createBaseVNode("div", { class: "database-item-icon" }, [
                          createBaseVNode("i", { class: "bi bi-database" })
                        ], -1)),
                        createBaseVNode("div", _hoisted_52$2, toDisplayString(database.name), 1),
                        createBaseVNode("div", _hoisted_53$2, [
                          createBaseVNode("button", {
                            class: "btn btn-sm btn-outline-secondary",
                            onClick: _cache[3] || (_cache[3] = withModifiers(($event) => activeTab.value = "sql", ["stop"]))
                          }, [..._cache[40] || (_cache[40] = [
                            createBaseVNode("i", { class: "bi bi-terminal" }, null, -1)
                          ])])
                        ])
                      ], 8, _hoisted_51$2);
                    }), 128))
                  ]))
                ])
              ])
            ], 512), [
              [vShow, activeTab.value === "databases"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_54$2, [
              createBaseVNode("div", _hoisted_55$2, [
                createBaseVNode("div", _hoisted_56$2, [
                  _cache[42] || (_cache[42] = createBaseVNode("h6", { class: "sql-title" }, [
                    createBaseVNode("i", { class: "bi bi-terminal" }),
                    createTextVNode(" SQL查询 ")
                  ], -1)),
                  props.connection ? (openBlock(), createElementBlock("div", _hoisted_57$2, [
                    createBaseVNode("span", _hoisted_58$2, toDisplayString(props.connection.name), 1)
                  ])) : createCommentVNode("", true)
                ]),
                createVNode(SqlExecutor, {
                  connection: props.connection,
                  database: ""
                }, null, 8, ["connection"])
              ])
            ], 512), [
              [vShow, activeTab.value === "sql"]
            ])
          ])
        ]),
        showCreateDatabase.value ? (openBlock(), createElementBlock("div", _hoisted_59$2, [
          createBaseVNode("div", _hoisted_60$2, [
            createBaseVNode("div", _hoisted_61$2, [
              createBaseVNode("div", _hoisted_62$2, [
                _cache[43] || (_cache[43] = createBaseVNode("h5", { class: "modal-title" }, "创建数据库", -1)),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: _cache[4] || (_cache[4] = ($event) => showCreateDatabase.value = false)
                })
              ]),
              createBaseVNode("div", _hoisted_63$2, [
                createBaseVNode("form", null, [
                  createBaseVNode("div", _hoisted_64$2, [
                    _cache[44] || (_cache[44] = createBaseVNode("label", { class: "form-label" }, [
                      createTextVNode("数据库名称 "),
                      createBaseVNode("span", { class: "text-danger" }, "*")
                    ], -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => newDatabase.value.name = $event),
                      placeholder: "输入数据库名称",
                      required: ""
                    }, null, 512), [
                      [vModelText, newDatabase.value.name]
                    ])
                  ]),
                  __props.connection?.type === "mysql" ? (openBlock(), createElementBlock("div", _hoisted_65$2, [
                    createBaseVNode("div", _hoisted_66$2, [
                      _cache[46] || (_cache[46] = createBaseVNode("label", { class: "form-label" }, "字符集", -1)),
                      withDirectives(createBaseVNode("select", {
                        class: "form-select",
                        "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => newDatabase.value.options.charset = $event)
                      }, [..._cache[45] || (_cache[45] = [
                        createBaseVNode("option", { value: "" }, "默认", -1),
                        createBaseVNode("option", { value: "utf8mb4" }, "utf8mb4", -1),
                        createBaseVNode("option", { value: "utf8" }, "utf8", -1),
                        createBaseVNode("option", { value: "latin1" }, "latin1", -1)
                      ])], 512), [
                        [vModelSelect, newDatabase.value.options.charset]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_67$2, [
                      _cache[48] || (_cache[48] = createBaseVNode("label", { class: "form-label" }, "排序规则", -1)),
                      withDirectives(createBaseVNode("select", {
                        class: "form-select",
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => newDatabase.value.options.collation = $event)
                      }, [..._cache[47] || (_cache[47] = [
                        createBaseVNode("option", { value: "" }, "默认", -1),
                        createBaseVNode("option", { value: "utf8mb4_unicode_ci" }, "utf8mb4_unicode_ci", -1),
                        createBaseVNode("option", { value: "utf8mb4_general_ci" }, "utf8mb4_general_ci", -1),
                        createBaseVNode("option", { value: "utf8_unicode_ci" }, "utf8_unicode_ci", -1)
                      ])], 512), [
                        [vModelSelect, newDatabase.value.options.collation]
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  __props.connection?.type === "postgres" ? (openBlock(), createElementBlock("div", _hoisted_68$2, [
                    createBaseVNode("div", _hoisted_69$2, [
                      _cache[49] || (_cache[49] = createBaseVNode("label", { class: "form-label" }, "所有者", -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control",
                        "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => newDatabase.value.options.owner = $event),
                        placeholder: "数据库所有者"
                      }, null, 512), [
                        [vModelText, newDatabase.value.options.owner]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_70$2, [
                      _cache[50] || (_cache[50] = createBaseVNode("label", { class: "form-label" }, "模板", -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control",
                        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => newDatabase.value.options.template = $event),
                        placeholder: "模板数据库"
                      }, null, 512), [
                        [vModelText, newDatabase.value.options.template]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_71$2, [
                      _cache[52] || (_cache[52] = createBaseVNode("label", { class: "form-label" }, "编码", -1)),
                      withDirectives(createBaseVNode("select", {
                        class: "form-select",
                        "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => newDatabase.value.options.encoding = $event)
                      }, [..._cache[51] || (_cache[51] = [
                        createBaseVNode("option", { value: "" }, "默认", -1),
                        createBaseVNode("option", { value: "UTF8" }, "UTF8", -1),
                        createBaseVNode("option", { value: "LATIN1" }, "LATIN1", -1)
                      ])], 512), [
                        [vModelSelect, newDatabase.value.options.encoding]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_72$2, [
                      _cache[53] || (_cache[53] = createBaseVNode("label", { class: "form-label" }, "表空间", -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control",
                        "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => newDatabase.value.options.tablespace = $event),
                        placeholder: "表空间"
                      }, null, 512), [
                        [vModelText, newDatabase.value.options.tablespace]
                      ])
                    ])
                  ])) : createCommentVNode("", true),
                  __props.connection?.type === "mssql" ? (openBlock(), createElementBlock("div", _hoisted_73$2, [
                    createBaseVNode("div", _hoisted_74$2, [
                      _cache[54] || (_cache[54] = createBaseVNode("label", { class: "form-label" }, "排序规则", -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        class: "form-control",
                        "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => newDatabase.value.options.collation = $event),
                        placeholder: "排序规则"
                      }, null, 512), [
                        [vModelText, newDatabase.value.options.collation]
                      ])
                    ])
                  ])) : createCommentVNode("", true)
                ])
              ]),
              createBaseVNode("div", _hoisted_75$2, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: _cache[13] || (_cache[13] = ($event) => showCreateDatabase.value = false)
                }, "取消"),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-primary",
                  onClick: createDatabase,
                  disabled: !newDatabase.value.name || creatingDatabase.value
                }, [
                  creatingDatabase.value ? (openBlock(), createElementBlock("span", _hoisted_77$2)) : createCommentVNode("", true),
                  _cache[55] || (_cache[55] = createTextVNode(" 创建 ", -1))
                ], 8, _hoisted_76$2)
              ])
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const ConnectionDetail = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-0f8e9231"]]);
var DatabaseType = /* @__PURE__ */ ((DatabaseType2) => {
  DatabaseType2["MYSQL"] = "mysql";
  DatabaseType2["POSTGRESQL"] = "postgres";
  DatabaseType2["SQLITE"] = "sqlite";
  DatabaseType2["ORACLE"] = "oracle";
  DatabaseType2["SQLSERVER"] = "mssql";
  return DatabaseType2;
})(DatabaseType || {});
var ColumnCategory = /* @__PURE__ */ ((ColumnCategory2) => {
  ColumnCategory2["NUMERIC"] = "numeric";
  ColumnCategory2["STRING"] = "string";
  ColumnCategory2["DATE_TIME"] = "date_time";
  ColumnCategory2["BOOLEAN"] = "boolean";
  ColumnCategory2["BINARY"] = "binary";
  ColumnCategory2["TEXT"] = "text";
  ColumnCategory2["SPATIAL"] = "spatial";
  ColumnCategory2["JSON"] = "json";
  ColumnCategory2["ARRAY"] = "array";
  ColumnCategory2["OTHER"] = "other";
  return ColumnCategory2;
})(ColumnCategory || {});
const MYSQL_COLUMN_TYPES = [
  // 数值类型
  { name: "TINYINT", label: "TINYINT", category: "numeric", requiresLength: true, defaultLength: 4, supportsUnsigned: true, supportsAutoIncrement: true, description: "微整数，1字节" },
  { name: "SMALLINT", label: "SMALLINT", category: "numeric", requiresLength: true, defaultLength: 6, supportsUnsigned: true, supportsAutoIncrement: true, description: "小整数，2字节" },
  { name: "MEDIUMINT", label: "MEDIUMINT", category: "numeric", requiresLength: true, defaultLength: 9, supportsUnsigned: true, supportsAutoIncrement: true, description: "中等整数，3字节" },
  { name: "INT", label: "INT", category: "numeric", requiresLength: true, defaultLength: 11, supportsUnsigned: true, supportsAutoIncrement: true, description: "标准整数，4字节" },
  { name: "BIGINT", label: "BIGINT", category: "numeric", requiresLength: true, defaultLength: 20, supportsUnsigned: true, supportsAutoIncrement: true, description: "大整数，8字节" },
  { name: "DECIMAL", label: "DECIMAL", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "定点小数" },
  { name: "FLOAT", label: "FLOAT", category: "numeric", requiresPrecision: true, defaultPrecision: 10, requiresScale: true, defaultScale: 2, description: "单精度浮点数" },
  { name: "DOUBLE", label: "DOUBLE", category: "numeric", requiresPrecision: true, defaultPrecision: 16, requiresScale: true, defaultScale: 4, description: "双精度浮点数" },
  { name: "BIT", label: "BIT", category: "numeric", requiresLength: true, defaultLength: 1, description: "位类型" },
  { name: "SERIAL", label: "SERIAL", category: "numeric", supportsAutoIncrement: true, description: "自增整数（别名）" },
  // 字符串类型
  { name: "CHAR", label: "CHAR", category: "string", requiresLength: true, defaultLength: 1, description: "固定长度字符串" },
  { name: "VARCHAR", label: "VARCHAR", category: "string", requiresLength: true, defaultLength: 255, description: "可变长度字符串" },
  { name: "BINARY", label: "BINARY", category: "binary", requiresLength: true, defaultLength: 1, description: "固定长度二进制" },
  { name: "VARBINARY", label: "VARBINARY", category: "binary", requiresLength: true, defaultLength: 255, description: "可变长度二进制" },
  // 文本类型
  { name: "TINYTEXT", label: "TINYTEXT", category: "text", description: "微型文本，最大255字符" },
  { name: "TEXT", label: "TEXT", category: "text", description: "文本，最大65535字符" },
  { name: "MEDIUMTEXT", label: "MEDIUMTEXT", category: "text", description: "中等文本，最大16MB" },
  { name: "LONGTEXT", label: "LONGTEXT", category: "text", description: "长文本，最大4GB" },
  // 日期时间类型
  { name: "DATE", label: "DATE", category: "date_time", description: "日期" },
  { name: "TIME", label: "TIME", category: "date_time", description: "时间" },
  { name: "DATETIME", label: "DATETIME", category: "date_time", description: "日期时间" },
  { name: "TIMESTAMP", label: "TIMESTAMP", category: "date_time", description: "时间戳" },
  { name: "YEAR", label: "YEAR", category: "date_time", description: "年份" },
  // JSON 类型
  { name: "JSON", label: "JSON", category: "json", description: "JSON数据类型" },
  // 枚举和集合类型
  { name: "ENUM", label: "ENUM", category: "other", description: "枚举类型" },
  { name: "SET", label: "SET", category: "other", description: "集合类型" },
  // 空间类型
  { name: "GEOMETRY", label: "GEOMETRY", category: "spatial", description: "几何类型" },
  { name: "POINT", label: "POINT", category: "spatial", description: "点类型" },
  { name: "LINESTRING", label: "LINESTRING", category: "spatial", description: "线类型" },
  { name: "POLYGON", label: "POLYGON", category: "spatial", description: "多边形类型" }
];
const POSTGRESQL_COLUMN_TYPES = [
  // 数值类型
  { name: "SMALLINT", label: "SMALLINT", category: "numeric", description: "小整数，2字节" },
  { name: "INTEGER", label: "INTEGER", category: "numeric", supportsAutoIncrement: true, description: "整数，4字节" },
  { name: "BIGINT", label: "BIGINT", category: "numeric", supportsAutoIncrement: true, description: "大整数，8字节" },
  { name: "DECIMAL", label: "DECIMAL", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "定点小数" },
  { name: "NUMERIC", label: "NUMERIC", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "定点小数" },
  { name: "REAL", label: "REAL", category: "numeric", description: "单精度浮点数，4字节" },
  { name: "DOUBLE PRECISION", label: "DOUBLE PRECISION", category: "numeric", description: "双精度浮点数，8字节" },
  { name: "SMALLSERIAL", label: "SMALLSERIAL", category: "numeric", supportsAutoIncrement: true, description: "自增小整数" },
  { name: "SERIAL", label: "SERIAL", category: "numeric", supportsAutoIncrement: true, description: "自增整数" },
  { name: "BIGSERIAL", label: "BIGSERIAL", category: "numeric", supportsAutoIncrement: true, description: "自增大整数" },
  { name: "MONEY", label: "MONEY", category: "numeric", description: "货币类型" },
  // 字符串类型
  { name: "CHARACTER VARYING", label: "VARCHAR", category: "string", requiresLength: true, defaultLength: 255, description: "可变长度字符串" },
  { name: "CHARACTER", label: "CHAR", category: "string", requiresLength: true, defaultLength: 1, description: "固定长度字符串" },
  { name: "TEXT", label: "TEXT", category: "text", description: "文本" },
  // 二进制类型
  { name: "BYTEA", label: "BYTEA", category: "binary", description: "二进制数据" },
  // 日期时间类型
  { name: "DATE", label: "DATE", category: "date_time", description: "日期" },
  { name: "TIME", label: "TIME", category: "date_time", description: "时间" },
  { name: "TIME WITH TIME ZONE", label: "TIME WITH TIME ZONE", category: "date_time", description: "带时区时间" },
  { name: "TIMESTAMP", label: "TIMESTAMP", category: "date_time", description: "时间戳" },
  { name: "TIMESTAMP WITH TIME ZONE", label: "TIMESTAMP WITH TIME ZONE", category: "date_time", description: "带时区时间戳" },
  { name: "INTERVAL", label: "INTERVAL", category: "date_time", description: "时间间隔" },
  // 布尔类型
  { name: "BOOLEAN", label: "BOOLEAN", category: "boolean", description: "布尔值" },
  // JSON 类型
  { name: "JSON", label: "JSON", category: "json", description: "JSON数据类型" },
  { name: "JSONB", label: "JSONB", category: "json", description: "二进制JSON数据类型" },
  // 数组类型
  { name: "TEXT[]", label: "TEXT[]", category: "array", description: "文本数组" },
  { name: "INTEGER[]", label: "INTEGER[]", category: "array", description: "整数数组" },
  // UUID 类型
  { name: "UUID", label: "UUID", category: "other", description: "UUID类型" },
  // 网络地址类型
  { name: "INET", label: "INET", category: "other", description: "IP地址" },
  { name: "CIDR", label: "CIDR", category: "other", description: "CIDR地址" },
  // 几何类型
  { name: "POINT", label: "POINT", category: "spatial", description: "点类型" },
  { name: "LINE", label: "LINE", category: "spatial", description: "线类型" },
  { name: "LSEG", label: "LSEG", category: "spatial", description: "线段类型" },
  { name: "BOX", label: "BOX", category: "spatial", description: "矩形类型" },
  { name: "PATH", label: "PATH", category: "spatial", description: "路径类型" },
  { name: "POLYGON", label: "POLYGON", category: "spatial", description: "多边形类型" },
  { name: "CIRCLE", label: "CIRCLE", category: "spatial", description: "圆形类型" }
];
const SQLITE_COLUMN_TYPES = [
  // 数值类型
  { name: "INTEGER", label: "INTEGER", category: "numeric", supportsAutoIncrement: true, description: "整数，支持自增" },
  { name: "INT", label: "INT", category: "numeric", supportsAutoIncrement: true, description: "整数（INTEGER别名）" },
  { name: "BIGINT", label: "BIGINT", category: "numeric", description: "大整数" },
  { name: "SMALLINT", label: "SMALLINT", category: "numeric", description: "小整数" },
  { name: "TINYINT", label: "TINYINT", category: "numeric", description: "微整数" },
  { name: "REAL", label: "REAL", category: "numeric", description: "浮点数" },
  { name: "DOUBLE", label: "DOUBLE", category: "numeric", description: "双精度浮点数" },
  { name: "FLOAT", label: "FLOAT", category: "numeric", description: "浮点数" },
  // 字符串类型
  { name: "TEXT", label: "TEXT", category: "text", description: "文本" },
  { name: "CHARACTER", label: "CHARACTER", category: "string", requiresLength: true, defaultLength: 1, description: "字符" },
  { name: "VARCHAR", label: "VARCHAR", category: "string", requiresLength: true, defaultLength: 255, description: "可变长字符串" },
  { name: "NCHAR", label: "NCHAR", category: "string", requiresLength: true, defaultLength: 1, description: "Unicode字符" },
  { name: "NVARCHAR", label: "NVARCHAR", category: "string", requiresLength: true, defaultLength: 255, description: "Unicode可变长字符串" },
  { name: "CLOB", label: "CLOB", category: "text", description: "字符大对象" },
  // 二进制类型
  { name: "BLOB", label: "BLOB", category: "binary", description: "二进制大对象" },
  { name: "BINARY", label: "BINARY", category: "binary", requiresLength: true, defaultLength: 1, description: "二进制" },
  { name: "VARBINARY", label: "VARBINARY", category: "binary", requiresLength: true, defaultLength: 255, description: "可变长二进制" },
  // 日期时间类型
  { name: "DATE", label: "DATE", category: "date_time", description: "日期" },
  { name: "DATETIME", label: "DATETIME", category: "date_time", description: "日期时间" },
  { name: "TIME", label: "TIME", category: "date_time", description: "时间" },
  { name: "TIMESTAMP", label: "TIMESTAMP", category: "date_time", description: "时间戳" },
  // 数值（特殊）
  { name: "NUMERIC", label: "NUMERIC", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "定点小数" },
  { name: "DECIMAL", label: "DECIMAL", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "定点小数" },
  { name: "BOOLEAN", label: "BOOLEAN", category: "boolean", description: "布尔值" },
  // 其他类型
  { name: "ANY", label: "ANY", category: "other", description: "任意类型" }
];
const ORACLE_COLUMN_TYPES = [
  // 数值类型
  { name: "NUMBER", label: "NUMBER", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 10, defaultScale: 2, description: "数值类型" },
  { name: "INTEGER", label: "INTEGER", category: "numeric", description: "整数类型" },
  { name: "INT", label: "INT", category: "numeric", description: "整数类型" },
  { name: "SMALLINT", label: "SMALLINT", category: "numeric", description: "小整数类型" },
  { name: "REAL", label: "REAL", category: "numeric", description: "浮点数类型" },
  { name: "DOUBLE PRECISION", label: "DOUBLE PRECISION", category: "numeric", description: "双精度浮点数" },
  { name: "FLOAT", label: "FLOAT", category: "numeric", requiresPrecision: true, defaultPrecision: 126, description: "浮点数" },
  { name: "BINARY_FLOAT", label: "BINARY_FLOAT", category: "numeric", description: "二进制浮点数" },
  { name: "BINARY_DOUBLE", label: "BINARY_DOUBLE", category: "numeric", description: "双精度二进制浮点数" },
  // 字符串类型
  { name: "CHAR", label: "CHAR", category: "string", requiresLength: true, defaultLength: 1, description: "固定长度字符串" },
  { name: "VARCHAR2", label: "VARCHAR2", category: "string", requiresLength: true, defaultLength: 4e3, description: "可变长度字符串" },
  { name: "NVARCHAR2", label: "NVARCHAR2", category: "string", requiresLength: true, defaultLength: 2e3, description: "Unicode可变长度字符串" },
  { name: "NCHAR", label: "NCHAR", category: "string", requiresLength: true, defaultLength: 1, description: "Unicode固定长度字符串" },
  { name: "CLOB", label: "CLOB", category: "text", description: "字符大对象" },
  { name: "NCLOB", label: "NCLOB", category: "text", description: "Unicode字符大对象" },
  { name: "LONG", label: "LONG", category: "text", description: "长字符串类型" },
  // 二进制类型
  { name: "RAW", label: "RAW", category: "binary", requiresLength: true, defaultLength: 2e3, description: "二进制数据" },
  { name: "LONG RAW", label: "LONG RAW", category: "binary", description: "长二进制数据" },
  { name: "BLOB", label: "BLOB", category: "binary", description: "二进制大对象" },
  { name: "BFILE", label: "BFILE", category: "binary", description: "外部二进制文件" },
  // 日期时间类型
  { name: "DATE", label: "DATE", category: "date_time", description: "日期时间" },
  { name: "TIMESTAMP", label: "TIMESTAMP", category: "date_time", description: "时间戳" },
  { name: "TIMESTAMP WITH TIME ZONE", label: "TIMESTAMP WITH TIME ZONE", category: "date_time", description: "带时区时间戳" },
  { name: "TIMESTAMP WITH LOCAL TIME ZONE", label: "TIMESTAMP WITH LOCAL TIME ZONE", category: "date_time", description: "带本地时区时间戳" },
  { name: "INTERVAL YEAR TO MONTH", label: "INTERVAL YEAR TO MONTH", category: "date_time", description: "年月间隔" },
  { name: "INTERVAL DAY TO SECOND", label: "INTERVAL DAY TO SECOND", category: "date_time", description: "日秒间隔" },
  // 行标识符类型
  { name: "ROWID", label: "ROWID", category: "other", description: "行标识符" },
  { name: "UROWID", label: "UROWID", category: "other", description: "通用行标识符" },
  // XML 类型
  { name: "XMLTYPE", label: "XMLTYPE", category: "other", description: "XML数据类型" },
  // 空间类型
  { name: "SDO_GEOMETRY", label: "SDO_GEOMETRY", category: "spatial", description: "空间几何类型" }
];
const SQLSERVER_COLUMN_TYPES = [
  // 精确数值类型
  { name: "BIGINT", label: "BIGINT", category: "numeric", supportsAutoIncrement: true, description: "大整数，8字节" },
  { name: "INT", label: "INT", category: "numeric", supportsAutoIncrement: true, description: "整数，4字节" },
  { name: "SMALLINT", label: "SMALLINT", category: "numeric", description: "小整数，2字节" },
  { name: "TINYINT", label: "TINYINT", category: "numeric", description: "微整数，1字节" },
  { name: "BIT", label: "BIT", category: "boolean", description: "位类型，布尔值" },
  { name: "DECIMAL", label: "DECIMAL", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 18, defaultScale: 0, description: "定点小数" },
  { name: "NUMERIC", label: "NUMERIC", category: "numeric", requiresPrecision: true, requiresScale: true, defaultPrecision: 18, defaultScale: 0, description: "定点小数" },
  { name: "MONEY", label: "MONEY", category: "numeric", description: "货币类型，8字节" },
  { name: "SMALLMONEY", label: "SMALLMONEY", category: "numeric", description: "小货币类型，4字节" },
  // 近似数值类型
  { name: "FLOAT", label: "FLOAT", category: "numeric", requiresPrecision: true, defaultPrecision: 53, description: "浮点数" },
  { name: "REAL", label: "REAL", category: "numeric", description: "浮点数，4字节" },
  // 日期时间类型
  { name: "DATE", label: "DATE", category: "date_time", description: "日期" },
  { name: "TIME", label: "TIME", category: "date_time", description: "时间" },
  { name: "DATETIMEOFFSET", label: "DATETIMEOFFSET", category: "date_time", description: "带时区日期时间" },
  { name: "DATETIME2", label: "DATETIME2", category: "date_time", description: "扩展日期时间" },
  { name: "SMALLDATETIME", label: "SMALLDATETIME", category: "date_time", description: "小日期时间" },
  { name: "DATETIME", label: "DATETIME", category: "date_time", description: "日期时间" },
  // 字符串类型
  { name: "CHAR", label: "CHAR", category: "string", requiresLength: true, defaultLength: 1, description: "固定长度字符串" },
  { name: "VARCHAR", label: "VARCHAR", category: "string", requiresLength: true, defaultLength: 1, description: "可变长度字符串" },
  { name: "TEXT", label: "TEXT", category: "text", description: "文本" },
  { name: "NCHAR", label: "NCHAR", category: "string", requiresLength: true, defaultLength: 1, description: "Unicode固定长度字符串" },
  { name: "NVARCHAR", label: "NVARCHAR", category: "string", requiresLength: true, defaultLength: 1, description: "Unicode可变长度字符串" },
  { name: "NTEXT", label: "NTEXT", category: "text", description: "Unicode文本" },
  // 二进制字符串类型
  { name: "BINARY", label: "BINARY", category: "binary", requiresLength: true, defaultLength: 1, description: "固定长度二进制" },
  { name: "VARBINARY", label: "VARBINARY", category: "binary", requiresLength: true, defaultLength: 1, description: "可变长度二进制" },
  { name: "IMAGE", label: "IMAGE", category: "binary", description: "二进制图像" },
  // 其他类型
  { name: "CURSOR", label: "CURSOR", category: "other", description: "游标类型" },
  { name: "TIMESTAMP", label: "TIMESTAMP", category: "other", description: "时间戳类型" },
  { name: "UNIQUEIDENTIFIER", label: "UNIQUEIDENTIFIER", category: "other", description: "唯一标识符" },
  { name: "SQL_VARIANT", label: "SQL_VARIANT", category: "other", description: "变体类型" },
  { name: "TABLE", label: "TABLE", category: "other", description: "表类型" },
  { name: "XML", label: "XML", category: "other", description: "XML数据类型" },
  // 空间类型
  { name: "GEOGRAPHY", label: "GEOGRAPHY", category: "spatial", description: "地理空间类型" },
  { name: "GEOMETRY", label: "GEOMETRY", category: "spatial", description: "几何空间类型" }
];
const DATABASE_TYPE_CONFIGS = {
  [
    "mysql"
    /* MYSQL */
  ]: {
    value: "mysql",
    label: "MySQL",
    icon: "bi-database",
    defaultPort: 3306,
    description: "MySQL数据库",
    supportedColumnTypes: MYSQL_COLUMN_TYPES
  },
  [
    "postgres"
    /* POSTGRESQL */
  ]: {
    value: "postgres",
    label: "PostgreSQL",
    icon: "bi-database",
    defaultPort: 5432,
    description: "PostgreSQL数据库",
    supportedColumnTypes: POSTGRESQL_COLUMN_TYPES
  },
  [
    "sqlite"
    /* SQLITE */
  ]: {
    value: "sqlite",
    label: "SQLite",
    icon: "bi-database",
    defaultPort: null,
    description: "SQLite数据库",
    supportedColumnTypes: SQLITE_COLUMN_TYPES
  },
  [
    "oracle"
    /* ORACLE */
  ]: {
    value: "oracle",
    label: "Oracle",
    icon: "bi-database",
    defaultPort: 1521,
    description: "Oracle数据库",
    supportedColumnTypes: ORACLE_COLUMN_TYPES
  },
  [
    "mssql"
    /* SQLSERVER */
  ]: {
    value: "mssql",
    label: "SQL Server",
    icon: "bi-database",
    defaultPort: 1433,
    description: "Microsoft SQL Server",
    supportedColumnTypes: SQLSERVER_COLUMN_TYPES
  }
};
function getColumnTypes(databaseType) {
  const config = DATABASE_TYPE_CONFIGS[databaseType];
  return config?.supportedColumnTypes || [];
}
function getColumnTypesByName(databaseTypeName) {
  const type = Object.values(DatabaseType).find((t2) => t2 === databaseTypeName.toLowerCase());
  return type ? getColumnTypes(type) : [];
}
const _hoisted_1$5 = { class: "modal-content" };
const _hoisted_2$5 = { class: "modal-header" };
const _hoisted_3$5 = { class: "modal-title" };
const _hoisted_4$5 = { class: "modal-body" };
const _hoisted_5$5 = { class: "table-info-section mb-4" };
const _hoisted_6$5 = { class: "row" };
const _hoisted_7$5 = { class: "col-md-6" };
const _hoisted_8$5 = { class: "mb-3" };
const _hoisted_9$5 = ["disabled"];
const _hoisted_10$5 = { class: "col-md-6" };
const _hoisted_11$5 = { class: "mb-3" };
const _hoisted_12$5 = { class: "columns-section" };
const _hoisted_13$5 = { class: "table-responsive" };
const _hoisted_14$5 = { class: "table table-sm table-bordered" };
const _hoisted_15$5 = ["onUpdate:modelValue"];
const _hoisted_16$5 = ["onUpdate:modelValue"];
const _hoisted_17$5 = ["label"];
const _hoisted_18$5 = ["value"];
const _hoisted_19$4 = {
  key: 0,
  class: "input-group input-group-sm"
};
const _hoisted_20$4 = ["onUpdate:modelValue"];
const _hoisted_21$4 = ["onUpdate:modelValue"];
const _hoisted_22$4 = ["onUpdate:modelValue"];
const _hoisted_23$4 = {
  key: 1,
  class: "text-muted"
};
const _hoisted_24$4 = { class: "form-check" };
const _hoisted_25$4 = ["onUpdate:modelValue"];
const _hoisted_26$4 = ["onUpdate:modelValue"];
const _hoisted_27$4 = { class: "form-check" };
const _hoisted_28$4 = ["onUpdate:modelValue", "onChange"];
const _hoisted_29$3 = { class: "form-check" };
const _hoisted_30$3 = ["onUpdate:modelValue", "disabled"];
const _hoisted_31$3 = ["onUpdate:modelValue"];
const _hoisted_32$3 = ["onClick", "disabled"];
const _hoisted_33$3 = { class: "sql-preview-section mt-4" };
const _hoisted_34$3 = { class: "sql-preview bg-light p-3 rounded" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "table-editor",
  props: {
    visible: { type: Boolean },
    connection: {},
    database: {},
    table: {},
    mode: {}
  },
  emits: ["close", "submit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const databaseService2 = new DatabaseService();
    const columnTypes = computed(() => {
      if (!props.connection) return [];
      return getColumnTypesByName(props.connection.type);
    });
    const columnTypesByCategory = computed(() => {
      const categories = {};
      columnTypes.value.forEach((type) => {
        if (!categories[type.category]) {
          categories[type.category] = [];
        }
        categories[type.category].push(type);
      });
      return categories;
    });
    const formData = ref({
      tableName: "",
      tableComment: "",
      columns: [{
        name: "",
        type: "",
        length: "",
        nullable: false,
        defaultValue: "",
        isPrimary: false,
        isAutoIncrement: false,
        comment: ""
      }]
    });
    function initFormData() {
      if (props.mode === "edit" && props.table) {
        formData.value = {
          tableName: props.table.name || "",
          tableComment: props.table.comment || "",
          columns: props.table.columns?.map((col) => ({
            name: col.name || "",
            type: col.type || "",
            length: col.length || "",
            precision: col.precision || null,
            scale: col.scale || null,
            nullable: col.nullable || false,
            defaultValue: col.defaultValue || "",
            isPrimary: col.isPrimary || false,
            isAutoIncrement: col.isAutoIncrement || false,
            comment: col.comment || ""
          })) || []
        };
      } else {
        formData.value = {
          tableName: "",
          tableComment: "",
          columns: [{
            name: "",
            type: "",
            length: "",
            precision: null,
            scale: null,
            nullable: false,
            defaultValue: "",
            isPrimary: false,
            isAutoIncrement: false,
            comment: ""
          }]
        };
      }
    }
    function addColumn() {
      formData.value.columns.push({
        name: "",
        type: "",
        length: "",
        precision: null,
        scale: null,
        nullable: false,
        defaultValue: "",
        isPrimary: false,
        isAutoIncrement: false,
        comment: ""
      });
    }
    function removeColumn(index) {
      if (formData.value.columns.length > 1) {
        formData.value.columns.splice(index, 1);
      }
    }
    function onPrimaryKeyChange(column, index) {
      if (column.isPrimary) {
        formData.value.columns.forEach((col, idx) => {
          if (idx !== index) {
            col.isPrimary = false;
          }
        });
      }
      if (!column.isPrimary) {
        column.isAutoIncrement = false;
      }
    }
    function generateSQL() {
      if (!formData.value.tableName) return "请输入表名";
      if (props.mode === "create") {
        const quoteIdentifier = (name2) => {
          if (!props.connection) return `"${name2}"`;
          switch (props.connection.type.toLowerCase()) {
            case "mysql":
              return `\`${name2}\``;
            case "postgres":
              return `"${name2}"`;
            case "sqlite":
              return `"${name2}"`;
            case "oracle":
              return `"${name2.toUpperCase()}"`;
            case "mssql":
              return `[${name2}]`;
            default:
              return `"${name2}"`;
          }
        };
        const columnsSQL = formData.value.columns.map((col) => {
          if (!col.name || !col.type) return "";
          let sql22 = `${quoteIdentifier(col.name)} ${col.type}`;
          if (col.length && (needsLength(col) || col.type.includes("CHAR"))) {
            sql22 += `(${col.length})`;
          } else if (col.precision) {
            if (col.scale) {
              sql22 += `(${col.precision},${col.scale})`;
            } else {
              sql22 += `(${col.precision})`;
            }
          }
          if (!col.nullable) sql22 += " NOT NULL";
          if (col.defaultValue) {
            sql22 += ` DEFAULT ${formatDefaultValue(col.defaultValue, col.type)}`;
          }
          if (col.isAutoIncrement) {
            switch (props.connection?.type.toLowerCase()) {
              case "mysql":
                sql22 += " AUTO_INCREMENT";
                break;
              case "postgres":
                if (col.type.toLowerCase().includes("serial") || col.type.toLowerCase().includes("bigserial")) ;
                else {
                  sql22 += " GENERATED ALWAYS AS IDENTITY";
                }
                break;
              case "sqlite":
                sql22 += " AUTOINCREMENT";
                break;
              case "oracle":
                break;
              case "mssql":
                sql22 += " IDENTITY(1,1)";
                break;
            }
          }
          if (col.comment) {
            switch (props.connection?.type.toLowerCase()) {
              case "mysql":
                sql22 += ` COMMENT '${col.comment}'`;
                break;
              case "postgres":
                break;
              case "sqlite":
                break;
              case "oracle":
                sql22 += ` COMMENT '${col.comment}'`;
                break;
            }
          }
          return sql22;
        }).filter((sql22) => sql22).join(",\n  ");
        const primaryKeys = formData.value.columns.filter((col) => col.isPrimary).map((col) => quoteIdentifier(col.name));
        let sql2 = `CREATE TABLE ${quoteIdentifier(formData.value.tableName)} (
  ${columnsSQL}`;
        if (primaryKeys.length > 0) {
          sql2 += `,
  PRIMARY KEY (${primaryKeys.join(", ")})`;
        }
        sql2 += "\n)";
        switch (props.connection?.type.toLowerCase()) {
          case "mysql":
            if (formData.value.tableComment) {
              sql2 += ` COMMENT='${formData.value.tableComment}'`;
            }
            sql2 += " ENGINE=InnoDB DEFAULT CHARSET=utf8mb4";
            break;
          case "postgres":
            break;
          case "oracle":
            if (formData.value.tableComment) {
              sql2 += ` COMMENT '${formData.value.tableComment}'`;
            }
            break;
        }
        if (props.connection?.type.toLowerCase() === "postgres") {
          const commentStatements = [];
          if (formData.value.tableComment) {
            commentStatements.push(`COMMENT ON TABLE ${quoteIdentifier(formData.value.tableName)} IS '${formData.value.tableComment}'`);
          }
          formData.value.columns.forEach((col) => {
            if (col.comment) {
              commentStatements.push(`COMMENT ON COLUMN ${quoteIdentifier(formData.value.tableName)}.${quoteIdentifier(col.name)} IS '${col.comment}'`);
            }
          });
          if (commentStatements.length > 0) {
            sql2 += ";\n" + commentStatements.join(";\n");
          }
        }
        return sql2;
      } else {
        return `-- 表结构修改SQL（需要对比差异生成）
-- 当前表名: ${formData.value.tableName}`;
      }
    }
    function formatDefaultValue(value, type) {
      if (value === null || value === void 0 || value === "") {
        return "NULL";
      }
      const lowerType = type.toLowerCase();
      if (isNumberInput(lowerType) && !isNaN(value)) {
        return String(value);
      }
      if (isBooleanInput(lowerType)) {
        return value ? "TRUE" : "FALSE";
      }
      return `'${String(value).replace(/'/g, "''")}'`;
    }
    async function submit() {
      try {
        if (!formData.value.tableName) {
          await modal.warning("请输入表名");
          return;
        }
        if (formData.value.columns.some((col) => !col.name || !col.type)) {
          await modal.warning("请完善所有字段信息");
          return;
        }
        const sql2 = generateSQL();
        if (!props.connection?.id) {
          await modal.warning("请先选择数据库连接");
          return;
        }
        const result = await databaseService2.executeQuery(
          props.connection.id,
          sql2,
          props.database
        );
        emit("submit", {
          success: result.ret === 0,
          message: result.ret === 0 ? "操作成功" : "操作失败",
          data: result.data
        });
        close();
      } catch (error) {
        console.error("提交失败:", error);
        emit("submit", {
          success: false,
          message: "操作失败"
        });
      }
    }
    function close() {
      emit("close");
    }
    watch(() => props.visible, (newVal) => {
      if (newVal) {
        initFormData();
      }
    });
    function getCategoryLabel(category) {
      const labels = {
        [ColumnCategory.NUMERIC]: "数值类型",
        [ColumnCategory.STRING]: "字符串类型",
        [ColumnCategory.TEXT]: "文本类型",
        [ColumnCategory.DATE_TIME]: "日期时间类型",
        [ColumnCategory.BOOLEAN]: "布尔类型",
        [ColumnCategory.BINARY]: "二进制类型",
        [ColumnCategory.JSON]: "JSON类型",
        [ColumnCategory.ARRAY]: "数组类型",
        [ColumnCategory.SPATIAL]: "空间类型",
        [ColumnCategory.OTHER]: "其他类型"
      };
      return labels[category] || category;
    }
    function getSelectedType(column) {
      return columnTypes.value.find((t2) => t2.name === column.type);
    }
    function needsLength(column) {
      const typeInfo = getSelectedType(column);
      return typeInfo?.requiresLength || false;
    }
    function needsPrecision(column) {
      const typeInfo = getSelectedType(column);
      return typeInfo?.requiresPrecision || false;
    }
    function needsScale(column) {
      const typeInfo = getSelectedType(column);
      return typeInfo?.requiresScale || false;
    }
    function supportsAutoIncrement(column) {
      const typeInfo = getSelectedType(column);
      return typeInfo?.supportsAutoIncrement || false;
    }
    onMounted(() => {
      if (props.visible) {
        initFormData();
      }
    });
    return (_ctx, _cache) => {
      return __props.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "modal fade show",
        style: { "display": "block", "background-color": "rgba(0,0,0,0.5)" },
        onClick: close
      }, [
        createBaseVNode("div", {
          class: "modal-dialog modal-lg",
          style: { "width": "80%", "max-width": "none" },
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", _hoisted_2$5, [
              createBaseVNode("h5", _hoisted_3$5, [
                _cache[3] || (_cache[3] = createBaseVNode("i", { class: "bi bi-pencil-square me-2" }, null, -1)),
                createTextVNode(" " + toDisplayString(__props.mode === "create" ? "创建新表" : "修改表结构"), 1)
              ]),
              createBaseVNode("button", {
                type: "button",
                class: "btn-close",
                onClick: close
              })
            ]),
            createBaseVNode("div", _hoisted_4$5, [
              createBaseVNode("div", _hoisted_5$5, [
                _cache[6] || (_cache[6] = createBaseVNode("h6", { class: "section-title" }, "表信息", -1)),
                createBaseVNode("div", _hoisted_6$5, [
                  createBaseVNode("div", _hoisted_7$5, [
                    createBaseVNode("div", _hoisted_8$5, [
                      _cache[4] || (_cache[4] = createBaseVNode("label", { class: "form-label" }, "表名", -1)),
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => formData.value.tableName = $event),
                        type: "text",
                        class: "form-control",
                        disabled: __props.mode === "edit",
                        placeholder: "请输入表名"
                      }, null, 8, _hoisted_9$5), [
                        [vModelText, formData.value.tableName]
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_10$5, [
                    createBaseVNode("div", _hoisted_11$5, [
                      _cache[5] || (_cache[5] = createBaseVNode("label", { class: "form-label" }, "表注释", -1)),
                      withDirectives(createBaseVNode("input", {
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.tableComment = $event),
                        type: "text",
                        class: "form-control",
                        placeholder: "请输入表注释"
                      }, null, 512), [
                        [vModelText, formData.value.tableComment]
                      ])
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_12$5, [
                createBaseVNode("div", { class: "section-header d-flex justify-content-between align-items-center mb-3" }, [
                  _cache[8] || (_cache[8] = createBaseVNode("h6", { class: "section-title mb-0" }, "字段管理", -1)),
                  createBaseVNode("button", {
                    class: "btn btn-success btn-sm",
                    onClick: addColumn
                  }, [..._cache[7] || (_cache[7] = [
                    createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
                    createTextVNode(" 添加字段 ", -1)
                  ])])
                ]),
                createBaseVNode("div", _hoisted_13$5, [
                  createBaseVNode("table", _hoisted_14$5, [
                    _cache[11] || (_cache[11] = createBaseVNode("thead", { class: "table-light" }, [
                      createBaseVNode("tr", null, [
                        createBaseVNode("th", { width: "120" }, "字段名"),
                        createBaseVNode("th", { width: "140" }, "数据类型"),
                        createBaseVNode("th", { width: "120" }, "长度/精度"),
                        createBaseVNode("th", { width: "80" }, "可空"),
                        createBaseVNode("th", { width: "100" }, "默认值"),
                        createBaseVNode("th", { width: "80" }, "主键"),
                        createBaseVNode("th", { width: "80" }, "自增"),
                        createBaseVNode("th", null, "注释"),
                        createBaseVNode("th", { width: "100" }, "操作")
                      ])
                    ], -1)),
                    createBaseVNode("tbody", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(formData.value.columns, (column, index) => {
                        return openBlock(), createElementBlock("tr", { key: index }, [
                          createBaseVNode("td", null, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": ($event) => column.name = $event,
                              type: "text",
                              class: "form-control form-control-sm",
                              placeholder: "字段名"
                            }, null, 8, _hoisted_15$5), [
                              [vModelText, column.name]
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            withDirectives(createBaseVNode("select", {
                              "onUpdate:modelValue": ($event) => column.type = $event,
                              class: "form-select form-select-sm"
                            }, [
                              _cache[9] || (_cache[9] = createBaseVNode("option", { value: "" }, "选择类型", -1)),
                              (openBlock(true), createElementBlock(Fragment, null, renderList(columnTypesByCategory.value, (types2, category) => {
                                return openBlock(), createElementBlock("optgroup", {
                                  key: category,
                                  label: getCategoryLabel(category)
                                }, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(types2, (type) => {
                                    return openBlock(), createElementBlock("option", {
                                      key: type.name,
                                      value: type.name
                                    }, toDisplayString(type.label), 9, _hoisted_18$5);
                                  }), 128))
                                ], 8, _hoisted_17$5);
                              }), 128))
                            ], 8, _hoisted_16$5), [
                              [vModelSelect, column.type]
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            needsLength(column) || needsPrecision(column) ? (openBlock(), createElementBlock("div", _hoisted_19$4, [
                              needsLength(column) ? withDirectives((openBlock(), createElementBlock("input", {
                                key: 0,
                                "onUpdate:modelValue": ($event) => column.length = $event,
                                type: "number",
                                class: "form-control form-control-sm",
                                placeholder: "长度"
                              }, null, 8, _hoisted_20$4)), [
                                [vModelText, column.length]
                              ]) : createCommentVNode("", true),
                              needsPrecision(column) ? withDirectives((openBlock(), createElementBlock("input", {
                                key: 1,
                                "onUpdate:modelValue": ($event) => column.precision = $event,
                                type: "number",
                                class: "form-control form-control-sm",
                                placeholder: "精度"
                              }, null, 8, _hoisted_21$4)), [
                                [vModelText, column.precision]
                              ]) : createCommentVNode("", true),
                              needsScale(column) ? withDirectives((openBlock(), createElementBlock("input", {
                                key: 2,
                                "onUpdate:modelValue": ($event) => column.scale = $event,
                                type: "number",
                                class: "form-control form-control-sm",
                                placeholder: "小数"
                              }, null, 8, _hoisted_22$4)), [
                                [vModelText, column.scale]
                              ]) : createCommentVNode("", true)
                            ])) : (openBlock(), createElementBlock("span", _hoisted_23$4, "-"))
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_24$4, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": ($event) => column.nullable = $event,
                                type: "checkbox",
                                class: "form-check-input"
                              }, null, 8, _hoisted_25$4), [
                                [vModelCheckbox, column.nullable]
                              ])
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": ($event) => column.defaultValue = $event,
                              type: "text",
                              class: "form-control form-control-sm",
                              placeholder: "默认值"
                            }, null, 8, _hoisted_26$4), [
                              [vModelText, column.defaultValue]
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_27$4, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": ($event) => column.isPrimary = $event,
                                type: "checkbox",
                                class: "form-check-input",
                                onChange: ($event) => onPrimaryKeyChange(column, index)
                              }, null, 40, _hoisted_28$4), [
                                [vModelCheckbox, column.isPrimary]
                              ])
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_29$3, [
                              withDirectives(createBaseVNode("input", {
                                "onUpdate:modelValue": ($event) => column.isAutoIncrement = $event,
                                type: "checkbox",
                                class: "form-check-input",
                                disabled: !column.isPrimary || !supportsAutoIncrement(column)
                              }, null, 8, _hoisted_30$3), [
                                [vModelCheckbox, column.isAutoIncrement]
                              ])
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            withDirectives(createBaseVNode("input", {
                              "onUpdate:modelValue": ($event) => column.comment = $event,
                              type: "text",
                              class: "form-control form-control-sm",
                              placeholder: "字段注释"
                            }, null, 8, _hoisted_31$3), [
                              [vModelText, column.comment]
                            ])
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("button", {
                              class: "btn btn-outline-danger btn-sm",
                              onClick: ($event) => removeColumn(index),
                              disabled: formData.value.columns.length <= 1
                            }, [..._cache[10] || (_cache[10] = [
                              createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                            ])], 8, _hoisted_32$3)
                          ])
                        ]);
                      }), 128))
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_33$3, [
                _cache[12] || (_cache[12] = createBaseVNode("h6", { class: "section-title" }, "SQL预览", -1)),
                createBaseVNode("pre", _hoisted_34$3, toDisplayString(generateSQL()), 1)
              ])
            ]),
            createBaseVNode("div", { class: "modal-footer" }, [
              createBaseVNode("button", {
                type: "button",
                class: "btn btn-secondary",
                onClick: close
              }, "取消"),
              createBaseVNode("button", {
                type: "button",
                class: "btn btn-primary",
                onClick: submit
              }, "保存")
            ])
          ])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});
const TableEditor = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-3648f2dc"]]);
const _hoisted_1$4 = { class: "db-tools" };
const _hoisted_2$4 = { class: "modal-dialog" };
const _hoisted_3$4 = { class: "modal-content" };
const _hoisted_4$4 = { class: "modal-body" };
const _hoisted_5$4 = { class: "mb-3" };
const _hoisted_6$4 = {
  key: 0,
  class: "alert alert-info"
};
const _hoisted_7$4 = { class: "mb-3 form-check" };
const _hoisted_8$4 = { class: "modal-footer" };
const _hoisted_9$4 = ["disabled"];
const _hoisted_10$4 = {
  key: 0,
  class: "spinner-border spinner-border-sm me-2"
};
const _hoisted_11$4 = { class: "modal-dialog modal-lg" };
const _hoisted_12$4 = { class: "modal-content" };
const _hoisted_13$4 = { class: "modal-body" };
const _hoisted_14$4 = {
  key: 0,
  class: "text-center py-4"
};
const _hoisted_15$4 = { key: 1 };
const _hoisted_16$4 = { class: "health-results" };
const _hoisted_17$4 = { class: "health-status" };
const _hoisted_18$4 = { class: "health-message text-wrap" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "db-tools",
  props: {
    connection: {},
    database: {}
  },
  emits: ["execute-sql"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const databaseService2 = new DatabaseService();
    const restoreModalVisible = ref(false);
    const healthModalVisible = ref(false);
    const selectedFile = ref(null);
    const restoring = ref(false);
    const healthChecking = ref(false);
    const healthResults = ref([]);
    const restoreOptions = ref({
      dropExisting: false
    });
    async function backupDatabase() {
      try {
        const res = await databaseService2.backupDatabase(props.connection?.id || "", props.database);
        if (res.ret === 0) await modal.success("数据库备份成功");
        else {
          modal.error(res.msg || "备份失败", {
            operation: "BACKUP",
            database: props.database
          });
        }
      } catch (error) {
        console.error("备份失败:", error);
        modal.error(error.msg || error.message || "备份失败", {
          operation: "BACKUP",
          database: props.database,
          //options: backupOptions.value,
          stack: error.stack
        });
      }
    }
    function showUsersList() {
      modal.info("用户列表功能开发中...");
    }
    function showCreateUserModal() {
      modal.info("创建用户功能开发中...");
    }
    function showPermissionsModal() {
      modal.info("权限管理功能开发中...");
    }
    function showProcessList() {
      const sql2 = "SHOW PROCESSLIST";
      emit("execute-sql", sql2);
    }
    function showSlowQueries() {
      const sql2 = "SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10";
      emit("execute-sql", sql2);
    }
    function showConnectionsList() {
      const sql2 = 'SHOW STATUS LIKE "Threads_connected"';
      emit("execute-sql", sql2);
    }
    async function optimizeDatabase() {
      try {
        await databaseService2.optimizeDatabase(props.connection?.id || "", props.database);
        await modal.success("数据库优化完成");
      } catch (error) {
        console.error("优化失败:", error);
        modal.error(error.msg || error.message || "优化失败", {
          operation: "OPTIMIZE",
          database: props.database,
          //options: optimizationOptions.value,
          stack: error.stack
        });
      }
    }
    async function analyzeTables() {
      try {
        await databaseService2.analyzeTables(props.connection?.id || "", props.database);
        await modal.success("表分析完成");
      } catch (error) {
        console.error("分析失败:", error);
        modal.error(error.msg || error.message || "分析失败", {
          operation: "ANALYZE",
          database: props.database,
          //options: analysisOptions.value,
          stack: error.stack
        });
      }
    }
    async function repairTables() {
      try {
        await databaseService2.repairTables(props.connection?.id || "", props.database);
        await modal.success("表修复完成");
      } catch (error) {
        console.error("修复失败:", error);
        modal.error(error.msg || error.message || "修复失败", {
          operation: "REPAIR",
          database: props.database,
          //options: repairOptions.value,
          stack: error.stack
        });
      }
    }
    async function clearLogs() {
      const logs = [
        "TRUNCATE TABLE mysql.slow_log",
        "TRUNCATE TABLE mysql.general_log",
        "FLUSH LOGS"
      ];
      logs.forEach((sql2) => emit("execute-sql", sql2));
      await modal.success("日志清理完成");
    }
    function showExportModal() {
      modal.info("导出结构功能开发中...");
    }
    function showImportModal() {
      modal.info("导入数据功能开发中...");
    }
    function showSyncModal() {
      modal.info("数据同步功能开发中...");
    }
    async function runHealthCheck() {
      healthChecking.value = true;
      healthResults.value = [];
      try {
        const checks = [
          { name: "连接状态", sql: "SELECT 1 as status" },
          { name: "表完整性", sql: 'SELECT COUNT(*) as status FROM information_schema.tables WHERE table_schema = DATABASE() AND table_type = "BASE TABLE"' },
          { name: "索引状态", sql: "SELECT COUNT(*) as status FROM information_schema.statistics WHERE table_schema = DATABASE()" },
          { name: "磁盘空间", sql: "SELECT SUM(data_length + index_length) as status FROM information_schema.tables WHERE table_schema = DATABASE()" }
        ];
        for (const check of checks) {
          try {
            healthResults.value.push({
              name: check.name,
              status: "healthy",
              message: "正常"
            });
          } catch (error) {
            healthResults.value.push({
              name: check.name,
              status: "error",
              message: error.message
            });
          }
        }
        healthModalVisible.value = true;
      } finally {
        healthChecking.value = false;
      }
    }
    function showStatistics() {
      const sql2 = `
    SELECT 
      table_name as '表名',
      table_rows as '记录数',
      ROUND(((data_length + index_length) / 1024 / 1024), 2) as '大小(MB)'
    FROM information_schema.tables 
    WHERE table_schema = DATABASE() 
    ORDER BY (data_length + index_length) DESC
  `;
      emit("execute-sql", sql2);
    }
    function showAuditLog() {
      const sql2 = "SELECT * FROM mysql.general_log ORDER BY event_time DESC LIMIT 100";
      emit("execute-sql", sql2);
    }
    function showRestoreModal() {
      restoreModalVisible.value = true;
    }
    function closeRestoreModal() {
      restoreModalVisible.value = false;
      selectedFile.value = null;
    }
    async function performRestore() {
      if (!selectedFile.value) return;
      try {
        restoring.value = true;
        const filePath = selectedFile.value.name;
        await databaseService2.restoreDatabase(
          props.connection?.id || "",
          props.database,
          filePath,
          { dropExisting: restoreOptions.value.dropExisting }
        );
        await modal.success("数据库恢复成功");
        closeRestoreModal();
      } catch (error) {
        console.error("恢复失败:", error);
        modal.error(error.msg || error.message || "恢复失败", {
          operation: "RESTORE",
          database: props.database,
          //file: restoreFile.value,
          stack: error.stack
        });
      } finally {
        restoring.value = false;
      }
    }
    function closeHealthModal() {
      healthModalVisible.value = false;
      healthResults.value = [];
    }
    function showScheduleModal() {
      modal.info("定时备份功能开发中...");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        _cache[33] || (_cache[33] = createBaseVNode("div", { class: "tools-header" }, [
          createBaseVNode("h5", { class: "tools-title" }, [
            createBaseVNode("i", { class: "bi bi-tools" }),
            createTextVNode(" 数据库管理工具 ")
          ])
        ], -1)),
        createBaseVNode("div", { class: "tools-content" }, [
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[5] || (_cache[5] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-shield-check" }),
              createTextVNode(" 数据备份 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-primary btn-sm",
                onClick: backupDatabase
              }, [..._cache[2] || (_cache[2] = [
                createBaseVNode("i", { class: "bi bi-download" }, null, -1),
                createTextVNode(" 备份数据库 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-secondary btn-sm",
                onClick: showRestoreModal
              }, [..._cache[3] || (_cache[3] = [
                createBaseVNode("i", { class: "bi bi-upload" }, null, -1),
                createTextVNode(" 恢复数据库 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-info btn-sm",
                onClick: showScheduleModal
              }, [..._cache[4] || (_cache[4] = [
                createBaseVNode("i", { class: "bi bi-clock" }, null, -1),
                createTextVNode(" 定时备份 ", -1)
              ])])
            ])
          ]),
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[9] || (_cache[9] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-people" }),
              createTextVNode(" 用户管理 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-success btn-sm",
                onClick: showUsersList
              }, [..._cache[6] || (_cache[6] = [
                createBaseVNode("i", { class: "bi bi-person-lines-fill" }, null, -1),
                createTextVNode(" 用户列表 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-primary btn-sm",
                onClick: showCreateUserModal
              }, [..._cache[7] || (_cache[7] = [
                createBaseVNode("i", { class: "bi bi-person-plus" }, null, -1),
                createTextVNode(" 创建用户 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-warning btn-sm",
                onClick: showPermissionsModal
              }, [..._cache[8] || (_cache[8] = [
                createBaseVNode("i", { class: "bi bi-key" }, null, -1),
                createTextVNode(" 权限管理 ", -1)
              ])])
            ])
          ]),
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[13] || (_cache[13] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-speedometer2" }),
              createTextVNode(" 性能监控 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-info btn-sm",
                onClick: showProcessList
              }, [..._cache[10] || (_cache[10] = [
                createBaseVNode("i", { class: "bi bi-activity" }, null, -1),
                createTextVNode(" 进程列表 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-warning btn-sm",
                onClick: showSlowQueries
              }, [..._cache[11] || (_cache[11] = [
                createBaseVNode("i", { class: "bi bi-hourglass-split" }, null, -1),
                createTextVNode(" 慢查询 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-danger btn-sm",
                onClick: showConnectionsList
              }, [..._cache[12] || (_cache[12] = [
                createBaseVNode("i", { class: "bi bi-diagram-3" }, null, -1),
                createTextVNode(" 连接数 ", -1)
              ])])
            ])
          ]),
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[18] || (_cache[18] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-gear-wide-connected" }),
              createTextVNode(" 数据库优化 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-success btn-sm",
                onClick: optimizeDatabase
              }, [..._cache[14] || (_cache[14] = [
                createBaseVNode("i", { class: "bi bi-lightning-charge" }, null, -1),
                createTextVNode(" 优化数据库 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-primary btn-sm",
                onClick: analyzeTables
              }, [..._cache[15] || (_cache[15] = [
                createBaseVNode("i", { class: "bi bi-search" }, null, -1),
                createTextVNode(" 分析表 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-secondary btn-sm",
                onClick: repairTables
              }, [..._cache[16] || (_cache[16] = [
                createBaseVNode("i", { class: "bi bi-tools" }, null, -1),
                createTextVNode(" 修复表 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-info btn-sm",
                onClick: clearLogs
              }, [..._cache[17] || (_cache[17] = [
                createBaseVNode("i", { class: "bi bi-trash" }, null, -1),
                createTextVNode(" 清理日志 ", -1)
              ])])
            ])
          ]),
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[22] || (_cache[22] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-arrow-left-right" }),
              createTextVNode(" 数据迁移 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-primary btn-sm",
                onClick: showExportModal
              }, [..._cache[19] || (_cache[19] = [
                createBaseVNode("i", { class: "bi bi-box-arrow-up-right" }, null, -1),
                createTextVNode(" 导出结构 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-success btn-sm",
                onClick: showImportModal
              }, [..._cache[20] || (_cache[20] = [
                createBaseVNode("i", { class: "bi bi-box-arrow-in-down" }, null, -1),
                createTextVNode(" 导入数据 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-warning btn-sm",
                onClick: showSyncModal
              }, [..._cache[21] || (_cache[21] = [
                createBaseVNode("i", { class: "bi bi-arrow-repeat" }, null, -1),
                createTextVNode(" 数据同步 ", -1)
              ])])
            ])
          ]),
          createBaseVNode("div", { class: "tool-section" }, [
            _cache[26] || (_cache[26] = createBaseVNode("h6", { class: "section-title" }, [
              createBaseVNode("i", { class: "bi bi-heart-pulse" }),
              createTextVNode(" 健康检查 ")
            ], -1)),
            createBaseVNode("div", { class: "tool-actions" }, [
              createBaseVNode("button", {
                class: "btn btn-outline-info btn-sm",
                onClick: runHealthCheck
              }, [..._cache[23] || (_cache[23] = [
                createBaseVNode("i", { class: "bi bi-clipboard-check" }, null, -1),
                createTextVNode(" 健康检查 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-secondary btn-sm",
                onClick: showStatistics
              }, [..._cache[24] || (_cache[24] = [
                createBaseVNode("i", { class: "bi bi-bar-chart" }, null, -1),
                createTextVNode(" 数据统计 ", -1)
              ])]),
              createBaseVNode("button", {
                class: "btn btn-outline-warning btn-sm",
                onClick: showAuditLog
              }, [..._cache[25] || (_cache[25] = [
                createBaseVNode("i", { class: "bi bi-journal-text" }, null, -1),
                createTextVNode(" 审计日志 ", -1)
              ])])
            ])
          ])
        ]),
        createBaseVNode("div", {
          class: normalizeClass(["modal fade", { show: restoreModalVisible.value }]),
          style: normalizeStyle({ display: restoreModalVisible.value ? "block" : "none", zIndex: 1055 })
        }, [
          createBaseVNode("div", _hoisted_2$4, [
            createBaseVNode("div", _hoisted_3$4, [
              createBaseVNode("div", { class: "modal-header" }, [
                _cache[27] || (_cache[27] = createBaseVNode("h5", { class: "modal-title" }, "恢复数据库", -1)),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: closeRestoreModal
                })
              ]),
              createBaseVNode("div", _hoisted_4$4, [
                _cache[29] || (_cache[29] = createBaseVNode("p", null, "请选择要恢复的备份文件：", -1)),
                createBaseVNode("div", _hoisted_5$4, [
                  createBaseVNode("input", {
                    type: "file",
                    class: "form-control",
                    onChange: _cache[0] || (_cache[0] = //@ts-ignore
                    (...args) => _ctx.handleFileChange && _ctx.handleFileChange(...args)),
                    accept: ".sql,.bak"
                  }, null, 32)
                ]),
                selectedFile.value ? (openBlock(), createElementBlock("div", _hoisted_6$4, " 已选择文件：" + toDisplayString(selectedFile.value.name), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_7$4, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    class: "form-check-input",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => restoreOptions.value.dropExisting = $event),
                    id: "dropExisting"
                  }, null, 512), [
                    [vModelCheckbox, restoreOptions.value.dropExisting]
                  ]),
                  _cache[28] || (_cache[28] = createBaseVNode("label", {
                    class: "form-check-label",
                    for: "dropExisting"
                  }, "删除现有表", -1))
                ])
              ]),
              createBaseVNode("div", _hoisted_8$4, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: closeRestoreModal
                }, "取消"),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-primary",
                  onClick: performRestore,
                  disabled: !selectedFile.value
                }, [
                  restoring.value ? (openBlock(), createElementBlock("span", _hoisted_10$4)) : createCommentVNode("", true),
                  _cache[30] || (_cache[30] = createTextVNode(" 恢复 ", -1))
                ], 8, _hoisted_9$4)
              ])
            ])
          ])
        ], 6),
        createBaseVNode("div", {
          class: normalizeClass(["modal fade", { show: healthModalVisible.value }]),
          style: normalizeStyle({ display: healthModalVisible.value ? "block" : "none", zIndex: 1055 })
        }, [
          createBaseVNode("div", _hoisted_11$4, [
            createBaseVNode("div", _hoisted_12$4, [
              createBaseVNode("div", { class: "modal-header" }, [
                _cache[31] || (_cache[31] = createBaseVNode("h5", { class: "modal-title" }, "数据库健康检查", -1)),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: closeHealthModal
                })
              ]),
              createBaseVNode("div", _hoisted_13$4, [
                healthChecking.value ? (openBlock(), createElementBlock("div", _hoisted_14$4, [..._cache[32] || (_cache[32] = [
                  createBaseVNode("div", {
                    class: "spinner-border text-primary",
                    role: "status"
                  }, null, -1),
                  createBaseVNode("div", { class: "mt-3" }, "正在检查数据库健康状况...", -1)
                ])])) : (openBlock(), createElementBlock("div", _hoisted_15$4, [
                  createBaseVNode("div", _hoisted_16$4, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(healthResults.value, (check) => {
                      return openBlock(), createElementBlock("div", {
                        key: check.name,
                        class: "health-item"
                      }, [
                        createBaseVNode("div", _hoisted_17$4, [
                          createBaseVNode("i", {
                            class: normalizeClass(check.status === "healthy" ? "bi bi-check-circle-fill text-success" : check.status === "warning" ? "bi bi-exclamation-triangle-fill text-warning" : "bi bi-x-circle-fill text-danger")
                          }, null, 2),
                          createTextVNode(" " + toDisplayString(check.name), 1)
                        ]),
                        createBaseVNode("div", _hoisted_18$4, toDisplayString(check.message), 1)
                      ]);
                    }), 128))
                  ])
                ]))
              ]),
              createBaseVNode("div", { class: "modal-footer" }, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: closeHealthModal
                }, "关闭")
              ])
            ])
          ])
        ], 6)
      ]);
    };
  }
});
const DbTools = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-94a9d8f2"]]);
const _hoisted_1$3 = { class: "database-detail" };
const _hoisted_2$3 = { class: "database-header" };
const _hoisted_3$3 = { class: "database-header-content" };
const _hoisted_4$3 = { class: "database-info" };
const _hoisted_5$3 = { class: "database-meta" };
const _hoisted_6$3 = { class: "database-name" };
const _hoisted_7$3 = { class: "connection-info" };
const _hoisted_8$3 = { class: "connection-name" };
const _hoisted_9$3 = { class: "connection-type" };
const _hoisted_10$3 = { class: "database-stats" };
const _hoisted_11$3 = { class: "stat-item" };
const _hoisted_12$3 = { class: "stat-value" };
const _hoisted_13$3 = { class: "stat-item" };
const _hoisted_14$3 = { class: "stat-value" };
const _hoisted_15$3 = { class: "database-tabs" };
const _hoisted_16$3 = { class: "nav nav-tabs" };
const _hoisted_17$3 = { class: "nav-item" };
const _hoisted_18$3 = { class: "nav-item" };
const _hoisted_19$3 = { class: "nav-item" };
const _hoisted_20$3 = { class: "nav-item" };
const _hoisted_21$3 = { class: "nav-item" };
const _hoisted_22$3 = { class: "tab-content" };
const _hoisted_23$3 = { class: "tab-panel" };
const _hoisted_24$3 = {
  key: 0,
  class: "loading-state"
};
const _hoisted_25$3 = { key: 1 };
const _hoisted_26$3 = { class: "table-grid" };
const _hoisted_27$3 = ["onClick"];
const _hoisted_28$3 = { class: "card-header" };
const _hoisted_29$2 = { class: "table-info" };
const _hoisted_30$2 = { class: "table-name" };
const _hoisted_31$2 = { class: "table-engine" };
const _hoisted_32$2 = { class: "card-body" };
const _hoisted_33$2 = { class: "table-stats" };
const _hoisted_34$2 = { class: "stat" };
const _hoisted_35$2 = { class: "stat-value" };
const _hoisted_36$2 = { class: "stat" };
const _hoisted_37$2 = { class: "stat-value" };
const _hoisted_38$2 = {
  key: 0,
  class: "table-comment"
};
const _hoisted_39$2 = { class: "table-actions" };
const _hoisted_40$2 = ["onClick"];
const _hoisted_41$1 = {
  key: 0,
  class: "empty-state"
};
const _hoisted_42$1 = { class: "tab-panel" };
const _hoisted_43$1 = {
  key: 0,
  class: "views-grid"
};
const _hoisted_44$1 = { class: "card-header" };
const _hoisted_45$1 = { class: "view-info" };
const _hoisted_46$1 = { class: "view-name" };
const _hoisted_47$1 = {
  key: 0,
  class: "view-comment"
};
const _hoisted_48$1 = { class: "card-body" };
const _hoisted_49$1 = { class: "view-actions" };
const _hoisted_50$1 = ["onClick"];
const _hoisted_51$1 = ["onClick"];
const _hoisted_52$1 = {
  key: 1,
  class: "empty-state"
};
const _hoisted_53$1 = { class: "tab-panel" };
const _hoisted_54$1 = {
  key: 0,
  class: "procedures-grid"
};
const _hoisted_55$1 = { class: "card-header" };
const _hoisted_56$1 = { class: "procedure-info" };
const _hoisted_57$1 = { class: "procedure-name" };
const _hoisted_58$1 = {
  key: 0,
  class: "procedure-comment"
};
const _hoisted_59$1 = { class: "procedure-type" };
const _hoisted_60$1 = { class: "badge bg-info" };
const _hoisted_61$1 = {
  key: 0,
  class: "badge bg-secondary ms-1"
};
const _hoisted_62$1 = { class: "card-body" };
const _hoisted_63$1 = { class: "procedure-actions" };
const _hoisted_64$1 = ["onClick"];
const _hoisted_65$1 = ["onClick"];
const _hoisted_66$1 = {
  key: 1,
  class: "empty-state"
};
const _hoisted_67$1 = { class: "tab-panel" };
const _hoisted_68$1 = { class: "tab-panel" };
const _hoisted_69$1 = { class: "sql-executor-section" };
const _hoisted_70$1 = { class: "tab-panel" };
const _hoisted_71$1 = {
  key: 0,
  class: "modal fade show d-block",
  style: { "background": "rgba(0,0,0,0.5)" }
};
const _hoisted_72$1 = { class: "modal-dialog modal-lg" };
const _hoisted_73$1 = { class: "modal-content" };
const _hoisted_74$1 = { class: "modal-header" };
const _hoisted_75$1 = { class: "modal-body" };
const _hoisted_76$1 = { class: "mb-3" };
const _hoisted_77$1 = { class: "mb-3" };
const _hoisted_78$1 = { class: "modal-footer" };
const _hoisted_79$1 = {
  key: 1,
  class: "modal fade show d-block",
  style: { "background": "rgba(0,0,0,0.5)" }
};
const _hoisted_80$1 = { class: "modal-dialog modal-lg" };
const _hoisted_81$1 = { class: "modal-content" };
const _hoisted_82$1 = { class: "modal-header" };
const _hoisted_83$1 = { class: "modal-title" };
const _hoisted_84$1 = { class: "modal-body" };
const _hoisted_85$1 = { class: "mb-3" };
const _hoisted_86$1 = { class: "mb-3" };
const _hoisted_87$1 = { class: "mb-3" };
const _hoisted_88 = { class: "modal-footer" };
const _hoisted_89 = {
  key: 2,
  class: "modal fade show d-block",
  style: { "background": "rgba(0,0,0,0.5)" }
};
const _hoisted_90 = { class: "modal-dialog modal-lg" };
const _hoisted_91 = { class: "modal-content" };
const _hoisted_92 = { class: "modal-header" };
const _hoisted_93 = { class: "modal-title" };
const _hoisted_94 = { class: "modal-body" };
const _hoisted_95 = { class: "mb-3" };
const _hoisted_96 = { class: "mb-3" };
const _hoisted_97 = { class: "mb-3" };
const _hoisted_98 = { class: "modal-footer" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "database-detail",
  props: {
    connection: {},
    database: {},
    tables: {},
    databaseInfo: {},
    loading: { type: Boolean }
  },
  emits: ["select-table", "refresh-database", "create-table", "execute-sql"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const databaseService2 = new DatabaseService();
    const activeTab = ref("tables");
    const showCreateTable = ref(false);
    const showCreateView = ref(false);
    const showCreateProcedure = ref(false);
    const newTable = ref({ name: "", comment: "" });
    const views = ref([]);
    const editingView = ref(null);
    const procedures = ref([]);
    const editingProcedure = ref(null);
    const showTableEditor = ref(false);
    const editingTableName = ref("");
    const tables = computed(() => {
      const tbs = props.tables || [];
      return tbs;
    });
    function getDbTypeLabel(type) {
      const labelMap = {
        mysql: "MySQL",
        postgres: "PostgreSQL",
        sqlite: "SQLite",
        mssql: "SQL Server",
        oracle: "Oracle"
      };
      return labelMap[type || ""] || type || "";
    }
    function formatSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB", "TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }
    function formatNumber2(num) {
      return num.toLocaleString();
    }
    function selectTable(table) {
      emit("select-table", props.connection, props.database, table);
    }
    function handleRefreshDatabase() {
      emit("refresh-database");
    }
    function createTable() {
      if (!newTable.value.name.trim()) {
        return;
      }
      editingTableName.value = newTable.value.name;
      showTableEditor.value = true;
      showCreateTable.value = false;
    }
    function editTable(table) {
      editingTableName.value = table.name;
      showTableEditor.value = true;
    }
    function createNewTable() {
      editingTableName.value = "";
      showTableEditor.value = true;
    }
    function closeTableEditor() {
      showTableEditor.value = false;
      editingTableName.value = "";
    }
    onMounted(() => {
      if (props.connection?.id && props.database) {
        loadViews();
        loadProcedures();
      }
    });
    watch(() => [props.connection?.id, props.database], () => {
      if (props.connection?.id && props.database) {
        loadViews();
        loadProcedures();
      }
    });
    async function loadViews() {
      if (!props.connection?.id) return;
      try {
        const result = await databaseService2.getViews(props.connection.id, props.database);
        views.value = result.data || [];
      } catch (error) {
        console.error("加载视图失败:", error);
        views.value = [];
      }
    }
    async function refreshViews() {
      await loadViews();
    }
    function showCreateViewModal() {
      editingView.value = { name: "", definition: "", comment: "" };
      showCreateView.value = true;
    }
    async function editView(view) {
      try {
        const result = await databaseService2.getViewDefinition(props.connection?.id || "", props.database, view.name);
        editingView.value = {
          name: view.name,
          definition: result.data?.[0]?.definition || "",
          comment: view.comment
        };
        showCreateView.value = true;
      } catch (error) {
        console.error("获取视图定义失败:", error);
        modal.error("获取视图定义失败");
      }
    }
    async function createOrUpdateView() {
      if (!editingView.value?.name || !editingView.value?.definition) {
        modal.error("请填写视图名称和定义");
        return;
      }
      try {
        if (views.value.some((v) => v.name === editingView.value.name)) {
          await databaseService2.dropView(props.connection?.id || "", props.database, editingView.value.name);
        }
        const result = await databaseService2.createView(
          props.connection?.id || "",
          props.database,
          editingView.value.name,
          editingView.value.definition
        );
        if (result.success || result.ret === 0) {
          await modal.success("视图保存成功");
          showCreateView.value = false;
          editingView.value = null;
          await loadViews();
        } else {
          await modal.error("视图保存失败");
        }
      } catch (error) {
        console.error("保存视图失败:", error);
        const errorMsg = error instanceof Error ? error.message : String(error);
        modal.error(errorMsg || "保存视图失败");
      }
    }
    async function deleteView(view) {
      const result = await modal.confirm(`确定要删除视图 "${view.name}" 吗？此操作不可恢复。`);
      if (result) {
        try {
          const response = await databaseService2.dropView(props.connection?.id || "", props.database, view.name);
          if (response.success || response.ok) {
            await modal.success("视图删除成功");
            await loadViews();
          } else {
            await modal.error("视图删除失败");
          }
        } catch (error) {
          console.error("删除视图失败:", error);
          const errorMsg = error instanceof Error ? error.message : String(error);
          modal.error(errorMsg || "删除视图失败");
        }
      }
    }
    async function loadProcedures() {
      if (!props.connection?.id) return;
      try {
        const result = await databaseService2.getProcedures(props.connection.id, props.database);
        procedures.value = result.data || [];
      } catch (error) {
        console.error("加载存储过程失败:", error);
        procedures.value = [];
      }
    }
    async function refreshProcedures() {
      await loadProcedures();
    }
    function showCreateProcedureModal() {
      editingProcedure.value = { name: "", definition: "", comment: "" };
      showCreateProcedure.value = true;
    }
    async function editProcedure(procedure) {
      try {
        const result = await databaseService2.getProcedureDefinition(props.connection?.id || "", props.database, procedure.name);
        editingProcedure.value = {
          name: procedure.name,
          definition: result.data?.[0]?.definition || "",
          comment: procedure.comment
        };
        showCreateProcedure.value = true;
      } catch (error) {
        console.error("获取存储过程定义失败:", error);
        modal.error("获取存储过程定义失败");
      }
    }
    async function createOrUpdateProcedure() {
      if (!editingProcedure.value?.name || !editingProcedure.value?.definition) {
        modal.error("请填写存储过程名称和定义");
        return;
      }
      try {
        if (procedures.value.some((p) => p.name === editingProcedure.value.name)) {
          await databaseService2.dropProcedure(props.connection?.id || "", props.database, editingProcedure.value.name);
        }
        const result = await databaseService2.createProcedure(
          props.connection?.id || "",
          props.database,
          editingProcedure.value.name,
          editingProcedure.value.definition
        );
        if (result.success || result.ret === 0) {
          await modal.success("存储过程保存成功");
          showCreateProcedure.value = false;
          editingProcedure.value = null;
          await loadProcedures();
        } else {
          await modal.error("存储过程保存失败");
        }
      } catch (error) {
        console.error("保存存储过程失败:", error);
        const errorMsg = error instanceof Error ? error.message : String(error);
        modal.error(errorMsg || "保存存储过程失败");
      }
    }
    async function deleteProcedure(procedure) {
      const result = await modal.confirm(`确定要删除存储过程 "${procedure.name}" 吗？此操作不可恢复。`);
      if (result) {
        try {
          const response = await databaseService2.dropProcedure(props.connection?.id || "", props.database, procedure.name);
          if (response.success || response.ok) {
            await modal.success("存储过程删除成功");
            await loadProcedures();
          } else {
            await modal.error("存储过程删除失败");
          }
        } catch (error) {
          console.error("删除存储过程失败:", error);
          modal.error(error.message || "删除存储过程失败");
        }
      }
    }
    async function handleTableChange(result) {
      try {
        if (result.success) {
          emit("refresh-database");
          await modal.success("表结构修改成功");
        } else {
          await modal.error("表结构修改失败");
        }
      } catch (error) {
        console.error("处理表结构修改失败:", error);
        modal.error(error.msg || error.message || "表结构修改失败", {
          operation: "MODIFY_TABLE",
          stack: error.stack
        });
      }
    }
    function handleExecuteSQL(sql2) {
      emit("execute-sql", sql2);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", _hoisted_2$3, [
          createBaseVNode("div", _hoisted_3$3, [
            createBaseVNode("div", _hoisted_4$3, [
              _cache[19] || (_cache[19] = createBaseVNode("div", { class: "database-icon" }, [
                createBaseVNode("i", { class: "bi bi-database" })
              ], -1)),
              createBaseVNode("div", _hoisted_5$3, [
                createBaseVNode("h4", _hoisted_6$3, toDisplayString(__props.database), 1),
                createBaseVNode("div", _hoisted_7$3, [
                  createBaseVNode("span", _hoisted_8$3, toDisplayString(__props.connection?.name), 1),
                  createBaseVNode("span", _hoisted_9$3, toDisplayString(getDbTypeLabel(__props.connection?.type)), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_10$3, [
              createBaseVNode("div", _hoisted_11$3, [
                createBaseVNode("div", _hoisted_12$3, toDisplayString(__props.databaseInfo?.tableCount || 0), 1),
                _cache[20] || (_cache[20] = createBaseVNode("div", { class: "stat-label" }, "表", -1))
              ]),
              createBaseVNode("div", _hoisted_13$3, [
                createBaseVNode("div", _hoisted_14$3, toDisplayString(formatSize(__props.databaseInfo?.size || 0)), 1),
                _cache[21] || (_cache[21] = createBaseVNode("div", { class: "stat-label" }, "大小", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_15$3, [
          createBaseVNode("ul", _hoisted_16$3, [
            createBaseVNode("li", _hoisted_17$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "tables" }]),
                onClick: _cache[0] || (_cache[0] = ($event) => activeTab.value = "tables")
              }, [..._cache[22] || (_cache[22] = [
                createBaseVNode("i", { class: "bi bi-table" }, null, -1),
                createTextVNode(" 数据表 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_18$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "views" }]),
                onClick: _cache[1] || (_cache[1] = ($event) => activeTab.value = "views")
              }, [..._cache[23] || (_cache[23] = [
                createBaseVNode("i", { class: "bi bi-eye" }, null, -1),
                createTextVNode(" 视图 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_19$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "procedures" }]),
                onClick: _cache[2] || (_cache[2] = ($event) => activeTab.value = "procedures")
              }, [..._cache[24] || (_cache[24] = [
                createBaseVNode("i", { class: "bi bi-gear" }, null, -1),
                createTextVNode(" 存储过程 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_20$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "sql" }]),
                onClick: _cache[3] || (_cache[3] = ($event) => activeTab.value = "sql")
              }, [..._cache[25] || (_cache[25] = [
                createBaseVNode("i", { class: "bi bi-terminal" }, null, -1),
                createTextVNode(" 执行SQL ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_21$3, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "tools" }]),
                onClick: _cache[4] || (_cache[4] = ($event) => activeTab.value = "tools")
              }, [..._cache[26] || (_cache[26] = [
                createBaseVNode("i", { class: "bi bi-tools" }, null, -1),
                createTextVNode(" 工具 ", -1)
              ])], 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_22$3, [
            withDirectives(createBaseVNode("div", _hoisted_23$3, [
              createBaseVNode("div", { class: "tables-actions mb-3" }, [
                createBaseVNode("button", {
                  class: "btn btn-primary btn-sm",
                  onClick: createNewTable
                }, [..._cache[27] || (_cache[27] = [
                  createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
                  createTextVNode(" 创建表 ", -1)
                ])]),
                createBaseVNode("button", {
                  class: "btn btn-outline-secondary btn-sm",
                  onClick: handleRefreshDatabase
                }, [..._cache[28] || (_cache[28] = [
                  createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1),
                  createTextVNode(" 刷新 ", -1)
                ])])
              ]),
              __props.loading ? (openBlock(), createElementBlock("div", _hoisted_24$3, [..._cache[29] || (_cache[29] = [
                createBaseVNode("div", {
                  class: "spinner-border",
                  role: "status"
                }, [
                  createBaseVNode("span", { class: "visually-hidden" }, "加载中...")
                ], -1),
                createBaseVNode("p", null, "加载数据表中...", -1)
              ])])) : (openBlock(), createElementBlock("div", _hoisted_25$3, [
                createBaseVNode("div", _hoisted_26$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(tables.value, (table) => {
                    return openBlock(), createElementBlock("div", {
                      key: table.name,
                      class: "table-card",
                      onClick: ($event) => selectTable(table)
                    }, [
                      createBaseVNode("div", _hoisted_28$3, [
                        _cache[30] || (_cache[30] = createBaseVNode("div", { class: "table-icon" }, [
                          createBaseVNode("i", { class: "bi bi-table" })
                        ], -1)),
                        createBaseVNode("div", _hoisted_29$2, [
                          createBaseVNode("div", _hoisted_30$2, toDisplayString(table.name), 1),
                          createBaseVNode("div", _hoisted_31$2, toDisplayString(table.engine || "-"), 1)
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32$2, [
                        createBaseVNode("div", _hoisted_33$2, [
                          createBaseVNode("div", _hoisted_34$2, [
                            _cache[31] || (_cache[31] = createBaseVNode("span", { class: "stat-label" }, "行数", -1)),
                            createBaseVNode("span", _hoisted_35$2, toDisplayString(formatNumber2(table.rowCount || 0)), 1)
                          ]),
                          createBaseVNode("div", _hoisted_36$2, [
                            _cache[32] || (_cache[32] = createBaseVNode("span", { class: "stat-label" }, "大小", -1)),
                            createBaseVNode("span", _hoisted_37$2, toDisplayString(formatSize(table.dataSize || 0)), 1)
                          ])
                        ]),
                        table.comment ? (openBlock(), createElementBlock("div", _hoisted_38$2, toDisplayString(table.comment), 1)) : createCommentVNode("", true),
                        createBaseVNode("div", _hoisted_39$2, [
                          createBaseVNode("button", {
                            class: "btn btn-sm btn-outline-primary",
                            onClick: withModifiers(($event) => editTable(table), ["stop"])
                          }, [..._cache[33] || (_cache[33] = [
                            createBaseVNode("i", { class: "bi bi-pencil" }, null, -1)
                          ])], 8, _hoisted_40$2)
                        ])
                      ])
                    ], 8, _hoisted_27$3);
                  }), 128))
                ]),
                !tables.value || tables.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_41$1, [
                  _cache[35] || (_cache[35] = createBaseVNode("i", { class: "bi bi-inbox" }, null, -1)),
                  _cache[36] || (_cache[36] = createBaseVNode("p", null, "暂无数据表", -1)),
                  createBaseVNode("button", {
                    class: "btn btn-primary",
                    onClick: createNewTable
                  }, [..._cache[34] || (_cache[34] = [
                    createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                    createTextVNode(" 创建表 ", -1)
                  ])])
                ])) : createCommentVNode("", true)
              ]))
            ], 512), [
              [vShow, activeTab.value === "tables"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_42$1, [
              createBaseVNode("div", { class: "views-actions mb-3" }, [
                createBaseVNode("button", {
                  class: "btn btn-success btn-sm",
                  onClick: showCreateViewModal
                }, [..._cache[37] || (_cache[37] = [
                  createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
                  createTextVNode(" 创建视图 ", -1)
                ])]),
                createBaseVNode("button", {
                  class: "btn btn-info btn-sm",
                  onClick: refreshViews
                }, [..._cache[38] || (_cache[38] = [
                  createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1),
                  createTextVNode(" 刷新 ", -1)
                ])])
              ]),
              views.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_43$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(views.value, (view) => {
                  return openBlock(), createElementBlock("div", {
                    key: view.name,
                    class: "view-card"
                  }, [
                    createBaseVNode("div", _hoisted_44$1, [
                      _cache[39] || (_cache[39] = createBaseVNode("div", { class: "view-icon" }, [
                        createBaseVNode("i", { class: "bi bi-eye" })
                      ], -1)),
                      createBaseVNode("div", _hoisted_45$1, [
                        createBaseVNode("div", _hoisted_46$1, toDisplayString(view.name), 1),
                        view.comment ? (openBlock(), createElementBlock("div", _hoisted_47$1, toDisplayString(view.comment), 1)) : createCommentVNode("", true)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_48$1, [
                      createBaseVNode("div", _hoisted_49$1, [
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-outline-primary",
                          onClick: ($event) => editView(view)
                        }, [..._cache[40] || (_cache[40] = [
                          createBaseVNode("i", { class: "bi bi-pencil" }, null, -1),
                          createTextVNode(" 编辑 ", -1)
                        ])], 8, _hoisted_50$1),
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-outline-danger",
                          onClick: ($event) => deleteView(view)
                        }, [..._cache[41] || (_cache[41] = [
                          createBaseVNode("i", { class: "bi bi-trash" }, null, -1),
                          createTextVNode(" 删除 ", -1)
                        ])], 8, _hoisted_51$1)
                      ])
                    ])
                  ]);
                }), 128))
              ])) : (openBlock(), createElementBlock("div", _hoisted_52$1, [
                _cache[43] || (_cache[43] = createBaseVNode("i", { class: "bi bi-eye" }, null, -1)),
                _cache[44] || (_cache[44] = createBaseVNode("p", null, "暂无视图", -1)),
                createBaseVNode("button", {
                  class: "btn btn-success",
                  onClick: showCreateViewModal
                }, [..._cache[42] || (_cache[42] = [
                  createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                  createTextVNode(" 创建视图 ", -1)
                ])])
              ]))
            ], 512), [
              [vShow, activeTab.value === "views"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_53$1, [
              createBaseVNode("div", { class: "procedures-actions mb-3" }, [
                createBaseVNode("button", {
                  class: "btn btn-info btn-sm",
                  onClick: showCreateProcedureModal
                }, [..._cache[45] || (_cache[45] = [
                  createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
                  createTextVNode(" 创建存储过程 ", -1)
                ])]),
                createBaseVNode("button", {
                  class: "btn btn-info btn-sm",
                  onClick: refreshProcedures
                }, [..._cache[46] || (_cache[46] = [
                  createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1),
                  createTextVNode(" 刷新 ", -1)
                ])])
              ]),
              procedures.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_54$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(procedures.value, (procedure) => {
                  return openBlock(), createElementBlock("div", {
                    key: procedure.name,
                    class: "procedure-card"
                  }, [
                    createBaseVNode("div", _hoisted_55$1, [
                      _cache[47] || (_cache[47] = createBaseVNode("div", { class: "procedure-icon" }, [
                        createBaseVNode("i", { class: "bi bi-gear" })
                      ], -1)),
                      createBaseVNode("div", _hoisted_56$1, [
                        createBaseVNode("div", _hoisted_57$1, toDisplayString(procedure.name), 1),
                        procedure.comment ? (openBlock(), createElementBlock("div", _hoisted_58$1, toDisplayString(procedure.comment), 1)) : createCommentVNode("", true),
                        createBaseVNode("div", _hoisted_59$1, [
                          createBaseVNode("span", _hoisted_60$1, toDisplayString(procedure.type), 1),
                          procedure.returnType ? (openBlock(), createElementBlock("span", _hoisted_61$1, toDisplayString(procedure.returnType), 1)) : createCommentVNode("", true)
                        ])
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_62$1, [
                      createBaseVNode("div", _hoisted_63$1, [
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-outline-primary",
                          onClick: ($event) => editProcedure(procedure)
                        }, [..._cache[48] || (_cache[48] = [
                          createBaseVNode("i", { class: "bi bi-pencil" }, null, -1),
                          createTextVNode(" 编辑 ", -1)
                        ])], 8, _hoisted_64$1),
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-outline-danger",
                          onClick: ($event) => deleteProcedure(procedure)
                        }, [..._cache[49] || (_cache[49] = [
                          createBaseVNode("i", { class: "bi bi-trash" }, null, -1),
                          createTextVNode(" 删除 ", -1)
                        ])], 8, _hoisted_65$1)
                      ])
                    ])
                  ]);
                }), 128))
              ])) : (openBlock(), createElementBlock("div", _hoisted_66$1, [
                _cache[51] || (_cache[51] = createBaseVNode("i", { class: "bi bi-gear" }, null, -1)),
                _cache[52] || (_cache[52] = createBaseVNode("p", null, "暂无存储过程", -1)),
                createBaseVNode("button", {
                  class: "btn btn-info",
                  onClick: showCreateProcedureModal
                }, [..._cache[50] || (_cache[50] = [
                  createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                  createTextVNode(" 创建存储过程 ", -1)
                ])])
              ]))
            ], 512), [
              [vShow, activeTab.value === "procedures"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_67$1, [..._cache[53] || (_cache[53] = [
              createBaseVNode("div", { class: "empty-state" }, [
                createBaseVNode("i", { class: "bi bi-code-slash" }),
                createBaseVNode("p", null, "函数功能开发中...")
              ], -1)
            ])], 512), [
              [vShow, activeTab.value === "functions"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_68$1, [
              createBaseVNode("div", _hoisted_69$1, [
                createVNode(SqlExecutor, {
                  connection: __props.connection,
                  database: __props.database
                }, null, 8, ["connection", "database"])
              ])
            ], 512), [
              [vShow, activeTab.value === "sql"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_70$1, [
              createVNode(DbTools, {
                connection: __props.connection,
                database: __props.database,
                onExecuteSql: handleExecuteSQL
              }, null, 8, ["connection", "database"])
            ], 512), [
              [vShow, activeTab.value === "tools"]
            ])
          ])
        ]),
        showCreateTable.value ? (openBlock(), createElementBlock("div", _hoisted_71$1, [
          createBaseVNode("div", _hoisted_72$1, [
            createBaseVNode("div", _hoisted_73$1, [
              createBaseVNode("div", _hoisted_74$1, [
                _cache[54] || (_cache[54] = createBaseVNode("h5", { class: "modal-title" }, "创建数据表", -1)),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: _cache[5] || (_cache[5] = ($event) => showCreateTable.value = false)
                })
              ]),
              createBaseVNode("div", _hoisted_75$1, [
                createBaseVNode("form", null, [
                  createBaseVNode("div", _hoisted_76$1, [
                    _cache[55] || (_cache[55] = createBaseVNode("label", { class: "form-label" }, "表名", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => newTable.value.name = $event),
                      placeholder: "输入表名"
                    }, null, 512), [
                      [vModelText, newTable.value.name]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_77$1, [
                    _cache[56] || (_cache[56] = createBaseVNode("label", { class: "form-label" }, "注释", -1)),
                    withDirectives(createBaseVNode("textarea", {
                      class: "form-control",
                      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => newTable.value.comment = $event),
                      placeholder: "输入表注释"
                    }, null, 512), [
                      [vModelText, newTable.value.comment]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_78$1, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: _cache[8] || (_cache[8] = ($event) => showCreateTable.value = false)
                }, "取消"),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-primary",
                  onClick: createTable
                }, "创建")
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        showCreateView.value && editingView.value ? (openBlock(), createElementBlock("div", _hoisted_79$1, [
          createBaseVNode("div", _hoisted_80$1, [
            createBaseVNode("div", _hoisted_81$1, [
              createBaseVNode("div", _hoisted_82$1, [
                createBaseVNode("h5", _hoisted_83$1, toDisplayString(views.value.some((v) => v.name === editingView.value.name) ? "编辑视图" : "创建视图"), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: _cache[9] || (_cache[9] = ($event) => showCreateView.value = false)
                })
              ]),
              createBaseVNode("div", _hoisted_84$1, [
                createBaseVNode("form", null, [
                  createBaseVNode("div", _hoisted_85$1, [
                    _cache[57] || (_cache[57] = createBaseVNode("label", { class: "form-label" }, "视图名称", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => editingView.value.name = $event),
                      placeholder: "输入视图名称"
                    }, null, 512), [
                      [vModelText, editingView.value.name]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_86$1, [
                    _cache[58] || (_cache[58] = createBaseVNode("label", { class: "form-label" }, "视图定义 (SQL查询)", -1)),
                    withDirectives(createBaseVNode("textarea", {
                      class: "form-control",
                      rows: "8",
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => editingView.value.definition = $event),
                      placeholder: "输入SELECT查询语句，例如: SELECT * FROM table_name WHERE condition"
                    }, null, 512), [
                      [vModelText, editingView.value.definition]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_87$1, [
                    _cache[59] || (_cache[59] = createBaseVNode("label", { class: "form-label" }, "注释", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => editingView.value.comment = $event),
                      placeholder: "输入视图注释"
                    }, null, 512), [
                      [vModelText, editingView.value.comment]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_88, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: _cache[13] || (_cache[13] = ($event) => showCreateView.value = false)
                }, "取消"),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-primary",
                  onClick: createOrUpdateView
                }, "保存")
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        showCreateProcedure.value && editingProcedure.value ? (openBlock(), createElementBlock("div", _hoisted_89, [
          createBaseVNode("div", _hoisted_90, [
            createBaseVNode("div", _hoisted_91, [
              createBaseVNode("div", _hoisted_92, [
                createBaseVNode("h5", _hoisted_93, toDisplayString(procedures.value.some((p) => p.name === editingProcedure.value.name) ? "编辑存储过程" : "创建存储过程"), 1),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-close",
                  onClick: _cache[14] || (_cache[14] = ($event) => showCreateProcedure.value = false)
                })
              ]),
              createBaseVNode("div", _hoisted_94, [
                createBaseVNode("form", null, [
                  createBaseVNode("div", _hoisted_95, [
                    _cache[60] || (_cache[60] = createBaseVNode("label", { class: "form-label" }, "存储过程名称", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => editingProcedure.value.name = $event),
                      placeholder: "输入存储过程名称"
                    }, null, 512), [
                      [vModelText, editingProcedure.value.name]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_96, [
                    _cache[61] || (_cache[61] = createBaseVNode("label", { class: "form-label" }, "存储过程定义", -1)),
                    withDirectives(createBaseVNode("textarea", {
                      class: "form-control",
                      rows: "12",
                      "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => editingProcedure.value.definition = $event),
                      placeholder: "输入存储过程的完整SQL定义，例如:\nBEGIN\n  -- 存储过程逻辑\nEND"
                    }, null, 512), [
                      [vModelText, editingProcedure.value.definition]
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_97, [
                    _cache[62] || (_cache[62] = createBaseVNode("label", { class: "form-label" }, "注释", -1)),
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => editingProcedure.value.comment = $event),
                      placeholder: "输入存储过程注释"
                    }, null, 512), [
                      [vModelText, editingProcedure.value.comment]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_98, [
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-secondary",
                  onClick: _cache[18] || (_cache[18] = ($event) => showCreateProcedure.value = false)
                }, "取消"),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn btn-primary",
                  onClick: createOrUpdateProcedure
                }, "保存")
              ])
            ])
          ])
        ])) : createCommentVNode("", true),
        createVNode(TableEditor, {
          visible: showTableEditor.value,
          connection: __props.connection,
          database: __props.database,
          "table-name": editingTableName.value,
          mode: editingTableName.value ? "edit" : "create",
          onClose: closeTableEditor,
          onSubmit: handleTableChange,
          onExecuteSql: handleExecuteSQL
        }, null, 8, ["visible", "connection", "database", "table-name", "mode"])
      ]);
    };
  }
});
const DatabaseDetail = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-cdf5979c"]]);
function isNumericType(type) {
  const numericTypes = [
    "int",
    "integer",
    "tinyint",
    "smallint",
    "mediumint",
    "bigint",
    "decimal",
    "numeric",
    "float",
    "double",
    "real",
    "number",
    "smallserial",
    "serial",
    "bigserial",
    "money",
    "smallmoney",
    "binary_float",
    "binary_double"
  ];
  return numericTypes.some((t2) => type.toLowerCase().includes(t2));
}
function isTextType(type) {
  const textTypes = [
    "text",
    "longtext",
    "mediumtext",
    "tinytext",
    "clob",
    "nclob",
    "ntext"
  ];
  return textTypes.some((t2) => type.toLowerCase().includes(t2));
}
function isDateTimeType(type) {
  const dateTimeTypes = [
    "date",
    "datetime",
    "timestamp",
    "time",
    "year",
    "time with time zone",
    "timestamp with time zone",
    "timestamp with local time zone",
    "interval",
    "datetimeoffset",
    "datetime2",
    "smalldatetime"
  ];
  return dateTimeTypes.some((t2) => type.toLowerCase().includes(t2));
}
function isBooleanType(type) {
  const booleanTypes = ["boolean", "bool", "bit", "tinyint(1)"];
  return booleanTypes.some((t2) => type.toLowerCase().includes(t2));
}
function isJsonType(type) {
  return ["json", "jsonb"].includes(type.toLowerCase());
}
function isArrayType(type) {
  return type.toLowerCase().endsWith("[]");
}
const _hoisted_1$2 = { class: "modal-dialog modal-lg" };
const _hoisted_2$2 = { class: "modal-content" };
const _hoisted_3$2 = {
  class: "modal-header",
  style: { "padding": "15px" }
};
const _hoisted_4$2 = { class: "modal-title" };
const _hoisted_5$2 = {
  key: 0,
  class: "bi bi-pencil-square"
};
const _hoisted_6$2 = {
  key: 1,
  class: "bi bi-plus-circle"
};
const _hoisted_7$2 = { class: "modal-body" };
const _hoisted_8$2 = { class: "row g-3" };
const _hoisted_9$2 = ["data-type"];
const _hoisted_10$2 = { class: "form-label" };
const _hoisted_11$2 = {
  key: 0,
  class: "text-danger"
};
const _hoisted_12$2 = { class: "text-muted ms-2" };
const _hoisted_13$2 = ["value"];
const _hoisted_14$2 = ["onUpdate:modelValue", "placeholder", "required", "step"];
const _hoisted_15$2 = ["onUpdate:modelValue", "required"];
const _hoisted_16$2 = ["onUpdate:modelValue", "placeholder", "required"];
const _hoisted_17$2 = ["onUpdate:modelValue", "required"];
const _hoisted_18$2 = ["value"];
const _hoisted_19$2 = ["onUpdate:modelValue"];
const _hoisted_20$2 = {
  key: 6,
  class: "json-editor"
};
const _hoisted_21$2 = ["onUpdate:modelValue", "placeholder", "required", "onInput"];
const _hoisted_22$2 = { class: "d-flex justify-content-between mt-1" };
const _hoisted_23$2 = { class: "text-muted" };
const _hoisted_24$2 = ["onClick"];
const _hoisted_25$2 = ["onUpdate:modelValue", "placeholder", "required"];
const _hoisted_26$2 = { class: "modal-footer" };
const _hoisted_27$2 = ["disabled"];
const _hoisted_28$2 = {
  key: 0,
  class: "spinner-border spinner-border-sm me-2"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "data-editor",
  props: {
    visible: { type: Boolean },
    isEdit: { type: Boolean },
    data: {},
    columns: {},
    connection: {},
    database: {},
    tableName: {}
  },
  emits: ["close", "submit"],
  setup(__props, { emit: __emit }) {
    const databaseService2 = new DatabaseService();
    const props = __props;
    const emit = __emit;
    const formData = ref({});
    const loading = ref(false);
    const jsonText = ref({});
    const jsonError = ref({});
    watch(() => props.visible, (visible) => {
      if (visible) {
        initializeFormData();
      }
    });
    function initializeFormData() {
      formData.value = {};
      jsonText.value = {};
      jsonError.value = {};
      props.columns.forEach((column) => {
        if (props.isEdit && props.data) {
          if (isDateInput(column.type)) {
            formData.value[column.name] = props.data[column.name] ? new Date(props.data[column.name]).toISOString().replace(".000Z", "") : null;
          } else if (isJsonInput(column.type) || isArrayInput(column.type)) {
            let value = props.data[column.name];
            if (typeof value === "string") {
              try {
                value = JSON.parse(value);
              } catch (e) {
                value = props.data[column.name];
              }
            }
            formData.value[column.name] = value;
            jsonText.value[column.name] = JSON.stringify(value, null, 2);
          } else formData.value[column.name] = props.data[column.name];
        } else {
          if (column.isPrimary && column.isAutoIncrement) {
            formData.value[column.name] = null;
          } else if (column.defaultValue !== null && column.defaultValue !== void 0) {
            formData.value[column.name] = column.defaultValue;
          } else if (column.nullable) {
            formData.value[column.name] = null;
          } else if (isBooleanInput2(column.type)) {
            formData.value[column.name] = false;
          } else if (isJsonInput(column.type) || isArrayInput(column.type)) {
            formData.value[column.name] = {};
            jsonText.value[column.name] = "{}";
          } else {
            formData.value[column.name] = "";
          }
        }
      });
    }
    function isNumberInput2(type) {
      return isNumericType(type);
    }
    function isDecimalInput(type) {
      return isNumericType(type) && (type.toLowerCase().includes("decimal") || type.toLowerCase().includes("numeric"));
    }
    function isDateInput(type) {
      return isDateTimeType(type);
    }
    function isTextArea(type) {
      return isTextType(type);
    }
    function isEnumInput(type) {
      return type.toLowerCase().startsWith("enum");
    }
    function isBooleanInput2(type) {
      return isBooleanType(type);
    }
    function isJsonInput(type, inputtype) {
      if (inputtype) {
        console.log(inputtype, type);
      }
      return isJsonType(type);
    }
    function isArrayInput(type) {
      return isArrayType(type);
    }
    function validateJson(columnName) {
      try {
        const value = jsonText.value[columnName];
        if (value && value.trim()) {
          const parsed = JSON.parse(value);
          formData.value[columnName] = parsed;
          jsonError.value[columnName] = "";
        } else {
          formData.value[columnName] = null;
          jsonError.value[columnName] = "";
        }
      } catch (error) {
        jsonError.value[columnName] = "JSON格式错误: " + error.message;
      }
    }
    function formatJson(columnName) {
      try {
        const value = jsonText.value[columnName];
        if (value && value.trim()) {
          const parsed = JSON.parse(value);
          jsonText.value[columnName] = JSON.stringify(parsed, null, 2);
          formData.value[columnName] = parsed;
          jsonError.value[columnName] = "";
        }
      } catch (error) {
        jsonError.value[columnName] = "JSON格式错误: " + error.message;
      }
    }
    function getEnumOptions(type) {
      const match = type?.match(/enum\((.*)\)/i);
      if (match && match[1]) {
        return match[1].split(",").map((option) => {
          return option.trim().replace(/'/g, "");
        });
      }
      return [];
    }
    function closeModal() {
      loading.value = false;
      emit("close");
    }
    async function handleSubmit() {
      try {
        let hasInvalidJson = false;
        props.columns.forEach((column) => {
          if (isJsonInput(column.type) || isArrayInput(column.type)) {
            validateJson(column.name);
            if (jsonError.value[column.name]) {
              hasInvalidJson = true;
            }
          }
        });
        if (hasInvalidJson) {
          modal.error("请修复 JSON 格式错误后再提交");
          return;
        }
        loading.value = true;
        let response;
        if (props.isEdit && props.data) {
          const whereClause = getPrimaryKeyWhere();
          response = await databaseService2.updateData(
            props.connection?.id || "",
            props.database || "",
            props.tableName || "",
            formData.value,
            whereClause
          );
        } else {
          response = await databaseService2.insertData(
            props.connection?.id || "",
            props.database || "",
            props.tableName || "",
            formData.value
          );
        }
        if (response.ret === 0) {
          modal.success(props.isEdit ? "数据更新成功" : "数据插入成功");
          closeModal();
          nextTick(() => {
            emit("submit", response);
          });
        } else {
          loading.value = false;
          modal.error(response.msg, {
            code: response.ret,
            operation: props.isEdit ? "UPDATE" : "INSERT",
            table: props.tableName,
            requestData: formData.value
          });
        }
      } catch (error) {
        console.error("提交数据失败:", error);
        const errorMsg = error instanceof Error ? error.message : String(error);
        modal.error(errorMsg, {
          operation: props.isEdit ? "UPDATE" : "INSERT",
          table: props.tableName,
          stack: error instanceof Error ? error.stack : void 0
        });
        loading.value = false;
      }
    }
    function getPrimaryKeyWhere() {
      const primaryKeys = props.columns.filter((col) => col.isPrimary);
      const whereClause = {};
      primaryKeys.forEach((key) => {
        whereClause[key.name] = props.data[key.name];
      });
      return whereClause;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["modal fade", { show: __props.visible }]),
        style: normalizeStyle({ display: __props.visible ? "block" : "none" })
      }, [
        createBaseVNode("div", _hoisted_1$2, [
          createBaseVNode("div", _hoisted_2$2, [
            createBaseVNode("div", _hoisted_3$2, [
              createBaseVNode("h5", _hoisted_4$2, [
                __props.isEdit ? (openBlock(), createElementBlock("i", _hoisted_5$2)) : (openBlock(), createElementBlock("i", _hoisted_6$2)),
                createTextVNode(" " + toDisplayString(__props.isEdit ? "编辑数据" : "新增数据"), 1)
              ]),
              createBaseVNode("button", {
                type: "button",
                class: "btn-close",
                onClick: closeModal
              })
            ]),
            createBaseVNode("div", _hoisted_7$2, [
              createBaseVNode("form", {
                onSubmit: withModifiers(handleSubmit, ["prevent"])
              }, [
                createBaseVNode("div", _hoisted_8$2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (column) => {
                    return openBlock(), createElementBlock("div", {
                      key: column.name,
                      "data-type": column.type,
                      class: "col-md-6"
                    }, [
                      createBaseVNode("label", _hoisted_10$2, [
                        createTextVNode(toDisplayString(column.name) + " ", 1),
                        column.isPrimary ? (openBlock(), createElementBlock("span", _hoisted_11$2, "*")) : createCommentVNode("", true),
                        createBaseVNode("small", _hoisted_12$2, toDisplayString(column.type), 1)
                      ]),
                      column.isPrimary && column.isAutoIncrement && __props.isEdit ? (openBlock(), createElementBlock("input", {
                        key: 0,
                        type: "text",
                        "data-type": "primary",
                        class: "form-control",
                        value: formData.value[column.name],
                        disabled: "",
                        readonly: ""
                      }, null, 8, _hoisted_13$2)) : isNumberInput2(column.type) ? withDirectives((openBlock(), createElementBlock("input", {
                        key: 1,
                        type: "number",
                        "data-type": "number",
                        class: "form-control",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event,
                        placeholder: "请输入" + column.name,
                        required: !column.nullable,
                        step: isDecimalInput(column.type) ? "0.01" : "1"
                      }, null, 8, _hoisted_14$2)), [
                        [vModelText, formData.value[column.name]]
                      ]) : isDateInput(column.type) ? withDirectives((openBlock(), createElementBlock("input", {
                        key: 2,
                        type: "datetime-local",
                        class: "form-control",
                        "data-type": "date",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event,
                        required: !column.nullable
                      }, null, 8, _hoisted_15$2)), [
                        [vModelText, formData.value[column.name]]
                      ]) : isTextArea(column.type) ? withDirectives((openBlock(), createElementBlock("textarea", {
                        key: 3,
                        class: "form-control",
                        "data-type": "textarea",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event,
                        placeholder: "请输入" + column.name,
                        required: !column.nullable,
                        rows: "3"
                      }, null, 8, _hoisted_16$2)), [
                        [vModelText, formData.value[column.name]]
                      ]) : isEnumInput(column.type) ? withDirectives((openBlock(), createElementBlock("select", {
                        key: 4,
                        class: "form-select",
                        "data-type": "select",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event,
                        required: !column.nullable
                      }, [
                        _cache[0] || (_cache[0] = createBaseVNode("option", { value: "" }, "请选择...", -1)),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(getEnumOptions(column.type), (option) => {
                          return openBlock(), createElementBlock("option", {
                            key: option,
                            value: option
                          }, toDisplayString(option), 9, _hoisted_18$2);
                        }), 128))
                      ], 8, _hoisted_17$2)), [
                        [vModelSelect, formData.value[column.name]]
                      ]) : isBooleanInput2(column.type) ? withDirectives((openBlock(), createElementBlock("select", {
                        key: 5,
                        class: "form-select",
                        "data-type": "boolean",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event
                      }, [..._cache[1] || (_cache[1] = [
                        createBaseVNode("option", { value: true }, "是/True", -1),
                        createBaseVNode("option", { value: false }, "否/False", -1)
                      ])], 8, _hoisted_19$2)), [
                        [vModelSelect, formData.value[column.name]]
                      ]) : isJsonInput(column.type, "input") || isArrayInput(column.type) ? (openBlock(), createElementBlock("div", _hoisted_20$2, [
                        withDirectives(createBaseVNode("textarea", {
                          class: "form-control font-monospace",
                          "data-type": "json",
                          "onUpdate:modelValue": ($event) => jsonText.value[column.name] = $event,
                          placeholder: "请输入" + column.name + "的JSON数据",
                          required: !column.nullable,
                          rows: "6",
                          onInput: ($event) => validateJson(column.name)
                        }, null, 40, _hoisted_21$2), [
                          [vModelText, jsonText.value[column.name]]
                        ]),
                        createBaseVNode("div", _hoisted_22$2, [
                          createBaseVNode("small", _hoisted_23$2, toDisplayString(jsonError.value[column.name] || "JSON格式正确"), 1),
                          createBaseVNode("button", {
                            type: "button",
                            class: "btn btn-sm btn-outline-primary",
                            onClick: ($event) => formatJson(column.name)
                          }, " 格式化 ", 8, _hoisted_24$2)
                        ])
                      ])) : withDirectives((openBlock(), createElementBlock("input", {
                        key: 7,
                        type: "text",
                        "data-type": "normal",
                        class: "form-control",
                        "onUpdate:modelValue": ($event) => formData.value[column.name] = $event,
                        placeholder: "请输入" + column.name,
                        required: !column.nullable
                      }, null, 8, _hoisted_25$2)), [
                        [vModelText, formData.value[column.name]]
                      ])
                    ], 8, _hoisted_9$2);
                  }), 128))
                ])
              ], 32)
            ]),
            createBaseVNode("div", _hoisted_26$2, [
              createBaseVNode("button", {
                type: "button",
                class: "btn btn-secondary",
                onClick: closeModal
              }, " 取消 "),
              createBaseVNode("button", {
                type: "button",
                class: "btn btn-primary",
                onClick: handleSubmit,
                disabled: loading.value
              }, [
                loading.value ? (openBlock(), createElementBlock("span", _hoisted_28$2)) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString(__props.isEdit ? "更新" : "插入"), 1)
              ], 8, _hoisted_27$2)
            ])
          ])
        ])
      ], 6);
    };
  }
});
const DataEditor = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-082bb783"]]);
const _hoisted_1$1 = { class: "table-detail" };
const _hoisted_2$1 = { class: "table-header" };
const _hoisted_3$1 = { class: "table-header-content" };
const _hoisted_4$1 = { class: "table-info" };
const _hoisted_5$1 = { class: "table-meta" };
const _hoisted_6$1 = { class: "table-name" };
const _hoisted_7$1 = { class: "table-breadcrumb" };
const _hoisted_8$1 = { class: "connection" };
const _hoisted_9$1 = { class: "database" };
const _hoisted_10$1 = { class: "table" };
const _hoisted_11$1 = { class: "table-stats" };
const _hoisted_12$1 = { class: "stat-item" };
const _hoisted_13$1 = { class: "stat-value" };
const _hoisted_14$1 = { class: "stat-item" };
const _hoisted_15$1 = { class: "stat-value" };
const _hoisted_16$1 = { class: "stat-item" };
const _hoisted_17$1 = { class: "stat-value" };
const _hoisted_18$1 = { class: "stat-item" };
const _hoisted_19$1 = { class: "stat-value" };
const _hoisted_20$1 = { class: "table-toolbar" };
const _hoisted_21$1 = { class: "toolbar-left" };
const _hoisted_22$1 = { class: "btn-group" };
const _hoisted_23$1 = { class: "dropdown-menu" };
const _hoisted_24$1 = { class: "toolbar-right" };
const _hoisted_25$1 = { class: "table-tabs" };
const _hoisted_26$1 = { class: "nav nav-tabs" };
const _hoisted_27$1 = { class: "nav-item" };
const _hoisted_28$1 = {
  key: 0,
  class: "badge bg-secondary ms-2"
};
const _hoisted_29$1 = { class: "nav-item" };
const _hoisted_30$1 = { class: "nav-item" };
const _hoisted_31$1 = { class: "nav-item" };
const _hoisted_32$1 = { class: "nav-item" };
const _hoisted_33$1 = { class: "tab-content" };
const _hoisted_34$1 = { class: "tab-panel" };
const _hoisted_35$1 = {
  key: 0,
  class: "table-responsive"
};
const _hoisted_36$1 = { class: "table table-sm table-striped table-hover" };
const _hoisted_37$1 = { class: "table-light" };
const _hoisted_38$1 = { class: "column-header" };
const _hoisted_39$1 = { class: "text-muted d-block" };
const _hoisted_40$1 = {
  key: 0,
  class: "column-key"
};
const _hoisted_41 = { class: "cell-value" };
const _hoisted_42 = { class: "btn-group btn-group-sm" };
const _hoisted_43 = ["onClick"];
const _hoisted_44 = ["onClick"];
const _hoisted_45 = {
  key: 1,
  class: "loading-state"
};
const _hoisted_46 = {
  key: 2,
  class: "empty-state"
};
const _hoisted_47 = { key: 0 };
const _hoisted_48 = { key: 1 };
const _hoisted_49 = {
  key: 3,
  class: "pagination-nav"
};
const _hoisted_50 = { class: "pagination-container" };
const _hoisted_51 = { class: "pagination-info" };
const _hoisted_52 = { class: "pagination pagination-sm" };
const _hoisted_53 = {
  key: 0,
  class: "page-item"
};
const _hoisted_54 = {
  key: 1,
  class: "page-item disabled"
};
const _hoisted_55 = ["onClick"];
const _hoisted_56 = {
  key: 2,
  class: "page-item disabled"
};
const _hoisted_57 = {
  key: 3,
  class: "page-item"
};
const _hoisted_58 = { class: "page-size-selector" };
const _hoisted_59 = { class: "page-jump" };
const _hoisted_60 = ["max"];
const _hoisted_61 = { class: "tab-panel" };
const _hoisted_62 = { class: "structure-content" };
const _hoisted_63 = { class: "structure-table" };
const _hoisted_64 = { class: "table table-bordered" };
const _hoisted_65 = {
  key: 0,
  class: "badge bg-primary"
};
const _hoisted_66 = { key: 1 };
const _hoisted_67 = {
  key: 0,
  class: "badge bg-success"
};
const _hoisted_68 = { key: 1 };
const _hoisted_69 = { class: "btn-group btn-group-sm" };
const _hoisted_70 = ["onClick"];
const _hoisted_71 = ["onClick"];
const _hoisted_72 = { class: "tab-panel" };
const _hoisted_73 = { class: "indexes-content" };
const _hoisted_74 = { class: "indexes-table" };
const _hoisted_75 = { class: "table table-bordered" };
const _hoisted_76 = { class: "badge bg-info" };
const _hoisted_77 = { class: "btn-group btn-group-sm" };
const _hoisted_78 = ["onClick"];
const _hoisted_79 = ["onClick"];
const _hoisted_80 = { class: "tab-panel" };
const _hoisted_81 = { class: "relations-content" };
const _hoisted_82 = { class: "relations-table" };
const _hoisted_83 = { class: "table table-bordered" };
const _hoisted_84 = { class: "btn-group btn-group-sm" };
const _hoisted_85 = ["onClick"];
const _hoisted_86 = { class: "tab-panel" };
const _hoisted_87 = { class: "sql-section" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "table-detail",
  props: {
    connection: {},
    database: {},
    table: {},
    tableData: {},
    tableStructure: {},
    loading: { type: Boolean },
    total: {},
    sqlExecuting: { type: Boolean },
    sqlResult: {}
  },
  emits: ["refresh-data", "refresh-database", "refresh-structure", "truncate-table", "drop-table", "delete-row", "insert-data", "export-table", "edit-row", "execute-sql"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const databaseService2 = new DatabaseService();
    const activeTab = ref("data");
    const searchQuery = ref("");
    const currentPage = ref(1);
    const pageSize = ref(50);
    ref("");
    const jumpToPage = ref(1);
    ref(null);
    const showDataEditor = ref(false);
    const isEditMode = ref(false);
    const editingRow = ref(null);
    const showTableEditor = ref(false);
    const tableEditorMode = ref("edit");
    computed(() => props.tableStructure?.columns || []);
    const safeTableColumns = computed(() => {
      const columns = props.tableStructure?.columns || [];
      return columns.map((col) => ({
        ...col,
        name: col.name || "",
        type: col.type || "",
        nullable: !!col.nullable,
        isPrimary: !!col.isPrimary,
        isAutoIncrement: !!col.isAutoIncrement,
        comment: col.comment || ""
      }));
    });
    const paginatedData = computed(() => {
      return props.tableData || [];
    });
    const totalPages = computed(() => {
      const total = parseInt(props.total) || 0;
      return Math.ceil(total / pageSize.value);
    });
    const visiblePages = computed(() => {
      const pages = [];
      let start = Math.max(1, currentPage.value - 2);
      let end = Math.min(totalPages.value, start + 4);
      if (end - start < 4) {
        start = Math.max(1, end - 4);
      }
      for (let i = start; i <= end; i++) {
        pages.push(i);
      }
      return pages;
    });
    watch(() => props.table, () => {
      activeTab.value = "data";
      currentPage.value = 1;
      searchQuery.value = "";
    });
    watch(pageSize, () => {
      currentPage.value = 1;
      jumpToPage.value = 1;
      emit("refresh-data", currentPage.value, pageSize.value, searchQuery.value);
    });
    watch(currentPage, (newPage) => {
      jumpToPage.value = newPage;
    });
    function formatSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB", "TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }
    function formatNumber2(num) {
      return num?.toLocaleString?.() || num?.toString() || "";
    }
    function formatCellValue(value) {
      if (value === null || value === void 0) return "NULL";
      let strValue = String(value);
      if (typeof value === "string") {
        const trimmedValue = strValue.trim();
        if (trimmedValue.startsWith("{") && trimmedValue.endsWith("}") || trimmedValue.startsWith("[") && trimmedValue.endsWith("]")) {
          try {
            const parsed = JSON.parse(trimmedValue);
            const formatted = JSON.stringify(parsed, null, 2);
            if (formatted.length > 50) {
              return formatted.substring(0, 50) + "...";
            }
            return formatted;
          } catch (e) {
          }
        }
      } else if (typeof value === "object") {
        try {
          const formatted = JSON.stringify(value, null, 2);
          if (formatted.length > 50) {
            return formatted.substring(0, 50) + "...";
          }
          return formatted;
        } catch (e) {
        }
      }
      if (strValue.length > 50) return strValue.substring(0, 50) + "...";
      return strValue;
    }
    function goToPage(page) {
      if (page >= 1 && page <= totalPages.value) {
        currentPage.value = page;
        emit("refresh-data", currentPage.value, pageSize.value, searchQuery.value);
      }
    }
    function jumpToPageHandler() {
      if (jumpToPage.value >= 1 && jumpToPage.value <= totalPages.value) {
        currentPage.value = jumpToPage.value;
        emit("refresh-data", currentPage.value, pageSize.value, searchQuery.value);
      } else {
        jumpToPage.value = Math.max(1, Math.min(jumpToPage.value, totalPages.value));
        currentPage.value = jumpToPage.value;
        emit("refresh-data", currentPage.value, pageSize.value, searchQuery.value);
      }
    }
    function refreshData() {
      emit("refresh-data", currentPage.value, pageSize.value, searchQuery.value);
    }
    function insertData(newData) {
      {
        editingRow.value = null;
        isEditMode.value = false;
        showDataEditor.value = true;
      }
    }
    async function editRow(row) {
      editingRow.value = row;
      isEditMode.value = true;
      showDataEditor.value = true;
    }
    async function deleteRow(row) {
      try {
        const result = await modal.confirm("确定要删除这条记录吗？", {
          confirmButtonText: "删除",
          cancelButtonText: "取消",
          type: "danger"
        });
        if (result) {
          emit("delete-row", row);
        }
      } catch (error) {
        console.error("删除行失败:", error);
      }
    }
    async function truncateTable() {
      try {
        const result = await modal.confirm("确定要清空表中的所有数据吗？此操作不可恢复！", {
          confirmButtonText: "确定清空",
          cancelButtonText: "取消",
          type: "danger"
        });
        if (result) {
          emit("truncate-table");
        }
      } catch (error) {
        console.error("清空表失败:", error);
      }
    }
    async function dropTable() {
      try {
        const result = await modal.confirm("确定要删除此表吗？此操作不可恢复！", {
          confirmButtonText: "删除",
          cancelButtonText: "取消",
          type: "danger"
        });
        if (result) {
          try {
            const response = await databaseService2.dropTable(
              props.connection?.id || "",
              props.database,
              props.table?.name || ""
            );
            if (response.ret === 0 && response.data?.success) {
              await modal.success("表删除成功");
              emit("refresh-database");
            } else {
              await modal.error("表删除失败");
            }
          } catch (error) {
            console.error("删除表失败:", error);
            modal.error(error.msg || error.message || "删除表失败", {
              operation: "DROP_TABLE",
              table: props.table?.name,
              stack: error.stack
            });
          }
        }
      } catch (error) {
        console.error("删除表失败:", error);
      }
    }
    function handleDataSubmit(result) {
      try {
        if (result.ret === 0) {
          emit("refresh-data");
          closeDataEditor();
        } else {
          modal.error("操作失败");
        }
      } catch (error) {
        console.error("处理数据提交失败:", error);
        modal.error(error.msg || error.message || "操作失败", {
          //operation: operation,
          table: props.table?.name,
          stack: error.stack
        });
      }
    }
    function closeDataEditor() {
      showDataEditor.value = false;
      editingRow.value = null;
      isEditMode.value = false;
    }
    function editTableStructure() {
      tableEditorMode.value = "edit";
      showTableEditor.value = true;
    }
    function addColumn() {
      tableEditorMode.value = "edit";
      showTableEditor.value = true;
    }
    function closeTableEditor() {
      showTableEditor.value = false;
    }
    async function handleTableStructureChange(result) {
      try {
        if (result.success) {
          emit("refresh-structure");
          emit("refresh-database");
          closeTableEditor();
          await modal.success("表结构修改成功");
        } else {
          await modal.error("表结构修改失败");
        }
      } catch (error) {
        console.error("处理表结构修改失败:", error);
        modal.error(error.msg || error.message || "表结构修改失败", {
          operation: "MODIFY_TABLE",
          table: props.table?.name,
          stack: error.stack
        });
      }
    }
    function editColumn(column) {
      tableEditorMode.value = "edit";
      showTableEditor.value = true;
    }
    function deleteColumn(column) {
      modal.confirm(`确定要删除列 ${column.name} 吗？`, {
        confirmButtonText: "删除",
        cancelButtonText: "取消",
        type: "danger"
      }).then((result) => {
        if (result) {
          emit("refresh-structure");
        }
      });
    }
    function editIndex(index) {
      console.log("编辑索引:", index);
    }
    function deleteIndex(index) {
      modal.confirm(`确定要删除索引 ${index.name} 吗？`, {
        confirmButtonText: "删除",
        cancelButtonText: "取消",
        type: "danger"
      }).then((result) => {
        if (result) {
          emit("refresh-structure");
        }
      });
    }
    function deleteForeignKey(fk) {
      modal.confirm(`确定要删除外键 ${fk.name} 吗？`, {
        confirmButtonText: "删除",
        cancelButtonText: "取消",
        type: "danger"
      }).then((result) => {
        if (result) {
          emit("refresh-structure");
        }
      });
    }
    async function exportTableData(format) {
      try {
        if (!props.connection || !props.database || !props.table?.name) {
          await modal.warning("缺少必要的连接信息");
          return;
        }
        let response;
        switch (format) {
          case "csv":
            response = await databaseService2.exportTableDataToCSV(
              props.connection.id,
              props.database,
              props.table.name
            );
            break;
          case "json":
            response = await databaseService2.exportTableDataToJSON(
              props.connection.id,
              props.database,
              props.table.name
            );
            break;
          case "excel":
            response = await databaseService2.exportTableDataToExcel(
              props.connection.id,
              props.database,
              props.table.name
            );
            break;
          default:
            throw new Error("不支持的导出格式");
        }
        if (response.ret === 0) {
          await modal.success(`表数据导出成功，文件路径：${response.data}`);
        } else {
          await modal.error("导出表数据失败: " + response.msg);
        }
      } catch (error) {
        console.error("导出表数据失败:", error);
        modal.error("导出表数据失败: " + error.message);
      }
    }
    async function exportTableStructure() {
      try {
        let createTableSQL = `CREATE TABLE ${props.table?.name} (
`;
        const columns = [];
        safeTableColumns.value.forEach((column, index) => {
          let columnDef = `  ${column.name} ${column.type}`;
          if (!column.nullable) {
            columnDef += " NOT NULL";
          }
          if (column.defaultValue !== void 0 && column.defaultValue !== null) {
            if (typeof column.defaultValue === "string") {
              columnDef += ` DEFAULT '${column.defaultValue.replace(/'/g, "''")}'`;
            } else {
              columnDef += ` DEFAULT ${column.defaultValue}`;
            }
          }
          if (column.isPrimary) {
            columnDef += " PRIMARY KEY";
          }
          if (column.isAutoIncrement) {
            columnDef += " AUTO_INCREMENT";
          }
          if (column.comment) {
            columnDef += ` COMMENT '${column.comment.replace(/'/g, "''")}'`;
          }
          columns.push(columnDef);
        });
        createTableSQL += columns.join(",\n");
        createTableSQL += "\n);\n";
        if (props.tableStructure?.indexes) {
          props.tableStructure.indexes.forEach((index) => {
            if (!index.isPrimary) {
              createTableSQL += `CREATE ${index.unique ? "UNIQUE " : ""}INDEX ${index.name} ON ${props.table?.name} (${index.columns.join(", ")})
`;
            }
          });
        }
        if (props.tableStructure?.foreignKeys) {
          props.tableStructure.foreignKeys.forEach((fk) => {
            createTableSQL += `ALTER TABLE ${props.table?.name} ADD CONSTRAINT ${fk.name} FOREIGN KEY (${fk.column}) REFERENCES ${fk.referencedTable} (${fk.referencedColumn})${fk.onDelete ? ` ON DELETE ${fk.onDelete}` : ""}${fk.onUpdate ? ` ON UPDATE ${fk.onUpdate}` : ""}
`;
          });
        }
        downloadSQLFile(createTableSQL, `${props.table?.name}_structure.sql`);
      } catch (error) {
        console.error("导出表结构失败:", error);
        modal.error("导出表结构失败: " + error.message);
      }
    }
    async function exportTableDataSQL() {
      try {
        if (!props.connection || !props.database || !props.table?.name) {
          await modal.warning("缺少必要的连接信息");
          return;
        }
        const response = await databaseService2.exportTableDataToSQL(
          props.connection.id,
          props.database,
          props.table.name
        );
        if (response.ret === 0) {
          await modal.success(`表数据导出成功，文件路径：${response.data}`);
        } else {
          await modal.error("导出表数据失败: " + response.msg);
        }
      } catch (error) {
        console.error("导出表数据失败:", error);
        modal.error("导出表数据失败: " + error.message);
      }
    }
    function downloadSQLFile(content2, filename) {
      const blob = new Blob([content2], { type: "text/sql;charset=utf-8;" });
      const link = document.createElement("a");
      if (link.download !== void 0) {
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("div", _hoisted_3$1, [
            createBaseVNode("div", _hoisted_4$1, [
              _cache[22] || (_cache[22] = createBaseVNode("div", { class: "table-icon" }, [
                createBaseVNode("i", { class: "bi bi-table" })
              ], -1)),
              createBaseVNode("div", _hoisted_5$1, [
                createBaseVNode("h4", _hoisted_6$1, toDisplayString(__props.table?.name), 1),
                createBaseVNode("div", _hoisted_7$1, [
                  createBaseVNode("span", _hoisted_8$1, toDisplayString(__props.connection?.name), 1),
                  _cache[20] || (_cache[20] = createBaseVNode("i", { class: "bi bi-chevron-right" }, null, -1)),
                  createBaseVNode("span", _hoisted_9$1, toDisplayString(__props.database), 1),
                  _cache[21] || (_cache[21] = createBaseVNode("i", { class: "bi bi-chevron-right" }, null, -1)),
                  createBaseVNode("span", _hoisted_10$1, toDisplayString(__props.table?.name), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_11$1, [
              createBaseVNode("div", _hoisted_12$1, [
                createBaseVNode("div", _hoisted_13$1, toDisplayString(formatNumber2(__props.table?.rowCount || 0)), 1),
                _cache[23] || (_cache[23] = createBaseVNode("div", { class: "stat-label" }, "行数据", -1))
              ]),
              createBaseVNode("div", _hoisted_14$1, [
                createBaseVNode("div", _hoisted_15$1, toDisplayString(__props.tableStructure?.columns?.length || 0), 1),
                _cache[24] || (_cache[24] = createBaseVNode("div", { class: "stat-label" }, "列", -1))
              ]),
              createBaseVNode("div", _hoisted_16$1, [
                createBaseVNode("div", _hoisted_17$1, toDisplayString(__props.tableStructure?.indexes?.length || 0), 1),
                _cache[25] || (_cache[25] = createBaseVNode("div", { class: "stat-label" }, "索引", -1))
              ]),
              createBaseVNode("div", _hoisted_18$1, [
                createBaseVNode("div", _hoisted_19$1, toDisplayString(formatSize(__props.table?.dataSize || 0)), 1),
                _cache[26] || (_cache[26] = createBaseVNode("div", { class: "stat-label" }, "大小", -1))
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_20$1, [
          createBaseVNode("div", _hoisted_21$1, [
            createBaseVNode("button", {
              class: "btn btn-primary btn-sm",
              onClick: refreshData
            }, [..._cache[27] || (_cache[27] = [
              createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1),
              createTextVNode(" 刷新数据 ", -1)
            ])]),
            createBaseVNode("button", {
              class: "btn btn-info btn-sm",
              onClick: editTableStructure
            }, [..._cache[28] || (_cache[28] = [
              createBaseVNode("i", { class: "bi bi-pencil-square" }, null, -1),
              createTextVNode(" 修改表结构 ", -1)
            ])]),
            createBaseVNode("button", {
              class: "btn btn-success btn-sm",
              onClick: _cache[0] || (_cache[0] = () => insertData())
            }, [..._cache[29] || (_cache[29] = [
              createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
              createTextVNode(" 插入数据 ", -1)
            ])]),
            createBaseVNode("div", _hoisted_22$1, [
              _cache[36] || (_cache[36] = createBaseVNode("button", {
                class: "btn btn-info btn-sm dropdown-toggle",
                "data-bs-toggle": "dropdown"
              }, [
                createBaseVNode("i", { class: "bi bi-download" }),
                createTextVNode(" 导出 ")
              ], -1)),
              createBaseVNode("ul", _hoisted_23$1, [
                createBaseVNode("li", null, [
                  createBaseVNode("button", {
                    class: "dropdown-item",
                    onClick: _cache[1] || (_cache[1] = ($event) => exportTableData("csv"))
                  }, [..._cache[30] || (_cache[30] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-spreadsheet me-2" }, null, -1),
                    createTextVNode("导出 CSV ", -1)
                  ])])
                ]),
                createBaseVNode("li", null, [
                  createBaseVNode("button", {
                    class: "dropdown-item",
                    onClick: _cache[2] || (_cache[2] = ($event) => exportTableData("json"))
                  }, [..._cache[31] || (_cache[31] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-code me-2" }, null, -1),
                    createTextVNode("导出 JSON ", -1)
                  ])])
                ]),
                createBaseVNode("li", null, [
                  createBaseVNode("button", {
                    class: "dropdown-item",
                    onClick: _cache[3] || (_cache[3] = ($event) => exportTableData("excel"))
                  }, [..._cache[32] || (_cache[32] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-excel me-2" }, null, -1),
                    createTextVNode("导出 Excel ", -1)
                  ])])
                ]),
                _cache[35] || (_cache[35] = createBaseVNode("li", null, [
                  createBaseVNode("hr", { class: "dropdown-divider" })
                ], -1)),
                createBaseVNode("li", null, [
                  createBaseVNode("button", {
                    class: "dropdown-item",
                    onClick: _cache[4] || (_cache[4] = ($event) => exportTableStructure())
                  }, [..._cache[33] || (_cache[33] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-text me-2" }, null, -1),
                    createTextVNode("导出表结构 ", -1)
                  ])])
                ]),
                createBaseVNode("li", null, [
                  createBaseVNode("button", {
                    class: "dropdown-item",
                    onClick: _cache[5] || (_cache[5] = ($event) => exportTableDataSQL())
                  }, [..._cache[34] || (_cache[34] = [
                    createBaseVNode("i", { class: "bi bi-file-earmark-code me-2" }, null, -1),
                    createTextVNode("导出表数据(SQL) ", -1)
                  ])])
                ])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_24$1, [
            __props.tableData.length > 0 ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "btn btn-outline-warning btn-sm",
              onClick: truncateTable
            }, [..._cache[37] || (_cache[37] = [
              createBaseVNode("i", { class: "bi bi-trash" }, null, -1),
              createTextVNode(" 清空表 ", -1)
            ])])) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: "btn btn-outline-danger btn-sm",
              onClick: dropTable
            }, [..._cache[38] || (_cache[38] = [
              createBaseVNode("i", { class: "bi bi-x-circle" }, null, -1),
              createTextVNode(" 删除表 ", -1)
            ])])
          ])
        ]),
        createBaseVNode("div", _hoisted_25$1, [
          createBaseVNode("ul", _hoisted_26$1, [
            createBaseVNode("li", _hoisted_27$1, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "data" }]),
                onClick: _cache[6] || (_cache[6] = ($event) => activeTab.value = "data")
              }, [
                _cache[39] || (_cache[39] = createBaseVNode("i", { class: "bi bi-grid" }, null, -1)),
                _cache[40] || (_cache[40] = createTextVNode(" 数据 ", -1)),
                __props.tableData.length > 0 ? (openBlock(), createElementBlock("span", _hoisted_28$1, toDisplayString(__props.tableData.length), 1)) : createCommentVNode("", true)
              ], 2)
            ]),
            createBaseVNode("li", _hoisted_29$1, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "structure" }]),
                onClick: _cache[7] || (_cache[7] = ($event) => activeTab.value = "structure")
              }, [..._cache[41] || (_cache[41] = [
                createBaseVNode("i", { class: "bi bi-diagram-3" }, null, -1),
                createTextVNode(" 结构 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_30$1, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "indexes" }]),
                onClick: _cache[8] || (_cache[8] = ($event) => activeTab.value = "indexes")
              }, [..._cache[42] || (_cache[42] = [
                createBaseVNode("i", { class: "bi bi-key" }, null, -1),
                createTextVNode(" 索引 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_31$1, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "relations" }]),
                onClick: _cache[9] || (_cache[9] = ($event) => activeTab.value = "relations")
              }, [..._cache[43] || (_cache[43] = [
                createBaseVNode("i", { class: "bi bi-link-45deg" }, null, -1),
                createTextVNode(" 关系 ", -1)
              ])], 2)
            ]),
            createBaseVNode("li", _hoisted_32$1, [
              createBaseVNode("button", {
                class: normalizeClass(["nav-link", { active: activeTab.value === "sql" }]),
                onClick: _cache[10] || (_cache[10] = ($event) => activeTab.value = "sql")
              }, [..._cache[44] || (_cache[44] = [
                createBaseVNode("i", { class: "bi bi-code-slash" }, null, -1),
                createTextVNode(" SQL ", -1)
              ])], 2)
            ])
          ]),
          createBaseVNode("div", _hoisted_33$1, [
            withDirectives(createBaseVNode("div", _hoisted_34$1, [
              createBaseVNode("div", {
                class: normalizeClass(["data-content", { "loading": __props.loading }])
              }, [
                !__props.loading && paginatedData.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_35$1, [
                  createBaseVNode("table", _hoisted_36$1, [
                    createBaseVNode("thead", _hoisted_37$1, [
                      createBaseVNode("tr", null, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(safeTableColumns.value, (column) => {
                          return openBlock(), createElementBlock("th", {
                            key: column.name
                          }, [
                            createBaseVNode("div", _hoisted_38$1, [
                              createBaseVNode("span", null, toDisplayString(column.name), 1),
                              createBaseVNode("small", _hoisted_39$1, toDisplayString(column.type), 1),
                              column.isPrimary ? (openBlock(), createElementBlock("span", _hoisted_40$1, [..._cache[45] || (_cache[45] = [
                                createBaseVNode("i", { class: "bi bi-key-fill" }, null, -1)
                              ])])) : createCommentVNode("", true)
                            ])
                          ]);
                        }), 128)),
                        _cache[46] || (_cache[46] = createBaseVNode("th", { width: "100" }, "操作", -1))
                      ])
                    ]),
                    createBaseVNode("tbody", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(paginatedData.value, (row, index) => {
                        return openBlock(), createElementBlock("tr", { key: index }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (value, key) => {
                            return openBlock(), createElementBlock("td", { key }, [
                              createBaseVNode("div", _hoisted_41, toDisplayString(formatCellValue(value)), 1)
                            ]);
                          }), 128)),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_42, [
                              createBaseVNode("button", {
                                class: "btn btn-outline-primary btn-sm",
                                onClick: ($event) => editRow(row)
                              }, [..._cache[47] || (_cache[47] = [
                                createBaseVNode("i", { class: "bi bi-pencil" }, null, -1)
                              ])], 8, _hoisted_43),
                              createBaseVNode("button", {
                                class: "btn btn-outline-danger btn-sm",
                                onClick: ($event) => deleteRow(row)
                              }, [..._cache[48] || (_cache[48] = [
                                createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                              ])], 8, _hoisted_44)
                            ])
                          ])
                        ]);
                      }), 128))
                    ])
                  ])
                ])) : createCommentVNode("", true),
                __props.loading ? (openBlock(), createElementBlock("div", _hoisted_45, [..._cache[49] || (_cache[49] = [
                  createBaseVNode("div", {
                    class: "spinner-border text-primary",
                    role: "status"
                  }, [
                    createBaseVNode("span", { class: "visually-hidden" }, "加载中...")
                  ], -1),
                  createBaseVNode("p", null, "正在加载数据...", -1)
                ])])) : createCommentVNode("", true),
                !__props.loading && paginatedData.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_46, [
                  _cache[51] || (_cache[51] = createBaseVNode("i", { class: "bi bi-inbox" }, null, -1)),
                  searchQuery.value ? (openBlock(), createElementBlock("p", _hoisted_47, "没有找到匹配的数据")) : (openBlock(), createElementBlock("p", _hoisted_48, "表中暂无数据")),
                  createBaseVNode("button", {
                    class: "btn btn-success",
                    onClick: _cache[11] || (_cache[11] = () => insertData())
                  }, [..._cache[50] || (_cache[50] = [
                    createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                    createTextVNode(" 插入第一条数据 ", -1)
                  ])])
                ])) : createCommentVNode("", true),
                !__props.loading && totalPages.value > 0 ? (openBlock(), createElementBlock("nav", _hoisted_49, [
                  createBaseVNode("div", _hoisted_50, [
                    createBaseVNode("div", _hoisted_51, " 共 " + toDisplayString(formatNumber2(__props.total)) + " 条记录，第 " + toDisplayString(formatNumber2(currentPage.value)) + " 页/共 " + toDisplayString(formatNumber2(totalPages.value)) + " 页 ", 1),
                    createBaseVNode("ul", _hoisted_52, [
                      createBaseVNode("li", {
                        class: normalizeClass(["page-item", { disabled: currentPage.value === 1 }])
                      }, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[12] || (_cache[12] = withModifiers(($event) => goToPage(1), ["prevent"])),
                          title: "首页"
                        }, [..._cache[52] || (_cache[52] = [
                          createBaseVNode("i", { class: "bi bi-chevron-double-left" }, null, -1)
                        ])])
                      ], 2),
                      createBaseVNode("li", {
                        class: normalizeClass(["page-item", { disabled: currentPage.value === 1 }])
                      }, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[13] || (_cache[13] = withModifiers(($event) => goToPage(currentPage.value - 1), ["prevent"])),
                          title: "上一页"
                        }, [..._cache[53] || (_cache[53] = [
                          createBaseVNode("i", { class: "bi bi-chevron-left" }, null, -1)
                        ])])
                      ], 2),
                      currentPage.value > 4 ? (openBlock(), createElementBlock("li", _hoisted_53, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[14] || (_cache[14] = withModifiers(($event) => goToPage(1), ["prevent"]))
                        }, "1")
                      ])) : createCommentVNode("", true),
                      currentPage.value > 5 ? (openBlock(), createElementBlock("li", _hoisted_54, [..._cache[54] || (_cache[54] = [
                        createBaseVNode("span", { class: "page-link" }, "...", -1)
                      ])])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(visiblePages.value, (page) => {
                        return openBlock(), createElementBlock("li", {
                          key: page,
                          class: normalizeClass(["page-item", { active: currentPage.value === page }])
                        }, [
                          createBaseVNode("a", {
                            class: "page-link",
                            href: "#",
                            onClick: withModifiers(($event) => goToPage(page), ["prevent"])
                          }, toDisplayString(page), 9, _hoisted_55)
                        ], 2);
                      }), 128)),
                      currentPage.value < totalPages.value - 4 ? (openBlock(), createElementBlock("li", _hoisted_56, [..._cache[55] || (_cache[55] = [
                        createBaseVNode("span", { class: "page-link" }, "...", -1)
                      ])])) : createCommentVNode("", true),
                      currentPage.value < totalPages.value - 3 ? (openBlock(), createElementBlock("li", _hoisted_57, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[15] || (_cache[15] = withModifiers(($event) => goToPage(totalPages.value), ["prevent"]))
                        }, toDisplayString(totalPages.value), 1)
                      ])) : createCommentVNode("", true),
                      createBaseVNode("li", {
                        class: normalizeClass(["page-item", { disabled: currentPage.value === totalPages.value }])
                      }, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[16] || (_cache[16] = withModifiers(($event) => goToPage(currentPage.value + 1), ["prevent"])),
                          title: "下一页"
                        }, [..._cache[56] || (_cache[56] = [
                          createBaseVNode("i", { class: "bi bi-chevron-right" }, null, -1)
                        ])])
                      ], 2),
                      createBaseVNode("li", {
                        class: normalizeClass(["page-item", { disabled: currentPage.value === totalPages.value }])
                      }, [
                        createBaseVNode("a", {
                          class: "page-link",
                          href: "#",
                          onClick: _cache[17] || (_cache[17] = withModifiers(($event) => goToPage(totalPages.value), ["prevent"])),
                          title: "末页"
                        }, [..._cache[57] || (_cache[57] = [
                          createBaseVNode("i", { class: "bi bi-chevron-double-right" }, null, -1)
                        ])])
                      ], 2)
                    ]),
                    createBaseVNode("div", _hoisted_58, [
                      _cache[59] || (_cache[59] = createBaseVNode("label", { class: "form-label-sm mb-0" }, "每页显示：", -1)),
                      withDirectives(createBaseVNode("select", {
                        class: "form-select form-select-sm ms-2",
                        "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => pageSize.value = $event),
                        style: { "width": "80px" }
                      }, [..._cache[58] || (_cache[58] = [
                        createBaseVNode("option", { value: 10 }, "10", -1),
                        createBaseVNode("option", { value: 20 }, "20", -1),
                        createBaseVNode("option", { value: 50 }, "50", -1),
                        createBaseVNode("option", { value: 100 }, "100", -1),
                        createBaseVNode("option", { value: 200 }, "200", -1),
                        createBaseVNode("option", { value: 500 }, "500", -1)
                      ])], 512), [
                        [vModelSelect, pageSize.value]
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_59, [
                      _cache[60] || (_cache[60] = createBaseVNode("label", { class: "form-label-sm mb-0" }, "跳转到：", -1)),
                      withDirectives(createBaseVNode("input", {
                        type: "number",
                        class: "form-control form-control-sm ms-2",
                        "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => jumpToPage.value = $event),
                        min: "1",
                        max: totalPages.value,
                        style: { "width": "70px" },
                        onKeyup: withKeys(jumpToPageHandler, ["enter"]),
                        onBlur: jumpToPageHandler
                      }, null, 40, _hoisted_60), [
                        [
                          vModelText,
                          jumpToPage.value,
                          void 0,
                          { number: true }
                        ]
                      ]),
                      createBaseVNode("button", {
                        class: "btn btn-primary btn-sm ms-2",
                        onClick: jumpToPageHandler
                      }, " 跳转 ")
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ], 2)
            ], 512), [
              [vShow, activeTab.value === "data"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_61, [
              createBaseVNode("div", { class: "structure-actions mb-3" }, [
                createBaseVNode("button", {
                  class: "btn btn-success btn-sm",
                  onClick: addColumn
                }, [..._cache[61] || (_cache[61] = [
                  createBaseVNode("i", { class: "bi bi-plus-lg" }, null, -1),
                  createTextVNode(" 新增字段 ", -1)
                ])]),
                createBaseVNode("button", {
                  class: "btn btn-info btn-sm",
                  onClick: editTableStructure
                }, [..._cache[62] || (_cache[62] = [
                  createBaseVNode("i", { class: "bi bi-pencil-square" }, null, -1),
                  createTextVNode(" 修改表结构 ", -1)
                ])])
              ]),
              createBaseVNode("div", _hoisted_62, [
                createBaseVNode("div", _hoisted_63, [
                  createBaseVNode("table", _hoisted_64, [
                    _cache[67] || (_cache[67] = createBaseVNode("thead", { class: "table-dark" }, [
                      createBaseVNode("tr", null, [
                        createBaseVNode("th", null, "列名"),
                        createBaseVNode("th", null, "数据类型"),
                        createBaseVNode("th", null, "可空"),
                        createBaseVNode("th", null, "默认值"),
                        createBaseVNode("th", null, "主键"),
                        createBaseVNode("th", null, "自增"),
                        createBaseVNode("th", null, "注释"),
                        createBaseVNode("th", { width: "100" }, "操作")
                      ])
                    ], -1)),
                    createBaseVNode("tbody", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tableStructure?.columns || [], (column) => {
                        return openBlock(), createElementBlock("tr", {
                          key: column.name
                        }, [
                          createBaseVNode("td", null, [
                            createBaseVNode("strong", null, toDisplayString(column.name), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("code", null, toDisplayString(column.type), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("span", {
                              class: normalizeClass(column.nullable ? "text-warning" : "text-success")
                            }, [
                              createBaseVNode("i", {
                                class: normalizeClass(column.nullable ? "bi bi-unlock" : "bi bi-lock-fill")
                              }, null, 2),
                              createTextVNode(" " + toDisplayString(column.nullable ? "YES" : "NO"), 1)
                            ], 2)
                          ]),
                          createBaseVNode("td", null, toDisplayString(column.defaultValue || "-"), 1),
                          createBaseVNode("td", null, [
                            column.isPrimary ? (openBlock(), createElementBlock("span", _hoisted_65, [..._cache[63] || (_cache[63] = [
                              createBaseVNode("i", { class: "bi bi-key-fill" }, null, -1),
                              createTextVNode(" 主键 ", -1)
                            ])])) : (openBlock(), createElementBlock("span", _hoisted_66, "-"))
                          ]),
                          createBaseVNode("td", null, [
                            column.isAutoIncrement ? (openBlock(), createElementBlock("span", _hoisted_67, [..._cache[64] || (_cache[64] = [
                              createBaseVNode("i", { class: "bi bi-arrow-up-circle" }, null, -1),
                              createTextVNode(" 自增 ", -1)
                            ])])) : (openBlock(), createElementBlock("span", _hoisted_68, "-"))
                          ]),
                          createBaseVNode("td", null, toDisplayString(column.comment || "-"), 1),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_69, [
                              createBaseVNode("button", {
                                class: "btn btn-outline-primary btn-sm",
                                onClick: ($event) => editColumn()
                              }, [..._cache[65] || (_cache[65] = [
                                createBaseVNode("i", { class: "bi bi-pencil" }, null, -1)
                              ])], 8, _hoisted_70),
                              createBaseVNode("button", {
                                class: "btn btn-outline-danger btn-sm",
                                onClick: ($event) => deleteColumn(column)
                              }, [..._cache[66] || (_cache[66] = [
                                createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                              ])], 8, _hoisted_71)
                            ])
                          ])
                        ]);
                      }), 128))
                    ])
                  ])
                ])
              ])
            ], 512), [
              [vShow, activeTab.value === "structure"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_72, [
              createBaseVNode("div", _hoisted_73, [
                createBaseVNode("div", _hoisted_74, [
                  createBaseVNode("table", _hoisted_75, [
                    _cache[70] || (_cache[70] = createBaseVNode("thead", { class: "table-dark" }, [
                      createBaseVNode("tr", null, [
                        createBaseVNode("th", null, "索引名"),
                        createBaseVNode("th", null, "类型"),
                        createBaseVNode("th", null, "唯一"),
                        createBaseVNode("th", null, "列"),
                        createBaseVNode("th", { width: "100" }, "操作")
                      ])
                    ], -1)),
                    createBaseVNode("tbody", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tableStructure?.indexes || [], (index) => {
                        return openBlock(), createElementBlock("tr", {
                          key: index.name
                        }, [
                          createBaseVNode("td", null, [
                            createBaseVNode("strong", null, toDisplayString(index.name), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("span", _hoisted_76, toDisplayString(index.type), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("span", {
                              class: normalizeClass(index.unique ? "text-success" : "text-secondary")
                            }, [
                              createBaseVNode("i", {
                                class: normalizeClass(index.unique ? "bi bi-check-circle-fill" : "bi bi-circle")
                              }, null, 2),
                              createTextVNode(" " + toDisplayString(index.unique ? "是" : "否"), 1)
                            ], 2)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("code", null, toDisplayString(index.columns.join(", ")), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_77, [
                              createBaseVNode("button", {
                                class: "btn btn-outline-primary btn-sm",
                                onClick: ($event) => editIndex(index)
                              }, [..._cache[68] || (_cache[68] = [
                                createBaseVNode("i", { class: "bi bi-pencil" }, null, -1)
                              ])], 8, _hoisted_78),
                              createBaseVNode("button", {
                                class: "btn btn-outline-danger btn-sm",
                                onClick: ($event) => deleteIndex(index)
                              }, [..._cache[69] || (_cache[69] = [
                                createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                              ])], 8, _hoisted_79)
                            ])
                          ])
                        ]);
                      }), 128))
                    ])
                  ])
                ])
              ])
            ], 512), [
              [vShow, activeTab.value === "indexes"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_80, [
              createBaseVNode("div", _hoisted_81, [
                createBaseVNode("div", _hoisted_82, [
                  createBaseVNode("table", _hoisted_83, [
                    _cache[72] || (_cache[72] = createBaseVNode("thead", { class: "table-dark" }, [
                      createBaseVNode("tr", null, [
                        createBaseVNode("th", null, "约束名"),
                        createBaseVNode("th", null, "本表列"),
                        createBaseVNode("th", null, "目标表"),
                        createBaseVNode("th", null, "目标列"),
                        createBaseVNode("th", null, "删除规则"),
                        createBaseVNode("th", null, "更新规则"),
                        createBaseVNode("th", { width: "100" }, "操作")
                      ])
                    ], -1)),
                    createBaseVNode("tbody", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tableStructure?.foreignKeys || [], (fk) => {
                        return openBlock(), createElementBlock("tr", {
                          key: fk.name
                        }, [
                          createBaseVNode("td", null, [
                            createBaseVNode("strong", null, toDisplayString(fk.name), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("code", null, toDisplayString(fk.column), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("code", null, toDisplayString(fk.referencedTable), 1)
                          ]),
                          createBaseVNode("td", null, [
                            createBaseVNode("code", null, toDisplayString(fk.referencedColumn), 1)
                          ]),
                          createBaseVNode("td", null, toDisplayString(fk.onDelete || "-"), 1),
                          createBaseVNode("td", null, toDisplayString(fk.onUpdate || "-"), 1),
                          createBaseVNode("td", null, [
                            createBaseVNode("div", _hoisted_84, [
                              createBaseVNode("button", {
                                class: "btn btn-outline-danger btn-sm",
                                onClick: ($event) => deleteForeignKey(fk)
                              }, [..._cache[71] || (_cache[71] = [
                                createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                              ])], 8, _hoisted_85)
                            ])
                          ])
                        ]);
                      }), 128))
                    ])
                  ])
                ])
              ])
            ], 512), [
              [vShow, activeTab.value === "relations"]
            ]),
            withDirectives(createBaseVNode("div", _hoisted_86, [
              createBaseVNode("div", _hoisted_87, [
                createVNode(SqlExecutor, {
                  connection: __props.connection,
                  database: __props.database
                }, null, 8, ["connection", "database"])
              ])
            ], 512), [
              [vShow, activeTab.value === "sql"]
            ])
          ])
        ]),
        createVNode(DataEditor, {
          visible: showDataEditor.value,
          "is-edit": isEditMode.value,
          data: editingRow.value,
          columns: safeTableColumns.value,
          connection: __props.connection,
          database: __props.database,
          "table-name": __props.table?.name,
          onClose: closeDataEditor,
          onSubmit: handleDataSubmit
        }, null, 8, ["visible", "is-edit", "data", "columns", "connection", "database", "table-name"]),
        createVNode(TableEditor, {
          visible: showTableEditor.value,
          connection: __props.connection,
          database: __props.database,
          table: __props.table,
          mode: tableEditorMode.value,
          onClose: closeTableEditor,
          onSubmit: handleTableStructureChange
        }, null, 8, ["visible", "connection", "database", "table", "mode"])
      ]);
    };
  }
});
const TableDetail = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-0c7bffd9"]]);
const _hoisted_1 = { class: "database-explorer" };
const _hoisted_2 = { class: "explorer-layout" };
const _hoisted_3 = { class: "explorer-sidebar" };
const _hoisted_4 = { class: "sidebar-content" };
const _hoisted_5 = { class: "tree-container" };
const _hoisted_6 = { class: "node-content connection-content" };
const _hoisted_7 = ["onClick"];
const _hoisted_8 = ["onClick"];
const _hoisted_9 = { class: "node-icon" };
const _hoisted_10 = { class: "node-label" };
const _hoisted_11 = { class: "connection-name" };
const _hoisted_12 = { class: "connection-type" };
const _hoisted_13 = { class: "node-actions" };
const _hoisted_14 = ["onClick"];
const _hoisted_15 = ["onClick"];
const _hoisted_16 = ["onClick"];
const _hoisted_17 = ["onClick"];
const _hoisted_18 = {
  key: 0,
  class: "node-spinner"
};
const _hoisted_19 = {
  key: 0,
  class: "tree-children"
};
const _hoisted_20 = { class: "node-content database-content" };
const _hoisted_21 = ["onClick"];
const _hoisted_22 = ["onClick"];
const _hoisted_23 = { class: "node-label" };
const _hoisted_24 = { class: "database-name" };
const _hoisted_25 = { class: "node-actions" };
const _hoisted_26 = ["onClick"];
const _hoisted_27 = ["onClick"];
const _hoisted_28 = {
  key: 0,
  class: "node-spinner"
};
const _hoisted_29 = {
  key: 0,
  class: "tree-children"
};
const _hoisted_30 = { class: "node-content table-content" };
const _hoisted_31 = ["onClick"];
const _hoisted_32 = { class: "node-label" };
const _hoisted_33 = { class: "table-name" };
const _hoisted_34 = {
  key: 0,
  class: "table-info"
};
const _hoisted_35 = { class: "node-actions" };
const _hoisted_36 = ["onClick"];
const _hoisted_37 = ["onClick"];
const _hoisted_38 = {
  key: 0,
  class: "empty-state"
};
const _hoisted_39 = { class: "explorer-main" };
const _hoisted_40 = {
  key: 3,
  class: "default-state"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "explorer",
  setup(__props) {
    const route = useRoute();
    const connectionService2 = new ConnectionService();
    const databaseService2 = new DatabaseService();
    const connections2 = ref([]);
    const selectedConnection = ref(null);
    const selectedDatabase = ref("");
    const selectedTable = ref(null);
    const expandedConnections = ref(/* @__PURE__ */ new Set());
    const expandedDatabases = ref(/* @__PURE__ */ new Set());
    const loadingDatabases = ref(/* @__PURE__ */ new Set());
    const loadingTables = ref(/* @__PURE__ */ new Set());
    const loadingConnections = ref(/* @__PURE__ */ new Set());
    const databaseCache = ref(/* @__PURE__ */ new Map());
    const tableCache = ref(/* @__PURE__ */ new Map());
    const databaseInfoCache = ref(/* @__PURE__ */ new Map());
    const activeTab = ref("overview");
    const activeTableTab = ref("data");
    const tableData = ref([]);
    const tableStructure = ref(null);
    const tableColumns = ref([]);
    ref("");
    const currentPage = ref(1);
    const pageSize = ref(50);
    const totalRecords = ref(0);
    const sqlResult = ref(null);
    const sqlExecuting = ref(false);
    const isGlobalLoading = ref(false);
    const loadingMessage = ref("加载中...");
    const connectionEditorRef = ref();
    const toastRef = ref();
    const databaseInfo = computed(() => {
      if (!selectedConnection.value || !selectedDatabase.value) return null;
      return databaseInfoCache.value.get(`${selectedConnection.value.id}-${selectedDatabase.value}`);
    });
    computed(() => {
      const start = (currentPage.value - 1) * pageSize.value;
      const end = start + pageSize.value;
      return tableData.value.slice(start, end);
    });
    computed(() => {
      return Math.ceil(tableData.value.length / pageSize.value);
    });
    onMounted(() => {
      loadConnections().then(() => {
        handleRouteQuery();
      });
    });
    function handleRouteQuery() {
      const connectionId = route.query.connectionId;
      const database = route.query.database;
      if (connectionId) {
        const connection = connections2.value.find((conn) => conn.id === connectionId);
        if (connection) {
          selectConnection(connection);
          if (!expandedConnections.value.has(connectionId)) {
            expandedConnections.value.add(connectionId);
            loadDatabasesForConnection(connection);
          }
          if (database) {
            setTimeout(() => {
              selectDatabase(connection, database);
              const dbKey = `${connectionId}-${database}`;
              if (!expandedDatabases.value.has(dbKey)) {
                expandedDatabases.value.add(dbKey);
                loadDatabaseInfo(connection, database);
                loadTablesForDatabase(connection, database);
              }
            }, 100);
          }
        }
      }
    }
    watch(() => route.query, () => {
      handleRouteQuery();
    }, { deep: true });
    async function loadConnections() {
      try {
        const response = await connectionService2.getAllConnections();
        connections2.value = response?.data || [];
      } catch (error) {
        console.error("加载连接失败:", error);
        modal.error(error.msg || error.message || "加载连接失败", {
          operation: "LOAD_CONNECTIONS",
          stack: error.stack
        });
      }
    }
    function toggleConnection(connection) {
      const connectionId = connection.id || "";
      if (expandedConnections.value.has(connectionId)) {
        expandedConnections.value.delete(connectionId);
      } else {
        expandedConnections.value.add(connectionId);
        loadDatabasesForConnection(connection);
      }
    }
    function selectConnection(connection) {
      selectedConnection.value = connection;
      selectedDatabase.value = "";
      selectedTable.value = null;
      activeTab.value = "overview";
    }
    async function loadDatabasesForConnection(connection, forceRefresh = false) {
      const cacheKey = connection.id || "";
      if (!forceRefresh && databaseCache.value.has(cacheKey)) {
        return;
      }
      if (!loadingConnections.value.has(cacheKey)) {
        loadingConnections.value.add(cacheKey);
      }
      try {
        const databases = await databaseService2.getDatabases(cacheKey);
        databaseCache.value.set(cacheKey, databases?.data || []);
      } catch (error) {
        console.error("加载数据库失败:", error);
        modal.error(error.msg || error.message || "加载数据库失败", {
          operation: "LOAD_DATABASES",
          connectionId: connection.id,
          stack: error.stack
        });
        databaseCache.value.set(cacheKey, []);
      } finally {
        loadingConnections.value.delete(cacheKey);
      }
    }
    function toggleDatabase(connection, database) {
      const dbKey = `${connection.id}-${database}`;
      if (expandedDatabases.value.has(dbKey)) {
        expandedDatabases.value.delete(dbKey);
      } else {
        expandedDatabases.value.add(dbKey);
        loadDatabaseInfo(connection, database);
      }
    }
    function selectDatabase(connection, database) {
      selectedConnection.value = connection;
      selectedDatabase.value = database;
      selectedTable.value = null;
      activeTab.value = "tables";
      loadDatabaseInfo(connection, database);
    }
    async function loadTablesForDatabase(connection, database, forceRefresh = false) {
      const dbKey = `${connection.id}-${database}`;
      if (loadingTables.value.has(dbKey)) return;
      if (!forceRefresh && tableCache.value.has(dbKey)) {
        return;
      }
      loadingTables.value.add(dbKey);
      try {
        const info = await databaseService2.getDatabaseInfo(connection.id, database);
        const tables = info?.data?.tables || [];
        tableCache.value.set(dbKey, tables);
      } catch (error) {
        console.error("加载表失败:", error);
        modal.error(error.msg || error.message || "加载表失败", {
          operation: "LOAD_TABLES",
          database,
          stack: error.stack
        });
        tableCache.value.set(dbKey, []);
      } finally {
        loadingTables.value.delete(dbKey);
      }
    }
    async function loadDatabaseInfo(connection, database) {
      const dbKey = `${connection.id}-${database}`;
      try {
        const info = await databaseService2.getDatabaseInfo(connection.id || "", database);
        databaseInfoCache.value.set(dbKey, info.data);
        loadTablesForDatabase(connection, database);
      } catch (error) {
        console.error("加载数据库信息失败:", error);
        modal.error(error.msg || error.message || "加载数据库信息失败", {
          operation: "LOAD_DATABASE_INFO",
          database,
          stack: error.stack
        });
      }
    }
    function selectTable(connection, database, table) {
      selectedConnection.value = connection;
      selectedDatabase.value = database;
      selectedTable.value = table;
      activeTableTab.value = "data";
      loadTableData(connection, database, table.name);
      loadTableStructure(connection, database, table.name);
    }
    async function loadTableData(connection, database, tableName, page = 1, pageSize2 = 50, searchQuery) {
      try {
        isGlobalLoading.value = true;
        loadingMessage.value = `正在加载表 "${tableName}" 的数据...`;
        let whereClause = "";
        if (searchQuery && searchQuery.trim()) {
          const searchTerm = searchQuery.trim();
          if (tableStructure.value?.columns && tableStructure.value.columns.length > 0) {
            const searchableColumns = tableStructure.value.columns.filter((col) => {
              const type = col.type?.toLowerCase() || "";
              return type.includes("char") || type.includes("text") || type.includes("varchar") || type.includes("int") || type.includes("decimal") || type.includes("float");
            });
            if (searchableColumns.length > 0) {
              const conditions = searchableColumns.map((col) => {
                const columnName = col.name;
                const type = col.type?.toLowerCase() || "";
                if (type.includes("int") || type.includes("decimal") || type.includes("float")) {
                  return `${columnName} = '${searchTerm}'`;
                } else {
                  return `${columnName} LIKE '%${searchTerm}%'`;
                }
              });
              whereClause = `WHERE (${conditions.join(" OR ")})`;
            }
          } else {
            whereClause = `WHERE column1 LIKE '%${searchTerm}%' OR column2 LIKE '%${searchTerm}%'`;
          }
        }
        const response = await databaseService2.getTableData(
          connection.id,
          database,
          tableName,
          page,
          pageSize2,
          whereClause
        );
        tableData.value = response?.data?.data || [];
        totalRecords.value = parseInt(response?.data?.total) || 0;
        currentPage.value = page;
      } catch (error) {
        console.error("加载表数据失败:", error);
        modal.error(error.msg || error.message || "加载表数据失败", {
          operation: "LOAD_TABLE_DATA",
          table: tableName,
          stack: error.stack
        });
        tableData.value = [];
      } finally {
        isGlobalLoading.value = false;
      }
    }
    async function loadTableStructure(connection, database, tableName) {
      try {
        const structure = await databaseService2.getTableInfo(connection.id, database, tableName);
        tableStructure.value = structure.data;
        tableColumns.value = structure?.data.columns || [];
      } catch (error) {
        console.error("加载表结构失败:", error);
        modal.error(error.msg || error.message || "加载表结构失败", {
          operation: "LOAD_TABLE_STRUCTURE",
          table: tableName,
          stack: error.stack
        });
        tableStructure.value = null;
        tableColumns.value = [];
      }
    }
    function getDatabasesForConnection(connectionId) {
      return databaseCache.value.get(connectionId) || [];
    }
    function getTablesForDatabase(connectionId, database) {
      if (!connectionId) return [];
      const dbKey = `${connectionId}-${database}`;
      return tableCache.value.get(dbKey) || [];
    }
    function editConnection(connection) {
      connectionEditorRef.value?.showEditModal(connection);
    }
    async function testConnection(connection) {
      try {
        const result = await connectionService2.testConnection(connection);
        if (result.ret === 0 && result.data) {
          showToast("", `连接 "${connection.name}" 测试成功`, "success");
        } else {
          showToast("", `连接 "${connection.name}" 测试失败`, "error");
        }
      } catch (error) {
        modal.error(error.msg || error.message || "连接测试失败", {
          operation: "TEST_CONNECTION",
          connectionId: connection.id,
          stack: error.stack
        });
      }
    }
    function showAddConnectionModal() {
      connectionEditorRef.value?.showAddModal();
    }
    function onConnectionSaved() {
      loadConnections();
    }
    function handleTestConnection(connection) {
      testConnection(connection);
    }
    function handleEditConnection(connection) {
      editConnection(connection);
    }
    function handleRefreshAll(connection) {
      refreshConnection(connection);
    }
    function handleOpenSqlQuery(connection) {
      showToast("提示", "SQL查询功能开发中...", "info");
    }
    function handleExportSchema(connection) {
      showToast("提示", "架构导出功能开发中...", "info");
    }
    function handleViewLogs(connection) {
      showToast("提示", "日志查看功能开发中...", "info");
    }
    function refreshAll() {
      databaseCache.value.clear();
      tableCache.value.clear();
      databaseInfoCache.value.clear();
      loadConnections();
    }
    async function refreshTableData(page = 1, pageSize2 = 50, searchQuery) {
      if (selectedConnection.value && selectedDatabase.value && selectedTable.value) {
        await loadTableData(selectedConnection.value, selectedDatabase.value, selectedTable.value.name, page, pageSize2, searchQuery);
      }
    }
    async function handleRefreshStructure() {
      if (selectedConnection.value && selectedDatabase.value && selectedTable.value) {
        await loadTableStructure(selectedConnection.value, selectedDatabase.value, selectedTable.value.name);
        showToast("", "表结构已刷新", "success");
      }
    }
    function viewTableStructure(connection, database, table) {
      selectTable(connection, database, table);
      activeTableTab.value = "structure";
    }
    function getDbTypeLabel(type) {
      const labelMap = {
        mysql: "MySQL",
        postgres: "PostgreSQL",
        sqlite: "SQLite",
        mssql: "SQL Server",
        oracle: "Oracle"
      };
      return labelMap[type] || type;
    }
    function getDbLogoClass(type) {
      const classMap = {
        mysql: "db-logo-mysql",
        postgres: "db-logo-postgres",
        sqlite: "db-logo-sqlite",
        mssql: "db-logo-mssql",
        oracle: "db-logo-oracle"
      };
      return classMap[type] || "db-logo-default";
    }
    function getDbLogoText(type) {
      const textMap = {
        mysql: "M",
        postgres: "P",
        sqlite: "S",
        mssql: "MS",
        oracle: "O"
      };
      return textMap[type] || "D";
    }
    function formatNumber2(num) {
      return num.toLocaleString();
    }
    async function refreshConnection(connection) {
      databaseCache.value.delete(connection.id);
      if (expandedConnections.value.has(connection.id)) {
        await loadDatabasesForConnection(connection, true);
      }
      showToast("", `连接 "${connection.name}" 已刷新`, "success");
    }
    async function refreshDatabase(connection, database) {
      const dbKey = `${connection.id}-${database}`;
      selectedTable.value = null;
      tableCache.value.delete(dbKey);
      databaseInfoCache.value.delete(dbKey);
      await loadTablesForDatabase(connection, database, true);
      await loadDatabaseInfo(connection, database);
      showToast("", `数据库 "${database}" 已刷新`, "success");
    }
    async function deleteDatabase(connection, database) {
      const result = await modal.confirm(`确定要删除数据库 "${database}" 吗？此操作将删除数据库及其所有数据且不可恢复。`);
      if (result) {
        try {
          isGlobalLoading.value = true;
          loadingMessage.value = `正在删除数据库 "${database}"...`;
          const deleteSql = `DROP DATABASE \`${database}\``;
          const result2 = await databaseService2.executeQuery(connection.id, deleteSql);
          if (result2.ret === 0) {
            showToast("成功", `数据库 "${database}" 已删除`, "success");
            const connectionId = connection.id || "";
            const databases = databaseCache.value.get(connectionId) || [];
            databaseCache.value.set(connectionId, databases.filter((db) => db !== database));
            if (selectedDatabase.value === database) {
              selectedDatabase.value = "";
              selectedTable.value = null;
            }
            const dbKey = `${connection.id}-${database}`;
            tableCache.value.delete(dbKey);
            databaseInfoCache.value.delete(dbKey);
          } else {
            showToast("错误", `删除数据库失败: ${result2.error}`, "error");
          }
        } catch (error) {
          console.error("删除数据库失败:", error);
          modal.error(error.msg || error.message || "删除数据库失败", {
            operation: "DELETE_DATABASE",
            database,
            stack: error.stack
          });
        } finally {
          isGlobalLoading.value = false;
        }
      }
    }
    async function deleteConnection(connection) {
      const result = await modal.confirm(`确定要删除连接 "${connection.name}" 吗？此操作将删除该连接的配置但不会删除实际的数据库数据。`);
      if (result) {
        try {
          isGlobalLoading.value = true;
          loadingMessage.value = `正在删除连接 "${connection.name}"...`;
          await connectionService2.deleteConnection(connection.id || "");
          showToast("成功", `连接 "${connection.name}" 已删除`, "success");
          const index = connections2.value.findIndex((conn) => conn.id === connection.id);
          if (index !== -1) {
            connections2.value.splice(index, 1);
          }
          databaseCache.value.delete(connection.id);
          tableCache.value.clear();
          databaseInfoCache.value.clear();
          expandedConnections.value.delete(connection.id);
          if (selectedConnection.value?.id === connection.id) {
            selectedConnection.value = null;
            selectedDatabase.value = "";
            selectedTable.value = null;
          }
        } catch (error) {
          console.error("删除连接失败:", error);
          modal.error(error.msg || error.message || "删除连接失败", {
            operation: "DELETE_CONNECTION",
            connectionId: connection.id,
            stack: error.stack
          });
        } finally {
          isGlobalLoading.value = false;
        }
      }
    }
    async function refreshTable(connection, database, table) {
      if (selectedTable.value?.name === table.name) {
        await loadTableData(connection, database, table.name);
        await loadTableStructure(connection, database, table.name);
      }
      showToast("", `表 "${table.name}" 已刷新`, "success");
    }
    function handleRefreshDatabase() {
      if (selectedConnection.value && selectedDatabase.value) {
        refreshDatabase(selectedConnection.value, selectedDatabase.value);
      }
    }
    async function handleCreateTable(tableData2) {
      try {
        isGlobalLoading.value = true;
        loadingMessage.value = `正在创建表 "${tableData2.name}"...`;
        console.log("创建表:", tableData2);
        await handleRefreshDatabase();
        showToast("成功", `表 "${tableData2.name}" 创建成功`, "success");
      } catch (error) {
        console.error("创建表失败:", error);
        modal.error(error.msg || error.message || "创建表失败", {
          operation: "CREATE_TABLE",
          stack: error.stack
        });
      } finally {
        isGlobalLoading.value = false;
      }
    }
    function handleInsertData() {
      showToast("提示", "插入数据功能开发中...", "info");
    }
    function handleExportTable() {
      showToast("提示", "导出表功能开发中...", "info");
    }
    async function handleTruncateTable() {
      if (!selectedTable.value || !selectedConnection.value || !selectedDatabase.value) return;
      const result = await modal.confirm(`确定要清空表 "${selectedTable.value.name}" 吗？此操作将删除所有数据且不可恢复。`);
      if (result) {
        try {
          isGlobalLoading.value = true;
          loadingMessage.value = `正在清空表 "${selectedTable.value.name}"...`;
          console.log("清空表:", selectedTable.value.name);
          await refreshTableData();
          showToast("成功", `表 "${selectedTable.value.name}" 已清空`, "success");
        } catch (error) {
          console.error("清空表失败:", error);
          modal.error(error.msg || error.message || "清空表失败", {
            operation: "TRUNCATE_TABLE",
            stack: error.stack
          });
        } finally {
          isGlobalLoading.value = false;
        }
      }
    }
    function handleEditRow(row) {
      showToast("提示", "编辑行功能开发中...", "info");
    }
    function handleDeleteRow(row) {
      showToast("提示", "删除行功能开发中...", "info");
    }
    async function handleExecuteSql(sql2) {
      if (!selectedConnection.value) {
        showToast("错误", "请先选择数据库连接", "error");
        return;
      }
      if (!sql2.trim()) {
        showToast("错误", "SQL语句不能为空", "error");
        return;
      }
      try {
        sqlResult.value = null;
        sqlExecuting.value = true;
        const databaseName = selectedTable.value ? selectedDatabase.value : selectedDatabase.value;
        const result = await databaseService2.executeQuery(selectedConnection.value.id, sql2, databaseName);
        if (result.ret === 0 && result.data) {
          showToast("", "SQL执行成功", "success");
          if (result.data && Array.isArray(result.data)) {
            sqlResult.value = {
              success: true,
              data: result.data,
              columns: result.data.length > 0 ? Object.keys(result.data[0]) : [],
              affectedRows: result.affectedRows || 0,
              insertId: result.insertId || null
            };
          } else {
            sqlResult.value = {
              success: true,
              data: [],
              columns: [],
              affectedRows: result.data.affectedRows || 0,
              insertId: result.data.insertId || null
            };
            showToast("", `执行成功，影响行数: ${result.data.affectedRows || 0}`, "success");
          }
        } else {
          sqlResult.value = {
            success: false,
            data: [],
            columns: [],
            affectedRows: 0,
            error: result.error
          };
          showToast("错误", `SQL执行失败: ${result.error}`, "error");
        }
      } catch (error) {
        console.error("SQL执行失败:", error);
        sqlResult.value = {
          success: false,
          data: [],
          columns: [],
          affectedRows: 0,
          error: error?.message || ""
        };
        modal.error(error.msg || error.message || "SQL执行失败", {
          operation: "EXECUTE_SQL",
          sql: sql2,
          stack: error.stack
        });
      } finally {
        sqlExecuting.value = false;
      }
    }
    function showToast(title, message, type = "success") {
      toastRef.value?.addToast(title, message, type);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("div", { class: "sidebar-header" }, [
              _cache[2] || (_cache[2] = createBaseVNode("h5", { class: "sidebar-title" }, [
                createBaseVNode("i", { class: "bi bi-diagram-3" }),
                createTextVNode(" 数据库浏览器 ")
              ], -1)),
              createBaseVNode("div", { class: "sidebar-actions" }, [
                createBaseVNode("button", {
                  class: "btn btn-sm btn-outline-primary",
                  onClick: refreshAll,
                  title: "刷新"
                }, [..._cache[0] || (_cache[0] = [
                  createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1)
                ])]),
                createBaseVNode("button", {
                  class: "btn btn-sm btn-outline-success",
                  onClick: showAddConnectionModal,
                  title: "添加连接"
                }, [..._cache[1] || (_cache[1] = [
                  createBaseVNode("i", { class: "bi bi-plus" }, null, -1)
                ])])
              ])
            ]),
            createBaseVNode("div", _hoisted_4, [
              createBaseVNode("div", _hoisted_5, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(connections2.value, (connection) => {
                  return openBlock(), createElementBlock("div", {
                    key: connection.id,
                    class: normalizeClass(["tree-node connection-node", { "selected": selectedConnection.value?.id === connection.id && !selectedDatabase.value && !selectedTable.value }])
                  }, [
                    createBaseVNode("div", _hoisted_6, [
                      createBaseVNode("div", {
                        class: "node-expand",
                        onClick: ($event) => toggleConnection(connection)
                      }, [
                        createBaseVNode("i", {
                          class: normalizeClass(["bi bi-chevron-right", { "expanded": expandedConnections.value.has(connection.id) }])
                        }, null, 2)
                      ], 8, _hoisted_7),
                      createBaseVNode("div", {
                        class: "node-main",
                        onClick: ($event) => selectConnection(connection)
                      }, [
                        createBaseVNode("div", _hoisted_9, [
                          createBaseVNode("div", {
                            class: normalizeClass(["db-logo", getDbLogoClass(connection.type)])
                          }, toDisplayString(getDbLogoText(connection.type)), 3)
                        ]),
                        createBaseVNode("div", _hoisted_10, [
                          createBaseVNode("span", _hoisted_11, toDisplayString(connection.name), 1),
                          createBaseVNode("span", _hoisted_12, toDisplayString(getDbTypeLabel(connection.type)), 1)
                        ])
                      ], 8, _hoisted_8),
                      createBaseVNode("div", _hoisted_13, [
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-icon",
                          onClick: withModifiers(($event) => refreshConnection(connection), ["stop"]),
                          title: "刷新连接"
                        }, [..._cache[3] || (_cache[3] = [
                          createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1)
                        ])], 8, _hoisted_14),
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-icon",
                          onClick: withModifiers(($event) => editConnection(connection), ["stop"]),
                          title: "编辑连接"
                        }, [..._cache[4] || (_cache[4] = [
                          createBaseVNode("i", { class: "bi bi-pencil" }, null, -1)
                        ])], 8, _hoisted_15),
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-icon",
                          onClick: withModifiers(($event) => testConnection(connection), ["stop"]),
                          title: "测试连接"
                        }, [..._cache[5] || (_cache[5] = [
                          createBaseVNode("i", { class: "bi bi-wifi" }, null, -1)
                        ])], 8, _hoisted_16),
                        createBaseVNode("button", {
                          class: "btn btn-sm btn-icon btn-icon-danger",
                          onClick: withModifiers(($event) => deleteConnection(connection), ["stop"]),
                          title: "删除连接"
                        }, [..._cache[6] || (_cache[6] = [
                          createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                        ])], 8, _hoisted_17)
                      ]),
                      loadingConnections.value.has(connection.id) ? (openBlock(), createElementBlock("div", _hoisted_18, [..._cache[7] || (_cache[7] = [
                        createBaseVNode("div", { class: "spinner-border spinner-border-sm" }, null, -1)
                      ])])) : createCommentVNode("", true)
                    ]),
                    expandedConnections.value.has(connection.id) ? (openBlock(), createElementBlock("div", _hoisted_19, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(getDatabasesForConnection(connection.id), (database) => {
                        return openBlock(), createElementBlock("div", {
                          key: `${connection.id}-${database}`,
                          class: normalizeClass(["tree-node database-node", { "selected": selectedDatabase.value === database && selectedConnection.value?.id === connection.id && !selectedTable.value }])
                        }, [
                          createBaseVNode("div", _hoisted_20, [
                            createBaseVNode("div", {
                              class: "node-expand",
                              onClick: ($event) => toggleDatabase(connection, database)
                            }, [
                              createBaseVNode("i", {
                                class: normalizeClass(["bi bi-chevron-right", { "expanded": expandedDatabases.value.has(`${connection.id}-${database}`) }])
                              }, null, 2)
                            ], 8, _hoisted_21),
                            createBaseVNode("div", {
                              class: "node-main",
                              onClick: ($event) => selectDatabase(connection, database)
                            }, [
                              _cache[8] || (_cache[8] = createBaseVNode("div", { class: "node-icon" }, [
                                createBaseVNode("i", { class: "bi bi-database" })
                              ], -1)),
                              createBaseVNode("div", _hoisted_23, [
                                createBaseVNode("span", _hoisted_24, toDisplayString(database), 1)
                              ])
                            ], 8, _hoisted_22),
                            createBaseVNode("div", _hoisted_25, [
                              createBaseVNode("button", {
                                class: "btn btn-sm btn-icon",
                                onClick: withModifiers(($event) => refreshDatabase(connection, database), ["stop"]),
                                title: "刷新数据库"
                              }, [..._cache[9] || (_cache[9] = [
                                createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1)
                              ])], 8, _hoisted_26),
                              createBaseVNode("button", {
                                class: "btn btn-sm btn-icon btn-icon-danger",
                                onClick: withModifiers(($event) => deleteDatabase(connection, database), ["stop"]),
                                title: "删除数据库"
                              }, [..._cache[10] || (_cache[10] = [
                                createBaseVNode("i", { class: "bi bi-trash" }, null, -1)
                              ])], 8, _hoisted_27)
                            ]),
                            loadingDatabases.value.has(`${connection.id}-${database}`) ? (openBlock(), createElementBlock("div", _hoisted_28, [..._cache[11] || (_cache[11] = [
                              createBaseVNode("div", { class: "spinner-border spinner-border-sm" }, null, -1)
                            ])])) : createCommentVNode("", true)
                          ]),
                          expandedDatabases.value.has(`${connection.id}-${database}`) ? (openBlock(), createElementBlock("div", _hoisted_29, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(getTablesForDatabase(connection.id, database), (table) => {
                              return openBlock(), createElementBlock("div", {
                                key: `${connection.id}-${database}-${table.name}`,
                                class: normalizeClass(["tree-node table-node", { "selected": selectedTable.value?.name === table.name && selectedDatabase.value === database && selectedConnection.value?.id === connection.id }])
                              }, [
                                createBaseVNode("div", _hoisted_30, [
                                  _cache[14] || (_cache[14] = createBaseVNode("div", { class: "node-icon" }, [
                                    createBaseVNode("i", { class: "bi bi-table" })
                                  ], -1)),
                                  createBaseVNode("div", {
                                    class: "node-main",
                                    onClick: ($event) => selectTable(connection, database, table)
                                  }, [
                                    createBaseVNode("div", _hoisted_32, [
                                      createBaseVNode("span", _hoisted_33, toDisplayString(table.name), 1),
                                      table.rowCount !== void 0 ? (openBlock(), createElementBlock("span", _hoisted_34, toDisplayString(formatNumber2(table.rowCount)) + " 行", 1)) : createCommentVNode("", true)
                                    ])
                                  ], 8, _hoisted_31),
                                  createBaseVNode("div", _hoisted_35, [
                                    createBaseVNode("button", {
                                      class: "btn btn-sm btn-icon",
                                      onClick: withModifiers(($event) => refreshTable(connection, database, table), ["stop"]),
                                      title: "刷新表"
                                    }, [..._cache[12] || (_cache[12] = [
                                      createBaseVNode("i", { class: "bi bi-arrow-clockwise" }, null, -1)
                                    ])], 8, _hoisted_36),
                                    createBaseVNode("button", {
                                      class: "btn btn-sm btn-icon",
                                      onClick: withModifiers(($event) => viewTableStructure(connection, database, table), ["stop"]),
                                      title: "查看结构"
                                    }, [..._cache[13] || (_cache[13] = [
                                      createBaseVNode("i", { class: "bi bi-diagram-3" }, null, -1)
                                    ])], 8, _hoisted_37)
                                  ])
                                ])
                              ], 2);
                            }), 128))
                          ])) : createCommentVNode("", true)
                        ], 2);
                      }), 128))
                    ])) : createCommentVNode("", true)
                  ], 2);
                }), 128))
              ]),
              connections2.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_38, [
                _cache[17] || (_cache[17] = createBaseVNode("div", { class: "empty-icon" }, [
                  createBaseVNode("i", { class: "bi bi-inbox" })
                ], -1)),
                createBaseVNode("div", { class: "empty-text" }, [
                  _cache[16] || (_cache[16] = createBaseVNode("p", null, "还没有数据库连接", -1)),
                  createBaseVNode("button", {
                    class: "btn btn-primary btn-sm",
                    onClick: showAddConnectionModal
                  }, [..._cache[15] || (_cache[15] = [
                    createBaseVNode("i", { class: "bi bi-plus" }, null, -1),
                    createTextVNode(" 添加连接 ", -1)
                  ])])
                ])
              ])) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_39, [
            selectedConnection.value && !selectedDatabase.value && !selectedTable.value ? (openBlock(), createBlock(ConnectionDetail, {
              key: 0,
              connection: selectedConnection.value,
              onTestConnection: handleTestConnection,
              onEditConnection: handleEditConnection,
              onRefreshAll: handleRefreshAll,
              onOpenSqlQuery: handleOpenSqlQuery,
              onExportSchema: handleExportSchema,
              onViewLogs: handleViewLogs
            }, null, 8, ["connection"])) : selectedConnection.value && selectedDatabase.value && !selectedTable.value ? (openBlock(), createBlock(DatabaseDetail, {
              key: 1,
              connection: selectedConnection.value,
              database: selectedDatabase.value,
              tables: getTablesForDatabase(selectedConnection.value.id || "", selectedDatabase.value),
              "database-info": databaseInfo.value,
              loading: loadingDatabases.value.has(`${selectedConnection.value.id}-${selectedDatabase.value}`),
              onSelectTable: selectTable,
              onRefreshDatabase: handleRefreshDatabase,
              onCreateTable: handleCreateTable,
              onExecuteSql: handleExecuteSql
            }, null, 8, ["connection", "database", "tables", "database-info", "loading"])) : selectedConnection.value && selectedDatabase.value && selectedTable.value ? (openBlock(), createBlock(TableDetail, {
              key: 2,
              connection: selectedConnection.value,
              database: selectedDatabase.value,
              table: selectedTable.value,
              "table-data": tableData.value,
              "table-structure": tableStructure.value,
              loading: isGlobalLoading.value,
              total: totalRecords.value,
              "sql-result": sqlResult.value,
              "sql-executing": sqlExecuting.value,
              onRefreshData: refreshTableData,
              onRefreshDatabase: handleRefreshDatabase,
              onRefreshStructure: handleRefreshStructure,
              onInsertData: handleInsertData,
              onExportTable: handleExportTable,
              onTruncateTable: handleTruncateTable,
              onEditRow: handleEditRow,
              onDeleteRow: handleDeleteRow,
              onExecuteSql: handleExecuteSql
            }, null, 8, ["connection", "database", "table", "table-data", "table-structure", "loading", "total", "sql-result", "sql-executing"])) : (openBlock(), createElementBlock("div", _hoisted_40, [..._cache[18] || (_cache[18] = [
              createBaseVNode("div", { class: "default-content" }, [
                createBaseVNode("div", { class: "default-icon" }, [
                  createBaseVNode("i", { class: "bi bi-diagram-3" })
                ]),
                createBaseVNode("h5", null, "数据库浏览器"),
                createBaseVNode("p", null, "请从左侧选择一个连接、数据库或表来查看详细信息")
              ], -1)
            ])]))
          ])
        ]),
        createVNode(ConnectionEditor, {
          ref_key: "connectionEditorRef",
          ref: connectionEditorRef,
          onSaved: onConnectionSaved
        }, null, 512),
        createVNode(Toast, {
          ref_key: "toastRef",
          ref: toastRef
        }, null, 512)
      ]);
    };
  }
});
const explorer = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-488c965d"]]);
export {
  explorer as default
};
